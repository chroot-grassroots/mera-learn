var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// node_modules/base64-js/index.js
var require_base64_js = __commonJS({
  "node_modules/base64-js/index.js"(exports) {
    "use strict";
    exports.byteLength = byteLength;
    exports.toByteArray = toByteArray;
    exports.fromByteArray = fromByteArray;
    var lookup = [];
    var revLookup = [];
    var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
    var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    for (i = 0, len = code.length; i < len; ++i) {
      lookup[i] = code[i];
      revLookup[code.charCodeAt(i)] = i;
    }
    var i;
    var len;
    revLookup["-".charCodeAt(0)] = 62;
    revLookup["_".charCodeAt(0)] = 63;
    function getLens(b64) {
      var len2 = b64.length;
      if (len2 % 4 > 0) {
        throw new Error("Invalid string. Length must be a multiple of 4");
      }
      var validLen = b64.indexOf("=");
      if (validLen === -1) validLen = len2;
      var placeHoldersLen = validLen === len2 ? 0 : 4 - validLen % 4;
      return [validLen, placeHoldersLen];
    }
    function byteLength(b64) {
      var lens = getLens(b64);
      var validLen = lens[0];
      var placeHoldersLen = lens[1];
      return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
    }
    function _byteLength(b64, validLen, placeHoldersLen) {
      return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
    }
    function toByteArray(b64) {
      var tmp;
      var lens = getLens(b64);
      var validLen = lens[0];
      var placeHoldersLen = lens[1];
      var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
      var curByte = 0;
      var len2 = placeHoldersLen > 0 ? validLen - 4 : validLen;
      var i2;
      for (i2 = 0; i2 < len2; i2 += 4) {
        tmp = revLookup[b64.charCodeAt(i2)] << 18 | revLookup[b64.charCodeAt(i2 + 1)] << 12 | revLookup[b64.charCodeAt(i2 + 2)] << 6 | revLookup[b64.charCodeAt(i2 + 3)];
        arr[curByte++] = tmp >> 16 & 255;
        arr[curByte++] = tmp >> 8 & 255;
        arr[curByte++] = tmp & 255;
      }
      if (placeHoldersLen === 2) {
        tmp = revLookup[b64.charCodeAt(i2)] << 2 | revLookup[b64.charCodeAt(i2 + 1)] >> 4;
        arr[curByte++] = tmp & 255;
      }
      if (placeHoldersLen === 1) {
        tmp = revLookup[b64.charCodeAt(i2)] << 10 | revLookup[b64.charCodeAt(i2 + 1)] << 4 | revLookup[b64.charCodeAt(i2 + 2)] >> 2;
        arr[curByte++] = tmp >> 8 & 255;
        arr[curByte++] = tmp & 255;
      }
      return arr;
    }
    function tripletToBase64(num) {
      return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
    }
    function encodeChunk(uint8, start, end) {
      var tmp;
      var output = [];
      for (var i2 = start; i2 < end; i2 += 3) {
        tmp = (uint8[i2] << 16 & 16711680) + (uint8[i2 + 1] << 8 & 65280) + (uint8[i2 + 2] & 255);
        output.push(tripletToBase64(tmp));
      }
      return output.join("");
    }
    function fromByteArray(uint8) {
      var tmp;
      var len2 = uint8.length;
      var extraBytes = len2 % 3;
      var parts = [];
      var maxChunkLength = 16383;
      for (var i2 = 0, len22 = len2 - extraBytes; i2 < len22; i2 += maxChunkLength) {
        parts.push(encodeChunk(uint8, i2, i2 + maxChunkLength > len22 ? len22 : i2 + maxChunkLength));
      }
      if (extraBytes === 1) {
        tmp = uint8[len2 - 1];
        parts.push(
          lookup[tmp >> 2] + lookup[tmp << 4 & 63] + "=="
        );
      } else if (extraBytes === 2) {
        tmp = (uint8[len2 - 2] << 8) + uint8[len2 - 1];
        parts.push(
          lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + "="
        );
      }
      return parts.join("");
    }
  }
});

// node_modules/ieee754/index.js
var require_ieee754 = __commonJS({
  "node_modules/ieee754/index.js"(exports) {
    exports.read = function(buffer, offset, isLE, mLen, nBytes) {
      var e, m;
      var eLen = nBytes * 8 - mLen - 1;
      var eMax = (1 << eLen) - 1;
      var eBias = eMax >> 1;
      var nBits = -7;
      var i = isLE ? nBytes - 1 : 0;
      var d = isLE ? -1 : 1;
      var s = buffer[offset + i];
      i += d;
      e = s & (1 << -nBits) - 1;
      s >>= -nBits;
      nBits += eLen;
      for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {
      }
      m = e & (1 << -nBits) - 1;
      e >>= -nBits;
      nBits += mLen;
      for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {
      }
      if (e === 0) {
        e = 1 - eBias;
      } else if (e === eMax) {
        return m ? NaN : (s ? -1 : 1) * Infinity;
      } else {
        m = m + Math.pow(2, mLen);
        e = e - eBias;
      }
      return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
    };
    exports.write = function(buffer, value, offset, isLE, mLen, nBytes) {
      var e, m, c;
      var eLen = nBytes * 8 - mLen - 1;
      var eMax = (1 << eLen) - 1;
      var eBias = eMax >> 1;
      var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
      var i = isLE ? 0 : nBytes - 1;
      var d = isLE ? 1 : -1;
      var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
      value = Math.abs(value);
      if (isNaN(value) || value === Infinity) {
        m = isNaN(value) ? 1 : 0;
        e = eMax;
      } else {
        e = Math.floor(Math.log(value) / Math.LN2);
        if (value * (c = Math.pow(2, -e)) < 1) {
          e--;
          c *= 2;
        }
        if (e + eBias >= 1) {
          value += rt / c;
        } else {
          value += rt * Math.pow(2, 1 - eBias);
        }
        if (value * c >= 2) {
          e++;
          c /= 2;
        }
        if (e + eBias >= eMax) {
          m = 0;
          e = eMax;
        } else if (e + eBias >= 1) {
          m = (value * c - 1) * Math.pow(2, mLen);
          e = e + eBias;
        } else {
          m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
          e = 0;
        }
      }
      for (; mLen >= 8; buffer[offset + i] = m & 255, i += d, m /= 256, mLen -= 8) {
      }
      e = e << mLen | m;
      eLen += mLen;
      for (; eLen > 0; buffer[offset + i] = e & 255, i += d, e /= 256, eLen -= 8) {
      }
      buffer[offset + i - d] |= s * 128;
    };
  }
});

// node_modules/buffer/index.js
var require_buffer = __commonJS({
  "node_modules/buffer/index.js"(exports) {
    "use strict";
    var base643 = require_base64_js();
    var ieee754 = require_ieee754();
    var customInspectSymbol = typeof Symbol === "function" && typeof Symbol["for"] === "function" ? Symbol["for"]("nodejs.util.inspect.custom") : null;
    exports.Buffer = Buffer3;
    exports.SlowBuffer = SlowBuffer;
    exports.INSPECT_MAX_BYTES = 50;
    var K_MAX_LENGTH = 2147483647;
    exports.kMaxLength = K_MAX_LENGTH;
    Buffer3.TYPED_ARRAY_SUPPORT = typedArraySupport();
    if (!Buffer3.TYPED_ARRAY_SUPPORT && typeof console !== "undefined" && typeof console.error === "function") {
      console.error(
        "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
      );
    }
    function typedArraySupport() {
      try {
        const arr = new Uint8Array(1);
        const proto = { foo: function() {
          return 42;
        } };
        Object.setPrototypeOf(proto, Uint8Array.prototype);
        Object.setPrototypeOf(arr, proto);
        return arr.foo() === 42;
      } catch (e) {
        return false;
      }
    }
    Object.defineProperty(Buffer3.prototype, "parent", {
      enumerable: true,
      get: function() {
        if (!Buffer3.isBuffer(this)) return void 0;
        return this.buffer;
      }
    });
    Object.defineProperty(Buffer3.prototype, "offset", {
      enumerable: true,
      get: function() {
        if (!Buffer3.isBuffer(this)) return void 0;
        return this.byteOffset;
      }
    });
    function createBuffer(length) {
      if (length > K_MAX_LENGTH) {
        throw new RangeError('The value "' + length + '" is invalid for option "size"');
      }
      const buf = new Uint8Array(length);
      Object.setPrototypeOf(buf, Buffer3.prototype);
      return buf;
    }
    function Buffer3(arg, encodingOrOffset, length) {
      if (typeof arg === "number") {
        if (typeof encodingOrOffset === "string") {
          throw new TypeError(
            'The "string" argument must be of type string. Received type number'
          );
        }
        return allocUnsafe(arg);
      }
      return from(arg, encodingOrOffset, length);
    }
    Buffer3.poolSize = 8192;
    function from(value, encodingOrOffset, length) {
      if (typeof value === "string") {
        return fromString(value, encodingOrOffset);
      }
      if (ArrayBuffer.isView(value)) {
        return fromArrayView(value);
      }
      if (value == null) {
        throw new TypeError(
          "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value
        );
      }
      if (isInstance(value, ArrayBuffer) || value && isInstance(value.buffer, ArrayBuffer)) {
        return fromArrayBuffer(value, encodingOrOffset, length);
      }
      if (typeof SharedArrayBuffer !== "undefined" && (isInstance(value, SharedArrayBuffer) || value && isInstance(value.buffer, SharedArrayBuffer))) {
        return fromArrayBuffer(value, encodingOrOffset, length);
      }
      if (typeof value === "number") {
        throw new TypeError(
          'The "value" argument must not be of type number. Received type number'
        );
      }
      const valueOf = value.valueOf && value.valueOf();
      if (valueOf != null && valueOf !== value) {
        return Buffer3.from(valueOf, encodingOrOffset, length);
      }
      const b = fromObject(value);
      if (b) return b;
      if (typeof Symbol !== "undefined" && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === "function") {
        return Buffer3.from(value[Symbol.toPrimitive]("string"), encodingOrOffset, length);
      }
      throw new TypeError(
        "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value
      );
    }
    Buffer3.from = function(value, encodingOrOffset, length) {
      return from(value, encodingOrOffset, length);
    };
    Object.setPrototypeOf(Buffer3.prototype, Uint8Array.prototype);
    Object.setPrototypeOf(Buffer3, Uint8Array);
    function assertSize(size) {
      if (typeof size !== "number") {
        throw new TypeError('"size" argument must be of type number');
      } else if (size < 0) {
        throw new RangeError('The value "' + size + '" is invalid for option "size"');
      }
    }
    function alloc(size, fill, encoding) {
      assertSize(size);
      if (size <= 0) {
        return createBuffer(size);
      }
      if (fill !== void 0) {
        return typeof encoding === "string" ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill);
      }
      return createBuffer(size);
    }
    Buffer3.alloc = function(size, fill, encoding) {
      return alloc(size, fill, encoding);
    };
    function allocUnsafe(size) {
      assertSize(size);
      return createBuffer(size < 0 ? 0 : checked(size) | 0);
    }
    Buffer3.allocUnsafe = function(size) {
      return allocUnsafe(size);
    };
    Buffer3.allocUnsafeSlow = function(size) {
      return allocUnsafe(size);
    };
    function fromString(string4, encoding) {
      if (typeof encoding !== "string" || encoding === "") {
        encoding = "utf8";
      }
      if (!Buffer3.isEncoding(encoding)) {
        throw new TypeError("Unknown encoding: " + encoding);
      }
      const length = byteLength(string4, encoding) | 0;
      let buf = createBuffer(length);
      const actual = buf.write(string4, encoding);
      if (actual !== length) {
        buf = buf.slice(0, actual);
      }
      return buf;
    }
    function fromArrayLike(array2) {
      const length = array2.length < 0 ? 0 : checked(array2.length) | 0;
      const buf = createBuffer(length);
      for (let i = 0; i < length; i += 1) {
        buf[i] = array2[i] & 255;
      }
      return buf;
    }
    function fromArrayView(arrayView) {
      if (isInstance(arrayView, Uint8Array)) {
        const copy = new Uint8Array(arrayView);
        return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength);
      }
      return fromArrayLike(arrayView);
    }
    function fromArrayBuffer(array2, byteOffset, length) {
      if (byteOffset < 0 || array2.byteLength < byteOffset) {
        throw new RangeError('"offset" is outside of buffer bounds');
      }
      if (array2.byteLength < byteOffset + (length || 0)) {
        throw new RangeError('"length" is outside of buffer bounds');
      }
      let buf;
      if (byteOffset === void 0 && length === void 0) {
        buf = new Uint8Array(array2);
      } else if (length === void 0) {
        buf = new Uint8Array(array2, byteOffset);
      } else {
        buf = new Uint8Array(array2, byteOffset, length);
      }
      Object.setPrototypeOf(buf, Buffer3.prototype);
      return buf;
    }
    function fromObject(obj) {
      if (Buffer3.isBuffer(obj)) {
        const len = checked(obj.length) | 0;
        const buf = createBuffer(len);
        if (buf.length === 0) {
          return buf;
        }
        obj.copy(buf, 0, 0, len);
        return buf;
      }
      if (obj.length !== void 0) {
        if (typeof obj.length !== "number" || numberIsNaN(obj.length)) {
          return createBuffer(0);
        }
        return fromArrayLike(obj);
      }
      if (obj.type === "Buffer" && Array.isArray(obj.data)) {
        return fromArrayLike(obj.data);
      }
    }
    function checked(length) {
      if (length >= K_MAX_LENGTH) {
        throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + K_MAX_LENGTH.toString(16) + " bytes");
      }
      return length | 0;
    }
    function SlowBuffer(length) {
      if (+length != length) {
        length = 0;
      }
      return Buffer3.alloc(+length);
    }
    Buffer3.isBuffer = function isBuffer(b) {
      return b != null && b._isBuffer === true && b !== Buffer3.prototype;
    };
    Buffer3.compare = function compare(a, b) {
      if (isInstance(a, Uint8Array)) a = Buffer3.from(a, a.offset, a.byteLength);
      if (isInstance(b, Uint8Array)) b = Buffer3.from(b, b.offset, b.byteLength);
      if (!Buffer3.isBuffer(a) || !Buffer3.isBuffer(b)) {
        throw new TypeError(
          'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
        );
      }
      if (a === b) return 0;
      let x = a.length;
      let y = b.length;
      for (let i = 0, len = Math.min(x, y); i < len; ++i) {
        if (a[i] !== b[i]) {
          x = a[i];
          y = b[i];
          break;
        }
      }
      if (x < y) return -1;
      if (y < x) return 1;
      return 0;
    };
    Buffer3.isEncoding = function isEncoding(encoding) {
      switch (String(encoding).toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "latin1":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return true;
        default:
          return false;
      }
    };
    Buffer3.concat = function concat2(list, length) {
      if (!Array.isArray(list)) {
        throw new TypeError('"list" argument must be an Array of Buffers');
      }
      if (list.length === 0) {
        return Buffer3.alloc(0);
      }
      let i;
      if (length === void 0) {
        length = 0;
        for (i = 0; i < list.length; ++i) {
          length += list[i].length;
        }
      }
      const buffer = Buffer3.allocUnsafe(length);
      let pos = 0;
      for (i = 0; i < list.length; ++i) {
        let buf = list[i];
        if (isInstance(buf, Uint8Array)) {
          if (pos + buf.length > buffer.length) {
            if (!Buffer3.isBuffer(buf)) buf = Buffer3.from(buf);
            buf.copy(buffer, pos);
          } else {
            Uint8Array.prototype.set.call(
              buffer,
              buf,
              pos
            );
          }
        } else if (!Buffer3.isBuffer(buf)) {
          throw new TypeError('"list" argument must be an Array of Buffers');
        } else {
          buf.copy(buffer, pos);
        }
        pos += buf.length;
      }
      return buffer;
    };
    function byteLength(string4, encoding) {
      if (Buffer3.isBuffer(string4)) {
        return string4.length;
      }
      if (ArrayBuffer.isView(string4) || isInstance(string4, ArrayBuffer)) {
        return string4.byteLength;
      }
      if (typeof string4 !== "string") {
        throw new TypeError(
          'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string4
        );
      }
      const len = string4.length;
      const mustMatch = arguments.length > 2 && arguments[2] === true;
      if (!mustMatch && len === 0) return 0;
      let loweredCase = false;
      for (; ; ) {
        switch (encoding) {
          case "ascii":
          case "latin1":
          case "binary":
            return len;
          case "utf8":
          case "utf-8":
            return utf8ToBytes(string4).length;
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return len * 2;
          case "hex":
            return len >>> 1;
          case "base64":
            return base64ToBytes(string4).length;
          default:
            if (loweredCase) {
              return mustMatch ? -1 : utf8ToBytes(string4).length;
            }
            encoding = ("" + encoding).toLowerCase();
            loweredCase = true;
        }
      }
    }
    Buffer3.byteLength = byteLength;
    function slowToString(encoding, start, end) {
      let loweredCase = false;
      if (start === void 0 || start < 0) {
        start = 0;
      }
      if (start > this.length) {
        return "";
      }
      if (end === void 0 || end > this.length) {
        end = this.length;
      }
      if (end <= 0) {
        return "";
      }
      end >>>= 0;
      start >>>= 0;
      if (end <= start) {
        return "";
      }
      if (!encoding) encoding = "utf8";
      while (true) {
        switch (encoding) {
          case "hex":
            return hexSlice(this, start, end);
          case "utf8":
          case "utf-8":
            return utf8Slice(this, start, end);
          case "ascii":
            return asciiSlice(this, start, end);
          case "latin1":
          case "binary":
            return latin1Slice(this, start, end);
          case "base64":
            return base64Slice(this, start, end);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return utf16leSlice(this, start, end);
          default:
            if (loweredCase) throw new TypeError("Unknown encoding: " + encoding);
            encoding = (encoding + "").toLowerCase();
            loweredCase = true;
        }
      }
    }
    Buffer3.prototype._isBuffer = true;
    function swap(b, n, m) {
      const i = b[n];
      b[n] = b[m];
      b[m] = i;
    }
    Buffer3.prototype.swap16 = function swap16() {
      const len = this.length;
      if (len % 2 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 16-bits");
      }
      for (let i = 0; i < len; i += 2) {
        swap(this, i, i + 1);
      }
      return this;
    };
    Buffer3.prototype.swap32 = function swap32() {
      const len = this.length;
      if (len % 4 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 32-bits");
      }
      for (let i = 0; i < len; i += 4) {
        swap(this, i, i + 3);
        swap(this, i + 1, i + 2);
      }
      return this;
    };
    Buffer3.prototype.swap64 = function swap64() {
      const len = this.length;
      if (len % 8 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 64-bits");
      }
      for (let i = 0; i < len; i += 8) {
        swap(this, i, i + 7);
        swap(this, i + 1, i + 6);
        swap(this, i + 2, i + 5);
        swap(this, i + 3, i + 4);
      }
      return this;
    };
    Buffer3.prototype.toString = function toString2() {
      const length = this.length;
      if (length === 0) return "";
      if (arguments.length === 0) return utf8Slice(this, 0, length);
      return slowToString.apply(this, arguments);
    };
    Buffer3.prototype.toLocaleString = Buffer3.prototype.toString;
    Buffer3.prototype.equals = function equals(b) {
      if (!Buffer3.isBuffer(b)) throw new TypeError("Argument must be a Buffer");
      if (this === b) return true;
      return Buffer3.compare(this, b) === 0;
    };
    Buffer3.prototype.inspect = function inspect() {
      let str2 = "";
      const max = exports.INSPECT_MAX_BYTES;
      str2 = this.toString("hex", 0, max).replace(/(.{2})/g, "$1 ").trim();
      if (this.length > max) str2 += " ... ";
      return "<Buffer " + str2 + ">";
    };
    if (customInspectSymbol) {
      Buffer3.prototype[customInspectSymbol] = Buffer3.prototype.inspect;
    }
    Buffer3.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
      if (isInstance(target, Uint8Array)) {
        target = Buffer3.from(target, target.offset, target.byteLength);
      }
      if (!Buffer3.isBuffer(target)) {
        throw new TypeError(
          'The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof target
        );
      }
      if (start === void 0) {
        start = 0;
      }
      if (end === void 0) {
        end = target ? target.length : 0;
      }
      if (thisStart === void 0) {
        thisStart = 0;
      }
      if (thisEnd === void 0) {
        thisEnd = this.length;
      }
      if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
        throw new RangeError("out of range index");
      }
      if (thisStart >= thisEnd && start >= end) {
        return 0;
      }
      if (thisStart >= thisEnd) {
        return -1;
      }
      if (start >= end) {
        return 1;
      }
      start >>>= 0;
      end >>>= 0;
      thisStart >>>= 0;
      thisEnd >>>= 0;
      if (this === target) return 0;
      let x = thisEnd - thisStart;
      let y = end - start;
      const len = Math.min(x, y);
      const thisCopy = this.slice(thisStart, thisEnd);
      const targetCopy = target.slice(start, end);
      for (let i = 0; i < len; ++i) {
        if (thisCopy[i] !== targetCopy[i]) {
          x = thisCopy[i];
          y = targetCopy[i];
          break;
        }
      }
      if (x < y) return -1;
      if (y < x) return 1;
      return 0;
    };
    function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
      if (buffer.length === 0) return -1;
      if (typeof byteOffset === "string") {
        encoding = byteOffset;
        byteOffset = 0;
      } else if (byteOffset > 2147483647) {
        byteOffset = 2147483647;
      } else if (byteOffset < -2147483648) {
        byteOffset = -2147483648;
      }
      byteOffset = +byteOffset;
      if (numberIsNaN(byteOffset)) {
        byteOffset = dir ? 0 : buffer.length - 1;
      }
      if (byteOffset < 0) byteOffset = buffer.length + byteOffset;
      if (byteOffset >= buffer.length) {
        if (dir) return -1;
        else byteOffset = buffer.length - 1;
      } else if (byteOffset < 0) {
        if (dir) byteOffset = 0;
        else return -1;
      }
      if (typeof val === "string") {
        val = Buffer3.from(val, encoding);
      }
      if (Buffer3.isBuffer(val)) {
        if (val.length === 0) {
          return -1;
        }
        return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
      } else if (typeof val === "number") {
        val = val & 255;
        if (typeof Uint8Array.prototype.indexOf === "function") {
          if (dir) {
            return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
          } else {
            return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
          }
        }
        return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);
      }
      throw new TypeError("val must be string, number or Buffer");
    }
    function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
      let indexSize = 1;
      let arrLength = arr.length;
      let valLength = val.length;
      if (encoding !== void 0) {
        encoding = String(encoding).toLowerCase();
        if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
          if (arr.length < 2 || val.length < 2) {
            return -1;
          }
          indexSize = 2;
          arrLength /= 2;
          valLength /= 2;
          byteOffset /= 2;
        }
      }
      function read(buf, i2) {
        if (indexSize === 1) {
          return buf[i2];
        } else {
          return buf.readUInt16BE(i2 * indexSize);
        }
      }
      let i;
      if (dir) {
        let foundIndex = -1;
        for (i = byteOffset; i < arrLength; i++) {
          if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
            if (foundIndex === -1) foundIndex = i;
            if (i - foundIndex + 1 === valLength) return foundIndex * indexSize;
          } else {
            if (foundIndex !== -1) i -= i - foundIndex;
            foundIndex = -1;
          }
        }
      } else {
        if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;
        for (i = byteOffset; i >= 0; i--) {
          let found = true;
          for (let j = 0; j < valLength; j++) {
            if (read(arr, i + j) !== read(val, j)) {
              found = false;
              break;
            }
          }
          if (found) return i;
        }
      }
      return -1;
    }
    Buffer3.prototype.includes = function includes(val, byteOffset, encoding) {
      return this.indexOf(val, byteOffset, encoding) !== -1;
    };
    Buffer3.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
    };
    Buffer3.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
    };
    function hexWrite(buf, string4, offset, length) {
      offset = Number(offset) || 0;
      const remaining = buf.length - offset;
      if (!length) {
        length = remaining;
      } else {
        length = Number(length);
        if (length > remaining) {
          length = remaining;
        }
      }
      const strLen = string4.length;
      if (length > strLen / 2) {
        length = strLen / 2;
      }
      let i;
      for (i = 0; i < length; ++i) {
        const parsed = parseInt(string4.substr(i * 2, 2), 16);
        if (numberIsNaN(parsed)) return i;
        buf[offset + i] = parsed;
      }
      return i;
    }
    function utf8Write(buf, string4, offset, length) {
      return blitBuffer(utf8ToBytes(string4, buf.length - offset), buf, offset, length);
    }
    function asciiWrite(buf, string4, offset, length) {
      return blitBuffer(asciiToBytes(string4), buf, offset, length);
    }
    function base64Write(buf, string4, offset, length) {
      return blitBuffer(base64ToBytes(string4), buf, offset, length);
    }
    function ucs2Write(buf, string4, offset, length) {
      return blitBuffer(utf16leToBytes(string4, buf.length - offset), buf, offset, length);
    }
    Buffer3.prototype.write = function write(string4, offset, length, encoding) {
      if (offset === void 0) {
        encoding = "utf8";
        length = this.length;
        offset = 0;
      } else if (length === void 0 && typeof offset === "string") {
        encoding = offset;
        length = this.length;
        offset = 0;
      } else if (isFinite(offset)) {
        offset = offset >>> 0;
        if (isFinite(length)) {
          length = length >>> 0;
          if (encoding === void 0) encoding = "utf8";
        } else {
          encoding = length;
          length = void 0;
        }
      } else {
        throw new Error(
          "Buffer.write(string, encoding, offset[, length]) is no longer supported"
        );
      }
      const remaining = this.length - offset;
      if (length === void 0 || length > remaining) length = remaining;
      if (string4.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
        throw new RangeError("Attempt to write outside buffer bounds");
      }
      if (!encoding) encoding = "utf8";
      let loweredCase = false;
      for (; ; ) {
        switch (encoding) {
          case "hex":
            return hexWrite(this, string4, offset, length);
          case "utf8":
          case "utf-8":
            return utf8Write(this, string4, offset, length);
          case "ascii":
          case "latin1":
          case "binary":
            return asciiWrite(this, string4, offset, length);
          case "base64":
            return base64Write(this, string4, offset, length);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return ucs2Write(this, string4, offset, length);
          default:
            if (loweredCase) throw new TypeError("Unknown encoding: " + encoding);
            encoding = ("" + encoding).toLowerCase();
            loweredCase = true;
        }
      }
    };
    Buffer3.prototype.toJSON = function toJSON() {
      return {
        type: "Buffer",
        data: Array.prototype.slice.call(this._arr || this, 0)
      };
    };
    function base64Slice(buf, start, end) {
      if (start === 0 && end === buf.length) {
        return base643.fromByteArray(buf);
      } else {
        return base643.fromByteArray(buf.slice(start, end));
      }
    }
    function utf8Slice(buf, start, end) {
      end = Math.min(buf.length, end);
      const res = [];
      let i = start;
      while (i < end) {
        const firstByte = buf[i];
        let codePoint = null;
        let bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
        if (i + bytesPerSequence <= end) {
          let secondByte, thirdByte, fourthByte, tempCodePoint;
          switch (bytesPerSequence) {
            case 1:
              if (firstByte < 128) {
                codePoint = firstByte;
              }
              break;
            case 2:
              secondByte = buf[i + 1];
              if ((secondByte & 192) === 128) {
                tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
                if (tempCodePoint > 127) {
                  codePoint = tempCodePoint;
                }
              }
              break;
            case 3:
              secondByte = buf[i + 1];
              thirdByte = buf[i + 2];
              if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
                tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
                if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                  codePoint = tempCodePoint;
                }
              }
              break;
            case 4:
              secondByte = buf[i + 1];
              thirdByte = buf[i + 2];
              fourthByte = buf[i + 3];
              if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
                tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
                if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                  codePoint = tempCodePoint;
                }
              }
          }
        }
        if (codePoint === null) {
          codePoint = 65533;
          bytesPerSequence = 1;
        } else if (codePoint > 65535) {
          codePoint -= 65536;
          res.push(codePoint >>> 10 & 1023 | 55296);
          codePoint = 56320 | codePoint & 1023;
        }
        res.push(codePoint);
        i += bytesPerSequence;
      }
      return decodeCodePointsArray(res);
    }
    var MAX_ARGUMENTS_LENGTH = 4096;
    function decodeCodePointsArray(codePoints) {
      const len = codePoints.length;
      if (len <= MAX_ARGUMENTS_LENGTH) {
        return String.fromCharCode.apply(String, codePoints);
      }
      let res = "";
      let i = 0;
      while (i < len) {
        res += String.fromCharCode.apply(
          String,
          codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
        );
      }
      return res;
    }
    function asciiSlice(buf, start, end) {
      let ret = "";
      end = Math.min(buf.length, end);
      for (let i = start; i < end; ++i) {
        ret += String.fromCharCode(buf[i] & 127);
      }
      return ret;
    }
    function latin1Slice(buf, start, end) {
      let ret = "";
      end = Math.min(buf.length, end);
      for (let i = start; i < end; ++i) {
        ret += String.fromCharCode(buf[i]);
      }
      return ret;
    }
    function hexSlice(buf, start, end) {
      const len = buf.length;
      if (!start || start < 0) start = 0;
      if (!end || end < 0 || end > len) end = len;
      let out = "";
      for (let i = start; i < end; ++i) {
        out += hexSliceLookupTable[buf[i]];
      }
      return out;
    }
    function utf16leSlice(buf, start, end) {
      const bytes = buf.slice(start, end);
      let res = "";
      for (let i = 0; i < bytes.length - 1; i += 2) {
        res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
      }
      return res;
    }
    Buffer3.prototype.slice = function slice(start, end) {
      const len = this.length;
      start = ~~start;
      end = end === void 0 ? len : ~~end;
      if (start < 0) {
        start += len;
        if (start < 0) start = 0;
      } else if (start > len) {
        start = len;
      }
      if (end < 0) {
        end += len;
        if (end < 0) end = 0;
      } else if (end > len) {
        end = len;
      }
      if (end < start) end = start;
      const newBuf = this.subarray(start, end);
      Object.setPrototypeOf(newBuf, Buffer3.prototype);
      return newBuf;
    };
    function checkOffset(offset, ext, length) {
      if (offset % 1 !== 0 || offset < 0) throw new RangeError("offset is not uint");
      if (offset + ext > length) throw new RangeError("Trying to access beyond buffer length");
    }
    Buffer3.prototype.readUintLE = Buffer3.prototype.readUIntLE = function readUIntLE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) checkOffset(offset, byteLength2, this.length);
      let val = this[offset];
      let mul = 1;
      let i = 0;
      while (++i < byteLength2 && (mul *= 256)) {
        val += this[offset + i] * mul;
      }
      return val;
    };
    Buffer3.prototype.readUintBE = Buffer3.prototype.readUIntBE = function readUIntBE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) {
        checkOffset(offset, byteLength2, this.length);
      }
      let val = this[offset + --byteLength2];
      let mul = 1;
      while (byteLength2 > 0 && (mul *= 256)) {
        val += this[offset + --byteLength2] * mul;
      }
      return val;
    };
    Buffer3.prototype.readUint8 = Buffer3.prototype.readUInt8 = function readUInt8(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 1, this.length);
      return this[offset];
    };
    Buffer3.prototype.readUint16LE = Buffer3.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 2, this.length);
      return this[offset] | this[offset + 1] << 8;
    };
    Buffer3.prototype.readUint16BE = Buffer3.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 2, this.length);
      return this[offset] << 8 | this[offset + 1];
    };
    Buffer3.prototype.readUint32LE = Buffer3.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 4, this.length);
      return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;
    };
    Buffer3.prototype.readUint32BE = Buffer3.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 4, this.length);
      return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
    };
    Buffer3.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE(offset) {
      offset = offset >>> 0;
      validateNumber(offset, "offset");
      const first = this[offset];
      const last = this[offset + 7];
      if (first === void 0 || last === void 0) {
        boundsError(offset, this.length - 8);
      }
      const lo = first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24;
      const hi = this[++offset] + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + last * 2 ** 24;
      return BigInt(lo) + (BigInt(hi) << BigInt(32));
    });
    Buffer3.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE(offset) {
      offset = offset >>> 0;
      validateNumber(offset, "offset");
      const first = this[offset];
      const last = this[offset + 7];
      if (first === void 0 || last === void 0) {
        boundsError(offset, this.length - 8);
      }
      const hi = first * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
      const lo = this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last;
      return (BigInt(hi) << BigInt(32)) + BigInt(lo);
    });
    Buffer3.prototype.readIntLE = function readIntLE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) checkOffset(offset, byteLength2, this.length);
      let val = this[offset];
      let mul = 1;
      let i = 0;
      while (++i < byteLength2 && (mul *= 256)) {
        val += this[offset + i] * mul;
      }
      mul *= 128;
      if (val >= mul) val -= Math.pow(2, 8 * byteLength2);
      return val;
    };
    Buffer3.prototype.readIntBE = function readIntBE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) checkOffset(offset, byteLength2, this.length);
      let i = byteLength2;
      let mul = 1;
      let val = this[offset + --i];
      while (i > 0 && (mul *= 256)) {
        val += this[offset + --i] * mul;
      }
      mul *= 128;
      if (val >= mul) val -= Math.pow(2, 8 * byteLength2);
      return val;
    };
    Buffer3.prototype.readInt8 = function readInt8(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 1, this.length);
      if (!(this[offset] & 128)) return this[offset];
      return (255 - this[offset] + 1) * -1;
    };
    Buffer3.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 2, this.length);
      const val = this[offset] | this[offset + 1] << 8;
      return val & 32768 ? val | 4294901760 : val;
    };
    Buffer3.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 2, this.length);
      const val = this[offset + 1] | this[offset] << 8;
      return val & 32768 ? val | 4294901760 : val;
    };
    Buffer3.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 4, this.length);
      return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
    };
    Buffer3.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 4, this.length);
      return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
    };
    Buffer3.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE(offset) {
      offset = offset >>> 0;
      validateNumber(offset, "offset");
      const first = this[offset];
      const last = this[offset + 7];
      if (first === void 0 || last === void 0) {
        boundsError(offset, this.length - 8);
      }
      const val = this[offset + 4] + this[offset + 5] * 2 ** 8 + this[offset + 6] * 2 ** 16 + (last << 24);
      return (BigInt(val) << BigInt(32)) + BigInt(first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24);
    });
    Buffer3.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE(offset) {
      offset = offset >>> 0;
      validateNumber(offset, "offset");
      const first = this[offset];
      const last = this[offset + 7];
      if (first === void 0 || last === void 0) {
        boundsError(offset, this.length - 8);
      }
      const val = (first << 24) + // Overflow
      this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
      return (BigInt(val) << BigInt(32)) + BigInt(this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last);
    });
    Buffer3.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 4, this.length);
      return ieee754.read(this, offset, true, 23, 4);
    };
    Buffer3.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 4, this.length);
      return ieee754.read(this, offset, false, 23, 4);
    };
    Buffer3.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 8, this.length);
      return ieee754.read(this, offset, true, 52, 8);
    };
    Buffer3.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 8, this.length);
      return ieee754.read(this, offset, false, 52, 8);
    };
    function checkInt(buf, value, offset, ext, max, min) {
      if (!Buffer3.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance');
      if (value > max || value < min) throw new RangeError('"value" argument is out of bounds');
      if (offset + ext > buf.length) throw new RangeError("Index out of range");
    }
    Buffer3.prototype.writeUintLE = Buffer3.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) {
        const maxBytes = Math.pow(2, 8 * byteLength2) - 1;
        checkInt(this, value, offset, byteLength2, maxBytes, 0);
      }
      let mul = 1;
      let i = 0;
      this[offset] = value & 255;
      while (++i < byteLength2 && (mul *= 256)) {
        this[offset + i] = value / mul & 255;
      }
      return offset + byteLength2;
    };
    Buffer3.prototype.writeUintBE = Buffer3.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) {
        const maxBytes = Math.pow(2, 8 * byteLength2) - 1;
        checkInt(this, value, offset, byteLength2, maxBytes, 0);
      }
      let i = byteLength2 - 1;
      let mul = 1;
      this[offset + i] = value & 255;
      while (--i >= 0 && (mul *= 256)) {
        this[offset + i] = value / mul & 255;
      }
      return offset + byteLength2;
    };
    Buffer3.prototype.writeUint8 = Buffer3.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 1, 255, 0);
      this[offset] = value & 255;
      return offset + 1;
    };
    Buffer3.prototype.writeUint16LE = Buffer3.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 2, 65535, 0);
      this[offset] = value & 255;
      this[offset + 1] = value >>> 8;
      return offset + 2;
    };
    Buffer3.prototype.writeUint16BE = Buffer3.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 2, 65535, 0);
      this[offset] = value >>> 8;
      this[offset + 1] = value & 255;
      return offset + 2;
    };
    Buffer3.prototype.writeUint32LE = Buffer3.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 4, 4294967295, 0);
      this[offset + 3] = value >>> 24;
      this[offset + 2] = value >>> 16;
      this[offset + 1] = value >>> 8;
      this[offset] = value & 255;
      return offset + 4;
    };
    Buffer3.prototype.writeUint32BE = Buffer3.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 4, 4294967295, 0);
      this[offset] = value >>> 24;
      this[offset + 1] = value >>> 16;
      this[offset + 2] = value >>> 8;
      this[offset + 3] = value & 255;
      return offset + 4;
    };
    function wrtBigUInt64LE(buf, value, offset, min, max) {
      checkIntBI(value, min, max, buf, offset, 7);
      let lo = Number(value & BigInt(4294967295));
      buf[offset++] = lo;
      lo = lo >> 8;
      buf[offset++] = lo;
      lo = lo >> 8;
      buf[offset++] = lo;
      lo = lo >> 8;
      buf[offset++] = lo;
      let hi = Number(value >> BigInt(32) & BigInt(4294967295));
      buf[offset++] = hi;
      hi = hi >> 8;
      buf[offset++] = hi;
      hi = hi >> 8;
      buf[offset++] = hi;
      hi = hi >> 8;
      buf[offset++] = hi;
      return offset;
    }
    function wrtBigUInt64BE(buf, value, offset, min, max) {
      checkIntBI(value, min, max, buf, offset, 7);
      let lo = Number(value & BigInt(4294967295));
      buf[offset + 7] = lo;
      lo = lo >> 8;
      buf[offset + 6] = lo;
      lo = lo >> 8;
      buf[offset + 5] = lo;
      lo = lo >> 8;
      buf[offset + 4] = lo;
      let hi = Number(value >> BigInt(32) & BigInt(4294967295));
      buf[offset + 3] = hi;
      hi = hi >> 8;
      buf[offset + 2] = hi;
      hi = hi >> 8;
      buf[offset + 1] = hi;
      hi = hi >> 8;
      buf[offset] = hi;
      return offset + 8;
    }
    Buffer3.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE(value, offset = 0) {
      return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
    });
    Buffer3.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE(value, offset = 0) {
      return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
    });
    Buffer3.prototype.writeIntLE = function writeIntLE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        const limit = Math.pow(2, 8 * byteLength2 - 1);
        checkInt(this, value, offset, byteLength2, limit - 1, -limit);
      }
      let i = 0;
      let mul = 1;
      let sub = 0;
      this[offset] = value & 255;
      while (++i < byteLength2 && (mul *= 256)) {
        if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
          sub = 1;
        }
        this[offset + i] = (value / mul >> 0) - sub & 255;
      }
      return offset + byteLength2;
    };
    Buffer3.prototype.writeIntBE = function writeIntBE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        const limit = Math.pow(2, 8 * byteLength2 - 1);
        checkInt(this, value, offset, byteLength2, limit - 1, -limit);
      }
      let i = byteLength2 - 1;
      let mul = 1;
      let sub = 0;
      this[offset + i] = value & 255;
      while (--i >= 0 && (mul *= 256)) {
        if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
          sub = 1;
        }
        this[offset + i] = (value / mul >> 0) - sub & 255;
      }
      return offset + byteLength2;
    };
    Buffer3.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 1, 127, -128);
      if (value < 0) value = 255 + value + 1;
      this[offset] = value & 255;
      return offset + 1;
    };
    Buffer3.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 2, 32767, -32768);
      this[offset] = value & 255;
      this[offset + 1] = value >>> 8;
      return offset + 2;
    };
    Buffer3.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 2, 32767, -32768);
      this[offset] = value >>> 8;
      this[offset + 1] = value & 255;
      return offset + 2;
    };
    Buffer3.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 4, 2147483647, -2147483648);
      this[offset] = value & 255;
      this[offset + 1] = value >>> 8;
      this[offset + 2] = value >>> 16;
      this[offset + 3] = value >>> 24;
      return offset + 4;
    };
    Buffer3.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 4, 2147483647, -2147483648);
      if (value < 0) value = 4294967295 + value + 1;
      this[offset] = value >>> 24;
      this[offset + 1] = value >>> 16;
      this[offset + 2] = value >>> 8;
      this[offset + 3] = value & 255;
      return offset + 4;
    };
    Buffer3.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE(value, offset = 0) {
      return wrtBigUInt64LE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
    });
    Buffer3.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE(value, offset = 0) {
      return wrtBigUInt64BE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
    });
    function checkIEEE754(buf, value, offset, ext, max, min) {
      if (offset + ext > buf.length) throw new RangeError("Index out of range");
      if (offset < 0) throw new RangeError("Index out of range");
    }
    function writeFloat(buf, value, offset, littleEndian, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        checkIEEE754(buf, value, offset, 4, 34028234663852886e22, -34028234663852886e22);
      }
      ieee754.write(buf, value, offset, littleEndian, 23, 4);
      return offset + 4;
    }
    Buffer3.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
      return writeFloat(this, value, offset, true, noAssert);
    };
    Buffer3.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
      return writeFloat(this, value, offset, false, noAssert);
    };
    function writeDouble(buf, value, offset, littleEndian, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        checkIEEE754(buf, value, offset, 8, 17976931348623157e292, -17976931348623157e292);
      }
      ieee754.write(buf, value, offset, littleEndian, 52, 8);
      return offset + 8;
    }
    Buffer3.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
      return writeDouble(this, value, offset, true, noAssert);
    };
    Buffer3.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
      return writeDouble(this, value, offset, false, noAssert);
    };
    Buffer3.prototype.copy = function copy(target, targetStart, start, end) {
      if (!Buffer3.isBuffer(target)) throw new TypeError("argument should be a Buffer");
      if (!start) start = 0;
      if (!end && end !== 0) end = this.length;
      if (targetStart >= target.length) targetStart = target.length;
      if (!targetStart) targetStart = 0;
      if (end > 0 && end < start) end = start;
      if (end === start) return 0;
      if (target.length === 0 || this.length === 0) return 0;
      if (targetStart < 0) {
        throw new RangeError("targetStart out of bounds");
      }
      if (start < 0 || start >= this.length) throw new RangeError("Index out of range");
      if (end < 0) throw new RangeError("sourceEnd out of bounds");
      if (end > this.length) end = this.length;
      if (target.length - targetStart < end - start) {
        end = target.length - targetStart + start;
      }
      const len = end - start;
      if (this === target && typeof Uint8Array.prototype.copyWithin === "function") {
        this.copyWithin(targetStart, start, end);
      } else {
        Uint8Array.prototype.set.call(
          target,
          this.subarray(start, end),
          targetStart
        );
      }
      return len;
    };
    Buffer3.prototype.fill = function fill(val, start, end, encoding) {
      if (typeof val === "string") {
        if (typeof start === "string") {
          encoding = start;
          start = 0;
          end = this.length;
        } else if (typeof end === "string") {
          encoding = end;
          end = this.length;
        }
        if (encoding !== void 0 && typeof encoding !== "string") {
          throw new TypeError("encoding must be a string");
        }
        if (typeof encoding === "string" && !Buffer3.isEncoding(encoding)) {
          throw new TypeError("Unknown encoding: " + encoding);
        }
        if (val.length === 1) {
          const code = val.charCodeAt(0);
          if (encoding === "utf8" && code < 128 || encoding === "latin1") {
            val = code;
          }
        }
      } else if (typeof val === "number") {
        val = val & 255;
      } else if (typeof val === "boolean") {
        val = Number(val);
      }
      if (start < 0 || this.length < start || this.length < end) {
        throw new RangeError("Out of range index");
      }
      if (end <= start) {
        return this;
      }
      start = start >>> 0;
      end = end === void 0 ? this.length : end >>> 0;
      if (!val) val = 0;
      let i;
      if (typeof val === "number") {
        for (i = start; i < end; ++i) {
          this[i] = val;
        }
      } else {
        const bytes = Buffer3.isBuffer(val) ? val : Buffer3.from(val, encoding);
        const len = bytes.length;
        if (len === 0) {
          throw new TypeError('The value "' + val + '" is invalid for argument "value"');
        }
        for (i = 0; i < end - start; ++i) {
          this[i + start] = bytes[i % len];
        }
      }
      return this;
    };
    var errors = {};
    function E(sym, getMessage, Base) {
      errors[sym] = class NodeError extends Base {
        constructor() {
          super();
          Object.defineProperty(this, "message", {
            value: getMessage.apply(this, arguments),
            writable: true,
            configurable: true
          });
          this.name = `${this.name} [${sym}]`;
          this.stack;
          delete this.name;
        }
        get code() {
          return sym;
        }
        set code(value) {
          Object.defineProperty(this, "code", {
            configurable: true,
            enumerable: true,
            value,
            writable: true
          });
        }
        toString() {
          return `${this.name} [${sym}]: ${this.message}`;
        }
      };
    }
    E(
      "ERR_BUFFER_OUT_OF_BOUNDS",
      function(name) {
        if (name) {
          return `${name} is outside of buffer bounds`;
        }
        return "Attempt to access memory outside buffer bounds";
      },
      RangeError
    );
    E(
      "ERR_INVALID_ARG_TYPE",
      function(name, actual) {
        return `The "${name}" argument must be of type number. Received type ${typeof actual}`;
      },
      TypeError
    );
    E(
      "ERR_OUT_OF_RANGE",
      function(str2, range, input) {
        let msg = `The value of "${str2}" is out of range.`;
        let received = input;
        if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {
          received = addNumericalSeparator(String(input));
        } else if (typeof input === "bigint") {
          received = String(input);
          if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) {
            received = addNumericalSeparator(received);
          }
          received += "n";
        }
        msg += ` It must be ${range}. Received ${received}`;
        return msg;
      },
      RangeError
    );
    function addNumericalSeparator(val) {
      let res = "";
      let i = val.length;
      const start = val[0] === "-" ? 1 : 0;
      for (; i >= start + 4; i -= 3) {
        res = `_${val.slice(i - 3, i)}${res}`;
      }
      return `${val.slice(0, i)}${res}`;
    }
    function checkBounds(buf, offset, byteLength2) {
      validateNumber(offset, "offset");
      if (buf[offset] === void 0 || buf[offset + byteLength2] === void 0) {
        boundsError(offset, buf.length - (byteLength2 + 1));
      }
    }
    function checkIntBI(value, min, max, buf, offset, byteLength2) {
      if (value > max || value < min) {
        const n = typeof min === "bigint" ? "n" : "";
        let range;
        if (byteLength2 > 3) {
          if (min === 0 || min === BigInt(0)) {
            range = `>= 0${n} and < 2${n} ** ${(byteLength2 + 1) * 8}${n}`;
          } else {
            range = `>= -(2${n} ** ${(byteLength2 + 1) * 8 - 1}${n}) and < 2 ** ${(byteLength2 + 1) * 8 - 1}${n}`;
          }
        } else {
          range = `>= ${min}${n} and <= ${max}${n}`;
        }
        throw new errors.ERR_OUT_OF_RANGE("value", range, value);
      }
      checkBounds(buf, offset, byteLength2);
    }
    function validateNumber(value, name) {
      if (typeof value !== "number") {
        throw new errors.ERR_INVALID_ARG_TYPE(name, "number", value);
      }
    }
    function boundsError(value, length, type2) {
      if (Math.floor(value) !== value) {
        validateNumber(value, type2);
        throw new errors.ERR_OUT_OF_RANGE(type2 || "offset", "an integer", value);
      }
      if (length < 0) {
        throw new errors.ERR_BUFFER_OUT_OF_BOUNDS();
      }
      throw new errors.ERR_OUT_OF_RANGE(
        type2 || "offset",
        `>= ${type2 ? 1 : 0} and <= ${length}`,
        value
      );
    }
    var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
    function base64clean(str2) {
      str2 = str2.split("=")[0];
      str2 = str2.trim().replace(INVALID_BASE64_RE, "");
      if (str2.length < 2) return "";
      while (str2.length % 4 !== 0) {
        str2 = str2 + "=";
      }
      return str2;
    }
    function utf8ToBytes(string4, units) {
      units = units || Infinity;
      let codePoint;
      const length = string4.length;
      let leadSurrogate = null;
      const bytes = [];
      for (let i = 0; i < length; ++i) {
        codePoint = string4.charCodeAt(i);
        if (codePoint > 55295 && codePoint < 57344) {
          if (!leadSurrogate) {
            if (codePoint > 56319) {
              if ((units -= 3) > -1) bytes.push(239, 191, 189);
              continue;
            } else if (i + 1 === length) {
              if ((units -= 3) > -1) bytes.push(239, 191, 189);
              continue;
            }
            leadSurrogate = codePoint;
            continue;
          }
          if (codePoint < 56320) {
            if ((units -= 3) > -1) bytes.push(239, 191, 189);
            leadSurrogate = codePoint;
            continue;
          }
          codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
        } else if (leadSurrogate) {
          if ((units -= 3) > -1) bytes.push(239, 191, 189);
        }
        leadSurrogate = null;
        if (codePoint < 128) {
          if ((units -= 1) < 0) break;
          bytes.push(codePoint);
        } else if (codePoint < 2048) {
          if ((units -= 2) < 0) break;
          bytes.push(
            codePoint >> 6 | 192,
            codePoint & 63 | 128
          );
        } else if (codePoint < 65536) {
          if ((units -= 3) < 0) break;
          bytes.push(
            codePoint >> 12 | 224,
            codePoint >> 6 & 63 | 128,
            codePoint & 63 | 128
          );
        } else if (codePoint < 1114112) {
          if ((units -= 4) < 0) break;
          bytes.push(
            codePoint >> 18 | 240,
            codePoint >> 12 & 63 | 128,
            codePoint >> 6 & 63 | 128,
            codePoint & 63 | 128
          );
        } else {
          throw new Error("Invalid code point");
        }
      }
      return bytes;
    }
    function asciiToBytes(str2) {
      const byteArray = [];
      for (let i = 0; i < str2.length; ++i) {
        byteArray.push(str2.charCodeAt(i) & 255);
      }
      return byteArray;
    }
    function utf16leToBytes(str2, units) {
      let c, hi, lo;
      const byteArray = [];
      for (let i = 0; i < str2.length; ++i) {
        if ((units -= 2) < 0) break;
        c = str2.charCodeAt(i);
        hi = c >> 8;
        lo = c % 256;
        byteArray.push(lo);
        byteArray.push(hi);
      }
      return byteArray;
    }
    function base64ToBytes(str2) {
      return base643.toByteArray(base64clean(str2));
    }
    function blitBuffer(src, dst, offset, length) {
      let i;
      for (i = 0; i < length; ++i) {
        if (i + offset >= dst.length || i >= src.length) break;
        dst[i + offset] = src[i];
      }
      return i;
    }
    function isInstance(obj, type2) {
      return obj instanceof type2 || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type2.name;
    }
    function numberIsNaN(obj) {
      return obj !== obj;
    }
    var hexSliceLookupTable = (function() {
      const alphabet = "0123456789abcdef";
      const table = new Array(256);
      for (let i = 0; i < 16; ++i) {
        const i16 = i * 16;
        for (let j = 0; j < 16; ++j) {
          table[i16 + j] = alphabet[i] + alphabet[j];
        }
      }
      return table;
    })();
    function defineBigIntMethod(fn) {
      return typeof BigInt === "undefined" ? BufferBigIntNotDefined : fn;
    }
    function BufferBigIntNotDefined() {
      throw new Error("BigInt not supported");
    }
  }
});

// node_modules/@bergos/jsonparse/jsonparse.js
var require_jsonparse = __commonJS({
  "node_modules/@bergos/jsonparse/jsonparse.js"(exports, module) {
    var { Buffer: Buffer3 } = require_buffer();
    var C = {};
    var LEFT_BRACE = C.LEFT_BRACE = 1;
    var RIGHT_BRACE = C.RIGHT_BRACE = 2;
    var LEFT_BRACKET = C.LEFT_BRACKET = 3;
    var RIGHT_BRACKET = C.RIGHT_BRACKET = 4;
    var COLON = C.COLON = 5;
    var COMMA = C.COMMA = 6;
    var TRUE = C.TRUE = 7;
    var FALSE = C.FALSE = 8;
    var NULL = C.NULL = 9;
    var STRING = C.STRING = 10;
    var NUMBER = C.NUMBER = 11;
    var START = C.START = 17;
    var STOP = C.STOP = 18;
    var TRUE1 = C.TRUE1 = 33;
    var TRUE2 = C.TRUE2 = 34;
    var TRUE3 = C.TRUE3 = 35;
    var FALSE1 = C.FALSE1 = 49;
    var FALSE2 = C.FALSE2 = 50;
    var FALSE3 = C.FALSE3 = 51;
    var FALSE4 = C.FALSE4 = 52;
    var NULL1 = C.NULL1 = 65;
    var NULL2 = C.NULL2 = 66;
    var NULL3 = C.NULL3 = 67;
    var NUMBER1 = C.NUMBER1 = 81;
    var NUMBER3 = C.NUMBER3 = 83;
    var STRING1 = C.STRING1 = 97;
    var STRING2 = C.STRING2 = 98;
    var STRING3 = C.STRING3 = 99;
    var STRING4 = C.STRING4 = 100;
    var STRING5 = C.STRING5 = 101;
    var STRING6 = C.STRING6 = 102;
    var VALUE = C.VALUE = 113;
    var KEY = C.KEY = 114;
    var OBJECT = C.OBJECT = 129;
    var ARRAY = C.ARRAY = 130;
    var BACK_SLASH = "\\".charCodeAt(0);
    var FORWARD_SLASH = "/".charCodeAt(0);
    var BACKSPACE = "\b".charCodeAt(0);
    var FORM_FEED = "\f".charCodeAt(0);
    var NEWLINE = "\n".charCodeAt(0);
    var CARRIAGE_RETURN = "\r".charCodeAt(0);
    var TAB = "	".charCodeAt(0);
    var STRING_BUFFER_SIZE = 64 * 1024;
    function alloc(size) {
      return Buffer3.alloc ? Buffer3.alloc(size) : new Buffer3(size);
    }
    function Parser() {
      this.tState = START;
      this.value = void 0;
      this.string = void 0;
      this.stringBuffer = alloc(STRING_BUFFER_SIZE);
      this.stringBufferOffset = 0;
      this.unicode = void 0;
      this.highSurrogate = void 0;
      this.key = void 0;
      this.mode = void 0;
      this.stack = [];
      this.state = VALUE;
      this.bytes_remaining = 0;
      this.bytes_in_sequence = 0;
      this.temp_buffs = { "2": alloc(2), "3": alloc(3), "4": alloc(4) };
      this.offset = -1;
    }
    Parser.toknam = function(code) {
      var keys = Object.keys(C);
      for (var i = 0, l = keys.length; i < l; i++) {
        var key = keys[i];
        if (C[key] === code) {
          return key;
        }
      }
      return code && "0x" + code.toString(16);
    };
    var proto = Parser.prototype;
    proto.onError = function(err) {
      throw err;
    };
    proto.charError = function(buffer, i) {
      this.tState = STOP;
      this.onError(new Error("Unexpected " + JSON.stringify(String.fromCharCode(buffer[i])) + " at position " + i + " in state " + Parser.toknam(this.tState)));
    };
    proto.appendStringChar = function(char) {
      if (this.stringBufferOffset >= STRING_BUFFER_SIZE) {
        this.string += this.stringBuffer.toString("utf8");
        this.stringBufferOffset = 0;
      }
      this.stringBuffer[this.stringBufferOffset++] = char;
    };
    proto.appendStringBuf = function(buf, start, end) {
      var size = buf.length;
      if (typeof start === "number") {
        if (typeof end === "number") {
          if (end < 0) {
            size = buf.length - start + end;
          } else {
            size = end - start;
          }
        } else {
          size = buf.length - start;
        }
      }
      if (size < 0) {
        size = 0;
      }
      if (this.stringBufferOffset + size > STRING_BUFFER_SIZE) {
        this.string += this.stringBuffer.toString("utf8", 0, this.stringBufferOffset);
        this.stringBufferOffset = 0;
      }
      buf.copy(this.stringBuffer, this.stringBufferOffset, start, end);
      this.stringBufferOffset += size;
    };
    proto.write = function(buffer) {
      if (typeof buffer === "string") buffer = new Buffer3(buffer);
      var n;
      for (var i = 0, l = buffer.length; i < l; i++) {
        if (this.tState === START) {
          n = buffer[i];
          this.offset++;
          if (n === 123) {
            this.onToken(LEFT_BRACE, "{");
          } else if (n === 125) {
            this.onToken(RIGHT_BRACE, "}");
          } else if (n === 91) {
            this.onToken(LEFT_BRACKET, "[");
          } else if (n === 93) {
            this.onToken(RIGHT_BRACKET, "]");
          } else if (n === 58) {
            this.onToken(COLON, ":");
          } else if (n === 44) {
            this.onToken(COMMA, ",");
          } else if (n === 116) {
            this.tState = TRUE1;
          } else if (n === 102) {
            this.tState = FALSE1;
          } else if (n === 110) {
            this.tState = NULL1;
          } else if (n === 34) {
            this.string = "";
            this.stringBufferOffset = 0;
            this.tState = STRING1;
          } else if (n === 45) {
            this.string = "-";
            this.tState = NUMBER1;
          } else {
            if (n >= 48 && n < 64) {
              this.string = String.fromCharCode(n);
              this.tState = NUMBER3;
            } else if (n === 32 || n === 9 || n === 10 || n === 13) {
            } else {
              return this.charError(buffer, i);
            }
          }
        } else if (this.tState === STRING1) {
          n = buffer[i];
          if (this.bytes_remaining > 0) {
            for (var j = 0; j < this.bytes_remaining; j++) {
              this.temp_buffs[this.bytes_in_sequence][this.bytes_in_sequence - this.bytes_remaining + j] = buffer[j];
            }
            this.appendStringBuf(this.temp_buffs[this.bytes_in_sequence]);
            this.bytes_in_sequence = this.bytes_remaining = 0;
            i = i + j - 1;
          } else if (this.bytes_remaining === 0 && n >= 128) {
            if (n <= 193 || n > 244) {
              return this.onError(new Error("Invalid UTF-8 character at position " + i + " in state " + Parser.toknam(this.tState)));
            }
            if (n >= 194 && n <= 223) this.bytes_in_sequence = 2;
            if (n >= 224 && n <= 239) this.bytes_in_sequence = 3;
            if (n >= 240 && n <= 244) this.bytes_in_sequence = 4;
            if (this.bytes_in_sequence + i > buffer.length) {
              for (var k = 0; k <= buffer.length - 1 - i; k++) {
                this.temp_buffs[this.bytes_in_sequence][k] = buffer[i + k];
              }
              this.bytes_remaining = i + this.bytes_in_sequence - buffer.length;
              i = buffer.length - 1;
            } else {
              this.appendStringBuf(buffer, i, i + this.bytes_in_sequence);
              i = i + this.bytes_in_sequence - 1;
            }
          } else if (n === 34) {
            this.tState = START;
            this.string += this.stringBuffer.toString("utf8", 0, this.stringBufferOffset);
            this.stringBufferOffset = 0;
            this.onToken(STRING, this.string);
            this.offset += Buffer3.byteLength(this.string, "utf8") + 1;
            this.string = void 0;
          } else if (n === 92) {
            this.tState = STRING2;
          } else if (n >= 32) {
            this.appendStringChar(n);
          } else {
            return this.charError(buffer, i);
          }
        } else if (this.tState === STRING2) {
          n = buffer[i];
          if (n === 34) {
            this.appendStringChar(n);
            this.tState = STRING1;
          } else if (n === 92) {
            this.appendStringChar(BACK_SLASH);
            this.tState = STRING1;
          } else if (n === 47) {
            this.appendStringChar(FORWARD_SLASH);
            this.tState = STRING1;
          } else if (n === 98) {
            this.appendStringChar(BACKSPACE);
            this.tState = STRING1;
          } else if (n === 102) {
            this.appendStringChar(FORM_FEED);
            this.tState = STRING1;
          } else if (n === 110) {
            this.appendStringChar(NEWLINE);
            this.tState = STRING1;
          } else if (n === 114) {
            this.appendStringChar(CARRIAGE_RETURN);
            this.tState = STRING1;
          } else if (n === 116) {
            this.appendStringChar(TAB);
            this.tState = STRING1;
          } else if (n === 117) {
            this.unicode = "";
            this.tState = STRING3;
          } else {
            return this.charError(buffer, i);
          }
        } else if (this.tState === STRING3 || this.tState === STRING4 || this.tState === STRING5 || this.tState === STRING6) {
          n = buffer[i];
          if (n >= 48 && n < 64 || n > 64 && n <= 70 || n > 96 && n <= 102) {
            this.unicode += String.fromCharCode(n);
            if (this.tState++ === STRING6) {
              var intVal = parseInt(this.unicode, 16);
              this.unicode = void 0;
              if (this.highSurrogate !== void 0 && intVal >= 56320 && intVal < 57343 + 1) {
                this.appendStringBuf(new Buffer3(String.fromCharCode(this.highSurrogate, intVal)));
                this.highSurrogate = void 0;
              } else if (this.highSurrogate === void 0 && intVal >= 55296 && intVal < 56319 + 1) {
                this.highSurrogate = intVal;
              } else {
                if (this.highSurrogate !== void 0) {
                  this.appendStringBuf(new Buffer3(String.fromCharCode(this.highSurrogate)));
                  this.highSurrogate = void 0;
                }
                this.appendStringBuf(new Buffer3(String.fromCharCode(intVal)));
              }
              this.tState = STRING1;
            }
          } else {
            return this.charError(buffer, i);
          }
        } else if (this.tState === NUMBER1 || this.tState === NUMBER3) {
          n = buffer[i];
          switch (n) {
            case 48:
            // 0
            case 49:
            // 1
            case 50:
            // 2
            case 51:
            // 3
            case 52:
            // 4
            case 53:
            // 5
            case 54:
            // 6
            case 55:
            // 7
            case 56:
            // 8
            case 57:
            // 9
            case 46:
            // .
            case 101:
            // e
            case 69:
            // E
            case 43:
            // +
            case 45:
              this.string += String.fromCharCode(n);
              this.tState = NUMBER3;
              break;
            default:
              this.tState = START;
              var error46 = this.numberReviver(this.string, buffer, i);
              if (error46) {
                return error46;
              }
              this.offset += this.string.length - 1;
              this.string = void 0;
              i--;
              break;
          }
        } else if (this.tState === TRUE1) {
          if (buffer[i] === 114) {
            this.tState = TRUE2;
          } else {
            return this.charError(buffer, i);
          }
        } else if (this.tState === TRUE2) {
          if (buffer[i] === 117) {
            this.tState = TRUE3;
          } else {
            return this.charError(buffer, i);
          }
        } else if (this.tState === TRUE3) {
          if (buffer[i] === 101) {
            this.tState = START;
            this.onToken(TRUE, true);
            this.offset += 3;
          } else {
            return this.charError(buffer, i);
          }
        } else if (this.tState === FALSE1) {
          if (buffer[i] === 97) {
            this.tState = FALSE2;
          } else {
            return this.charError(buffer, i);
          }
        } else if (this.tState === FALSE2) {
          if (buffer[i] === 108) {
            this.tState = FALSE3;
          } else {
            return this.charError(buffer, i);
          }
        } else if (this.tState === FALSE3) {
          if (buffer[i] === 115) {
            this.tState = FALSE4;
          } else {
            return this.charError(buffer, i);
          }
        } else if (this.tState === FALSE4) {
          if (buffer[i] === 101) {
            this.tState = START;
            this.onToken(FALSE, false);
            this.offset += 4;
          } else {
            return this.charError(buffer, i);
          }
        } else if (this.tState === NULL1) {
          if (buffer[i] === 117) {
            this.tState = NULL2;
          } else {
            return this.charError(buffer, i);
          }
        } else if (this.tState === NULL2) {
          if (buffer[i] === 108) {
            this.tState = NULL3;
          } else {
            return this.charError(buffer, i);
          }
        } else if (this.tState === NULL3) {
          if (buffer[i] === 108) {
            this.tState = START;
            this.onToken(NULL, null);
            this.offset += 3;
          } else {
            return this.charError(buffer, i);
          }
        }
      }
    };
    proto.onToken = function(token, value) {
    };
    proto.parseError = function(token, value) {
      this.tState = STOP;
      this.onError(new Error("Unexpected " + Parser.toknam(token) + (value ? "(" + JSON.stringify(value) + ")" : "") + " in state " + Parser.toknam(this.state)));
    };
    proto.push = function() {
      this.stack.push({ value: this.value, key: this.key, mode: this.mode });
    };
    proto.pop = function() {
      var value = this.value;
      var parent = this.stack.pop();
      this.value = parent.value;
      this.key = parent.key;
      this.mode = parent.mode;
      this.emit(value);
      if (!this.mode) {
        this.state = VALUE;
      }
    };
    proto.emit = function(value) {
      if (this.mode) {
        this.state = COMMA;
      }
      this.onValue(value);
    };
    proto.onValue = function(value) {
    };
    proto.onToken = function(token, value) {
      if (this.state === VALUE) {
        if (token === STRING || token === NUMBER || token === TRUE || token === FALSE || token === NULL) {
          if (this.value) {
            this.value[this.key] = value;
          }
          this.emit(value);
        } else if (token === LEFT_BRACE) {
          this.push();
          if (this.value) {
            this.value = this.value[this.key] = {};
          } else {
            this.value = {};
          }
          this.key = void 0;
          this.state = KEY;
          this.mode = OBJECT;
        } else if (token === LEFT_BRACKET) {
          this.push();
          if (this.value) {
            this.value = this.value[this.key] = [];
          } else {
            this.value = [];
          }
          this.key = 0;
          this.mode = ARRAY;
          this.state = VALUE;
        } else if (token === RIGHT_BRACE) {
          if (this.mode === OBJECT) {
            this.pop();
          } else {
            return this.parseError(token, value);
          }
        } else if (token === RIGHT_BRACKET) {
          if (this.mode === ARRAY) {
            this.pop();
          } else {
            return this.parseError(token, value);
          }
        } else {
          return this.parseError(token, value);
        }
      } else if (this.state === KEY) {
        if (token === STRING) {
          this.key = value;
          this.state = COLON;
        } else if (token === RIGHT_BRACE) {
          this.pop();
        } else {
          return this.parseError(token, value);
        }
      } else if (this.state === COLON) {
        if (token === COLON) {
          this.state = VALUE;
        } else {
          return this.parseError(token, value);
        }
      } else if (this.state === COMMA) {
        if (token === COMMA) {
          if (this.mode === ARRAY) {
            this.key++;
            this.state = VALUE;
          } else if (this.mode === OBJECT) {
            this.state = KEY;
          }
        } else if (token === RIGHT_BRACKET && this.mode === ARRAY || token === RIGHT_BRACE && this.mode === OBJECT) {
          this.pop();
        } else {
          return this.parseError(token, value);
        }
      } else {
        return this.parseError(token, value);
      }
    };
    proto.numberReviver = function(text, buffer, i) {
      var result = Number(text);
      if (isNaN(result)) {
        return this.charError(buffer, i);
      }
      if (text.match(/[0-9]+/) == text && result.toString() != text) {
        this.onToken(STRING, text);
      } else {
        this.onToken(NUMBER, result);
      }
    };
    Parser.C = C;
    module.exports = Parser;
  }
});

// node_modules/relative-to-absolute-iri/lib/Resolve.js
var require_Resolve = __commonJS({
  "node_modules/relative-to-absolute-iri/lib/Resolve.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.removeDotSegmentsOfPath = exports.removeDotSegments = exports.resolve = void 0;
    function resolve(relativeIRI, baseIRI) {
      baseIRI = baseIRI || "";
      const baseFragmentPos = baseIRI.indexOf("#");
      if (baseFragmentPos > 0) {
        baseIRI = baseIRI.substr(0, baseFragmentPos);
      }
      if (!relativeIRI.length) {
        if (baseIRI.indexOf(":") < 0) {
          throw new Error(`Found invalid baseIRI '${baseIRI}' for value '${relativeIRI}'`);
        }
        return baseIRI;
      }
      if (relativeIRI.startsWith("?")) {
        const baseQueryPos = baseIRI.indexOf("?");
        if (baseQueryPos > 0) {
          baseIRI = baseIRI.substr(0, baseQueryPos);
        }
        return baseIRI + relativeIRI;
      }
      if (relativeIRI.startsWith("#")) {
        return baseIRI + relativeIRI;
      }
      if (!baseIRI.length) {
        const relativeColonPos = relativeIRI.indexOf(":");
        if (relativeColonPos < 0) {
          throw new Error(`Found invalid relative IRI '${relativeIRI}' for a missing baseIRI`);
        }
        return removeDotSegmentsOfPath(relativeIRI, relativeColonPos);
      }
      const valueColonPos = relativeIRI.indexOf(":");
      if (valueColonPos >= 0) {
        return removeDotSegmentsOfPath(relativeIRI, valueColonPos);
      }
      const baseColonPos = baseIRI.indexOf(":");
      if (baseColonPos < 0) {
        throw new Error(`Found invalid baseIRI '${baseIRI}' for value '${relativeIRI}'`);
      }
      const baseIRIScheme = baseIRI.substr(0, baseColonPos + 1);
      if (relativeIRI.indexOf("//") === 0) {
        return baseIRIScheme + removeDotSegmentsOfPath(relativeIRI, valueColonPos);
      }
      let baseSlashAfterColonPos;
      if (baseIRI.indexOf("//", baseColonPos) === baseColonPos + 1) {
        baseSlashAfterColonPos = baseIRI.indexOf("/", baseColonPos + 3);
        if (baseSlashAfterColonPos < 0) {
          if (baseIRI.length > baseColonPos + 3) {
            return baseIRI + "/" + removeDotSegmentsOfPath(relativeIRI, valueColonPos);
          } else {
            return baseIRIScheme + removeDotSegmentsOfPath(relativeIRI, valueColonPos);
          }
        }
      } else {
        baseSlashAfterColonPos = baseIRI.indexOf("/", baseColonPos + 1);
        if (baseSlashAfterColonPos < 0) {
          return baseIRIScheme + removeDotSegmentsOfPath(relativeIRI, valueColonPos);
        }
      }
      if (relativeIRI.indexOf("/") === 0) {
        return baseIRI.substr(0, baseSlashAfterColonPos) + removeDotSegments(relativeIRI);
      }
      let baseIRIPath = baseIRI.substr(baseSlashAfterColonPos);
      const baseIRILastSlashPos = baseIRIPath.lastIndexOf("/");
      if (baseIRILastSlashPos >= 0 && baseIRILastSlashPos < baseIRIPath.length - 1) {
        baseIRIPath = baseIRIPath.substr(0, baseIRILastSlashPos + 1);
        if (relativeIRI[0] === "." && relativeIRI[1] !== "." && relativeIRI[1] !== "/" && relativeIRI[2]) {
          relativeIRI = relativeIRI.substr(1);
        }
      }
      relativeIRI = baseIRIPath + relativeIRI;
      relativeIRI = removeDotSegments(relativeIRI);
      return baseIRI.substr(0, baseSlashAfterColonPos) + relativeIRI;
    }
    exports.resolve = resolve;
    function removeDotSegments(path) {
      const segmentBuffers = [];
      let i = 0;
      while (i < path.length) {
        switch (path[i]) {
          case "/":
            if (path[i + 1] === ".") {
              if (path[i + 2] === ".") {
                if (!isCharacterAllowedAfterRelativePathSegment(path[i + 3])) {
                  segmentBuffers.push([]);
                  i++;
                  break;
                }
                segmentBuffers.pop();
                if (!path[i + 3]) {
                  segmentBuffers.push([]);
                }
                i += 3;
              } else {
                if (!isCharacterAllowedAfterRelativePathSegment(path[i + 2])) {
                  segmentBuffers.push([]);
                  i++;
                  break;
                }
                if (!path[i + 2]) {
                  segmentBuffers.push([]);
                }
                i += 2;
              }
            } else {
              segmentBuffers.push([]);
              i++;
            }
            break;
          case "#":
          case "?":
            if (!segmentBuffers.length) {
              segmentBuffers.push([]);
            }
            segmentBuffers[segmentBuffers.length - 1].push(path.substr(i));
            i = path.length;
            break;
          default:
            if (!segmentBuffers.length) {
              segmentBuffers.push([]);
            }
            segmentBuffers[segmentBuffers.length - 1].push(path[i]);
            i++;
            break;
        }
      }
      return "/" + segmentBuffers.map((buffer) => buffer.join("")).join("/");
    }
    exports.removeDotSegments = removeDotSegments;
    function removeDotSegmentsOfPath(iri, colonPosition) {
      let searchOffset = colonPosition + 1;
      if (colonPosition >= 0) {
        if (iri[colonPosition + 1] === "/" && iri[colonPosition + 2] === "/") {
          searchOffset = colonPosition + 3;
        }
      } else {
        if (iri[0] === "/" && iri[1] === "/") {
          searchOffset = 2;
        }
      }
      const pathSeparator = iri.indexOf("/", searchOffset);
      if (pathSeparator < 0) {
        return iri;
      }
      const base = iri.substr(0, pathSeparator);
      const path = iri.substr(pathSeparator);
      return base + removeDotSegments(path);
    }
    exports.removeDotSegmentsOfPath = removeDotSegmentsOfPath;
    function isCharacterAllowedAfterRelativePathSegment(character) {
      return !character || character === "#" || character === "?" || character === "/";
    }
  }
});

// node_modules/relative-to-absolute-iri/index.js
var require_relative_to_absolute_iri = __commonJS({
  "node_modules/relative-to-absolute-iri/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    }) : (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    }));
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p)) __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_Resolve(), exports);
  }
});

// node_modules/jsonld-context-parser/lib/ErrorCoded.js
var require_ErrorCoded = __commonJS({
  "node_modules/jsonld-context-parser/lib/ErrorCoded.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ERROR_CODES = exports.ErrorCoded = void 0;
    var ErrorCoded = class extends Error {
      /* istanbul ignore next */
      constructor(message2, code) {
        super(message2);
        this.code = code;
      }
    };
    exports.ErrorCoded = ErrorCoded;
    var ERROR_CODES;
    (function(ERROR_CODES2) {
      ERROR_CODES2["COLLIDING_KEYWORDS"] = "colliding keywords";
      ERROR_CODES2["CONFLICTING_INDEXES"] = "conflicting indexes";
      ERROR_CODES2["CYCLIC_IRI_MAPPING"] = "cyclic IRI mapping";
      ERROR_CODES2["INVALID_ID_VALUE"] = "invalid @id value";
      ERROR_CODES2["INVALID_INDEX_VALUE"] = "invalid @index value";
      ERROR_CODES2["INVALID_NEST_VALUE"] = "invalid @nest value";
      ERROR_CODES2["INVALID_PREFIX_VALUE"] = "invalid @prefix value";
      ERROR_CODES2["INVALID_PROPAGATE_VALUE"] = "invalid @propagate value";
      ERROR_CODES2["INVALID_REVERSE_VALUE"] = "invalid @reverse value";
      ERROR_CODES2["INVALID_IMPORT_VALUE"] = "invalid @import value";
      ERROR_CODES2["INVALID_VERSION_VALUE"] = "invalid @version value";
      ERROR_CODES2["INVALID_BASE_IRI"] = "invalid base IRI";
      ERROR_CODES2["INVALID_CONTAINER_MAPPING"] = "invalid container mapping";
      ERROR_CODES2["INVALID_CONTEXT_ENTRY"] = "invalid context entry";
      ERROR_CODES2["INVALID_CONTEXT_NULLIFICATION"] = "invalid context nullification";
      ERROR_CODES2["INVALID_DEFAULT_LANGUAGE"] = "invalid default language";
      ERROR_CODES2["INVALID_INCLUDED_VALUE"] = "invalid @included value";
      ERROR_CODES2["INVALID_IRI_MAPPING"] = "invalid IRI mapping";
      ERROR_CODES2["INVALID_JSON_LITERAL"] = "invalid JSON literal";
      ERROR_CODES2["INVALID_KEYWORD_ALIAS"] = "invalid keyword alias";
      ERROR_CODES2["INVALID_LANGUAGE_MAP_VALUE"] = "invalid language map value";
      ERROR_CODES2["INVALID_LANGUAGE_MAPPING"] = "invalid language mapping";
      ERROR_CODES2["INVALID_LANGUAGE_TAGGED_STRING"] = "invalid language-tagged string";
      ERROR_CODES2["INVALID_LANGUAGE_TAGGED_VALUE"] = "invalid language-tagged value";
      ERROR_CODES2["INVALID_LOCAL_CONTEXT"] = "invalid local context";
      ERROR_CODES2["INVALID_REMOTE_CONTEXT"] = "invalid remote context";
      ERROR_CODES2["INVALID_REVERSE_PROPERTY"] = "invalid reverse property";
      ERROR_CODES2["INVALID_REVERSE_PROPERTY_MAP"] = "invalid reverse property map";
      ERROR_CODES2["INVALID_REVERSE_PROPERTY_VALUE"] = "invalid reverse property value";
      ERROR_CODES2["INVALID_SCOPED_CONTEXT"] = "invalid scoped context";
      ERROR_CODES2["INVALID_SCRIPT_ELEMENT"] = "invalid script element";
      ERROR_CODES2["INVALID_SET_OR_LIST_OBJECT"] = "invalid set or list object";
      ERROR_CODES2["INVALID_TERM_DEFINITION"] = "invalid term definition";
      ERROR_CODES2["INVALID_TYPE_MAPPING"] = "invalid type mapping";
      ERROR_CODES2["INVALID_TYPE_VALUE"] = "invalid type value";
      ERROR_CODES2["INVALID_TYPED_VALUE"] = "invalid typed value";
      ERROR_CODES2["INVALID_VALUE_OBJECT"] = "invalid value object";
      ERROR_CODES2["INVALID_VALUE_OBJECT_VALUE"] = "invalid value object value";
      ERROR_CODES2["INVALID_VOCAB_MAPPING"] = "invalid vocab mapping";
      ERROR_CODES2["IRI_CONFUSED_WITH_PREFIX"] = "IRI confused with prefix";
      ERROR_CODES2["KEYWORD_REDEFINITION"] = "keyword redefinition";
      ERROR_CODES2["LOADING_DOCUMENT_FAILED"] = "loading document failed";
      ERROR_CODES2["LOADING_REMOTE_CONTEXT_FAILED"] = "loading remote context failed";
      ERROR_CODES2["MULTIPLE_CONTEXT_LINK_HEADERS"] = "multiple context link headers";
      ERROR_CODES2["PROCESSING_MODE_CONFLICT"] = "processing mode conflict";
      ERROR_CODES2["PROTECTED_TERM_REDEFINITION"] = "protected term redefinition";
      ERROR_CODES2["CONTEXT_OVERFLOW"] = "context overflow";
      ERROR_CODES2["INVALID_BASE_DIRECTION"] = "invalid base direction";
      ERROR_CODES2["RECURSIVE_CONTEXT_INCLUSION"] = "recursive context inclusion";
      ERROR_CODES2["INVALID_STREAMING_KEY_ORDER"] = "invalid streaming key order";
      ERROR_CODES2["INVALID_EMBEDDED_NODE"] = "invalid embedded node";
      ERROR_CODES2["INVALID_ANNOTATION"] = "invalid annotation";
    })(ERROR_CODES = exports.ERROR_CODES || (exports.ERROR_CODES = {}));
  }
});

// node_modules/http-link-header/lib/link.js
var require_link = __commonJS({
  "node_modules/http-link-header/lib/link.js"(exports, module) {
    "use strict";
    var COMPATIBLE_ENCODING_PATTERN = /^utf-?8|ascii|utf-?16-?le|ucs-?2|base-?64|latin-?1$/i;
    var WS_TRIM_PATTERN = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g;
    var WS_CHAR_PATTERN = /\s|\uFEFF|\xA0/;
    var WS_FOLD_PATTERN = /\r?\n[\x20\x09]+/g;
    var DELIMITER_PATTERN = /[;,"]/;
    var WS_DELIMITER_PATTERN = /[;,"]|\s/;
    var TOKEN_PATTERN = /^[!#$%&'*+\-\.^_`|~\da-zA-Z]+$/;
    var STATE = {
      IDLE: 1 << 0,
      URI: 1 << 1,
      ATTR: 1 << 2
    };
    function trim(value) {
      return value.replace(WS_TRIM_PATTERN, "");
    }
    function hasWhitespace(value) {
      return WS_CHAR_PATTERN.test(value);
    }
    function skipWhitespace(value, offset) {
      while (hasWhitespace(value[offset])) {
        offset++;
      }
      return offset;
    }
    function needsQuotes(value) {
      return WS_DELIMITER_PATTERN.test(value) || !TOKEN_PATTERN.test(value);
    }
    function shallowCompareObjects(object1, object2) {
      return Object.keys(object1).length === Object.keys(object2).length && Object.keys(object1).every(
        (key) => key in object2 && object1[key] === object2[key]
      );
    }
    var Link = class _Link {
      /**
       * Link
       * @constructor
       * @param {String} [value]
       * @returns {Link}
       */
      constructor(value) {
        this.refs = [];
        if (value) {
          this.parse(value);
        }
      }
      /**
       * Get refs with given relation type
       * @param {String} value
       * @returns {Array<Object>}
       */
      rel(value) {
        var links = [];
        var type2 = value.toLowerCase();
        for (var i = 0; i < this.refs.length; i++) {
          if (typeof this.refs[i].rel === "string" && this.refs[i].rel.toLowerCase() === type2) {
            links.push(this.refs[i]);
          }
        }
        return links;
      }
      /**
       * Get refs where given attribute has a given value
       * @param {String} attr
       * @param {String} value
       * @returns {Array<Object>}
       */
      get(attr, value) {
        attr = attr.toLowerCase();
        value = value.toLowerCase();
        var links = [];
        for (var i = 0; i < this.refs.length; i++) {
          if (typeof this.refs[i][attr] === "string" && this.refs[i][attr].toLowerCase() === value) {
            links.push(this.refs[i]);
          }
        }
        return links;
      }
      /** Sets a reference. */
      set(link) {
        this.refs.push(link);
        return this;
      }
      /**
       * Sets a reference if a reference with similar properties isnt already set.
       */
      setUnique(link) {
        if (!this.refs.some((ref) => shallowCompareObjects(ref, link))) {
          this.refs.push(link);
        }
        return this;
      }
      has(attr, value) {
        attr = attr.toLowerCase();
        value = value.toLowerCase();
        for (var i = 0; i < this.refs.length; i++) {
          if (typeof this.refs[i][attr] === "string" && this.refs[i][attr].toLowerCase() === value) {
            return true;
          }
        }
        return false;
      }
      parse(value, offset) {
        offset = offset || 0;
        value = offset ? value.slice(offset) : value;
        value = trim(value).replace(WS_FOLD_PATTERN, "");
        var state = STATE.IDLE;
        var length = value.length;
        var offset = 0;
        var ref = null;
        while (offset < length) {
          if (state === STATE.IDLE) {
            if (hasWhitespace(value[offset])) {
              offset++;
              continue;
            } else if (value[offset] === "<") {
              if (ref != null) {
                ref.rel != null ? this.refs.push(..._Link.expandRelations(ref)) : this.refs.push(ref);
              }
              var end = value.indexOf(">", offset);
              if (end === -1) throw new Error("Expected end of URI delimiter at offset " + offset);
              ref = { uri: value.slice(offset + 1, end) };
              offset = end;
              state = STATE.URI;
            } else {
              throw new Error('Unexpected character "' + value[offset] + '" at offset ' + offset);
            }
            offset++;
          } else if (state === STATE.URI) {
            if (hasWhitespace(value[offset])) {
              offset++;
              continue;
            } else if (value[offset] === ";") {
              state = STATE.ATTR;
              offset++;
            } else if (value[offset] === ",") {
              state = STATE.IDLE;
              offset++;
            } else {
              throw new Error('Unexpected character "' + value[offset] + '" at offset ' + offset);
            }
          } else if (state === STATE.ATTR) {
            if (value[offset] === ";" || hasWhitespace(value[offset])) {
              offset++;
              continue;
            }
            var end = value.indexOf("=", offset);
            if (end === -1) end = value.indexOf(";", offset);
            if (end === -1) end = value.length;
            var attr = trim(value.slice(offset, end)).toLowerCase();
            var attrValue = "";
            offset = end + 1;
            offset = skipWhitespace(value, offset);
            if (value[offset] === '"') {
              offset++;
              while (offset < length) {
                if (value[offset] === '"') {
                  offset++;
                  break;
                }
                if (value[offset] === "\\") {
                  offset++;
                }
                attrValue += value[offset];
                offset++;
              }
            } else {
              var end = offset + 1;
              while (!DELIMITER_PATTERN.test(value[end]) && end < length) {
                end++;
              }
              attrValue = value.slice(offset, end);
              offset = end;
            }
            if (ref[attr] && _Link.isSingleOccurenceAttr(attr)) {
            } else if (attr[attr.length - 1] === "*") {
              ref[attr] = _Link.parseExtendedValue(attrValue);
            } else {
              attrValue = attr === "type" ? attrValue.toLowerCase() : attrValue;
              if (ref[attr] != null) {
                if (Array.isArray(ref[attr])) {
                  ref[attr].push(attrValue);
                } else {
                  ref[attr] = [ref[attr], attrValue];
                }
              } else {
                ref[attr] = attrValue;
              }
            }
            switch (value[offset]) {
              case ",":
                state = STATE.IDLE;
                break;
              case ";":
                state = STATE.ATTR;
                break;
            }
            offset++;
          } else {
            throw new Error('Unknown parser state "' + state + '"');
          }
        }
        if (ref != null) {
          ref.rel != null ? this.refs.push(..._Link.expandRelations(ref)) : this.refs.push(ref);
        }
        ref = null;
        return this;
      }
      toString() {
        var refs = [];
        var link = "";
        var ref = null;
        for (var i = 0; i < this.refs.length; i++) {
          ref = this.refs[i];
          link = Object.keys(this.refs[i]).reduce(function(link2, attr) {
            if (attr === "uri") return link2;
            return link2 + "; " + _Link.formatAttribute(attr, ref[attr]);
          }, "<" + ref.uri + ">");
          refs.push(link);
        }
        return refs.join(", ");
      }
    };
    Link.isCompatibleEncoding = function(value) {
      return COMPATIBLE_ENCODING_PATTERN.test(value);
    };
    Link.parse = function(value, offset) {
      return new Link().parse(value, offset);
    };
    Link.isSingleOccurenceAttr = function(attr) {
      return attr === "rel" || attr === "type" || attr === "media" || attr === "title" || attr === "title*";
    };
    Link.isTokenAttr = function(attr) {
      return attr === "rel" || attr === "type" || attr === "anchor";
    };
    Link.escapeQuotes = function(value) {
      return value.replace(/"/g, '\\"');
    };
    Link.expandRelations = function(ref) {
      var rels = ref.rel.split(" ");
      return rels.map(function(rel) {
        var value = Object.assign({}, ref);
        value.rel = rel;
        return value;
      });
    };
    Link.parseExtendedValue = function(value) {
      var parts = /([^']+)?(?:'([^']*)')?(.+)/.exec(value);
      return {
        language: parts[2].toLowerCase(),
        encoding: Link.isCompatibleEncoding(parts[1]) ? null : parts[1].toLowerCase(),
        value: Link.isCompatibleEncoding(parts[1]) ? decodeURIComponent(parts[3]) : parts[3]
      };
    };
    Link.formatExtendedAttribute = function(attr, data) {
      var encoding = (data.encoding || "utf-8").toUpperCase();
      var language = data.language || "en";
      var encodedValue = "";
      if (Buffer.isBuffer(data.value) && Link.isCompatibleEncoding(encoding)) {
        encodedValue = data.value.toString(encoding);
      } else if (Buffer.isBuffer(data.value)) {
        encodedValue = data.value.toString("hex").replace(/[0-9a-f]{2}/gi, "%$1");
      } else {
        encodedValue = encodeURIComponent(data.value);
      }
      return attr + "=" + encoding + "'" + language + "'" + encodedValue;
    };
    Link.formatAttribute = function(attr, value) {
      if (Array.isArray(value)) {
        return value.map((item) => {
          return Link.formatAttribute(attr, item);
        }).join("; ");
      }
      if (attr[attr.length - 1] === "*" || typeof value !== "string") {
        return Link.formatExtendedAttribute(attr, value);
      }
      if (Link.isTokenAttr(attr)) {
        value = needsQuotes(value) ? '"' + Link.escapeQuotes(value) + '"' : Link.escapeQuotes(value);
      } else if (needsQuotes(value)) {
        value = encodeURIComponent(value);
        value = value.replace(/%20/g, " ").replace(/%2C/g, ",").replace(/%3B/g, ";");
        value = '"' + value + '"';
      }
      return attr + "=" + value;
    };
    module.exports = Link;
  }
});

// node_modules/jsonld-context-parser/lib/FetchDocumentLoader.js
var require_FetchDocumentLoader = __commonJS({
  "node_modules/jsonld-context-parser/lib/FetchDocumentLoader.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.FetchDocumentLoader = void 0;
    var ErrorCoded_1 = require_ErrorCoded();
    var http_link_header_1 = require_link();
    var relative_to_absolute_iri_1 = require_relative_to_absolute_iri();
    var FetchDocumentLoader2 = class {
      constructor(fetcher) {
        this.fetcher = fetcher;
      }
      async load(url2) {
        const response = await (this.fetcher || fetch)(url2, { headers: new Headers({ accept: "application/ld+json" }) });
        if (response.ok && response.headers) {
          let mediaType = response.headers.get("Content-Type");
          if (mediaType) {
            const colonPos = mediaType.indexOf(";");
            if (colonPos > 0) {
              mediaType = mediaType.substr(0, colonPos);
            }
          }
          if (mediaType === "application/ld+json") {
            return await response.json();
          } else {
            if (response.headers.has("Link")) {
              let alternateUrl;
              response.headers.forEach((value, key) => {
                if (key === "link") {
                  const linkHeader = (0, http_link_header_1.parse)(value);
                  for (const link of linkHeader.get("type", "application/ld+json")) {
                    if (link.rel === "alternate") {
                      if (alternateUrl) {
                        throw new Error("Multiple JSON-LD alternate links were found on " + url2);
                      }
                      alternateUrl = (0, relative_to_absolute_iri_1.resolve)(link.uri, url2);
                    }
                  }
                }
              });
              if (alternateUrl) {
                return this.load(alternateUrl);
              }
            }
            throw new ErrorCoded_1.ErrorCoded(`Unsupported JSON-LD media type ${mediaType}`, ErrorCoded_1.ERROR_CODES.LOADING_DOCUMENT_FAILED);
          }
        } else {
          throw new Error(response.statusText || `Status code: ${response.status}`);
        }
      }
    };
    exports.FetchDocumentLoader = FetchDocumentLoader2;
  }
});

// node_modules/jsonld-context-parser/lib/Util.js
var require_Util = __commonJS({
  "node_modules/jsonld-context-parser/lib/Util.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Util = void 0;
    var Util = class _Util {
      /**
       * Check if the given term is a valid compact IRI.
       * Otherwise, it may be an IRI.
       * @param {string} term A term.
       * @return {boolean} If it is a compact IRI.
       */
      static isCompactIri(term) {
        return term.indexOf(":") > 0 && !(term && term[0] === "#");
      }
      /**
       * Get the prefix from the given term.
       * @see https://json-ld.org/spec/latest/json-ld/#compact-iris
       * @param {string} term A term that is an URL or a prefixed URL.
       * @param {IJsonLdContextNormalizedRaw} context A context.
       * @return {string} The prefix or null.
       */
      static getPrefix(term, context) {
        if (term && term[0] === "#") {
          return null;
        }
        const separatorPos = term.indexOf(":");
        if (separatorPos >= 0) {
          if (term.length > separatorPos + 1 && term.charAt(separatorPos + 1) === "/" && term.charAt(separatorPos + 2) === "/") {
            return null;
          }
          const prefix = term.substr(0, separatorPos);
          if (prefix === "_") {
            return null;
          }
          if (context[prefix]) {
            return prefix;
          }
        }
        return null;
      }
      /**
       * From a given context entry value, get the string value, or the @id field.
       * @param contextValue A value for a term in a context.
       * @return {string} The id value, or null.
       */
      static getContextValueId(contextValue) {
        if (contextValue === null || typeof contextValue === "string") {
          return contextValue;
        }
        const id = contextValue["@id"];
        return id ? id : null;
      }
      /**
       * Check if the given simple term definition (string-based value of a context term)
       * should be considered a prefix.
       * @param value A simple term definition value.
       * @param options Options that define the way how expansion must be done.
       */
      static isSimpleTermDefinitionPrefix(value, options) {
        return !_Util.isPotentialKeyword(value) && (options.allowPrefixNonGenDelims || typeof value === "string" && (value[0] === "_" || _Util.isPrefixIriEndingWithGenDelim(value)));
      }
      /**
       * Check if the given keyword is of the keyword format "@"1*ALPHA.
       * @param {string} keyword A potential keyword.
       * @return {boolean} If the given keyword is of the keyword format.
       */
      static isPotentialKeyword(keyword) {
        return typeof keyword === "string" && _Util.KEYWORD_REGEX.test(keyword);
      }
      /**
       * Check if the given prefix ends with a gen-delim character.
       * @param {string} prefixIri A prefix IRI.
       * @return {boolean} If the given prefix IRI is valid.
       */
      static isPrefixIriEndingWithGenDelim(prefixIri) {
        return _Util.ENDS_WITH_GEN_DELIM.test(prefixIri);
      }
      /**
       * Check if the given context value can be a prefix value.
       * @param value A context value.
       * @return {boolean} If it can be a prefix value.
       */
      static isPrefixValue(value) {
        return value && (typeof value === "string" || value && typeof value === "object");
      }
      /**
       * Check if the given IRI is valid.
       * @param {string} iri A potential IRI.
       * @return {boolean} If the given IRI is valid.
       */
      static isValidIri(iri) {
        return Boolean(iri && _Util.IRI_REGEX.test(iri));
      }
      /**
       * Check if the given IRI is valid, this includes the possibility of being a relative IRI.
       * @param {string} iri A potential IRI.
       * @return {boolean} If the given IRI is valid.
       */
      static isValidIriWeak(iri) {
        return !!iri && iri[0] !== ":" && _Util.IRI_REGEX_WEAK.test(iri);
      }
      /**
       * Check if the given keyword is a defined according to the JSON-LD specification.
       * @param {string} keyword A potential keyword.
       * @return {boolean} If the given keyword is valid.
       */
      static isValidKeyword(keyword) {
        return _Util.VALID_KEYWORDS[keyword];
      }
      /**
       * Check if the given term is protected in the context.
       * @param {IJsonLdContextNormalizedRaw} context A context.
       * @param {string} key A context term.
       * @return {boolean} If the given term has an @protected flag.
       */
      static isTermProtected(context, key) {
        const value = context[key];
        return !(typeof value === "string") && value && value["@protected"];
      }
      /**
       * Check if the given context has at least one protected term.
       * @param context A context.
       * @return If the context has a protected term.
       */
      static hasProtectedTerms(context) {
        for (const key of Object.keys(context)) {
          if (_Util.isTermProtected(context, key)) {
            return true;
          }
        }
        return false;
      }
      /**
       * Check if the given key is an internal reserved keyword.
       * @param key A context key.
       */
      static isReservedInternalKeyword(key) {
        return key.startsWith("@__");
      }
      /**
       * Check if two objects are deepEqual to on another.
       * @param object1 The first object to test.
       * @param object2 The second object to test.
       */
      static deepEqual(object1, object2) {
        const objKeys1 = Object.keys(object1);
        const objKeys2 = Object.keys(object2);
        if (objKeys1.length !== objKeys2.length)
          return false;
        return objKeys1.every((key) => {
          const value1 = object1[key];
          const value2 = object2[key];
          return value1 === value2 || value1 !== null && value2 !== null && typeof value1 === "object" && typeof value2 === "object" && this.deepEqual(value1, value2);
        });
      }
    };
    Util.IRI_REGEX = /^([A-Za-z][A-Za-z0-9+-.]*|_):[^ "<>{}|\\\[\]`#]*(#[^#]*)?$/;
    Util.IRI_REGEX_WEAK = /(?::[^:])|\//;
    Util.KEYWORD_REGEX = /^@[a-z]+$/i;
    Util.ENDS_WITH_GEN_DELIM = /[:/?#\[\]@]$/;
    Util.REGEX_LANGUAGE_TAG = /^[a-zA-Z]+(-[a-zA-Z0-9]+)*$/;
    Util.REGEX_DIRECTION_TAG = /^(ltr)|(rtl)$/;
    Util.VALID_KEYWORDS = {
      "@annotation": true,
      "@base": true,
      "@container": true,
      "@context": true,
      "@direction": true,
      "@graph": true,
      "@id": true,
      "@import": true,
      "@included": true,
      "@index": true,
      "@json": true,
      "@language": true,
      "@list": true,
      "@nest": true,
      "@none": true,
      "@prefix": true,
      "@propagate": true,
      "@protected": true,
      "@reverse": true,
      "@set": true,
      "@type": true,
      "@value": true,
      "@version": true,
      "@vocab": true
    };
    Util.EXPAND_KEYS_BLACKLIST = [
      "@base",
      "@vocab",
      "@language",
      "@version",
      "@direction"
    ];
    Util.ALIAS_DOMAIN_BLACKLIST = [
      "@container",
      "@graph",
      "@id",
      "@index",
      "@list",
      "@nest",
      "@none",
      "@prefix",
      "@reverse",
      "@set",
      "@type",
      "@value",
      "@version"
    ];
    Util.ALIAS_RANGE_BLACKLIST = [
      "@context",
      "@preserve"
    ];
    Util.CONTAINERS = [
      "@list",
      "@set",
      "@index",
      "@language",
      "@graph",
      "@id",
      "@type"
    ];
    Util.CONTAINERS_1_0 = [
      "@list",
      "@set",
      "@index"
    ];
    exports.Util = Util;
  }
});

// node_modules/jsonld-context-parser/lib/JsonLdContextNormalized.js
var require_JsonLdContextNormalized = __commonJS({
  "node_modules/jsonld-context-parser/lib/JsonLdContextNormalized.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.defaultExpandOptions = exports.JsonLdContextNormalized = void 0;
    var relative_to_absolute_iri_1 = require_relative_to_absolute_iri();
    var ErrorCoded_1 = require_ErrorCoded();
    var Util_1 = require_Util();
    var JsonLdContextNormalized = class {
      constructor(contextRaw) {
        this.contextRaw = contextRaw;
      }
      /**
       * @return The raw inner context.
       */
      getContextRaw() {
        return this.contextRaw;
      }
      /**
       * Expand the term or prefix of the given term if it has one,
       * otherwise return the term as-is.
       *
       * This will try to expand the IRI as much as possible.
       *
       * Iff in vocab-mode, then other references to other terms in the context can be used,
       * such as to `myTerm`:
       * ```
       * {
       *   "myTerm": "http://example.org/myLongTerm"
       * }
       * ```
       *
       * @param {string} term A term that is an URL or a prefixed URL.
       * @param {boolean} expandVocab If the term is a predicate or type and should be expanded based on @vocab,
       *                              otherwise it is considered a regular term that is expanded based on @base.
       * @param {IExpandOptions} options Options that define the way how expansion must be done.
       * @return {string} The expanded term, the term as-is, or null if it was explicitly disabled in the context.
       * @throws If the term is aliased to an invalid value (not a string, IRI or keyword).
       */
      expandTerm(term, expandVocab, options = exports.defaultExpandOptions) {
        const contextValue = this.contextRaw[term];
        if (contextValue === null || contextValue && contextValue["@id"] === null) {
          return null;
        }
        let validIriMapping = true;
        if (contextValue && expandVocab) {
          const value = Util_1.Util.getContextValueId(contextValue);
          if (value && value !== term) {
            if (typeof value !== "string" || !Util_1.Util.isValidIri(value) && !Util_1.Util.isValidKeyword(value)) {
              if (!Util_1.Util.isPotentialKeyword(value)) {
                validIriMapping = false;
              }
            } else {
              return value;
            }
          }
        }
        const prefix = Util_1.Util.getPrefix(term, this.contextRaw);
        const vocab = this.contextRaw["@vocab"];
        const vocabRelative = (!!vocab || vocab === "") && vocab.indexOf(":") < 0;
        const base = this.contextRaw["@base"];
        const potentialKeyword = Util_1.Util.isPotentialKeyword(term);
        if (prefix) {
          const contextPrefixValue = this.contextRaw[prefix];
          const value = Util_1.Util.getContextValueId(contextPrefixValue);
          if (value) {
            if (typeof contextPrefixValue === "string" || !options.allowPrefixForcing) {
              if (!Util_1.Util.isSimpleTermDefinitionPrefix(value, options)) {
                return term;
              }
            } else {
              if (value[0] !== "_" && !potentialKeyword && !contextPrefixValue["@prefix"] && !(term in this.contextRaw)) {
                return term;
              }
            }
            return value + term.substr(prefix.length + 1);
          }
        } else if (expandVocab && (vocab || vocab === "" || options.allowVocabRelativeToBase && (base && vocabRelative)) && !potentialKeyword && !Util_1.Util.isCompactIri(term)) {
          if (vocabRelative) {
            if (options.allowVocabRelativeToBase) {
              return (vocab || base ? (0, relative_to_absolute_iri_1.resolve)(vocab, base) : "") + term;
            } else {
              throw new ErrorCoded_1.ErrorCoded(`Relative vocab expansion for term '${term}' with vocab '${vocab}' is not allowed.`, ErrorCoded_1.ERROR_CODES.INVALID_VOCAB_MAPPING);
            }
          } else {
            return vocab + term;
          }
        } else if (!expandVocab && base && !potentialKeyword && !Util_1.Util.isCompactIri(term)) {
          return (0, relative_to_absolute_iri_1.resolve)(term, base);
        }
        if (validIriMapping) {
          return term;
        } else {
          throw new ErrorCoded_1.ErrorCoded(`Invalid IRI mapping found for context entry '${term}': '${JSON.stringify(contextValue)}'`, ErrorCoded_1.ERROR_CODES.INVALID_IRI_MAPPING);
        }
      }
      /**
       * Compact the given term using @base, @vocab, an aliased term, or a prefixed term.
       *
       * This will try to compact the IRI as much as possible.
       *
       * @param {string} iri An IRI to compact.
       * @param {boolean} vocab If the term is a predicate or type and should be compacted based on @vocab,
       *                        otherwise it is considered a regular term that is compacted based on @base.
       * @return {string} The compacted term or the IRI as-is.
       */
      compactIri(iri, vocab) {
        if (vocab && this.contextRaw["@vocab"] && iri.startsWith(this.contextRaw["@vocab"])) {
          return iri.substr(this.contextRaw["@vocab"].length);
        }
        if (!vocab && this.contextRaw["@base"] && iri.startsWith(this.contextRaw["@base"])) {
          return iri.substr(this.contextRaw["@base"].length);
        }
        const shortestPrefixing = { prefix: "", suffix: iri };
        for (const key in this.contextRaw) {
          const value = this.contextRaw[key];
          if (value && !Util_1.Util.isPotentialKeyword(key)) {
            const contextIri = Util_1.Util.getContextValueId(value);
            if (iri.startsWith(contextIri)) {
              const suffix = iri.substr(contextIri.length);
              if (!suffix) {
                if (vocab) {
                  return key;
                }
              } else if (suffix.length < shortestPrefixing.suffix.length) {
                shortestPrefixing.prefix = key;
                shortestPrefixing.suffix = suffix;
              }
            }
          }
        }
        if (shortestPrefixing.prefix) {
          return shortestPrefixing.prefix + ":" + shortestPrefixing.suffix;
        }
        return iri;
      }
    };
    exports.JsonLdContextNormalized = JsonLdContextNormalized;
    exports.defaultExpandOptions = {
      allowPrefixForcing: true,
      allowPrefixNonGenDelims: false,
      allowVocabRelativeToBase: true
    };
  }
});

// node_modules/jsonld-context-parser/lib/ContextParser.js
var require_ContextParser = __commonJS({
  "node_modules/jsonld-context-parser/lib/ContextParser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ContextParser = void 0;
    var relative_to_absolute_iri_1 = require_relative_to_absolute_iri();
    var ErrorCoded_1 = require_ErrorCoded();
    var FetchDocumentLoader_1 = require_FetchDocumentLoader();
    var JsonLdContextNormalized_1 = require_JsonLdContextNormalized();
    var Util_1 = require_Util();
    var ContextParser = class _ContextParser {
      constructor(options) {
        options = options || {};
        this.documentLoader = options.documentLoader || new FetchDocumentLoader_1.FetchDocumentLoader();
        this.documentCache = {};
        this.validateContext = !options.skipValidation;
        this.expandContentTypeToBase = !!options.expandContentTypeToBase;
        this.remoteContextsDepthLimit = options.remoteContextsDepthLimit || 32;
        this.redirectSchemaOrgHttps = "redirectSchemaOrgHttps" in options ? !!options.redirectSchemaOrgHttps : true;
      }
      /**
       * Validate the given @language value.
       * An error will be thrown if it is invalid.
       * @param value An @language value.
       * @param {boolean} strictRange If the string value should be strictly checked against a regex.
       * @param {string} errorCode The error code to emit on errors.
       * @return {boolean} If validation passed.
       *                   Can only be false if strictRange is false and the string value did not pass the regex.
       */
      static validateLanguage(value, strictRange, errorCode) {
        if (typeof value !== "string") {
          throw new ErrorCoded_1.ErrorCoded(`The value of an '@language' must be a string, got '${JSON.stringify(value)}'`, errorCode);
        }
        if (!Util_1.Util.REGEX_LANGUAGE_TAG.test(value)) {
          if (strictRange) {
            throw new ErrorCoded_1.ErrorCoded(`The value of an '@language' must be a valid language tag, got '${JSON.stringify(value)}'`, errorCode);
          } else {
            return false;
          }
        }
        return true;
      }
      /**
       * Validate the given @direction value.
       * An error will be thrown if it is invalid.
       * @param value An @direction value.
       * @param {boolean} strictValues If the string value should be strictly checked against a regex.
       * @return {boolean} If validation passed.
       *                   Can only be false if strictRange is false and the string value did not pass the regex.
       */
      static validateDirection(value, strictValues) {
        if (typeof value !== "string") {
          throw new ErrorCoded_1.ErrorCoded(`The value of an '@direction' must be a string, got '${JSON.stringify(value)}'`, ErrorCoded_1.ERROR_CODES.INVALID_BASE_DIRECTION);
        }
        if (!Util_1.Util.REGEX_DIRECTION_TAG.test(value)) {
          if (strictValues) {
            throw new ErrorCoded_1.ErrorCoded(`The value of an '@direction' must be 'ltr' or 'rtl', got '${JSON.stringify(value)}'`, ErrorCoded_1.ERROR_CODES.INVALID_BASE_DIRECTION);
          } else {
            return false;
          }
        }
        return true;
      }
      /**
       * Add an @id term for all @reverse terms.
       * @param {IJsonLdContextNormalizedRaw} context A context.
       * @return {IJsonLdContextNormalizedRaw} The mutated input context.
       */
      idifyReverseTerms(context) {
        for (const key of Object.keys(context)) {
          let value = context[key];
          if (value && typeof value === "object") {
            if (value["@reverse"] && !value["@id"]) {
              if (typeof value["@reverse"] !== "string" || Util_1.Util.isValidKeyword(value["@reverse"])) {
                throw new ErrorCoded_1.ErrorCoded(`Invalid @reverse value, must be absolute IRI or blank node: '${value["@reverse"]}'`, ErrorCoded_1.ERROR_CODES.INVALID_IRI_MAPPING);
              }
              value = context[key] = Object.assign(Object.assign({}, value), { "@id": value["@reverse"] });
              value["@id"] = value["@reverse"];
              if (Util_1.Util.isPotentialKeyword(value["@reverse"])) {
                delete value["@reverse"];
              } else {
                value["@reverse"] = true;
              }
            }
          }
        }
        return context;
      }
      /**
       * Expand all prefixed terms in the given context.
       * @param {IJsonLdContextNormalizedRaw} context A context.
       * @param {boolean} expandContentTypeToBase If @type inside the context may be expanded
       *                                          via @base if @vocab is set to null.
       * @param {string[]} keys Optional set of keys from the context to expand. If left undefined, all
       * keys in the context will be expanded.
       */
      expandPrefixedTerms(context, expandContentTypeToBase, keys) {
        const contextRaw = context.getContextRaw();
        for (const key of keys || Object.keys(contextRaw)) {
          if (Util_1.Util.EXPAND_KEYS_BLACKLIST.indexOf(key) < 0 && !Util_1.Util.isReservedInternalKeyword(key)) {
            const keyValue = contextRaw[key];
            if (Util_1.Util.isPotentialKeyword(key) && Util_1.Util.ALIAS_DOMAIN_BLACKLIST.indexOf(key) >= 0) {
              if (key !== "@type" || typeof contextRaw[key] === "object" && !(contextRaw[key]["@protected"] || contextRaw[key]["@container"] === "@set")) {
                throw new ErrorCoded_1.ErrorCoded(`Keywords can not be aliased to something else.
Tried mapping ${key} to ${JSON.stringify(keyValue)}`, ErrorCoded_1.ERROR_CODES.KEYWORD_REDEFINITION);
              }
            }
            if (Util_1.Util.ALIAS_RANGE_BLACKLIST.indexOf(Util_1.Util.getContextValueId(keyValue)) >= 0) {
              throw new ErrorCoded_1.ErrorCoded(`Aliasing to certain keywords is not allowed.
Tried mapping ${key} to ${JSON.stringify(keyValue)}`, ErrorCoded_1.ERROR_CODES.INVALID_KEYWORD_ALIAS);
            }
            if (keyValue && Util_1.Util.isPotentialKeyword(Util_1.Util.getContextValueId(keyValue)) && keyValue["@prefix"] === true) {
              throw new ErrorCoded_1.ErrorCoded(`Tried to use keyword aliases as prefix: '${key}': '${JSON.stringify(keyValue)}'`, ErrorCoded_1.ERROR_CODES.INVALID_TERM_DEFINITION);
            }
            while (Util_1.Util.isPrefixValue(contextRaw[key])) {
              const value = contextRaw[key];
              let changed = false;
              if (typeof value === "string") {
                contextRaw[key] = context.expandTerm(value, true);
                changed = changed || value !== contextRaw[key];
              } else {
                const id = value["@id"];
                const type2 = value["@type"];
                const canAddIdEntry = !("@prefix" in value) || Util_1.Util.isValidIri(key);
                if ("@id" in value) {
                  if (id !== void 0 && id !== null && typeof id === "string") {
                    contextRaw[key] = Object.assign(Object.assign({}, contextRaw[key]), { "@id": context.expandTerm(id, true) });
                    changed = changed || id !== contextRaw[key]["@id"];
                  }
                } else if (!Util_1.Util.isPotentialKeyword(key) && canAddIdEntry) {
                  const newId = context.expandTerm(key, true);
                  if (newId !== key) {
                    contextRaw[key] = Object.assign(Object.assign({}, contextRaw[key]), { "@id": newId });
                    changed = true;
                  }
                }
                if (type2 && typeof type2 === "string" && type2 !== "@vocab" && (!value["@container"] || !value["@container"]["@type"]) && canAddIdEntry) {
                  let expandedType = context.expandTerm(type2, true);
                  if (expandContentTypeToBase && type2 === expandedType) {
                    expandedType = context.expandTerm(type2, false);
                  }
                  if (expandedType !== type2) {
                    changed = true;
                    contextRaw[key] = Object.assign(Object.assign({}, contextRaw[key]), { "@type": expandedType });
                  }
                }
              }
              if (!changed) {
                break;
              }
            }
          }
        }
      }
      /**
       * Normalize the @language entries in the given context to lowercase.
       * @param {IJsonLdContextNormalizedRaw} context A context.
       * @param {IParseOptions} parseOptions The parsing options.
       */
      normalize(context, { processingMode, normalizeLanguageTags }) {
        if (normalizeLanguageTags || processingMode === 1) {
          for (const key of Object.keys(context)) {
            if (key === "@language" && typeof context[key] === "string") {
              context[key] = context[key].toLowerCase();
            } else {
              const value = context[key];
              if (value && typeof value === "object") {
                if (typeof value["@language"] === "string") {
                  const lowercase2 = value["@language"].toLowerCase();
                  if (lowercase2 !== value["@language"]) {
                    context[key] = Object.assign(Object.assign({}, value), { "@language": lowercase2 });
                  }
                }
              }
            }
          }
        }
      }
      /**
       * Convert all @container strings and array values to hash-based values.
       * @param {IJsonLdContextNormalizedRaw} context A context.
       */
      containersToHash(context) {
        for (const key of Object.keys(context)) {
          const value = context[key];
          if (value && typeof value === "object") {
            if (typeof value["@container"] === "string") {
              context[key] = Object.assign(Object.assign({}, value), { "@container": { [value["@container"]]: true } });
            } else if (Array.isArray(value["@container"])) {
              const newValue = {};
              for (const containerValue of value["@container"]) {
                newValue[containerValue] = true;
              }
              context[key] = Object.assign(Object.assign({}, value), { "@container": newValue });
            }
          }
        }
      }
      /**
       * Normalize and apply context-level @protected terms onto each term separately.
       * @param {IJsonLdContextNormalizedRaw} context A context.
       * @param {number} processingMode The processing mode.
       */
      applyScopedProtected(context, { processingMode }, expandOptions) {
        if (processingMode && processingMode >= 1.1) {
          if (context["@protected"]) {
            for (const key of Object.keys(context)) {
              if (Util_1.Util.isReservedInternalKeyword(key)) {
                continue;
              }
              if (!Util_1.Util.isPotentialKeyword(key) && !Util_1.Util.isTermProtected(context, key)) {
                const value = context[key];
                if (value && typeof value === "object") {
                  if (!("@protected" in context[key])) {
                    context[key] = Object.assign(Object.assign({}, context[key]), { "@protected": true });
                  }
                } else {
                  context[key] = {
                    "@id": value,
                    "@protected": true
                  };
                  if (Util_1.Util.isSimpleTermDefinitionPrefix(value, expandOptions)) {
                    context[key] = Object.assign(Object.assign({}, context[key]), { "@prefix": true });
                  }
                }
              }
            }
            delete context["@protected"];
          }
        }
      }
      /**
       * Check if the given context inheritance does not contain any overrides of protected terms.
       * @param {IJsonLdContextNormalizedRaw} contextBefore The context that may contain some protected terms.
       * @param {IJsonLdContextNormalizedRaw} contextAfter A new context that is being applied on the first one.
       * @param {IExpandOptions} expandOptions Options that are needed for any expansions during this validation.
       * @param {string[]} keys Optional set of keys from the context to validate. If left undefined, all
       * keys defined in contextAfter will be checked.
       */
      validateKeywordRedefinitions(contextBefore, contextAfter, expandOptions, keys) {
        for (const key of keys !== null && keys !== void 0 ? keys : Object.keys(contextAfter)) {
          if (Util_1.Util.isTermProtected(contextBefore, key)) {
            if (typeof contextAfter[key] === "string") {
              contextAfter[key] = { "@id": contextAfter[key], "@protected": true };
            } else {
              contextAfter[key] = Object.assign(Object.assign({}, contextAfter[key]), { "@protected": true });
            }
            if (!Util_1.Util.deepEqual(contextBefore[key], contextAfter[key])) {
              throw new ErrorCoded_1.ErrorCoded(`Attempted to override the protected keyword ${key} from ${JSON.stringify(Util_1.Util.getContextValueId(contextBefore[key]))} to ${JSON.stringify(Util_1.Util.getContextValueId(contextAfter[key]))}`, ErrorCoded_1.ERROR_CODES.PROTECTED_TERM_REDEFINITION);
            }
          }
        }
      }
      /**
       * Validate the entries of the given context.
       * @param {IJsonLdContextNormalizedRaw} context A context.
       * @param {IParseOptions} options The parse options.
       */
      validate(context, { processingMode }) {
        for (const key of Object.keys(context)) {
          if (Util_1.Util.isReservedInternalKeyword(key)) {
            continue;
          }
          if (key === "") {
            throw new ErrorCoded_1.ErrorCoded(`The empty term is not allowed, got: '${key}': '${JSON.stringify(context[key])}'`, ErrorCoded_1.ERROR_CODES.INVALID_TERM_DEFINITION);
          }
          const value = context[key];
          const valueType = typeof value;
          if (Util_1.Util.isPotentialKeyword(key)) {
            switch (key.substr(1)) {
              case "vocab":
                if (value !== null && valueType !== "string") {
                  throw new ErrorCoded_1.ErrorCoded(`Found an invalid @vocab IRI: ${value}`, ErrorCoded_1.ERROR_CODES.INVALID_VOCAB_MAPPING);
                }
                break;
              case "base":
                if (value !== null && valueType !== "string") {
                  throw new ErrorCoded_1.ErrorCoded(`Found an invalid @base IRI: ${context[key]}`, ErrorCoded_1.ERROR_CODES.INVALID_BASE_IRI);
                }
                break;
              case "language":
                if (value !== null) {
                  _ContextParser.validateLanguage(value, true, ErrorCoded_1.ERROR_CODES.INVALID_DEFAULT_LANGUAGE);
                }
                break;
              case "version":
                if (value !== null && valueType !== "number") {
                  throw new ErrorCoded_1.ErrorCoded(`Found an invalid @version number: ${value}`, ErrorCoded_1.ERROR_CODES.INVALID_VERSION_VALUE);
                }
                break;
              case "direction":
                if (value !== null) {
                  _ContextParser.validateDirection(value, true);
                }
                break;
              case "propagate":
                if (processingMode === 1) {
                  throw new ErrorCoded_1.ErrorCoded(`Found an illegal @propagate keyword: ${value}`, ErrorCoded_1.ERROR_CODES.INVALID_CONTEXT_ENTRY);
                }
                if (value !== null && valueType !== "boolean") {
                  throw new ErrorCoded_1.ErrorCoded(`Found an invalid @propagate value: ${value}`, ErrorCoded_1.ERROR_CODES.INVALID_PROPAGATE_VALUE);
                }
                break;
            }
            if (Util_1.Util.isValidKeyword(key) && Util_1.Util.isValidKeyword(Util_1.Util.getContextValueId(value))) {
              throw new ErrorCoded_1.ErrorCoded(`Illegal keyword alias in term value, found: '${key}': '${Util_1.Util.getContextValueId(value)}'`, ErrorCoded_1.ERROR_CODES.KEYWORD_REDEFINITION);
            }
            continue;
          }
          if (value !== null) {
            switch (valueType) {
              case "string":
                if (Util_1.Util.getPrefix(value, context) === key) {
                  throw new ErrorCoded_1.ErrorCoded(`Detected cyclical IRI mapping in context entry: '${key}': '${JSON.stringify(value)}'`, ErrorCoded_1.ERROR_CODES.CYCLIC_IRI_MAPPING);
                }
                if (Util_1.Util.isValidIriWeak(key)) {
                  if (value === "@type") {
                    throw new ErrorCoded_1.ErrorCoded(`IRIs can not be mapped to @type, found: '${key}': '${value}'`, ErrorCoded_1.ERROR_CODES.INVALID_IRI_MAPPING);
                  } else if (Util_1.Util.isValidIri(value) && value !== new JsonLdContextNormalized_1.JsonLdContextNormalized(context).expandTerm(key)) {
                    throw new ErrorCoded_1.ErrorCoded(`IRIs can not be mapped to other IRIs, found: '${key}': '${value}'`, ErrorCoded_1.ERROR_CODES.INVALID_IRI_MAPPING);
                  }
                }
                break;
              case "object":
                if (!Util_1.Util.isCompactIri(key) && !("@id" in value) && (value["@type"] === "@id" ? !context["@base"] : !context["@vocab"])) {
                  throw new ErrorCoded_1.ErrorCoded(`Missing @id in context entry: '${key}': '${JSON.stringify(value)}'`, ErrorCoded_1.ERROR_CODES.INVALID_IRI_MAPPING);
                }
                for (const objectKey of Object.keys(value)) {
                  const objectValue = value[objectKey];
                  if (!objectValue) {
                    continue;
                  }
                  switch (objectKey) {
                    case "@id":
                      if (Util_1.Util.isValidKeyword(objectValue) && objectValue !== "@type" && objectValue !== "@id" && objectValue !== "@graph" && objectValue !== "@nest") {
                        throw new ErrorCoded_1.ErrorCoded(`Illegal keyword alias in term value, found: '${key}': '${JSON.stringify(value)}'`, ErrorCoded_1.ERROR_CODES.INVALID_IRI_MAPPING);
                      }
                      if (Util_1.Util.isValidIriWeak(key)) {
                        if (objectValue === "@type") {
                          throw new ErrorCoded_1.ErrorCoded(`IRIs can not be mapped to @type, found: '${key}': '${JSON.stringify(value)}'`, ErrorCoded_1.ERROR_CODES.INVALID_IRI_MAPPING);
                        } else if (Util_1.Util.isValidIri(objectValue) && objectValue !== new JsonLdContextNormalized_1.JsonLdContextNormalized(context).expandTerm(key)) {
                          throw new ErrorCoded_1.ErrorCoded(`IRIs can not be mapped to other IRIs, found: '${key}': '${JSON.stringify(value)}'`, ErrorCoded_1.ERROR_CODES.INVALID_IRI_MAPPING);
                        }
                      }
                      if (typeof objectValue !== "string") {
                        throw new ErrorCoded_1.ErrorCoded(`Detected non-string @id in context entry: '${key}': '${JSON.stringify(value)}'`, ErrorCoded_1.ERROR_CODES.INVALID_IRI_MAPPING);
                      }
                      if (Util_1.Util.getPrefix(objectValue, context) === key) {
                        throw new ErrorCoded_1.ErrorCoded(`Detected cyclical IRI mapping in context entry: '${key}': '${JSON.stringify(value)}'`, ErrorCoded_1.ERROR_CODES.CYCLIC_IRI_MAPPING);
                      }
                      break;
                    case "@type":
                      if (value["@container"] === "@type" && objectValue !== "@id" && objectValue !== "@vocab") {
                        throw new ErrorCoded_1.ErrorCoded(`@container: @type only allows @type: @id or @vocab, but got: '${key}': '${objectValue}'`, ErrorCoded_1.ERROR_CODES.INVALID_TYPE_MAPPING);
                      }
                      if (typeof objectValue !== "string") {
                        throw new ErrorCoded_1.ErrorCoded(`The value of an '@type' must be a string, got '${JSON.stringify(valueType)}'`, ErrorCoded_1.ERROR_CODES.INVALID_TYPE_MAPPING);
                      }
                      if (objectValue !== "@id" && objectValue !== "@vocab" && (processingMode === 1 || objectValue !== "@json") && (processingMode === 1 || objectValue !== "@none") && (objectValue[0] === "_" || !Util_1.Util.isValidIri(objectValue))) {
                        throw new ErrorCoded_1.ErrorCoded(`A context @type must be an absolute IRI, found: '${key}': '${objectValue}'`, ErrorCoded_1.ERROR_CODES.INVALID_TYPE_MAPPING);
                      }
                      break;
                    case "@reverse":
                      if (typeof objectValue === "string" && value["@id"] && value["@id"] !== objectValue) {
                        throw new ErrorCoded_1.ErrorCoded(`Found non-matching @id and @reverse term values in '${key}':'${objectValue}' and '${value["@id"]}'`, ErrorCoded_1.ERROR_CODES.INVALID_REVERSE_PROPERTY);
                      }
                      if ("@nest" in value) {
                        throw new ErrorCoded_1.ErrorCoded(`@nest is not allowed in the reverse property '${key}'`, ErrorCoded_1.ERROR_CODES.INVALID_REVERSE_PROPERTY);
                      }
                      break;
                    case "@container":
                      if (processingMode === 1) {
                        if (Object.keys(objectValue).length > 1 || Util_1.Util.CONTAINERS_1_0.indexOf(Object.keys(objectValue)[0]) < 0) {
                          throw new ErrorCoded_1.ErrorCoded(`Invalid term @container for '${key}' ('${Object.keys(objectValue)}') in 1.0, must be only one of ${Util_1.Util.CONTAINERS_1_0.join(", ")}`, ErrorCoded_1.ERROR_CODES.INVALID_CONTAINER_MAPPING);
                        }
                      }
                      for (const containerValue of Object.keys(objectValue)) {
                        if (containerValue === "@list" && value["@reverse"]) {
                          throw new ErrorCoded_1.ErrorCoded(`Term value can not be @container: @list and @reverse at the same time on '${key}'`, ErrorCoded_1.ERROR_CODES.INVALID_REVERSE_PROPERTY);
                        }
                        if (Util_1.Util.CONTAINERS.indexOf(containerValue) < 0) {
                          throw new ErrorCoded_1.ErrorCoded(`Invalid term @container for '${key}' ('${containerValue}'), must be one of ${Util_1.Util.CONTAINERS.join(", ")}`, ErrorCoded_1.ERROR_CODES.INVALID_CONTAINER_MAPPING);
                        }
                      }
                      break;
                    case "@language":
                      _ContextParser.validateLanguage(objectValue, true, ErrorCoded_1.ERROR_CODES.INVALID_LANGUAGE_MAPPING);
                      break;
                    case "@direction":
                      _ContextParser.validateDirection(objectValue, true);
                      break;
                    case "@prefix":
                      if (objectValue !== null && typeof objectValue !== "boolean") {
                        throw new ErrorCoded_1.ErrorCoded(`Found an invalid term @prefix boolean in: '${key}': '${JSON.stringify(value)}'`, ErrorCoded_1.ERROR_CODES.INVALID_PREFIX_VALUE);
                      }
                      if (!("@id" in value) && !Util_1.Util.isValidIri(key)) {
                        throw new ErrorCoded_1.ErrorCoded(`Invalid @prefix definition for '${key}' ('${JSON.stringify(value)}'`, ErrorCoded_1.ERROR_CODES.INVALID_TERM_DEFINITION);
                      }
                      break;
                    case "@index":
                      if (processingMode === 1 || !value["@container"] || !value["@container"]["@index"]) {
                        throw new ErrorCoded_1.ErrorCoded(`Attempt to add illegal key to value object: '${key}': '${JSON.stringify(value)}'`, ErrorCoded_1.ERROR_CODES.INVALID_TERM_DEFINITION);
                      }
                      break;
                    case "@nest":
                      if (Util_1.Util.isPotentialKeyword(objectValue) && objectValue !== "@nest") {
                        throw new ErrorCoded_1.ErrorCoded(`Found an invalid term @nest value in: '${key}': '${JSON.stringify(value)}'`, ErrorCoded_1.ERROR_CODES.INVALID_NEST_VALUE);
                      }
                  }
                }
                break;
              default:
                throw new ErrorCoded_1.ErrorCoded(`Found an invalid term value: '${key}': '${value}'`, ErrorCoded_1.ERROR_CODES.INVALID_TERM_DEFINITION);
            }
          }
        }
      }
      /**
       * Apply the @base context entry to the given context under certain circumstances.
       * @param context A context.
       * @param options Parsing options.
       * @param inheritFromParent If the @base value from the parent context can be inherited.
       * @return The given context.
       */
      applyBaseEntry(context, options, inheritFromParent) {
        if (typeof context === "string") {
          return context;
        }
        if (inheritFromParent && !("@base" in context) && options.parentContext && typeof options.parentContext === "object" && "@base" in options.parentContext) {
          context["@base"] = options.parentContext["@base"];
          if (options.parentContext["@__baseDocument"]) {
            context["@__baseDocument"] = true;
          }
        }
        if (options.baseIRI && !options.external) {
          if (!("@base" in context)) {
            context["@base"] = options.baseIRI;
            context["@__baseDocument"] = true;
          } else if (context["@base"] !== null && typeof context["@base"] === "string" && !Util_1.Util.isValidIri(context["@base"])) {
            context["@base"] = (0, relative_to_absolute_iri_1.resolve)(context["@base"], options.parentContext && options.parentContext["@base"] || options.baseIRI);
          }
        }
        return context;
      }
      /**
       * Resolve relative context IRIs, or return full IRIs as-is.
       * @param {string} contextIri A context IRI.
       * @param {string} baseIRI A base IRI.
       * @return {string} The normalized context IRI.
       */
      normalizeContextIri(contextIri, baseIRI) {
        if (!Util_1.Util.isValidIri(contextIri)) {
          try {
            contextIri = (0, relative_to_absolute_iri_1.resolve)(contextIri, baseIRI);
          } catch (_a) {
            throw new Error(`Invalid context IRI: ${contextIri}`);
          }
        }
        if (this.redirectSchemaOrgHttps && contextIri.startsWith("http://schema.org")) {
          contextIri = "https://schema.org/";
        }
        return contextIri;
      }
      /**
       * Parse scoped contexts in the given context.
       * @param {IJsonLdContextNormalizedRaw} context A context.
       * @param {IParseOptions} options Parsing options.
       * @return {IJsonLdContextNormalizedRaw} The mutated input context.
       * @param {string[]} keys Optional set of keys from the context to parseInnerContexts of. If left undefined, all
       * keys in the context will be iterated over.
       */
      async parseInnerContexts(context, options, keys) {
        for (const key of keys !== null && keys !== void 0 ? keys : Object.keys(context)) {
          const value = context[key];
          if (value && typeof value === "object") {
            if ("@context" in value && value["@context"] !== null && !options.ignoreScopedContexts) {
              if (this.validateContext) {
                try {
                  const parentContext = Object.assign(Object.assign({}, context), { [key]: Object.assign({}, context[key]) });
                  delete parentContext[key]["@context"];
                  await this.parse(value["@context"], Object.assign(Object.assign({}, options), { external: false, parentContext, ignoreProtection: true, ignoreRemoteScopedContexts: true, ignoreScopedContexts: true }));
                } catch (e) {
                  throw new ErrorCoded_1.ErrorCoded(e.message, ErrorCoded_1.ERROR_CODES.INVALID_SCOPED_CONTEXT);
                }
              }
              context[key] = Object.assign(Object.assign({}, value), { "@context": (await this.parse(value["@context"], Object.assign(Object.assign({}, options), { external: false, minimalProcessing: true, ignoreRemoteScopedContexts: true, parentContext: context }))).getContextRaw() });
            }
          }
        }
        return context;
      }
      async parse(context, options = {}, internalOptions = {}) {
        const { baseIRI, parentContext, external, processingMode = _ContextParser.DEFAULT_PROCESSING_MODE, normalizeLanguageTags, ignoreProtection, minimalProcessing } = options;
        const remoteContexts = options.remoteContexts || {};
        if (Object.keys(remoteContexts).length >= this.remoteContextsDepthLimit) {
          throw new ErrorCoded_1.ErrorCoded("Detected an overflow in remote context inclusions: " + Object.keys(remoteContexts), ErrorCoded_1.ERROR_CODES.CONTEXT_OVERFLOW);
        }
        if (context === null || context === void 0) {
          if (!ignoreProtection && parentContext && Util_1.Util.hasProtectedTerms(parentContext)) {
            throw new ErrorCoded_1.ErrorCoded("Illegal context nullification when terms are protected", ErrorCoded_1.ERROR_CODES.INVALID_CONTEXT_NULLIFICATION);
          }
          return new JsonLdContextNormalized_1.JsonLdContextNormalized(this.applyBaseEntry({}, options, false));
        } else if (typeof context === "string") {
          const contextIri = this.normalizeContextIri(context, baseIRI);
          const overriddenLoad = this.getOverriddenLoad(contextIri, options);
          if (overriddenLoad) {
            return new JsonLdContextNormalized_1.JsonLdContextNormalized(overriddenLoad);
          }
          const parsedStringContext = await this.parse(await this.load(contextIri), Object.assign(Object.assign({}, options), { baseIRI: contextIri, external: true, remoteContexts: Object.assign(Object.assign({}, remoteContexts), { [contextIri]: true }) }));
          this.applyBaseEntry(parsedStringContext.getContextRaw(), options, true);
          return parsedStringContext;
        } else if (Array.isArray(context)) {
          const contextIris = [];
          const contexts = await Promise.all(context.map((subContext, i) => {
            if (typeof subContext === "string") {
              const contextIri = this.normalizeContextIri(subContext, baseIRI);
              contextIris[i] = contextIri;
              const overriddenLoad = this.getOverriddenLoad(contextIri, options);
              if (overriddenLoad) {
                return overriddenLoad;
              }
              return this.load(contextIri);
            } else {
              return subContext;
            }
          }));
          if (minimalProcessing) {
            return new JsonLdContextNormalized_1.JsonLdContextNormalized(contexts);
          }
          const reducedContexts = await contexts.reduce((accContextPromise, contextEntry, i) => accContextPromise.then((accContext) => this.parse(
            contextEntry,
            Object.assign(Object.assign({}, options), { baseIRI: contextIris[i] || options.baseIRI, external: !!contextIris[i] || options.external, parentContext: accContext.getContextRaw(), remoteContexts: contextIris[i] ? Object.assign(Object.assign({}, remoteContexts), { [contextIris[i]]: true }) : remoteContexts }),
            // @ts-expect-error: This third argument causes a type error because we have hidden it from consumers
            {
              skipValidation: i < contexts.length - 1
            }
          )), Promise.resolve(new JsonLdContextNormalized_1.JsonLdContextNormalized(parentContext || {})));
          this.applyBaseEntry(reducedContexts.getContextRaw(), options, true);
          return reducedContexts;
        } else if (typeof context === "object") {
          if ("@context" in context) {
            return await this.parse(context["@context"], options);
          }
          context = Object.assign({}, context);
          if (external) {
            delete context["@base"];
          }
          this.applyBaseEntry(context, options, true);
          this.containersToHash(context);
          if (minimalProcessing) {
            return new JsonLdContextNormalized_1.JsonLdContextNormalized(context);
          }
          let importContext = {};
          if ("@import" in context) {
            if (processingMode >= 1.1) {
              if (typeof context["@import"] !== "string") {
                throw new ErrorCoded_1.ErrorCoded("An @import value must be a string, but got " + typeof context["@import"], ErrorCoded_1.ERROR_CODES.INVALID_IMPORT_VALUE);
              }
              importContext = await this.loadImportContext(this.normalizeContextIri(context["@import"], baseIRI));
              delete context["@import"];
            } else {
              throw new ErrorCoded_1.ErrorCoded("Context importing is not supported in JSON-LD 1.0", ErrorCoded_1.ERROR_CODES.INVALID_CONTEXT_ENTRY);
            }
          }
          this.applyScopedProtected(importContext, { processingMode }, JsonLdContextNormalized_1.defaultExpandOptions);
          const newContext = Object.assign(importContext, context);
          this.idifyReverseTerms(newContext);
          this.normalize(newContext, { processingMode, normalizeLanguageTags });
          this.applyScopedProtected(newContext, { processingMode }, JsonLdContextNormalized_1.defaultExpandOptions);
          const keys = Object.keys(newContext);
          const overlappingKeys = [];
          if (typeof parentContext === "object") {
            for (const key in parentContext) {
              if (key in newContext) {
                overlappingKeys.push(key);
              } else {
                newContext[key] = parentContext[key];
              }
            }
          }
          await this.parseInnerContexts(newContext, options, keys);
          const newContextWrapped = new JsonLdContextNormalized_1.JsonLdContextNormalized(newContext);
          if ((newContext && newContext["@version"] || _ContextParser.DEFAULT_PROCESSING_MODE) >= 1.1 && (context["@vocab"] && typeof context["@vocab"] === "string" || context["@vocab"] === "")) {
            if (parentContext && "@vocab" in parentContext && context["@vocab"].indexOf(":") < 0) {
              newContext["@vocab"] = parentContext["@vocab"] + context["@vocab"];
            } else if (Util_1.Util.isCompactIri(context["@vocab"]) || context["@vocab"] in newContext) {
              newContext["@vocab"] = newContextWrapped.expandTerm(context["@vocab"], true);
            }
          }
          this.expandPrefixedTerms(newContextWrapped, this.expandContentTypeToBase, keys);
          if (!ignoreProtection && parentContext && processingMode >= 1.1) {
            this.validateKeywordRedefinitions(parentContext, newContext, JsonLdContextNormalized_1.defaultExpandOptions, overlappingKeys);
          }
          if (this.validateContext && !internalOptions.skipValidation) {
            this.validate(newContext, { processingMode });
          }
          return newContextWrapped;
        } else {
          throw new ErrorCoded_1.ErrorCoded(`Tried parsing a context that is not a string, array or object, but got ${context}`, ErrorCoded_1.ERROR_CODES.INVALID_LOCAL_CONTEXT);
        }
      }
      /**
       * Fetch the given URL as a raw JSON-LD context.
       * @param url An URL.
       * @return A promise resolving to a raw JSON-LD context.
       */
      async load(url2) {
        const cached2 = this.documentCache[url2];
        if (cached2) {
          return cached2;
        }
        let document2;
        try {
          document2 = await this.documentLoader.load(url2);
        } catch (e) {
          throw new ErrorCoded_1.ErrorCoded(`Failed to load remote context ${url2}: ${e.message}`, ErrorCoded_1.ERROR_CODES.LOADING_REMOTE_CONTEXT_FAILED);
        }
        if (!("@context" in document2)) {
          throw new ErrorCoded_1.ErrorCoded(`Missing @context in remote context at ${url2}`, ErrorCoded_1.ERROR_CODES.INVALID_REMOTE_CONTEXT);
        }
        return this.documentCache[url2] = document2["@context"];
      }
      /**
       * Override the given context that may be loaded.
       *
       * This will check whether or not the url is recursively being loaded.
       * @param url An URL.
       * @param options Parsing options.
       * @return An overridden context, or null.
       *         Optionally an error can be thrown if a cyclic context is detected.
       */
      getOverriddenLoad(url2, options) {
        if (url2 in (options.remoteContexts || {})) {
          if (options.ignoreRemoteScopedContexts) {
            return url2;
          } else {
            throw new ErrorCoded_1.ErrorCoded("Detected a cyclic context inclusion of " + url2, ErrorCoded_1.ERROR_CODES.RECURSIVE_CONTEXT_INCLUSION);
          }
        }
        return null;
      }
      /**
       * Load an @import'ed context.
       * @param importContextIri The full URI of an @import value.
       */
      async loadImportContext(importContextIri) {
        let importContext = await this.load(importContextIri);
        if (typeof importContext !== "object" || Array.isArray(importContext)) {
          throw new ErrorCoded_1.ErrorCoded("An imported context must be a single object: " + importContextIri, ErrorCoded_1.ERROR_CODES.INVALID_REMOTE_CONTEXT);
        }
        if ("@import" in importContext) {
          throw new ErrorCoded_1.ErrorCoded("An imported context can not import another context: " + importContextIri, ErrorCoded_1.ERROR_CODES.INVALID_CONTEXT_ENTRY);
        }
        importContext = Object.assign({}, importContext);
        this.containersToHash(importContext);
        return importContext;
      }
    };
    ContextParser.DEFAULT_PROCESSING_MODE = 1.1;
    exports.ContextParser = ContextParser;
  }
});

// node_modules/jsonld-context-parser/lib/IDocumentLoader.js
var require_IDocumentLoader = __commonJS({
  "node_modules/jsonld-context-parser/lib/IDocumentLoader.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/jsonld-context-parser/lib/JsonLdContext.js
var require_JsonLdContext = __commonJS({
  "node_modules/jsonld-context-parser/lib/JsonLdContext.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/jsonld-context-parser/index.js
var require_jsonld_context_parser = __commonJS({
  "node_modules/jsonld-context-parser/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    }) : (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    }));
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p)) __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_ContextParser(), exports);
    __exportStar(require_ErrorCoded(), exports);
    __exportStar(require_FetchDocumentLoader(), exports);
    __exportStar(require_IDocumentLoader(), exports);
    __exportStar(require_JsonLdContext(), exports);
    __exportStar(require_JsonLdContextNormalized(), exports);
    __exportStar(require_Util(), exports);
  }
});

// node_modules/jsonld-streaming-parser/node_modules/readable-stream/lib/ours/primordials.js
var require_primordials = __commonJS({
  "node_modules/jsonld-streaming-parser/node_modules/readable-stream/lib/ours/primordials.js"(exports, module) {
    "use strict";
    var AggregateError = class extends Error {
      constructor(errors) {
        if (!Array.isArray(errors)) {
          throw new TypeError(`Expected input to be an Array, got ${typeof errors}`);
        }
        let message2 = "";
        for (let i = 0; i < errors.length; i++) {
          message2 += `    ${errors[i].stack}
`;
        }
        super(message2);
        this.name = "AggregateError";
        this.errors = errors;
      }
    };
    module.exports = {
      AggregateError,
      ArrayIsArray(self2) {
        return Array.isArray(self2);
      },
      ArrayPrototypeIncludes(self2, el) {
        return self2.includes(el);
      },
      ArrayPrototypeIndexOf(self2, el) {
        return self2.indexOf(el);
      },
      ArrayPrototypeJoin(self2, sep) {
        return self2.join(sep);
      },
      ArrayPrototypeMap(self2, fn) {
        return self2.map(fn);
      },
      ArrayPrototypePop(self2, el) {
        return self2.pop(el);
      },
      ArrayPrototypePush(self2, el) {
        return self2.push(el);
      },
      ArrayPrototypeSlice(self2, start, end) {
        return self2.slice(start, end);
      },
      Error,
      FunctionPrototypeCall(fn, thisArgs, ...args) {
        return fn.call(thisArgs, ...args);
      },
      FunctionPrototypeSymbolHasInstance(self2, instance) {
        return Function.prototype[Symbol.hasInstance].call(self2, instance);
      },
      MathFloor: Math.floor,
      Number,
      NumberIsInteger: Number.isInteger,
      NumberIsNaN: Number.isNaN,
      NumberMAX_SAFE_INTEGER: Number.MAX_SAFE_INTEGER,
      NumberMIN_SAFE_INTEGER: Number.MIN_SAFE_INTEGER,
      NumberParseInt: Number.parseInt,
      ObjectDefineProperties(self2, props) {
        return Object.defineProperties(self2, props);
      },
      ObjectDefineProperty(self2, name, prop) {
        return Object.defineProperty(self2, name, prop);
      },
      ObjectGetOwnPropertyDescriptor(self2, name) {
        return Object.getOwnPropertyDescriptor(self2, name);
      },
      ObjectKeys(obj) {
        return Object.keys(obj);
      },
      ObjectSetPrototypeOf(target, proto) {
        return Object.setPrototypeOf(target, proto);
      },
      Promise,
      PromisePrototypeCatch(self2, fn) {
        return self2.catch(fn);
      },
      PromisePrototypeThen(self2, thenFn, catchFn) {
        return self2.then(thenFn, catchFn);
      },
      PromiseReject(err) {
        return Promise.reject(err);
      },
      PromiseResolve(val) {
        return Promise.resolve(val);
      },
      ReflectApply: Reflect.apply,
      RegExpPrototypeTest(self2, value) {
        return self2.test(value);
      },
      SafeSet: Set,
      String,
      StringPrototypeSlice(self2, start, end) {
        return self2.slice(start, end);
      },
      StringPrototypeToLowerCase(self2) {
        return self2.toLowerCase();
      },
      StringPrototypeToUpperCase(self2) {
        return self2.toUpperCase();
      },
      StringPrototypeTrim(self2) {
        return self2.trim();
      },
      Symbol,
      SymbolFor: Symbol.for,
      SymbolAsyncIterator: Symbol.asyncIterator,
      SymbolHasInstance: Symbol.hasInstance,
      SymbolIterator: Symbol.iterator,
      SymbolDispose: Symbol.dispose || Symbol("Symbol.dispose"),
      SymbolAsyncDispose: Symbol.asyncDispose || Symbol("Symbol.asyncDispose"),
      TypedArrayPrototypeSet(self2, buf, len) {
        return self2.set(buf, len);
      },
      Boolean,
      Uint8Array
    };
  }
});

// node_modules/jsonld-streaming-parser/node_modules/readable-stream/lib/ours/util/inspect.js
var require_inspect = __commonJS({
  "node_modules/jsonld-streaming-parser/node_modules/readable-stream/lib/ours/util/inspect.js"(exports, module) {
    "use strict";
    module.exports = {
      format(format, ...args) {
        return format.replace(/%([sdifj])/g, function(...[_unused, type2]) {
          const replacement = args.shift();
          if (type2 === "f") {
            return replacement.toFixed(6);
          } else if (type2 === "j") {
            return JSON.stringify(replacement);
          } else if (type2 === "s" && typeof replacement === "object") {
            const ctor = replacement.constructor !== Object ? replacement.constructor.name : "";
            return `${ctor} {}`.trim();
          } else {
            return replacement.toString();
          }
        });
      },
      inspect(value) {
        switch (typeof value) {
          case "string":
            if (value.includes("'")) {
              if (!value.includes('"')) {
                return `"${value}"`;
              } else if (!value.includes("`") && !value.includes("${")) {
                return `\`${value}\``;
              }
            }
            return `'${value}'`;
          case "number":
            if (isNaN(value)) {
              return "NaN";
            } else if (Object.is(value, -0)) {
              return String(value);
            }
            return value;
          case "bigint":
            return `${String(value)}n`;
          case "boolean":
          case "undefined":
            return String(value);
          case "object":
            return "{}";
        }
      }
    };
  }
});

// node_modules/jsonld-streaming-parser/node_modules/readable-stream/lib/ours/errors.js
var require_errors = __commonJS({
  "node_modules/jsonld-streaming-parser/node_modules/readable-stream/lib/ours/errors.js"(exports, module) {
    "use strict";
    var { format, inspect } = require_inspect();
    var { AggregateError: CustomAggregateError } = require_primordials();
    var AggregateError = globalThis.AggregateError || CustomAggregateError;
    var kIsNodeError = Symbol("kIsNodeError");
    var kTypes = [
      "string",
      "function",
      "number",
      "object",
      // Accept 'Function' and 'Object' as alternative to the lower cased version.
      "Function",
      "Object",
      "boolean",
      "bigint",
      "symbol"
    ];
    var classRegExp = /^([A-Z][a-z0-9]*)+$/;
    var nodeInternalPrefix = "__node_internal_";
    var codes = {};
    function assert2(value, message2) {
      if (!value) {
        throw new codes.ERR_INTERNAL_ASSERTION(message2);
      }
    }
    function addNumericalSeparator(val) {
      let res = "";
      let i = val.length;
      const start = val[0] === "-" ? 1 : 0;
      for (; i >= start + 4; i -= 3) {
        res = `_${val.slice(i - 3, i)}${res}`;
      }
      return `${val.slice(0, i)}${res}`;
    }
    function getMessage(key, msg, args) {
      if (typeof msg === "function") {
        assert2(
          msg.length <= args.length,
          // Default options do not count.
          `Code: ${key}; The provided arguments length (${args.length}) does not match the required ones (${msg.length}).`
        );
        return msg(...args);
      }
      const expectedLength = (msg.match(/%[dfijoOs]/g) || []).length;
      assert2(
        expectedLength === args.length,
        `Code: ${key}; The provided arguments length (${args.length}) does not match the required ones (${expectedLength}).`
      );
      if (args.length === 0) {
        return msg;
      }
      return format(msg, ...args);
    }
    function E(code, message2, Base) {
      if (!Base) {
        Base = Error;
      }
      class NodeError extends Base {
        constructor(...args) {
          super(getMessage(code, message2, args));
        }
        toString() {
          return `${this.name} [${code}]: ${this.message}`;
        }
      }
      Object.defineProperties(NodeError.prototype, {
        name: {
          value: Base.name,
          writable: true,
          enumerable: false,
          configurable: true
        },
        toString: {
          value() {
            return `${this.name} [${code}]: ${this.message}`;
          },
          writable: true,
          enumerable: false,
          configurable: true
        }
      });
      NodeError.prototype.code = code;
      NodeError.prototype[kIsNodeError] = true;
      codes[code] = NodeError;
    }
    function hideStackFrames(fn) {
      const hidden = nodeInternalPrefix + fn.name;
      Object.defineProperty(fn, "name", {
        value: hidden
      });
      return fn;
    }
    function aggregateTwoErrors(innerError, outerError) {
      if (innerError && outerError && innerError !== outerError) {
        if (Array.isArray(outerError.errors)) {
          outerError.errors.push(innerError);
          return outerError;
        }
        const err = new AggregateError([outerError, innerError], outerError.message);
        err.code = outerError.code;
        return err;
      }
      return innerError || outerError;
    }
    var AbortError = class extends Error {
      constructor(message2 = "The operation was aborted", options = void 0) {
        if (options !== void 0 && typeof options !== "object") {
          throw new codes.ERR_INVALID_ARG_TYPE("options", "Object", options);
        }
        super(message2, options);
        this.code = "ABORT_ERR";
        this.name = "AbortError";
      }
    };
    E("ERR_ASSERTION", "%s", Error);
    E(
      "ERR_INVALID_ARG_TYPE",
      (name, expected, actual) => {
        assert2(typeof name === "string", "'name' must be a string");
        if (!Array.isArray(expected)) {
          expected = [expected];
        }
        let msg = "The ";
        if (name.endsWith(" argument")) {
          msg += `${name} `;
        } else {
          msg += `"${name}" ${name.includes(".") ? "property" : "argument"} `;
        }
        msg += "must be ";
        const types3 = [];
        const instances = [];
        const other = [];
        for (const value of expected) {
          assert2(typeof value === "string", "All expected entries have to be of type string");
          if (kTypes.includes(value)) {
            types3.push(value.toLowerCase());
          } else if (classRegExp.test(value)) {
            instances.push(value);
          } else {
            assert2(value !== "object", 'The value "object" should be written as "Object"');
            other.push(value);
          }
        }
        if (instances.length > 0) {
          const pos = types3.indexOf("object");
          if (pos !== -1) {
            types3.splice(types3, pos, 1);
            instances.push("Object");
          }
        }
        if (types3.length > 0) {
          switch (types3.length) {
            case 1:
              msg += `of type ${types3[0]}`;
              break;
            case 2:
              msg += `one of type ${types3[0]} or ${types3[1]}`;
              break;
            default: {
              const last = types3.pop();
              msg += `one of type ${types3.join(", ")}, or ${last}`;
            }
          }
          if (instances.length > 0 || other.length > 0) {
            msg += " or ";
          }
        }
        if (instances.length > 0) {
          switch (instances.length) {
            case 1:
              msg += `an instance of ${instances[0]}`;
              break;
            case 2:
              msg += `an instance of ${instances[0]} or ${instances[1]}`;
              break;
            default: {
              const last = instances.pop();
              msg += `an instance of ${instances.join(", ")}, or ${last}`;
            }
          }
          if (other.length > 0) {
            msg += " or ";
          }
        }
        switch (other.length) {
          case 0:
            break;
          case 1:
            if (other[0].toLowerCase() !== other[0]) {
              msg += "an ";
            }
            msg += `${other[0]}`;
            break;
          case 2:
            msg += `one of ${other[0]} or ${other[1]}`;
            break;
          default: {
            const last = other.pop();
            msg += `one of ${other.join(", ")}, or ${last}`;
          }
        }
        if (actual == null) {
          msg += `. Received ${actual}`;
        } else if (typeof actual === "function" && actual.name) {
          msg += `. Received function ${actual.name}`;
        } else if (typeof actual === "object") {
          var _actual$constructor;
          if ((_actual$constructor = actual.constructor) !== null && _actual$constructor !== void 0 && _actual$constructor.name) {
            msg += `. Received an instance of ${actual.constructor.name}`;
          } else {
            const inspected = inspect(actual, {
              depth: -1
            });
            msg += `. Received ${inspected}`;
          }
        } else {
          let inspected = inspect(actual, {
            colors: false
          });
          if (inspected.length > 25) {
            inspected = `${inspected.slice(0, 25)}...`;
          }
          msg += `. Received type ${typeof actual} (${inspected})`;
        }
        return msg;
      },
      TypeError
    );
    E(
      "ERR_INVALID_ARG_VALUE",
      (name, value, reason = "is invalid") => {
        let inspected = inspect(value);
        if (inspected.length > 128) {
          inspected = inspected.slice(0, 128) + "...";
        }
        const type2 = name.includes(".") ? "property" : "argument";
        return `The ${type2} '${name}' ${reason}. Received ${inspected}`;
      },
      TypeError
    );
    E(
      "ERR_INVALID_RETURN_VALUE",
      (input, name, value) => {
        var _value$constructor;
        const type2 = value !== null && value !== void 0 && (_value$constructor = value.constructor) !== null && _value$constructor !== void 0 && _value$constructor.name ? `instance of ${value.constructor.name}` : `type ${typeof value}`;
        return `Expected ${input} to be returned from the "${name}" function but got ${type2}.`;
      },
      TypeError
    );
    E(
      "ERR_MISSING_ARGS",
      (...args) => {
        assert2(args.length > 0, "At least one arg needs to be specified");
        let msg;
        const len = args.length;
        args = (Array.isArray(args) ? args : [args]).map((a) => `"${a}"`).join(" or ");
        switch (len) {
          case 1:
            msg += `The ${args[0]} argument`;
            break;
          case 2:
            msg += `The ${args[0]} and ${args[1]} arguments`;
            break;
          default:
            {
              const last = args.pop();
              msg += `The ${args.join(", ")}, and ${last} arguments`;
            }
            break;
        }
        return `${msg} must be specified`;
      },
      TypeError
    );
    E(
      "ERR_OUT_OF_RANGE",
      (str2, range, input) => {
        assert2(range, 'Missing "range" argument');
        let received;
        if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {
          received = addNumericalSeparator(String(input));
        } else if (typeof input === "bigint") {
          received = String(input);
          const limit = BigInt(2) ** BigInt(32);
          if (input > limit || input < -limit) {
            received = addNumericalSeparator(received);
          }
          received += "n";
        } else {
          received = inspect(input);
        }
        return `The value of "${str2}" is out of range. It must be ${range}. Received ${received}`;
      },
      RangeError
    );
    E("ERR_MULTIPLE_CALLBACK", "Callback called multiple times", Error);
    E("ERR_METHOD_NOT_IMPLEMENTED", "The %s method is not implemented", Error);
    E("ERR_STREAM_ALREADY_FINISHED", "Cannot call %s after a stream was finished", Error);
    E("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable", Error);
    E("ERR_STREAM_DESTROYED", "Cannot call %s after a stream was destroyed", Error);
    E("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError);
    E("ERR_STREAM_PREMATURE_CLOSE", "Premature close", Error);
    E("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF", Error);
    E("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event", Error);
    E("ERR_STREAM_WRITE_AFTER_END", "write after end", Error);
    E("ERR_UNKNOWN_ENCODING", "Unknown encoding: %s", TypeError);
    module.exports = {
      AbortError,
      aggregateTwoErrors: hideStackFrames(aggregateTwoErrors),
      hideStackFrames,
      codes
    };
  }
});

// node_modules/abort-controller/browser.js
var require_browser = __commonJS({
  "node_modules/abort-controller/browser.js"(exports, module) {
    "use strict";
    var { AbortController: AbortController2, AbortSignal } = typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : (
      /* otherwise */
      void 0
    );
    module.exports = AbortController2;
    module.exports.AbortSignal = AbortSignal;
    module.exports.default = AbortController2;
  }
});

// node_modules/events/events.js
var require_events = __commonJS({
  "node_modules/events/events.js"(exports, module) {
    "use strict";
    var R = typeof Reflect === "object" ? Reflect : null;
    var ReflectApply = R && typeof R.apply === "function" ? R.apply : function ReflectApply2(target, receiver, args) {
      return Function.prototype.apply.call(target, receiver, args);
    };
    var ReflectOwnKeys;
    if (R && typeof R.ownKeys === "function") {
      ReflectOwnKeys = R.ownKeys;
    } else if (Object.getOwnPropertySymbols) {
      ReflectOwnKeys = function ReflectOwnKeys2(target) {
        return Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target));
      };
    } else {
      ReflectOwnKeys = function ReflectOwnKeys2(target) {
        return Object.getOwnPropertyNames(target);
      };
    }
    function ProcessEmitWarning(warning) {
      if (console && console.warn) console.warn(warning);
    }
    var NumberIsNaN = Number.isNaN || function NumberIsNaN2(value) {
      return value !== value;
    };
    function EventEmitter2() {
      EventEmitter2.init.call(this);
    }
    module.exports = EventEmitter2;
    module.exports.once = once;
    EventEmitter2.EventEmitter = EventEmitter2;
    EventEmitter2.prototype._events = void 0;
    EventEmitter2.prototype._eventsCount = 0;
    EventEmitter2.prototype._maxListeners = void 0;
    var defaultMaxListeners = 10;
    function checkListener(listener) {
      if (typeof listener !== "function") {
        throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
      }
    }
    Object.defineProperty(EventEmitter2, "defaultMaxListeners", {
      enumerable: true,
      get: function() {
        return defaultMaxListeners;
      },
      set: function(arg) {
        if (typeof arg !== "number" || arg < 0 || NumberIsNaN(arg)) {
          throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + ".");
        }
        defaultMaxListeners = arg;
      }
    });
    EventEmitter2.init = function() {
      if (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) {
        this._events = /* @__PURE__ */ Object.create(null);
        this._eventsCount = 0;
      }
      this._maxListeners = this._maxListeners || void 0;
    };
    EventEmitter2.prototype.setMaxListeners = function setMaxListeners(n) {
      if (typeof n !== "number" || n < 0 || NumberIsNaN(n)) {
        throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n + ".");
      }
      this._maxListeners = n;
      return this;
    };
    function _getMaxListeners(that) {
      if (that._maxListeners === void 0)
        return EventEmitter2.defaultMaxListeners;
      return that._maxListeners;
    }
    EventEmitter2.prototype.getMaxListeners = function getMaxListeners() {
      return _getMaxListeners(this);
    };
    EventEmitter2.prototype.emit = function emit(type2) {
      var args = [];
      for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);
      var doError = type2 === "error";
      var events = this._events;
      if (events !== void 0)
        doError = doError && events.error === void 0;
      else if (!doError)
        return false;
      if (doError) {
        var er;
        if (args.length > 0)
          er = args[0];
        if (er instanceof Error) {
          throw er;
        }
        var err = new Error("Unhandled error." + (er ? " (" + er.message + ")" : ""));
        err.context = er;
        throw err;
      }
      var handler = events[type2];
      if (handler === void 0)
        return false;
      if (typeof handler === "function") {
        ReflectApply(handler, this, args);
      } else {
        var len = handler.length;
        var listeners = arrayClone(handler, len);
        for (var i = 0; i < len; ++i)
          ReflectApply(listeners[i], this, args);
      }
      return true;
    };
    function _addListener(target, type2, listener, prepend) {
      var m;
      var events;
      var existing;
      checkListener(listener);
      events = target._events;
      if (events === void 0) {
        events = target._events = /* @__PURE__ */ Object.create(null);
        target._eventsCount = 0;
      } else {
        if (events.newListener !== void 0) {
          target.emit(
            "newListener",
            type2,
            listener.listener ? listener.listener : listener
          );
          events = target._events;
        }
        existing = events[type2];
      }
      if (existing === void 0) {
        existing = events[type2] = listener;
        ++target._eventsCount;
      } else {
        if (typeof existing === "function") {
          existing = events[type2] = prepend ? [listener, existing] : [existing, listener];
        } else if (prepend) {
          existing.unshift(listener);
        } else {
          existing.push(listener);
        }
        m = _getMaxListeners(target);
        if (m > 0 && existing.length > m && !existing.warned) {
          existing.warned = true;
          var w = new Error("Possible EventEmitter memory leak detected. " + existing.length + " " + String(type2) + " listeners added. Use emitter.setMaxListeners() to increase limit");
          w.name = "MaxListenersExceededWarning";
          w.emitter = target;
          w.type = type2;
          w.count = existing.length;
          ProcessEmitWarning(w);
        }
      }
      return target;
    }
    EventEmitter2.prototype.addListener = function addListener(type2, listener) {
      return _addListener(this, type2, listener, false);
    };
    EventEmitter2.prototype.on = EventEmitter2.prototype.addListener;
    EventEmitter2.prototype.prependListener = function prependListener(type2, listener) {
      return _addListener(this, type2, listener, true);
    };
    function onceWrapper() {
      if (!this.fired) {
        this.target.removeListener(this.type, this.wrapFn);
        this.fired = true;
        if (arguments.length === 0)
          return this.listener.call(this.target);
        return this.listener.apply(this.target, arguments);
      }
    }
    function _onceWrap(target, type2, listener) {
      var state = { fired: false, wrapFn: void 0, target, type: type2, listener };
      var wrapped = onceWrapper.bind(state);
      wrapped.listener = listener;
      state.wrapFn = wrapped;
      return wrapped;
    }
    EventEmitter2.prototype.once = function once2(type2, listener) {
      checkListener(listener);
      this.on(type2, _onceWrap(this, type2, listener));
      return this;
    };
    EventEmitter2.prototype.prependOnceListener = function prependOnceListener(type2, listener) {
      checkListener(listener);
      this.prependListener(type2, _onceWrap(this, type2, listener));
      return this;
    };
    EventEmitter2.prototype.removeListener = function removeListener(type2, listener) {
      var list, events, position, i, originalListener;
      checkListener(listener);
      events = this._events;
      if (events === void 0)
        return this;
      list = events[type2];
      if (list === void 0)
        return this;
      if (list === listener || list.listener === listener) {
        if (--this._eventsCount === 0)
          this._events = /* @__PURE__ */ Object.create(null);
        else {
          delete events[type2];
          if (events.removeListener)
            this.emit("removeListener", type2, list.listener || listener);
        }
      } else if (typeof list !== "function") {
        position = -1;
        for (i = list.length - 1; i >= 0; i--) {
          if (list[i] === listener || list[i].listener === listener) {
            originalListener = list[i].listener;
            position = i;
            break;
          }
        }
        if (position < 0)
          return this;
        if (position === 0)
          list.shift();
        else {
          spliceOne(list, position);
        }
        if (list.length === 1)
          events[type2] = list[0];
        if (events.removeListener !== void 0)
          this.emit("removeListener", type2, originalListener || listener);
      }
      return this;
    };
    EventEmitter2.prototype.off = EventEmitter2.prototype.removeListener;
    EventEmitter2.prototype.removeAllListeners = function removeAllListeners(type2) {
      var listeners, events, i;
      events = this._events;
      if (events === void 0)
        return this;
      if (events.removeListener === void 0) {
        if (arguments.length === 0) {
          this._events = /* @__PURE__ */ Object.create(null);
          this._eventsCount = 0;
        } else if (events[type2] !== void 0) {
          if (--this._eventsCount === 0)
            this._events = /* @__PURE__ */ Object.create(null);
          else
            delete events[type2];
        }
        return this;
      }
      if (arguments.length === 0) {
        var keys = Object.keys(events);
        var key;
        for (i = 0; i < keys.length; ++i) {
          key = keys[i];
          if (key === "removeListener") continue;
          this.removeAllListeners(key);
        }
        this.removeAllListeners("removeListener");
        this._events = /* @__PURE__ */ Object.create(null);
        this._eventsCount = 0;
        return this;
      }
      listeners = events[type2];
      if (typeof listeners === "function") {
        this.removeListener(type2, listeners);
      } else if (listeners !== void 0) {
        for (i = listeners.length - 1; i >= 0; i--) {
          this.removeListener(type2, listeners[i]);
        }
      }
      return this;
    };
    function _listeners(target, type2, unwrap) {
      var events = target._events;
      if (events === void 0)
        return [];
      var evlistener = events[type2];
      if (evlistener === void 0)
        return [];
      if (typeof evlistener === "function")
        return unwrap ? [evlistener.listener || evlistener] : [evlistener];
      return unwrap ? unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
    }
    EventEmitter2.prototype.listeners = function listeners(type2) {
      return _listeners(this, type2, true);
    };
    EventEmitter2.prototype.rawListeners = function rawListeners(type2) {
      return _listeners(this, type2, false);
    };
    EventEmitter2.listenerCount = function(emitter, type2) {
      if (typeof emitter.listenerCount === "function") {
        return emitter.listenerCount(type2);
      } else {
        return listenerCount.call(emitter, type2);
      }
    };
    EventEmitter2.prototype.listenerCount = listenerCount;
    function listenerCount(type2) {
      var events = this._events;
      if (events !== void 0) {
        var evlistener = events[type2];
        if (typeof evlistener === "function") {
          return 1;
        } else if (evlistener !== void 0) {
          return evlistener.length;
        }
      }
      return 0;
    }
    EventEmitter2.prototype.eventNames = function eventNames() {
      return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
    };
    function arrayClone(arr, n) {
      var copy = new Array(n);
      for (var i = 0; i < n; ++i)
        copy[i] = arr[i];
      return copy;
    }
    function spliceOne(list, index) {
      for (; index + 1 < list.length; index++)
        list[index] = list[index + 1];
      list.pop();
    }
    function unwrapListeners(arr) {
      var ret = new Array(arr.length);
      for (var i = 0; i < ret.length; ++i) {
        ret[i] = arr[i].listener || arr[i];
      }
      return ret;
    }
    function once(emitter, name) {
      return new Promise(function(resolve, reject2) {
        function errorListener(err) {
          emitter.removeListener(name, resolver);
          reject2(err);
        }
        function resolver() {
          if (typeof emitter.removeListener === "function") {
            emitter.removeListener("error", errorListener);
          }
          resolve([].slice.call(arguments));
        }
        ;
        eventTargetAgnosticAddListener(emitter, name, resolver, { once: true });
        if (name !== "error") {
          addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });
        }
      });
    }
    function addErrorHandlerIfEventEmitter(emitter, handler, flags) {
      if (typeof emitter.on === "function") {
        eventTargetAgnosticAddListener(emitter, "error", handler, flags);
      }
    }
    function eventTargetAgnosticAddListener(emitter, name, listener, flags) {
      if (typeof emitter.on === "function") {
        if (flags.once) {
          emitter.once(name, listener);
        } else {
          emitter.on(name, listener);
        }
      } else if (typeof emitter.addEventListener === "function") {
        emitter.addEventListener(name, function wrapListener(arg) {
          if (flags.once) {
            emitter.removeEventListener(name, wrapListener);
          }
          listener(arg);
        });
      } else {
        throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof emitter);
      }
    }
  }
});

// node_modules/jsonld-streaming-parser/node_modules/readable-stream/lib/ours/util.js
var require_util = __commonJS({
  "node_modules/jsonld-streaming-parser/node_modules/readable-stream/lib/ours/util.js"(exports, module) {
    "use strict";
    var bufferModule = require_buffer();
    var { format, inspect } = require_inspect();
    var {
      codes: { ERR_INVALID_ARG_TYPE }
    } = require_errors();
    var { kResistStopPropagation, AggregateError, SymbolDispose } = require_primordials();
    var AbortSignal = globalThis.AbortSignal || require_browser().AbortSignal;
    var AbortController2 = globalThis.AbortController || require_browser().AbortController;
    var AsyncFunction = Object.getPrototypeOf(async function() {
    }).constructor;
    var Blob2 = globalThis.Blob || bufferModule.Blob;
    var isBlob = typeof Blob2 !== "undefined" ? function isBlob2(b) {
      return b instanceof Blob2;
    } : function isBlob2(b) {
      return false;
    };
    var validateAbortSignal = (signal, name) => {
      if (signal !== void 0 && (signal === null || typeof signal !== "object" || !("aborted" in signal))) {
        throw new ERR_INVALID_ARG_TYPE(name, "AbortSignal", signal);
      }
    };
    var validateFunction = (value, name) => {
      if (typeof value !== "function") {
        throw new ERR_INVALID_ARG_TYPE(name, "Function", value);
      }
    };
    module.exports = {
      AggregateError,
      kEmptyObject: Object.freeze({}),
      once(callback) {
        let called = false;
        return function(...args) {
          if (called) {
            return;
          }
          called = true;
          callback.apply(this, args);
        };
      },
      createDeferredPromise: function() {
        let resolve;
        let reject2;
        const promise2 = new Promise((res, rej) => {
          resolve = res;
          reject2 = rej;
        });
        return {
          promise: promise2,
          resolve,
          reject: reject2
        };
      },
      promisify(fn) {
        return new Promise((resolve, reject2) => {
          fn((err, ...args) => {
            if (err) {
              return reject2(err);
            }
            return resolve(...args);
          });
        });
      },
      debuglog() {
        return function() {
        };
      },
      format,
      inspect,
      types: {
        isAsyncFunction(fn) {
          return fn instanceof AsyncFunction;
        },
        isArrayBufferView(arr) {
          return ArrayBuffer.isView(arr);
        }
      },
      isBlob,
      deprecate(fn, message2) {
        return fn;
      },
      addAbortListener: require_events().addAbortListener || function addAbortListener(signal, listener) {
        if (signal === void 0) {
          throw new ERR_INVALID_ARG_TYPE("signal", "AbortSignal", signal);
        }
        validateAbortSignal(signal, "signal");
        validateFunction(listener, "listener");
        let removeEventListener;
        if (signal.aborted) {
          queueMicrotask(() => listener());
        } else {
          signal.addEventListener("abort", listener, {
            __proto__: null,
            once: true,
            [kResistStopPropagation]: true
          });
          removeEventListener = () => {
            signal.removeEventListener("abort", listener);
          };
        }
        return {
          __proto__: null,
          [SymbolDispose]() {
            var _removeEventListener;
            (_removeEventListener = removeEventListener) === null || _removeEventListener === void 0 ? void 0 : _removeEventListener();
          }
        };
      },
      AbortSignalAny: AbortSignal.any || function AbortSignalAny(signals) {
        if (signals.length === 1) {
          return signals[0];
        }
        const ac = new AbortController2();
        const abort = () => ac.abort();
        signals.forEach((signal) => {
          validateAbortSignal(signal, "signals");
          signal.addEventListener("abort", abort, {
            once: true
          });
        });
        ac.signal.addEventListener(
          "abort",
          () => {
            signals.forEach((signal) => signal.removeEventListener("abort", abort));
          },
          {
            once: true
          }
        );
        return ac.signal;
      }
    };
    module.exports.promisify.custom = Symbol.for("nodejs.util.promisify.custom");
  }
});

// node_modules/jsonld-streaming-parser/node_modules/readable-stream/lib/internal/validators.js
var require_validators = __commonJS({
  "node_modules/jsonld-streaming-parser/node_modules/readable-stream/lib/internal/validators.js"(exports, module) {
    "use strict";
    var {
      ArrayIsArray,
      ArrayPrototypeIncludes,
      ArrayPrototypeJoin,
      ArrayPrototypeMap,
      NumberIsInteger,
      NumberIsNaN,
      NumberMAX_SAFE_INTEGER,
      NumberMIN_SAFE_INTEGER,
      NumberParseInt,
      ObjectPrototypeHasOwnProperty,
      RegExpPrototypeExec,
      String: String2,
      StringPrototypeToUpperCase,
      StringPrototypeTrim
    } = require_primordials();
    var {
      hideStackFrames,
      codes: { ERR_SOCKET_BAD_PORT, ERR_INVALID_ARG_TYPE, ERR_INVALID_ARG_VALUE, ERR_OUT_OF_RANGE, ERR_UNKNOWN_SIGNAL }
    } = require_errors();
    var { normalizeEncoding } = require_util();
    var { isAsyncFunction, isArrayBufferView } = require_util().types;
    var signals = {};
    function isInt32(value) {
      return value === (value | 0);
    }
    function isUint32(value) {
      return value === value >>> 0;
    }
    var octalReg = /^[0-7]+$/;
    var modeDesc = "must be a 32-bit unsigned integer or an octal string";
    function parseFileMode(value, name, def) {
      if (typeof value === "undefined") {
        value = def;
      }
      if (typeof value === "string") {
        if (RegExpPrototypeExec(octalReg, value) === null) {
          throw new ERR_INVALID_ARG_VALUE(name, value, modeDesc);
        }
        value = NumberParseInt(value, 8);
      }
      validateUint32(value, name);
      return value;
    }
    var validateInteger = hideStackFrames((value, name, min = NumberMIN_SAFE_INTEGER, max = NumberMAX_SAFE_INTEGER) => {
      if (typeof value !== "number") throw new ERR_INVALID_ARG_TYPE(name, "number", value);
      if (!NumberIsInteger(value)) throw new ERR_OUT_OF_RANGE(name, "an integer", value);
      if (value < min || value > max) throw new ERR_OUT_OF_RANGE(name, `>= ${min} && <= ${max}`, value);
    });
    var validateInt32 = hideStackFrames((value, name, min = -2147483648, max = 2147483647) => {
      if (typeof value !== "number") {
        throw new ERR_INVALID_ARG_TYPE(name, "number", value);
      }
      if (!NumberIsInteger(value)) {
        throw new ERR_OUT_OF_RANGE(name, "an integer", value);
      }
      if (value < min || value > max) {
        throw new ERR_OUT_OF_RANGE(name, `>= ${min} && <= ${max}`, value);
      }
    });
    var validateUint32 = hideStackFrames((value, name, positive = false) => {
      if (typeof value !== "number") {
        throw new ERR_INVALID_ARG_TYPE(name, "number", value);
      }
      if (!NumberIsInteger(value)) {
        throw new ERR_OUT_OF_RANGE(name, "an integer", value);
      }
      const min = positive ? 1 : 0;
      const max = 4294967295;
      if (value < min || value > max) {
        throw new ERR_OUT_OF_RANGE(name, `>= ${min} && <= ${max}`, value);
      }
    });
    function validateString(value, name) {
      if (typeof value !== "string") throw new ERR_INVALID_ARG_TYPE(name, "string", value);
    }
    function validateNumber(value, name, min = void 0, max) {
      if (typeof value !== "number") throw new ERR_INVALID_ARG_TYPE(name, "number", value);
      if (min != null && value < min || max != null && value > max || (min != null || max != null) && NumberIsNaN(value)) {
        throw new ERR_OUT_OF_RANGE(
          name,
          `${min != null ? `>= ${min}` : ""}${min != null && max != null ? " && " : ""}${max != null ? `<= ${max}` : ""}`,
          value
        );
      }
    }
    var validateOneOf = hideStackFrames((value, name, oneOf) => {
      if (!ArrayPrototypeIncludes(oneOf, value)) {
        const allowed = ArrayPrototypeJoin(
          ArrayPrototypeMap(oneOf, (v) => typeof v === "string" ? `'${v}'` : String2(v)),
          ", "
        );
        const reason = "must be one of: " + allowed;
        throw new ERR_INVALID_ARG_VALUE(name, value, reason);
      }
    });
    function validateBoolean(value, name) {
      if (typeof value !== "boolean") throw new ERR_INVALID_ARG_TYPE(name, "boolean", value);
    }
    function getOwnPropertyValueOrDefault(options, key, defaultValue) {
      return options == null || !ObjectPrototypeHasOwnProperty(options, key) ? defaultValue : options[key];
    }
    var validateObject = hideStackFrames((value, name, options = null) => {
      const allowArray = getOwnPropertyValueOrDefault(options, "allowArray", false);
      const allowFunction = getOwnPropertyValueOrDefault(options, "allowFunction", false);
      const nullable2 = getOwnPropertyValueOrDefault(options, "nullable", false);
      if (!nullable2 && value === null || !allowArray && ArrayIsArray(value) || typeof value !== "object" && (!allowFunction || typeof value !== "function")) {
        throw new ERR_INVALID_ARG_TYPE(name, "Object", value);
      }
    });
    var validateDictionary = hideStackFrames((value, name) => {
      if (value != null && typeof value !== "object" && typeof value !== "function") {
        throw new ERR_INVALID_ARG_TYPE(name, "a dictionary", value);
      }
    });
    var validateArray = hideStackFrames((value, name, minLength = 0) => {
      if (!ArrayIsArray(value)) {
        throw new ERR_INVALID_ARG_TYPE(name, "Array", value);
      }
      if (value.length < minLength) {
        const reason = `must be longer than ${minLength}`;
        throw new ERR_INVALID_ARG_VALUE(name, value, reason);
      }
    });
    function validateStringArray(value, name) {
      validateArray(value, name);
      for (let i = 0; i < value.length; i++) {
        validateString(value[i], `${name}[${i}]`);
      }
    }
    function validateBooleanArray(value, name) {
      validateArray(value, name);
      for (let i = 0; i < value.length; i++) {
        validateBoolean(value[i], `${name}[${i}]`);
      }
    }
    function validateAbortSignalArray(value, name) {
      validateArray(value, name);
      for (let i = 0; i < value.length; i++) {
        const signal = value[i];
        const indexedName = `${name}[${i}]`;
        if (signal == null) {
          throw new ERR_INVALID_ARG_TYPE(indexedName, "AbortSignal", signal);
        }
        validateAbortSignal(signal, indexedName);
      }
    }
    function validateSignalName(signal, name = "signal") {
      validateString(signal, name);
      if (signals[signal] === void 0) {
        if (signals[StringPrototypeToUpperCase(signal)] !== void 0) {
          throw new ERR_UNKNOWN_SIGNAL(signal + " (signals must use all capital letters)");
        }
        throw new ERR_UNKNOWN_SIGNAL(signal);
      }
    }
    var validateBuffer = hideStackFrames((buffer, name = "buffer") => {
      if (!isArrayBufferView(buffer)) {
        throw new ERR_INVALID_ARG_TYPE(name, ["Buffer", "TypedArray", "DataView"], buffer);
      }
    });
    function validateEncoding(data, encoding) {
      const normalizedEncoding = normalizeEncoding(encoding);
      const length = data.length;
      if (normalizedEncoding === "hex" && length % 2 !== 0) {
        throw new ERR_INVALID_ARG_VALUE("encoding", encoding, `is invalid for data of length ${length}`);
      }
    }
    function validatePort(port, name = "Port", allowZero = true) {
      if (typeof port !== "number" && typeof port !== "string" || typeof port === "string" && StringPrototypeTrim(port).length === 0 || +port !== +port >>> 0 || port > 65535 || port === 0 && !allowZero) {
        throw new ERR_SOCKET_BAD_PORT(name, port, allowZero);
      }
      return port | 0;
    }
    var validateAbortSignal = hideStackFrames((signal, name) => {
      if (signal !== void 0 && (signal === null || typeof signal !== "object" || !("aborted" in signal))) {
        throw new ERR_INVALID_ARG_TYPE(name, "AbortSignal", signal);
      }
    });
    var validateFunction = hideStackFrames((value, name) => {
      if (typeof value !== "function") throw new ERR_INVALID_ARG_TYPE(name, "Function", value);
    });
    var validatePlainFunction = hideStackFrames((value, name) => {
      if (typeof value !== "function" || isAsyncFunction(value)) throw new ERR_INVALID_ARG_TYPE(name, "Function", value);
    });
    var validateUndefined = hideStackFrames((value, name) => {
      if (value !== void 0) throw new ERR_INVALID_ARG_TYPE(name, "undefined", value);
    });
    function validateUnion(value, name, union2) {
      if (!ArrayPrototypeIncludes(union2, value)) {
        throw new ERR_INVALID_ARG_TYPE(name, `('${ArrayPrototypeJoin(union2, "|")}')`, value);
      }
    }
    var linkValueRegExp = /^(?:<[^>]*>)(?:\s*;\s*[^;"\s]+(?:=(")?[^;"\s]*\1)?)*$/;
    function validateLinkHeaderFormat(value, name) {
      if (typeof value === "undefined" || !RegExpPrototypeExec(linkValueRegExp, value)) {
        throw new ERR_INVALID_ARG_VALUE(
          name,
          value,
          'must be an array or string of format "</styles.css>; rel=preload; as=style"'
        );
      }
    }
    function validateLinkHeaderValue(hints) {
      if (typeof hints === "string") {
        validateLinkHeaderFormat(hints, "hints");
        return hints;
      } else if (ArrayIsArray(hints)) {
        const hintsLength = hints.length;
        let result = "";
        if (hintsLength === 0) {
          return result;
        }
        for (let i = 0; i < hintsLength; i++) {
          const link = hints[i];
          validateLinkHeaderFormat(link, "hints");
          result += link;
          if (i !== hintsLength - 1) {
            result += ", ";
          }
        }
        return result;
      }
      throw new ERR_INVALID_ARG_VALUE(
        "hints",
        hints,
        'must be an array or string of format "</styles.css>; rel=preload; as=style"'
      );
    }
    module.exports = {
      isInt32,
      isUint32,
      parseFileMode,
      validateArray,
      validateStringArray,
      validateBooleanArray,
      validateAbortSignalArray,
      validateBoolean,
      validateBuffer,
      validateDictionary,
      validateEncoding,
      validateFunction,
      validateInt32,
      validateInteger,
      validateNumber,
      validateObject,
      validateOneOf,
      validatePlainFunction,
      validatePort,
      validateSignalName,
      validateString,
      validateUint32,
      validateUndefined,
      validateUnion,
      validateAbortSignal,
      validateLinkHeaderValue
    };
  }
});

// node_modules/process/browser.js
var require_browser2 = __commonJS({
  "node_modules/process/browser.js"(exports, module) {
    var process = module.exports = {};
    var cachedSetTimeout;
    var cachedClearTimeout;
    function defaultSetTimout() {
      throw new Error("setTimeout has not been defined");
    }
    function defaultClearTimeout() {
      throw new Error("clearTimeout has not been defined");
    }
    (function() {
      try {
        if (typeof setTimeout === "function") {
          cachedSetTimeout = setTimeout;
        } else {
          cachedSetTimeout = defaultSetTimout;
        }
      } catch (e) {
        cachedSetTimeout = defaultSetTimout;
      }
      try {
        if (typeof clearTimeout === "function") {
          cachedClearTimeout = clearTimeout;
        } else {
          cachedClearTimeout = defaultClearTimeout;
        }
      } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
      }
    })();
    function runTimeout(fun) {
      if (cachedSetTimeout === setTimeout) {
        return setTimeout(fun, 0);
      }
      if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
      }
      try {
        return cachedSetTimeout(fun, 0);
      } catch (e) {
        try {
          return cachedSetTimeout.call(null, fun, 0);
        } catch (e2) {
          return cachedSetTimeout.call(this, fun, 0);
        }
      }
    }
    function runClearTimeout(marker) {
      if (cachedClearTimeout === clearTimeout) {
        return clearTimeout(marker);
      }
      if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
      }
      try {
        return cachedClearTimeout(marker);
      } catch (e) {
        try {
          return cachedClearTimeout.call(null, marker);
        } catch (e2) {
          return cachedClearTimeout.call(this, marker);
        }
      }
    }
    var queue = [];
    var draining = false;
    var currentQueue;
    var queueIndex = -1;
    function cleanUpNextTick() {
      if (!draining || !currentQueue) {
        return;
      }
      draining = false;
      if (currentQueue.length) {
        queue = currentQueue.concat(queue);
      } else {
        queueIndex = -1;
      }
      if (queue.length) {
        drainQueue();
      }
    }
    function drainQueue() {
      if (draining) {
        return;
      }
      var timeout = runTimeout(cleanUpNextTick);
      draining = true;
      var len = queue.length;
      while (len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
          if (currentQueue) {
            currentQueue[queueIndex].run();
          }
        }
        queueIndex = -1;
        len = queue.length;
      }
      currentQueue = null;
      draining = false;
      runClearTimeout(timeout);
    }
    process.nextTick = function(fun) {
      var args = new Array(arguments.length - 1);
      if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
          args[i - 1] = arguments[i];
        }
      }
      queue.push(new Item(fun, args));
      if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
      }
    };
    function Item(fun, array2) {
      this.fun = fun;
      this.array = array2;
    }
    Item.prototype.run = function() {
      this.fun.apply(null, this.array);
    };
    process.title = "browser";
    process.browser = true;
    process.env = {};
    process.argv = [];
    process.version = "";
    process.versions = {};
    function noop2() {
    }
    process.on = noop2;
    process.addListener = noop2;
    process.once = noop2;
    process.off = noop2;
    process.removeListener = noop2;
    process.removeAllListeners = noop2;
    process.emit = noop2;
    process.prependListener = noop2;
    process.prependOnceListener = noop2;
    process.listeners = function(name) {
      return [];
    };
    process.binding = function(name) {
      throw new Error("process.binding is not supported");
    };
    process.cwd = function() {
      return "/";
    };
    process.chdir = function(dir) {
      throw new Error("process.chdir is not supported");
    };
    process.umask = function() {
      return 0;
    };
  }
});

// node_modules/jsonld-streaming-parser/node_modules/readable-stream/lib/internal/streams/utils.js
var require_utils = __commonJS({
  "node_modules/jsonld-streaming-parser/node_modules/readable-stream/lib/internal/streams/utils.js"(exports, module) {
    "use strict";
    var { SymbolAsyncIterator, SymbolIterator, SymbolFor } = require_primordials();
    var kIsDestroyed = SymbolFor("nodejs.stream.destroyed");
    var kIsErrored = SymbolFor("nodejs.stream.errored");
    var kIsReadable = SymbolFor("nodejs.stream.readable");
    var kIsWritable = SymbolFor("nodejs.stream.writable");
    var kIsDisturbed = SymbolFor("nodejs.stream.disturbed");
    var kIsClosedPromise = SymbolFor("nodejs.webstream.isClosedPromise");
    var kControllerErrorFunction = SymbolFor("nodejs.webstream.controllerErrorFunction");
    function isReadableNodeStream(obj, strict = false) {
      var _obj$_readableState;
      return !!(obj && typeof obj.pipe === "function" && typeof obj.on === "function" && (!strict || typeof obj.pause === "function" && typeof obj.resume === "function") && (!obj._writableState || ((_obj$_readableState = obj._readableState) === null || _obj$_readableState === void 0 ? void 0 : _obj$_readableState.readable) !== false) && // Duplex
      (!obj._writableState || obj._readableState));
    }
    function isWritableNodeStream(obj) {
      var _obj$_writableState;
      return !!(obj && typeof obj.write === "function" && typeof obj.on === "function" && (!obj._readableState || ((_obj$_writableState = obj._writableState) === null || _obj$_writableState === void 0 ? void 0 : _obj$_writableState.writable) !== false));
    }
    function isDuplexNodeStream(obj) {
      return !!(obj && typeof obj.pipe === "function" && obj._readableState && typeof obj.on === "function" && typeof obj.write === "function");
    }
    function isNodeStream(obj) {
      return obj && (obj._readableState || obj._writableState || typeof obj.write === "function" && typeof obj.on === "function" || typeof obj.pipe === "function" && typeof obj.on === "function");
    }
    function isReadableStream(obj) {
      return !!(obj && !isNodeStream(obj) && typeof obj.pipeThrough === "function" && typeof obj.getReader === "function" && typeof obj.cancel === "function");
    }
    function isWritableStream(obj) {
      return !!(obj && !isNodeStream(obj) && typeof obj.getWriter === "function" && typeof obj.abort === "function");
    }
    function isTransformStream(obj) {
      return !!(obj && !isNodeStream(obj) && typeof obj.readable === "object" && typeof obj.writable === "object");
    }
    function isWebStream(obj) {
      return isReadableStream(obj) || isWritableStream(obj) || isTransformStream(obj);
    }
    function isIterable(obj, isAsync) {
      if (obj == null) return false;
      if (isAsync === true) return typeof obj[SymbolAsyncIterator] === "function";
      if (isAsync === false) return typeof obj[SymbolIterator] === "function";
      return typeof obj[SymbolAsyncIterator] === "function" || typeof obj[SymbolIterator] === "function";
    }
    function isDestroyed(stream) {
      if (!isNodeStream(stream)) return null;
      const wState = stream._writableState;
      const rState = stream._readableState;
      const state = wState || rState;
      return !!(stream.destroyed || stream[kIsDestroyed] || state !== null && state !== void 0 && state.destroyed);
    }
    function isWritableEnded(stream) {
      if (!isWritableNodeStream(stream)) return null;
      if (stream.writableEnded === true) return true;
      const wState = stream._writableState;
      if (wState !== null && wState !== void 0 && wState.errored) return false;
      if (typeof (wState === null || wState === void 0 ? void 0 : wState.ended) !== "boolean") return null;
      return wState.ended;
    }
    function isWritableFinished(stream, strict) {
      if (!isWritableNodeStream(stream)) return null;
      if (stream.writableFinished === true) return true;
      const wState = stream._writableState;
      if (wState !== null && wState !== void 0 && wState.errored) return false;
      if (typeof (wState === null || wState === void 0 ? void 0 : wState.finished) !== "boolean") return null;
      return !!(wState.finished || strict === false && wState.ended === true && wState.length === 0);
    }
    function isReadableEnded(stream) {
      if (!isReadableNodeStream(stream)) return null;
      if (stream.readableEnded === true) return true;
      const rState = stream._readableState;
      if (!rState || rState.errored) return false;
      if (typeof (rState === null || rState === void 0 ? void 0 : rState.ended) !== "boolean") return null;
      return rState.ended;
    }
    function isReadableFinished(stream, strict) {
      if (!isReadableNodeStream(stream)) return null;
      const rState = stream._readableState;
      if (rState !== null && rState !== void 0 && rState.errored) return false;
      if (typeof (rState === null || rState === void 0 ? void 0 : rState.endEmitted) !== "boolean") return null;
      return !!(rState.endEmitted || strict === false && rState.ended === true && rState.length === 0);
    }
    function isReadable(stream) {
      if (stream && stream[kIsReadable] != null) return stream[kIsReadable];
      if (typeof (stream === null || stream === void 0 ? void 0 : stream.readable) !== "boolean") return null;
      if (isDestroyed(stream)) return false;
      return isReadableNodeStream(stream) && stream.readable && !isReadableFinished(stream);
    }
    function isWritable(stream) {
      if (stream && stream[kIsWritable] != null) return stream[kIsWritable];
      if (typeof (stream === null || stream === void 0 ? void 0 : stream.writable) !== "boolean") return null;
      if (isDestroyed(stream)) return false;
      return isWritableNodeStream(stream) && stream.writable && !isWritableEnded(stream);
    }
    function isFinished(stream, opts) {
      if (!isNodeStream(stream)) {
        return null;
      }
      if (isDestroyed(stream)) {
        return true;
      }
      if ((opts === null || opts === void 0 ? void 0 : opts.readable) !== false && isReadable(stream)) {
        return false;
      }
      if ((opts === null || opts === void 0 ? void 0 : opts.writable) !== false && isWritable(stream)) {
        return false;
      }
      return true;
    }
    function isWritableErrored(stream) {
      var _stream$_writableStat, _stream$_writableStat2;
      if (!isNodeStream(stream)) {
        return null;
      }
      if (stream.writableErrored) {
        return stream.writableErrored;
      }
      return (_stream$_writableStat = (_stream$_writableStat2 = stream._writableState) === null || _stream$_writableStat2 === void 0 ? void 0 : _stream$_writableStat2.errored) !== null && _stream$_writableStat !== void 0 ? _stream$_writableStat : null;
    }
    function isReadableErrored(stream) {
      var _stream$_readableStat, _stream$_readableStat2;
      if (!isNodeStream(stream)) {
        return null;
      }
      if (stream.readableErrored) {
        return stream.readableErrored;
      }
      return (_stream$_readableStat = (_stream$_readableStat2 = stream._readableState) === null || _stream$_readableStat2 === void 0 ? void 0 : _stream$_readableStat2.errored) !== null && _stream$_readableStat !== void 0 ? _stream$_readableStat : null;
    }
    function isClosed(stream) {
      if (!isNodeStream(stream)) {
        return null;
      }
      if (typeof stream.closed === "boolean") {
        return stream.closed;
      }
      const wState = stream._writableState;
      const rState = stream._readableState;
      if (typeof (wState === null || wState === void 0 ? void 0 : wState.closed) === "boolean" || typeof (rState === null || rState === void 0 ? void 0 : rState.closed) === "boolean") {
        return (wState === null || wState === void 0 ? void 0 : wState.closed) || (rState === null || rState === void 0 ? void 0 : rState.closed);
      }
      if (typeof stream._closed === "boolean" && isOutgoingMessage(stream)) {
        return stream._closed;
      }
      return null;
    }
    function isOutgoingMessage(stream) {
      return typeof stream._closed === "boolean" && typeof stream._defaultKeepAlive === "boolean" && typeof stream._removedConnection === "boolean" && typeof stream._removedContLen === "boolean";
    }
    function isServerResponse(stream) {
      return typeof stream._sent100 === "boolean" && isOutgoingMessage(stream);
    }
    function isServerRequest(stream) {
      var _stream$req;
      return typeof stream._consuming === "boolean" && typeof stream._dumped === "boolean" && ((_stream$req = stream.req) === null || _stream$req === void 0 ? void 0 : _stream$req.upgradeOrConnect) === void 0;
    }
    function willEmitClose(stream) {
      if (!isNodeStream(stream)) return null;
      const wState = stream._writableState;
      const rState = stream._readableState;
      const state = wState || rState;
      return !state && isServerResponse(stream) || !!(state && state.autoDestroy && state.emitClose && state.closed === false);
    }
    function isDisturbed(stream) {
      var _stream$kIsDisturbed;
      return !!(stream && ((_stream$kIsDisturbed = stream[kIsDisturbed]) !== null && _stream$kIsDisturbed !== void 0 ? _stream$kIsDisturbed : stream.readableDidRead || stream.readableAborted));
    }
    function isErrored(stream) {
      var _ref, _ref2, _ref3, _ref4, _ref5, _stream$kIsErrored, _stream$_readableStat3, _stream$_writableStat3, _stream$_readableStat4, _stream$_writableStat4;
      return !!(stream && ((_ref = (_ref2 = (_ref3 = (_ref4 = (_ref5 = (_stream$kIsErrored = stream[kIsErrored]) !== null && _stream$kIsErrored !== void 0 ? _stream$kIsErrored : stream.readableErrored) !== null && _ref5 !== void 0 ? _ref5 : stream.writableErrored) !== null && _ref4 !== void 0 ? _ref4 : (_stream$_readableStat3 = stream._readableState) === null || _stream$_readableStat3 === void 0 ? void 0 : _stream$_readableStat3.errorEmitted) !== null && _ref3 !== void 0 ? _ref3 : (_stream$_writableStat3 = stream._writableState) === null || _stream$_writableStat3 === void 0 ? void 0 : _stream$_writableStat3.errorEmitted) !== null && _ref2 !== void 0 ? _ref2 : (_stream$_readableStat4 = stream._readableState) === null || _stream$_readableStat4 === void 0 ? void 0 : _stream$_readableStat4.errored) !== null && _ref !== void 0 ? _ref : (_stream$_writableStat4 = stream._writableState) === null || _stream$_writableStat4 === void 0 ? void 0 : _stream$_writableStat4.errored));
    }
    module.exports = {
      isDestroyed,
      kIsDestroyed,
      isDisturbed,
      kIsDisturbed,
      isErrored,
      kIsErrored,
      isReadable,
      kIsReadable,
      kIsClosedPromise,
      kControllerErrorFunction,
      kIsWritable,
      isClosed,
      isDuplexNodeStream,
      isFinished,
      isIterable,
      isReadableNodeStream,
      isReadableStream,
      isReadableEnded,
      isReadableFinished,
      isReadableErrored,
      isNodeStream,
      isWebStream,
      isWritable,
      isWritableNodeStream,
      isWritableStream,
      isWritableEnded,
      isWritableFinished,
      isWritableErrored,
      isServerRequest,
      isServerResponse,
      willEmitClose,
      isTransformStream
    };
  }
});

// node_modules/jsonld-streaming-parser/node_modules/readable-stream/lib/internal/streams/end-of-stream.js
var require_end_of_stream = __commonJS({
  "node_modules/jsonld-streaming-parser/node_modules/readable-stream/lib/internal/streams/end-of-stream.js"(exports, module) {
    "use strict";
    var process = require_browser2();
    var { AbortError, codes } = require_errors();
    var { ERR_INVALID_ARG_TYPE, ERR_STREAM_PREMATURE_CLOSE } = codes;
    var { kEmptyObject, once } = require_util();
    var { validateAbortSignal, validateFunction, validateObject, validateBoolean } = require_validators();
    var { Promise: Promise2, PromisePrototypeThen, SymbolDispose } = require_primordials();
    var {
      isClosed,
      isReadable,
      isReadableNodeStream,
      isReadableStream,
      isReadableFinished,
      isReadableErrored,
      isWritable,
      isWritableNodeStream,
      isWritableStream,
      isWritableFinished,
      isWritableErrored,
      isNodeStream,
      willEmitClose: _willEmitClose,
      kIsClosedPromise
    } = require_utils();
    var addAbortListener;
    function isRequest(stream) {
      return stream.setHeader && typeof stream.abort === "function";
    }
    var nop = () => {
    };
    function eos(stream, options, callback) {
      var _options$readable, _options$writable;
      if (arguments.length === 2) {
        callback = options;
        options = kEmptyObject;
      } else if (options == null) {
        options = kEmptyObject;
      } else {
        validateObject(options, "options");
      }
      validateFunction(callback, "callback");
      validateAbortSignal(options.signal, "options.signal");
      callback = once(callback);
      if (isReadableStream(stream) || isWritableStream(stream)) {
        return eosWeb(stream, options, callback);
      }
      if (!isNodeStream(stream)) {
        throw new ERR_INVALID_ARG_TYPE("stream", ["ReadableStream", "WritableStream", "Stream"], stream);
      }
      const readable = (_options$readable = options.readable) !== null && _options$readable !== void 0 ? _options$readable : isReadableNodeStream(stream);
      const writable = (_options$writable = options.writable) !== null && _options$writable !== void 0 ? _options$writable : isWritableNodeStream(stream);
      const wState = stream._writableState;
      const rState = stream._readableState;
      const onlegacyfinish = () => {
        if (!stream.writable) {
          onfinish();
        }
      };
      let willEmitClose = _willEmitClose(stream) && isReadableNodeStream(stream) === readable && isWritableNodeStream(stream) === writable;
      let writableFinished = isWritableFinished(stream, false);
      const onfinish = () => {
        writableFinished = true;
        if (stream.destroyed) {
          willEmitClose = false;
        }
        if (willEmitClose && (!stream.readable || readable)) {
          return;
        }
        if (!readable || readableFinished) {
          callback.call(stream);
        }
      };
      let readableFinished = isReadableFinished(stream, false);
      const onend = () => {
        readableFinished = true;
        if (stream.destroyed) {
          willEmitClose = false;
        }
        if (willEmitClose && (!stream.writable || writable)) {
          return;
        }
        if (!writable || writableFinished) {
          callback.call(stream);
        }
      };
      const onerror = (err) => {
        callback.call(stream, err);
      };
      let closed = isClosed(stream);
      const onclose = () => {
        closed = true;
        const errored = isWritableErrored(stream) || isReadableErrored(stream);
        if (errored && typeof errored !== "boolean") {
          return callback.call(stream, errored);
        }
        if (readable && !readableFinished && isReadableNodeStream(stream, true)) {
          if (!isReadableFinished(stream, false)) return callback.call(stream, new ERR_STREAM_PREMATURE_CLOSE());
        }
        if (writable && !writableFinished) {
          if (!isWritableFinished(stream, false)) return callback.call(stream, new ERR_STREAM_PREMATURE_CLOSE());
        }
        callback.call(stream);
      };
      const onclosed = () => {
        closed = true;
        const errored = isWritableErrored(stream) || isReadableErrored(stream);
        if (errored && typeof errored !== "boolean") {
          return callback.call(stream, errored);
        }
        callback.call(stream);
      };
      const onrequest = () => {
        stream.req.on("finish", onfinish);
      };
      if (isRequest(stream)) {
        stream.on("complete", onfinish);
        if (!willEmitClose) {
          stream.on("abort", onclose);
        }
        if (stream.req) {
          onrequest();
        } else {
          stream.on("request", onrequest);
        }
      } else if (writable && !wState) {
        stream.on("end", onlegacyfinish);
        stream.on("close", onlegacyfinish);
      }
      if (!willEmitClose && typeof stream.aborted === "boolean") {
        stream.on("aborted", onclose);
      }
      stream.on("end", onend);
      stream.on("finish", onfinish);
      if (options.error !== false) {
        stream.on("error", onerror);
      }
      stream.on("close", onclose);
      if (closed) {
        process.nextTick(onclose);
      } else if (wState !== null && wState !== void 0 && wState.errorEmitted || rState !== null && rState !== void 0 && rState.errorEmitted) {
        if (!willEmitClose) {
          process.nextTick(onclosed);
        }
      } else if (!readable && (!willEmitClose || isReadable(stream)) && (writableFinished || isWritable(stream) === false)) {
        process.nextTick(onclosed);
      } else if (!writable && (!willEmitClose || isWritable(stream)) && (readableFinished || isReadable(stream) === false)) {
        process.nextTick(onclosed);
      } else if (rState && stream.req && stream.aborted) {
        process.nextTick(onclosed);
      }
      const cleanup = () => {
        callback = nop;
        stream.removeListener("aborted", onclose);
        stream.removeListener("complete", onfinish);
        stream.removeListener("abort", onclose);
        stream.removeListener("request", onrequest);
        if (stream.req) stream.req.removeListener("finish", onfinish);
        stream.removeListener("end", onlegacyfinish);
        stream.removeListener("close", onlegacyfinish);
        stream.removeListener("finish", onfinish);
        stream.removeListener("end", onend);
        stream.removeListener("error", onerror);
        stream.removeListener("close", onclose);
      };
      if (options.signal && !closed) {
        const abort = () => {
          const endCallback = callback;
          cleanup();
          endCallback.call(
            stream,
            new AbortError(void 0, {
              cause: options.signal.reason
            })
          );
        };
        if (options.signal.aborted) {
          process.nextTick(abort);
        } else {
          addAbortListener = addAbortListener || require_util().addAbortListener;
          const disposable = addAbortListener(options.signal, abort);
          const originalCallback = callback;
          callback = once((...args) => {
            disposable[SymbolDispose]();
            originalCallback.apply(stream, args);
          });
        }
      }
      return cleanup;
    }
    function eosWeb(stream, options, callback) {
      let isAborted = false;
      let abort = nop;
      if (options.signal) {
        abort = () => {
          isAborted = true;
          callback.call(
            stream,
            new AbortError(void 0, {
              cause: options.signal.reason
            })
          );
        };
        if (options.signal.aborted) {
          process.nextTick(abort);
        } else {
          addAbortListener = addAbortListener || require_util().addAbortListener;
          const disposable = addAbortListener(options.signal, abort);
          const originalCallback = callback;
          callback = once((...args) => {
            disposable[SymbolDispose]();
            originalCallback.apply(stream, args);
          });
        }
      }
      const resolverFn = (...args) => {
        if (!isAborted) {
          process.nextTick(() => callback.apply(stream, args));
        }
      };
      PromisePrototypeThen(stream[kIsClosedPromise].promise, resolverFn, resolverFn);
      return nop;
    }
    function finished(stream, opts) {
      var _opts;
      let autoCleanup = false;
      if (opts === null) {
        opts = kEmptyObject;
      }
      if ((_opts = opts) !== null && _opts !== void 0 && _opts.cleanup) {
        validateBoolean(opts.cleanup, "cleanup");
        autoCleanup = opts.cleanup;
      }
      return new Promise2((resolve, reject2) => {
        const cleanup = eos(stream, opts, (err) => {
          if (autoCleanup) {
            cleanup();
          }
          if (err) {
            reject2(err);
          } else {
            resolve();
          }
        });
      });
    }
    module.exports = eos;
    module.exports.finished = finished;
  }
});

// node_modules/jsonld-streaming-parser/node_modules/readable-stream/lib/internal/streams/destroy.js
var require_destroy = __commonJS({
  "node_modules/jsonld-streaming-parser/node_modules/readable-stream/lib/internal/streams/destroy.js"(exports, module) {
    "use strict";
    var process = require_browser2();
    var {
      aggregateTwoErrors,
      codes: { ERR_MULTIPLE_CALLBACK },
      AbortError
    } = require_errors();
    var { Symbol: Symbol2 } = require_primordials();
    var { kIsDestroyed, isDestroyed, isFinished, isServerRequest } = require_utils();
    var kDestroy = Symbol2("kDestroy");
    var kConstruct = Symbol2("kConstruct");
    function checkError(err, w, r) {
      if (err) {
        err.stack;
        if (w && !w.errored) {
          w.errored = err;
        }
        if (r && !r.errored) {
          r.errored = err;
        }
      }
    }
    function destroy(err, cb) {
      const r = this._readableState;
      const w = this._writableState;
      const s = w || r;
      if (w !== null && w !== void 0 && w.destroyed || r !== null && r !== void 0 && r.destroyed) {
        if (typeof cb === "function") {
          cb();
        }
        return this;
      }
      checkError(err, w, r);
      if (w) {
        w.destroyed = true;
      }
      if (r) {
        r.destroyed = true;
      }
      if (!s.constructed) {
        this.once(kDestroy, function(er) {
          _destroy(this, aggregateTwoErrors(er, err), cb);
        });
      } else {
        _destroy(this, err, cb);
      }
      return this;
    }
    function _destroy(self2, err, cb) {
      let called = false;
      function onDestroy(err2) {
        if (called) {
          return;
        }
        called = true;
        const r = self2._readableState;
        const w = self2._writableState;
        checkError(err2, w, r);
        if (w) {
          w.closed = true;
        }
        if (r) {
          r.closed = true;
        }
        if (typeof cb === "function") {
          cb(err2);
        }
        if (err2) {
          process.nextTick(emitErrorCloseNT, self2, err2);
        } else {
          process.nextTick(emitCloseNT, self2);
        }
      }
      try {
        self2._destroy(err || null, onDestroy);
      } catch (err2) {
        onDestroy(err2);
      }
    }
    function emitErrorCloseNT(self2, err) {
      emitErrorNT(self2, err);
      emitCloseNT(self2);
    }
    function emitCloseNT(self2) {
      const r = self2._readableState;
      const w = self2._writableState;
      if (w) {
        w.closeEmitted = true;
      }
      if (r) {
        r.closeEmitted = true;
      }
      if (w !== null && w !== void 0 && w.emitClose || r !== null && r !== void 0 && r.emitClose) {
        self2.emit("close");
      }
    }
    function emitErrorNT(self2, err) {
      const r = self2._readableState;
      const w = self2._writableState;
      if (w !== null && w !== void 0 && w.errorEmitted || r !== null && r !== void 0 && r.errorEmitted) {
        return;
      }
      if (w) {
        w.errorEmitted = true;
      }
      if (r) {
        r.errorEmitted = true;
      }
      self2.emit("error", err);
    }
    function undestroy() {
      const r = this._readableState;
      const w = this._writableState;
      if (r) {
        r.constructed = true;
        r.closed = false;
        r.closeEmitted = false;
        r.destroyed = false;
        r.errored = null;
        r.errorEmitted = false;
        r.reading = false;
        r.ended = r.readable === false;
        r.endEmitted = r.readable === false;
      }
      if (w) {
        w.constructed = true;
        w.destroyed = false;
        w.closed = false;
        w.closeEmitted = false;
        w.errored = null;
        w.errorEmitted = false;
        w.finalCalled = false;
        w.prefinished = false;
        w.ended = w.writable === false;
        w.ending = w.writable === false;
        w.finished = w.writable === false;
      }
    }
    function errorOrDestroy(stream, err, sync) {
      const r = stream._readableState;
      const w = stream._writableState;
      if (w !== null && w !== void 0 && w.destroyed || r !== null && r !== void 0 && r.destroyed) {
        return this;
      }
      if (r !== null && r !== void 0 && r.autoDestroy || w !== null && w !== void 0 && w.autoDestroy)
        stream.destroy(err);
      else if (err) {
        err.stack;
        if (w && !w.errored) {
          w.errored = err;
        }
        if (r && !r.errored) {
          r.errored = err;
        }
        if (sync) {
          process.nextTick(emitErrorNT, stream, err);
        } else {
          emitErrorNT(stream, err);
        }
      }
    }
    function construct(stream, cb) {
      if (typeof stream._construct !== "function") {
        return;
      }
      const r = stream._readableState;
      const w = stream._writableState;
      if (r) {
        r.constructed = false;
      }
      if (w) {
        w.constructed = false;
      }
      stream.once(kConstruct, cb);
      if (stream.listenerCount(kConstruct) > 1) {
        return;
      }
      process.nextTick(constructNT, stream);
    }
    function constructNT(stream) {
      let called = false;
      function onConstruct(err) {
        if (called) {
          errorOrDestroy(stream, err !== null && err !== void 0 ? err : new ERR_MULTIPLE_CALLBACK());
          return;
        }
        called = true;
        const r = stream._readableState;
        const w = stream._writableState;
        const s = w || r;
        if (r) {
          r.constructed = true;
        }
        if (w) {
          w.constructed = true;
        }
        if (s.destroyed) {
          stream.emit(kDestroy, err);
        } else if (err) {
          errorOrDestroy(stream, err, true);
        } else {
          process.nextTick(emitConstructNT, stream);
        }
      }
      try {
        stream._construct((err) => {
          process.nextTick(onConstruct, err);
        });
      } catch (err) {
        process.nextTick(onConstruct, err);
      }
    }
    function emitConstructNT(stream) {
      stream.emit(kConstruct);
    }
    function isRequest(stream) {
      return (stream === null || stream === void 0 ? void 0 : stream.setHeader) && typeof stream.abort === "function";
    }
    function emitCloseLegacy(stream) {
      stream.emit("close");
    }
    function emitErrorCloseLegacy(stream, err) {
      stream.emit("error", err);
      process.nextTick(emitCloseLegacy, stream);
    }
    function destroyer(stream, err) {
      if (!stream || isDestroyed(stream)) {
        return;
      }
      if (!err && !isFinished(stream)) {
        err = new AbortError();
      }
      if (isServerRequest(stream)) {
        stream.socket = null;
        stream.destroy(err);
      } else if (isRequest(stream)) {
        stream.abort();
      } else if (isRequest(stream.req)) {
        stream.req.abort();
      } else if (typeof stream.destroy === "function") {
        stream.destroy(err);
      } else if (typeof stream.close === "function") {
        stream.close();
      } else if (err) {
        process.nextTick(emitErrorCloseLegacy, stream, err);
      } else {
        process.nextTick(emitCloseLegacy, stream);
      }
      if (!stream.destroyed) {
        stream[kIsDestroyed] = true;
      }
    }
    module.exports = {
      construct,
      destroyer,
      destroy,
      undestroy,
      errorOrDestroy
    };
  }
});

// node_modules/jsonld-streaming-parser/node_modules/readable-stream/lib/internal/streams/legacy.js
var require_legacy = __commonJS({
  "node_modules/jsonld-streaming-parser/node_modules/readable-stream/lib/internal/streams/legacy.js"(exports, module) {
    "use strict";
    var { ArrayIsArray, ObjectSetPrototypeOf } = require_primordials();
    var { EventEmitter: EE } = require_events();
    function Stream(opts) {
      EE.call(this, opts);
    }
    ObjectSetPrototypeOf(Stream.prototype, EE.prototype);
    ObjectSetPrototypeOf(Stream, EE);
    Stream.prototype.pipe = function(dest, options) {
      const source = this;
      function ondata(chunk) {
        if (dest.writable && dest.write(chunk) === false && source.pause) {
          source.pause();
        }
      }
      source.on("data", ondata);
      function ondrain() {
        if (source.readable && source.resume) {
          source.resume();
        }
      }
      dest.on("drain", ondrain);
      if (!dest._isStdio && (!options || options.end !== false)) {
        source.on("end", onend);
        source.on("close", onclose);
      }
      let didOnEnd = false;
      function onend() {
        if (didOnEnd) return;
        didOnEnd = true;
        dest.end();
      }
      function onclose() {
        if (didOnEnd) return;
        didOnEnd = true;
        if (typeof dest.destroy === "function") dest.destroy();
      }
      function onerror(er) {
        cleanup();
        if (EE.listenerCount(this, "error") === 0) {
          this.emit("error", er);
        }
      }
      prependListener(source, "error", onerror);
      prependListener(dest, "error", onerror);
      function cleanup() {
        source.removeListener("data", ondata);
        dest.removeListener("drain", ondrain);
        source.removeListener("end", onend);
        source.removeListener("close", onclose);
        source.removeListener("error", onerror);
        dest.removeListener("error", onerror);
        source.removeListener("end", cleanup);
        source.removeListener("close", cleanup);
        dest.removeListener("close", cleanup);
      }
      source.on("end", cleanup);
      source.on("close", cleanup);
      dest.on("close", cleanup);
      dest.emit("pipe", source);
      return dest;
    };
    function prependListener(emitter, event, fn) {
      if (typeof emitter.prependListener === "function") return emitter.prependListener(event, fn);
      if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);
      else if (ArrayIsArray(emitter._events[event])) emitter._events[event].unshift(fn);
      else emitter._events[event] = [fn, emitter._events[event]];
    }
    module.exports = {
      Stream,
      prependListener
    };
  }
});

// node_modules/jsonld-streaming-parser/node_modules/readable-stream/lib/internal/streams/add-abort-signal.js
var require_add_abort_signal = __commonJS({
  "node_modules/jsonld-streaming-parser/node_modules/readable-stream/lib/internal/streams/add-abort-signal.js"(exports, module) {
    "use strict";
    var { SymbolDispose } = require_primordials();
    var { AbortError, codes } = require_errors();
    var { isNodeStream, isWebStream, kControllerErrorFunction } = require_utils();
    var eos = require_end_of_stream();
    var { ERR_INVALID_ARG_TYPE } = codes;
    var addAbortListener;
    var validateAbortSignal = (signal, name) => {
      if (typeof signal !== "object" || !("aborted" in signal)) {
        throw new ERR_INVALID_ARG_TYPE(name, "AbortSignal", signal);
      }
    };
    module.exports.addAbortSignal = function addAbortSignal(signal, stream) {
      validateAbortSignal(signal, "signal");
      if (!isNodeStream(stream) && !isWebStream(stream)) {
        throw new ERR_INVALID_ARG_TYPE("stream", ["ReadableStream", "WritableStream", "Stream"], stream);
      }
      return module.exports.addAbortSignalNoValidate(signal, stream);
    };
    module.exports.addAbortSignalNoValidate = function(signal, stream) {
      if (typeof signal !== "object" || !("aborted" in signal)) {
        return stream;
      }
      const onAbort = isNodeStream(stream) ? () => {
        stream.destroy(
          new AbortError(void 0, {
            cause: signal.reason
          })
        );
      } : () => {
        stream[kControllerErrorFunction](
          new AbortError(void 0, {
            cause: signal.reason
          })
        );
      };
      if (signal.aborted) {
        onAbort();
      } else {
        addAbortListener = addAbortListener || require_util().addAbortListener;
        const disposable = addAbortListener(signal, onAbort);
        eos(stream, disposable[SymbolDispose]);
      }
      return stream;
    };
  }
});

// node_modules/jsonld-streaming-parser/node_modules/readable-stream/lib/internal/streams/buffer_list.js
var require_buffer_list = __commonJS({
  "node_modules/jsonld-streaming-parser/node_modules/readable-stream/lib/internal/streams/buffer_list.js"(exports, module) {
    "use strict";
    var { StringPrototypeSlice, SymbolIterator, TypedArrayPrototypeSet, Uint8Array: Uint8Array2 } = require_primordials();
    var { Buffer: Buffer3 } = require_buffer();
    var { inspect } = require_util();
    module.exports = class BufferList {
      constructor() {
        this.head = null;
        this.tail = null;
        this.length = 0;
      }
      push(v) {
        const entry = {
          data: v,
          next: null
        };
        if (this.length > 0) this.tail.next = entry;
        else this.head = entry;
        this.tail = entry;
        ++this.length;
      }
      unshift(v) {
        const entry = {
          data: v,
          next: this.head
        };
        if (this.length === 0) this.tail = entry;
        this.head = entry;
        ++this.length;
      }
      shift() {
        if (this.length === 0) return;
        const ret = this.head.data;
        if (this.length === 1) this.head = this.tail = null;
        else this.head = this.head.next;
        --this.length;
        return ret;
      }
      clear() {
        this.head = this.tail = null;
        this.length = 0;
      }
      join(s) {
        if (this.length === 0) return "";
        let p = this.head;
        let ret = "" + p.data;
        while ((p = p.next) !== null) ret += s + p.data;
        return ret;
      }
      concat(n) {
        if (this.length === 0) return Buffer3.alloc(0);
        const ret = Buffer3.allocUnsafe(n >>> 0);
        let p = this.head;
        let i = 0;
        while (p) {
          TypedArrayPrototypeSet(ret, p.data, i);
          i += p.data.length;
          p = p.next;
        }
        return ret;
      }
      // Consumes a specified amount of bytes or characters from the buffered data.
      consume(n, hasStrings) {
        const data = this.head.data;
        if (n < data.length) {
          const slice = data.slice(0, n);
          this.head.data = data.slice(n);
          return slice;
        }
        if (n === data.length) {
          return this.shift();
        }
        return hasStrings ? this._getString(n) : this._getBuffer(n);
      }
      first() {
        return this.head.data;
      }
      *[SymbolIterator]() {
        for (let p = this.head; p; p = p.next) {
          yield p.data;
        }
      }
      // Consumes a specified amount of characters from the buffered data.
      _getString(n) {
        let ret = "";
        let p = this.head;
        let c = 0;
        do {
          const str2 = p.data;
          if (n > str2.length) {
            ret += str2;
            n -= str2.length;
          } else {
            if (n === str2.length) {
              ret += str2;
              ++c;
              if (p.next) this.head = p.next;
              else this.head = this.tail = null;
            } else {
              ret += StringPrototypeSlice(str2, 0, n);
              this.head = p;
              p.data = StringPrototypeSlice(str2, n);
            }
            break;
          }
          ++c;
        } while ((p = p.next) !== null);
        this.length -= c;
        return ret;
      }
      // Consumes a specified amount of bytes from the buffered data.
      _getBuffer(n) {
        const ret = Buffer3.allocUnsafe(n);
        const retLen = n;
        let p = this.head;
        let c = 0;
        do {
          const buf = p.data;
          if (n > buf.length) {
            TypedArrayPrototypeSet(ret, buf, retLen - n);
            n -= buf.length;
          } else {
            if (n === buf.length) {
              TypedArrayPrototypeSet(ret, buf, retLen - n);
              ++c;
              if (p.next) this.head = p.next;
              else this.head = this.tail = null;
            } else {
              TypedArrayPrototypeSet(ret, new Uint8Array2(buf.buffer, buf.byteOffset, n), retLen - n);
              this.head = p;
              p.data = buf.slice(n);
            }
            break;
          }
          ++c;
        } while ((p = p.next) !== null);
        this.length -= c;
        return ret;
      }
      // Make sure the linked list only shows the minimal necessary information.
      [Symbol.for("nodejs.util.inspect.custom")](_, options) {
        return inspect(this, {
          ...options,
          // Only inspect one level.
          depth: 0,
          // It should not recurse.
          customInspect: false
        });
      }
    };
  }
});

// node_modules/jsonld-streaming-parser/node_modules/readable-stream/lib/internal/streams/state.js
var require_state = __commonJS({
  "node_modules/jsonld-streaming-parser/node_modules/readable-stream/lib/internal/streams/state.js"(exports, module) {
    "use strict";
    var { MathFloor, NumberIsInteger } = require_primordials();
    var { validateInteger } = require_validators();
    var { ERR_INVALID_ARG_VALUE } = require_errors().codes;
    var defaultHighWaterMarkBytes = 16 * 1024;
    var defaultHighWaterMarkObjectMode = 16;
    function highWaterMarkFrom(options, isDuplex, duplexKey) {
      return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;
    }
    function getDefaultHighWaterMark(objectMode) {
      return objectMode ? defaultHighWaterMarkObjectMode : defaultHighWaterMarkBytes;
    }
    function setDefaultHighWaterMark(objectMode, value) {
      validateInteger(value, "value", 0);
      if (objectMode) {
        defaultHighWaterMarkObjectMode = value;
      } else {
        defaultHighWaterMarkBytes = value;
      }
    }
    function getHighWaterMark(state, options, duplexKey, isDuplex) {
      const hwm = highWaterMarkFrom(options, isDuplex, duplexKey);
      if (hwm != null) {
        if (!NumberIsInteger(hwm) || hwm < 0) {
          const name = isDuplex ? `options.${duplexKey}` : "options.highWaterMark";
          throw new ERR_INVALID_ARG_VALUE(name, hwm);
        }
        return MathFloor(hwm);
      }
      return getDefaultHighWaterMark(state.objectMode);
    }
    module.exports = {
      getHighWaterMark,
      getDefaultHighWaterMark,
      setDefaultHighWaterMark
    };
  }
});

// node_modules/safe-buffer/index.js
var require_safe_buffer = __commonJS({
  "node_modules/safe-buffer/index.js"(exports, module) {
    var buffer = require_buffer();
    var Buffer3 = buffer.Buffer;
    function copyProps(src, dst) {
      for (var key in src) {
        dst[key] = src[key];
      }
    }
    if (Buffer3.from && Buffer3.alloc && Buffer3.allocUnsafe && Buffer3.allocUnsafeSlow) {
      module.exports = buffer;
    } else {
      copyProps(buffer, exports);
      exports.Buffer = SafeBuffer;
    }
    function SafeBuffer(arg, encodingOrOffset, length) {
      return Buffer3(arg, encodingOrOffset, length);
    }
    SafeBuffer.prototype = Object.create(Buffer3.prototype);
    copyProps(Buffer3, SafeBuffer);
    SafeBuffer.from = function(arg, encodingOrOffset, length) {
      if (typeof arg === "number") {
        throw new TypeError("Argument must not be a number");
      }
      return Buffer3(arg, encodingOrOffset, length);
    };
    SafeBuffer.alloc = function(size, fill, encoding) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      var buf = Buffer3(size);
      if (fill !== void 0) {
        if (typeof encoding === "string") {
          buf.fill(fill, encoding);
        } else {
          buf.fill(fill);
        }
      } else {
        buf.fill(0);
      }
      return buf;
    };
    SafeBuffer.allocUnsafe = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return Buffer3(size);
    };
    SafeBuffer.allocUnsafeSlow = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return buffer.SlowBuffer(size);
    };
  }
});

// node_modules/jsonld-streaming-parser/node_modules/string_decoder/lib/string_decoder.js
var require_string_decoder = __commonJS({
  "node_modules/jsonld-streaming-parser/node_modules/string_decoder/lib/string_decoder.js"(exports) {
    "use strict";
    var Buffer3 = require_safe_buffer().Buffer;
    var isEncoding = Buffer3.isEncoding || function(encoding) {
      encoding = "" + encoding;
      switch (encoding && encoding.toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
        case "raw":
          return true;
        default:
          return false;
      }
    };
    function _normalizeEncoding(enc) {
      if (!enc) return "utf8";
      var retried;
      while (true) {
        switch (enc) {
          case "utf8":
          case "utf-8":
            return "utf8";
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return "utf16le";
          case "latin1":
          case "binary":
            return "latin1";
          case "base64":
          case "ascii":
          case "hex":
            return enc;
          default:
            if (retried) return;
            enc = ("" + enc).toLowerCase();
            retried = true;
        }
      }
    }
    function normalizeEncoding(enc) {
      var nenc = _normalizeEncoding(enc);
      if (typeof nenc !== "string" && (Buffer3.isEncoding === isEncoding || !isEncoding(enc))) throw new Error("Unknown encoding: " + enc);
      return nenc || enc;
    }
    exports.StringDecoder = StringDecoder;
    function StringDecoder(encoding) {
      this.encoding = normalizeEncoding(encoding);
      var nb;
      switch (this.encoding) {
        case "utf16le":
          this.text = utf16Text;
          this.end = utf16End;
          nb = 4;
          break;
        case "utf8":
          this.fillLast = utf8FillLast;
          nb = 4;
          break;
        case "base64":
          this.text = base64Text;
          this.end = base64End;
          nb = 3;
          break;
        default:
          this.write = simpleWrite;
          this.end = simpleEnd;
          return;
      }
      this.lastNeed = 0;
      this.lastTotal = 0;
      this.lastChar = Buffer3.allocUnsafe(nb);
    }
    StringDecoder.prototype.write = function(buf) {
      if (buf.length === 0) return "";
      var r;
      var i;
      if (this.lastNeed) {
        r = this.fillLast(buf);
        if (r === void 0) return "";
        i = this.lastNeed;
        this.lastNeed = 0;
      } else {
        i = 0;
      }
      if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);
      return r || "";
    };
    StringDecoder.prototype.end = utf8End;
    StringDecoder.prototype.text = utf8Text;
    StringDecoder.prototype.fillLast = function(buf) {
      if (this.lastNeed <= buf.length) {
        buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
        return this.lastChar.toString(this.encoding, 0, this.lastTotal);
      }
      buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
      this.lastNeed -= buf.length;
    };
    function utf8CheckByte(byte) {
      if (byte <= 127) return 0;
      else if (byte >> 5 === 6) return 2;
      else if (byte >> 4 === 14) return 3;
      else if (byte >> 3 === 30) return 4;
      return byte >> 6 === 2 ? -1 : -2;
    }
    function utf8CheckIncomplete(self2, buf, i) {
      var j = buf.length - 1;
      if (j < i) return 0;
      var nb = utf8CheckByte(buf[j]);
      if (nb >= 0) {
        if (nb > 0) self2.lastNeed = nb - 1;
        return nb;
      }
      if (--j < i || nb === -2) return 0;
      nb = utf8CheckByte(buf[j]);
      if (nb >= 0) {
        if (nb > 0) self2.lastNeed = nb - 2;
        return nb;
      }
      if (--j < i || nb === -2) return 0;
      nb = utf8CheckByte(buf[j]);
      if (nb >= 0) {
        if (nb > 0) {
          if (nb === 2) nb = 0;
          else self2.lastNeed = nb - 3;
        }
        return nb;
      }
      return 0;
    }
    function utf8CheckExtraBytes(self2, buf, p) {
      if ((buf[0] & 192) !== 128) {
        self2.lastNeed = 0;
        return "\uFFFD";
      }
      if (self2.lastNeed > 1 && buf.length > 1) {
        if ((buf[1] & 192) !== 128) {
          self2.lastNeed = 1;
          return "\uFFFD";
        }
        if (self2.lastNeed > 2 && buf.length > 2) {
          if ((buf[2] & 192) !== 128) {
            self2.lastNeed = 2;
            return "\uFFFD";
          }
        }
      }
    }
    function utf8FillLast(buf) {
      var p = this.lastTotal - this.lastNeed;
      var r = utf8CheckExtraBytes(this, buf, p);
      if (r !== void 0) return r;
      if (this.lastNeed <= buf.length) {
        buf.copy(this.lastChar, p, 0, this.lastNeed);
        return this.lastChar.toString(this.encoding, 0, this.lastTotal);
      }
      buf.copy(this.lastChar, p, 0, buf.length);
      this.lastNeed -= buf.length;
    }
    function utf8Text(buf, i) {
      var total = utf8CheckIncomplete(this, buf, i);
      if (!this.lastNeed) return buf.toString("utf8", i);
      this.lastTotal = total;
      var end = buf.length - (total - this.lastNeed);
      buf.copy(this.lastChar, 0, end);
      return buf.toString("utf8", i, end);
    }
    function utf8End(buf) {
      var r = buf && buf.length ? this.write(buf) : "";
      if (this.lastNeed) return r + "\uFFFD";
      return r;
    }
    function utf16Text(buf, i) {
      if ((buf.length - i) % 2 === 0) {
        var r = buf.toString("utf16le", i);
        if (r) {
          var c = r.charCodeAt(r.length - 1);
          if (c >= 55296 && c <= 56319) {
            this.lastNeed = 2;
            this.lastTotal = 4;
            this.lastChar[0] = buf[buf.length - 2];
            this.lastChar[1] = buf[buf.length - 1];
            return r.slice(0, -1);
          }
        }
        return r;
      }
      this.lastNeed = 1;
      this.lastTotal = 2;
      this.lastChar[0] = buf[buf.length - 1];
      return buf.toString("utf16le", i, buf.length - 1);
    }
    function utf16End(buf) {
      var r = buf && buf.length ? this.write(buf) : "";
      if (this.lastNeed) {
        var end = this.lastTotal - this.lastNeed;
        return r + this.lastChar.toString("utf16le", 0, end);
      }
      return r;
    }
    function base64Text(buf, i) {
      var n = (buf.length - i) % 3;
      if (n === 0) return buf.toString("base64", i);
      this.lastNeed = 3 - n;
      this.lastTotal = 3;
      if (n === 1) {
        this.lastChar[0] = buf[buf.length - 1];
      } else {
        this.lastChar[0] = buf[buf.length - 2];
        this.lastChar[1] = buf[buf.length - 1];
      }
      return buf.toString("base64", i, buf.length - n);
    }
    function base64End(buf) {
      var r = buf && buf.length ? this.write(buf) : "";
      if (this.lastNeed) return r + this.lastChar.toString("base64", 0, 3 - this.lastNeed);
      return r;
    }
    function simpleWrite(buf) {
      return buf.toString(this.encoding);
    }
    function simpleEnd(buf) {
      return buf && buf.length ? this.write(buf) : "";
    }
  }
});

// node_modules/jsonld-streaming-parser/node_modules/readable-stream/lib/internal/streams/from.js
var require_from = __commonJS({
  "node_modules/jsonld-streaming-parser/node_modules/readable-stream/lib/internal/streams/from.js"(exports, module) {
    "use strict";
    var process = require_browser2();
    var { PromisePrototypeThen, SymbolAsyncIterator, SymbolIterator } = require_primordials();
    var { Buffer: Buffer3 } = require_buffer();
    var { ERR_INVALID_ARG_TYPE, ERR_STREAM_NULL_VALUES } = require_errors().codes;
    function from(Readable2, iterable, opts) {
      let iterator;
      if (typeof iterable === "string" || iterable instanceof Buffer3) {
        return new Readable2({
          objectMode: true,
          ...opts,
          read() {
            this.push(iterable);
            this.push(null);
          }
        });
      }
      let isAsync;
      if (iterable && iterable[SymbolAsyncIterator]) {
        isAsync = true;
        iterator = iterable[SymbolAsyncIterator]();
      } else if (iterable && iterable[SymbolIterator]) {
        isAsync = false;
        iterator = iterable[SymbolIterator]();
      } else {
        throw new ERR_INVALID_ARG_TYPE("iterable", ["Iterable"], iterable);
      }
      const readable = new Readable2({
        objectMode: true,
        highWaterMark: 1,
        // TODO(ronag): What options should be allowed?
        ...opts
      });
      let reading = false;
      readable._read = function() {
        if (!reading) {
          reading = true;
          next();
        }
      };
      readable._destroy = function(error46, cb) {
        PromisePrototypeThen(
          close(error46),
          () => process.nextTick(cb, error46),
          // nextTick is here in case cb throws
          (e) => process.nextTick(cb, e || error46)
        );
      };
      async function close(error46) {
        const hadError = error46 !== void 0 && error46 !== null;
        const hasThrow = typeof iterator.throw === "function";
        if (hadError && hasThrow) {
          const { value, done } = await iterator.throw(error46);
          await value;
          if (done) {
            return;
          }
        }
        if (typeof iterator.return === "function") {
          const { value } = await iterator.return();
          await value;
        }
      }
      async function next() {
        for (; ; ) {
          try {
            const { value, done } = isAsync ? await iterator.next() : iterator.next();
            if (done) {
              readable.push(null);
            } else {
              const res = value && typeof value.then === "function" ? await value : value;
              if (res === null) {
                reading = false;
                throw new ERR_STREAM_NULL_VALUES();
              } else if (readable.push(res)) {
                continue;
              } else {
                reading = false;
              }
            }
          } catch (err) {
            readable.destroy(err);
          }
          break;
        }
      }
      return readable;
    }
    module.exports = from;
  }
});

// node_modules/jsonld-streaming-parser/node_modules/readable-stream/lib/internal/streams/readable.js
var require_readable = __commonJS({
  "node_modules/jsonld-streaming-parser/node_modules/readable-stream/lib/internal/streams/readable.js"(exports, module) {
    "use strict";
    var process = require_browser2();
    var {
      ArrayPrototypeIndexOf,
      NumberIsInteger,
      NumberIsNaN,
      NumberParseInt,
      ObjectDefineProperties,
      ObjectKeys,
      ObjectSetPrototypeOf,
      Promise: Promise2,
      SafeSet,
      SymbolAsyncDispose,
      SymbolAsyncIterator,
      Symbol: Symbol2
    } = require_primordials();
    module.exports = Readable2;
    Readable2.ReadableState = ReadableState;
    var { EventEmitter: EE } = require_events();
    var { Stream, prependListener } = require_legacy();
    var { Buffer: Buffer3 } = require_buffer();
    var { addAbortSignal } = require_add_abort_signal();
    var eos = require_end_of_stream();
    var debug = require_util().debuglog("stream", (fn) => {
      debug = fn;
    });
    var BufferList = require_buffer_list();
    var destroyImpl = require_destroy();
    var { getHighWaterMark, getDefaultHighWaterMark } = require_state();
    var {
      aggregateTwoErrors,
      codes: {
        ERR_INVALID_ARG_TYPE,
        ERR_METHOD_NOT_IMPLEMENTED,
        ERR_OUT_OF_RANGE,
        ERR_STREAM_PUSH_AFTER_EOF,
        ERR_STREAM_UNSHIFT_AFTER_END_EVENT
      },
      AbortError
    } = require_errors();
    var { validateObject } = require_validators();
    var kPaused = Symbol2("kPaused");
    var { StringDecoder } = require_string_decoder();
    var from = require_from();
    ObjectSetPrototypeOf(Readable2.prototype, Stream.prototype);
    ObjectSetPrototypeOf(Readable2, Stream);
    var nop = () => {
    };
    var { errorOrDestroy } = destroyImpl;
    var kObjectMode = 1 << 0;
    var kEnded = 1 << 1;
    var kEndEmitted = 1 << 2;
    var kReading = 1 << 3;
    var kConstructed = 1 << 4;
    var kSync = 1 << 5;
    var kNeedReadable = 1 << 6;
    var kEmittedReadable = 1 << 7;
    var kReadableListening = 1 << 8;
    var kResumeScheduled = 1 << 9;
    var kErrorEmitted = 1 << 10;
    var kEmitClose = 1 << 11;
    var kAutoDestroy = 1 << 12;
    var kDestroyed = 1 << 13;
    var kClosed = 1 << 14;
    var kCloseEmitted = 1 << 15;
    var kMultiAwaitDrain = 1 << 16;
    var kReadingMore = 1 << 17;
    var kDataEmitted = 1 << 18;
    function makeBitMapDescriptor(bit) {
      return {
        enumerable: false,
        get() {
          return (this.state & bit) !== 0;
        },
        set(value) {
          if (value) this.state |= bit;
          else this.state &= ~bit;
        }
      };
    }
    ObjectDefineProperties(ReadableState.prototype, {
      objectMode: makeBitMapDescriptor(kObjectMode),
      ended: makeBitMapDescriptor(kEnded),
      endEmitted: makeBitMapDescriptor(kEndEmitted),
      reading: makeBitMapDescriptor(kReading),
      // Stream is still being constructed and cannot be
      // destroyed until construction finished or failed.
      // Async construction is opt in, therefore we start as
      // constructed.
      constructed: makeBitMapDescriptor(kConstructed),
      // A flag to be able to tell if the event 'readable'/'data' is emitted
      // immediately, or on a later tick.  We set this to true at first, because
      // any actions that shouldn't happen until "later" should generally also
      // not happen before the first read call.
      sync: makeBitMapDescriptor(kSync),
      // Whenever we return null, then we set a flag to say
      // that we're awaiting a 'readable' event emission.
      needReadable: makeBitMapDescriptor(kNeedReadable),
      emittedReadable: makeBitMapDescriptor(kEmittedReadable),
      readableListening: makeBitMapDescriptor(kReadableListening),
      resumeScheduled: makeBitMapDescriptor(kResumeScheduled),
      // True if the error was already emitted and should not be thrown again.
      errorEmitted: makeBitMapDescriptor(kErrorEmitted),
      emitClose: makeBitMapDescriptor(kEmitClose),
      autoDestroy: makeBitMapDescriptor(kAutoDestroy),
      // Has it been destroyed.
      destroyed: makeBitMapDescriptor(kDestroyed),
      // Indicates whether the stream has finished destroying.
      closed: makeBitMapDescriptor(kClosed),
      // True if close has been emitted or would have been emitted
      // depending on emitClose.
      closeEmitted: makeBitMapDescriptor(kCloseEmitted),
      multiAwaitDrain: makeBitMapDescriptor(kMultiAwaitDrain),
      // If true, a maybeReadMore has been scheduled.
      readingMore: makeBitMapDescriptor(kReadingMore),
      dataEmitted: makeBitMapDescriptor(kDataEmitted)
    });
    function ReadableState(options, stream, isDuplex) {
      if (typeof isDuplex !== "boolean") isDuplex = stream instanceof require_duplex();
      this.state = kEmitClose | kAutoDestroy | kConstructed | kSync;
      if (options && options.objectMode) this.state |= kObjectMode;
      if (isDuplex && options && options.readableObjectMode) this.state |= kObjectMode;
      this.highWaterMark = options ? getHighWaterMark(this, options, "readableHighWaterMark", isDuplex) : getDefaultHighWaterMark(false);
      this.buffer = new BufferList();
      this.length = 0;
      this.pipes = [];
      this.flowing = null;
      this[kPaused] = null;
      if (options && options.emitClose === false) this.state &= ~kEmitClose;
      if (options && options.autoDestroy === false) this.state &= ~kAutoDestroy;
      this.errored = null;
      this.defaultEncoding = options && options.defaultEncoding || "utf8";
      this.awaitDrainWriters = null;
      this.decoder = null;
      this.encoding = null;
      if (options && options.encoding) {
        this.decoder = new StringDecoder(options.encoding);
        this.encoding = options.encoding;
      }
    }
    function Readable2(options) {
      if (!(this instanceof Readable2)) return new Readable2(options);
      const isDuplex = this instanceof require_duplex();
      this._readableState = new ReadableState(options, this, isDuplex);
      if (options) {
        if (typeof options.read === "function") this._read = options.read;
        if (typeof options.destroy === "function") this._destroy = options.destroy;
        if (typeof options.construct === "function") this._construct = options.construct;
        if (options.signal && !isDuplex) addAbortSignal(options.signal, this);
      }
      Stream.call(this, options);
      destroyImpl.construct(this, () => {
        if (this._readableState.needReadable) {
          maybeReadMore(this, this._readableState);
        }
      });
    }
    Readable2.prototype.destroy = destroyImpl.destroy;
    Readable2.prototype._undestroy = destroyImpl.undestroy;
    Readable2.prototype._destroy = function(err, cb) {
      cb(err);
    };
    Readable2.prototype[EE.captureRejectionSymbol] = function(err) {
      this.destroy(err);
    };
    Readable2.prototype[SymbolAsyncDispose] = function() {
      let error46;
      if (!this.destroyed) {
        error46 = this.readableEnded ? null : new AbortError();
        this.destroy(error46);
      }
      return new Promise2((resolve, reject2) => eos(this, (err) => err && err !== error46 ? reject2(err) : resolve(null)));
    };
    Readable2.prototype.push = function(chunk, encoding) {
      return readableAddChunk(this, chunk, encoding, false);
    };
    Readable2.prototype.unshift = function(chunk, encoding) {
      return readableAddChunk(this, chunk, encoding, true);
    };
    function readableAddChunk(stream, chunk, encoding, addToFront) {
      debug("readableAddChunk", chunk);
      const state = stream._readableState;
      let err;
      if ((state.state & kObjectMode) === 0) {
        if (typeof chunk === "string") {
          encoding = encoding || state.defaultEncoding;
          if (state.encoding !== encoding) {
            if (addToFront && state.encoding) {
              chunk = Buffer3.from(chunk, encoding).toString(state.encoding);
            } else {
              chunk = Buffer3.from(chunk, encoding);
              encoding = "";
            }
          }
        } else if (chunk instanceof Buffer3) {
          encoding = "";
        } else if (Stream._isUint8Array(chunk)) {
          chunk = Stream._uint8ArrayToBuffer(chunk);
          encoding = "";
        } else if (chunk != null) {
          err = new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer", "Uint8Array"], chunk);
        }
      }
      if (err) {
        errorOrDestroy(stream, err);
      } else if (chunk === null) {
        state.state &= ~kReading;
        onEofChunk(stream, state);
      } else if ((state.state & kObjectMode) !== 0 || chunk && chunk.length > 0) {
        if (addToFront) {
          if ((state.state & kEndEmitted) !== 0) errorOrDestroy(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());
          else if (state.destroyed || state.errored) return false;
          else addChunk(stream, state, chunk, true);
        } else if (state.ended) {
          errorOrDestroy(stream, new ERR_STREAM_PUSH_AFTER_EOF());
        } else if (state.destroyed || state.errored) {
          return false;
        } else {
          state.state &= ~kReading;
          if (state.decoder && !encoding) {
            chunk = state.decoder.write(chunk);
            if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);
            else maybeReadMore(stream, state);
          } else {
            addChunk(stream, state, chunk, false);
          }
        }
      } else if (!addToFront) {
        state.state &= ~kReading;
        maybeReadMore(stream, state);
      }
      return !state.ended && (state.length < state.highWaterMark || state.length === 0);
    }
    function addChunk(stream, state, chunk, addToFront) {
      if (state.flowing && state.length === 0 && !state.sync && stream.listenerCount("data") > 0) {
        if ((state.state & kMultiAwaitDrain) !== 0) {
          state.awaitDrainWriters.clear();
        } else {
          state.awaitDrainWriters = null;
        }
        state.dataEmitted = true;
        stream.emit("data", chunk);
      } else {
        state.length += state.objectMode ? 1 : chunk.length;
        if (addToFront) state.buffer.unshift(chunk);
        else state.buffer.push(chunk);
        if ((state.state & kNeedReadable) !== 0) emitReadable(stream);
      }
      maybeReadMore(stream, state);
    }
    Readable2.prototype.isPaused = function() {
      const state = this._readableState;
      return state[kPaused] === true || state.flowing === false;
    };
    Readable2.prototype.setEncoding = function(enc) {
      const decoder2 = new StringDecoder(enc);
      this._readableState.decoder = decoder2;
      this._readableState.encoding = this._readableState.decoder.encoding;
      const buffer = this._readableState.buffer;
      let content = "";
      for (const data of buffer) {
        content += decoder2.write(data);
      }
      buffer.clear();
      if (content !== "") buffer.push(content);
      this._readableState.length = content.length;
      return this;
    };
    var MAX_HWM = 1073741824;
    function computeNewHighWaterMark(n) {
      if (n > MAX_HWM) {
        throw new ERR_OUT_OF_RANGE("size", "<= 1GiB", n);
      } else {
        n--;
        n |= n >>> 1;
        n |= n >>> 2;
        n |= n >>> 4;
        n |= n >>> 8;
        n |= n >>> 16;
        n++;
      }
      return n;
    }
    function howMuchToRead(n, state) {
      if (n <= 0 || state.length === 0 && state.ended) return 0;
      if ((state.state & kObjectMode) !== 0) return 1;
      if (NumberIsNaN(n)) {
        if (state.flowing && state.length) return state.buffer.first().length;
        return state.length;
      }
      if (n <= state.length) return n;
      return state.ended ? state.length : 0;
    }
    Readable2.prototype.read = function(n) {
      debug("read", n);
      if (n === void 0) {
        n = NaN;
      } else if (!NumberIsInteger(n)) {
        n = NumberParseInt(n, 10);
      }
      const state = this._readableState;
      const nOrig = n;
      if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);
      if (n !== 0) state.state &= ~kEmittedReadable;
      if (n === 0 && state.needReadable && ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)) {
        debug("read: emitReadable", state.length, state.ended);
        if (state.length === 0 && state.ended) endReadable(this);
        else emitReadable(this);
        return null;
      }
      n = howMuchToRead(n, state);
      if (n === 0 && state.ended) {
        if (state.length === 0) endReadable(this);
        return null;
      }
      let doRead = (state.state & kNeedReadable) !== 0;
      debug("need readable", doRead);
      if (state.length === 0 || state.length - n < state.highWaterMark) {
        doRead = true;
        debug("length less than watermark", doRead);
      }
      if (state.ended || state.reading || state.destroyed || state.errored || !state.constructed) {
        doRead = false;
        debug("reading, ended or constructing", doRead);
      } else if (doRead) {
        debug("do read");
        state.state |= kReading | kSync;
        if (state.length === 0) state.state |= kNeedReadable;
        try {
          this._read(state.highWaterMark);
        } catch (err) {
          errorOrDestroy(this, err);
        }
        state.state &= ~kSync;
        if (!state.reading) n = howMuchToRead(nOrig, state);
      }
      let ret;
      if (n > 0) ret = fromList(n, state);
      else ret = null;
      if (ret === null) {
        state.needReadable = state.length <= state.highWaterMark;
        n = 0;
      } else {
        state.length -= n;
        if (state.multiAwaitDrain) {
          state.awaitDrainWriters.clear();
        } else {
          state.awaitDrainWriters = null;
        }
      }
      if (state.length === 0) {
        if (!state.ended) state.needReadable = true;
        if (nOrig !== n && state.ended) endReadable(this);
      }
      if (ret !== null && !state.errorEmitted && !state.closeEmitted) {
        state.dataEmitted = true;
        this.emit("data", ret);
      }
      return ret;
    };
    function onEofChunk(stream, state) {
      debug("onEofChunk");
      if (state.ended) return;
      if (state.decoder) {
        const chunk = state.decoder.end();
        if (chunk && chunk.length) {
          state.buffer.push(chunk);
          state.length += state.objectMode ? 1 : chunk.length;
        }
      }
      state.ended = true;
      if (state.sync) {
        emitReadable(stream);
      } else {
        state.needReadable = false;
        state.emittedReadable = true;
        emitReadable_(stream);
      }
    }
    function emitReadable(stream) {
      const state = stream._readableState;
      debug("emitReadable", state.needReadable, state.emittedReadable);
      state.needReadable = false;
      if (!state.emittedReadable) {
        debug("emitReadable", state.flowing);
        state.emittedReadable = true;
        process.nextTick(emitReadable_, stream);
      }
    }
    function emitReadable_(stream) {
      const state = stream._readableState;
      debug("emitReadable_", state.destroyed, state.length, state.ended);
      if (!state.destroyed && !state.errored && (state.length || state.ended)) {
        stream.emit("readable");
        state.emittedReadable = false;
      }
      state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark;
      flow(stream);
    }
    function maybeReadMore(stream, state) {
      if (!state.readingMore && state.constructed) {
        state.readingMore = true;
        process.nextTick(maybeReadMore_, stream, state);
      }
    }
    function maybeReadMore_(stream, state) {
      while (!state.reading && !state.ended && (state.length < state.highWaterMark || state.flowing && state.length === 0)) {
        const len = state.length;
        debug("maybeReadMore read 0");
        stream.read(0);
        if (len === state.length)
          break;
      }
      state.readingMore = false;
    }
    Readable2.prototype._read = function(n) {
      throw new ERR_METHOD_NOT_IMPLEMENTED("_read()");
    };
    Readable2.prototype.pipe = function(dest, pipeOpts) {
      const src = this;
      const state = this._readableState;
      if (state.pipes.length === 1) {
        if (!state.multiAwaitDrain) {
          state.multiAwaitDrain = true;
          state.awaitDrainWriters = new SafeSet(state.awaitDrainWriters ? [state.awaitDrainWriters] : []);
        }
      }
      state.pipes.push(dest);
      debug("pipe count=%d opts=%j", state.pipes.length, pipeOpts);
      const doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
      const endFn = doEnd ? onend : unpipe;
      if (state.endEmitted) process.nextTick(endFn);
      else src.once("end", endFn);
      dest.on("unpipe", onunpipe);
      function onunpipe(readable, unpipeInfo) {
        debug("onunpipe");
        if (readable === src) {
          if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
            unpipeInfo.hasUnpiped = true;
            cleanup();
          }
        }
      }
      function onend() {
        debug("onend");
        dest.end();
      }
      let ondrain;
      let cleanedUp = false;
      function cleanup() {
        debug("cleanup");
        dest.removeListener("close", onclose);
        dest.removeListener("finish", onfinish);
        if (ondrain) {
          dest.removeListener("drain", ondrain);
        }
        dest.removeListener("error", onerror);
        dest.removeListener("unpipe", onunpipe);
        src.removeListener("end", onend);
        src.removeListener("end", unpipe);
        src.removeListener("data", ondata);
        cleanedUp = true;
        if (ondrain && state.awaitDrainWriters && (!dest._writableState || dest._writableState.needDrain)) ondrain();
      }
      function pause() {
        if (!cleanedUp) {
          if (state.pipes.length === 1 && state.pipes[0] === dest) {
            debug("false write response, pause", 0);
            state.awaitDrainWriters = dest;
            state.multiAwaitDrain = false;
          } else if (state.pipes.length > 1 && state.pipes.includes(dest)) {
            debug("false write response, pause", state.awaitDrainWriters.size);
            state.awaitDrainWriters.add(dest);
          }
          src.pause();
        }
        if (!ondrain) {
          ondrain = pipeOnDrain(src, dest);
          dest.on("drain", ondrain);
        }
      }
      src.on("data", ondata);
      function ondata(chunk) {
        debug("ondata");
        const ret = dest.write(chunk);
        debug("dest.write", ret);
        if (ret === false) {
          pause();
        }
      }
      function onerror(er) {
        debug("onerror", er);
        unpipe();
        dest.removeListener("error", onerror);
        if (dest.listenerCount("error") === 0) {
          const s = dest._writableState || dest._readableState;
          if (s && !s.errorEmitted) {
            errorOrDestroy(dest, er);
          } else {
            dest.emit("error", er);
          }
        }
      }
      prependListener(dest, "error", onerror);
      function onclose() {
        dest.removeListener("finish", onfinish);
        unpipe();
      }
      dest.once("close", onclose);
      function onfinish() {
        debug("onfinish");
        dest.removeListener("close", onclose);
        unpipe();
      }
      dest.once("finish", onfinish);
      function unpipe() {
        debug("unpipe");
        src.unpipe(dest);
      }
      dest.emit("pipe", src);
      if (dest.writableNeedDrain === true) {
        pause();
      } else if (!state.flowing) {
        debug("pipe resume");
        src.resume();
      }
      return dest;
    };
    function pipeOnDrain(src, dest) {
      return function pipeOnDrainFunctionResult() {
        const state = src._readableState;
        if (state.awaitDrainWriters === dest) {
          debug("pipeOnDrain", 1);
          state.awaitDrainWriters = null;
        } else if (state.multiAwaitDrain) {
          debug("pipeOnDrain", state.awaitDrainWriters.size);
          state.awaitDrainWriters.delete(dest);
        }
        if ((!state.awaitDrainWriters || state.awaitDrainWriters.size === 0) && src.listenerCount("data")) {
          src.resume();
        }
      };
    }
    Readable2.prototype.unpipe = function(dest) {
      const state = this._readableState;
      const unpipeInfo = {
        hasUnpiped: false
      };
      if (state.pipes.length === 0) return this;
      if (!dest) {
        const dests = state.pipes;
        state.pipes = [];
        this.pause();
        for (let i = 0; i < dests.length; i++)
          dests[i].emit("unpipe", this, {
            hasUnpiped: false
          });
        return this;
      }
      const index = ArrayPrototypeIndexOf(state.pipes, dest);
      if (index === -1) return this;
      state.pipes.splice(index, 1);
      if (state.pipes.length === 0) this.pause();
      dest.emit("unpipe", this, unpipeInfo);
      return this;
    };
    Readable2.prototype.on = function(ev, fn) {
      const res = Stream.prototype.on.call(this, ev, fn);
      const state = this._readableState;
      if (ev === "data") {
        state.readableListening = this.listenerCount("readable") > 0;
        if (state.flowing !== false) this.resume();
      } else if (ev === "readable") {
        if (!state.endEmitted && !state.readableListening) {
          state.readableListening = state.needReadable = true;
          state.flowing = false;
          state.emittedReadable = false;
          debug("on readable", state.length, state.reading);
          if (state.length) {
            emitReadable(this);
          } else if (!state.reading) {
            process.nextTick(nReadingNextTick, this);
          }
        }
      }
      return res;
    };
    Readable2.prototype.addListener = Readable2.prototype.on;
    Readable2.prototype.removeListener = function(ev, fn) {
      const res = Stream.prototype.removeListener.call(this, ev, fn);
      if (ev === "readable") {
        process.nextTick(updateReadableListening, this);
      }
      return res;
    };
    Readable2.prototype.off = Readable2.prototype.removeListener;
    Readable2.prototype.removeAllListeners = function(ev) {
      const res = Stream.prototype.removeAllListeners.apply(this, arguments);
      if (ev === "readable" || ev === void 0) {
        process.nextTick(updateReadableListening, this);
      }
      return res;
    };
    function updateReadableListening(self2) {
      const state = self2._readableState;
      state.readableListening = self2.listenerCount("readable") > 0;
      if (state.resumeScheduled && state[kPaused] === false) {
        state.flowing = true;
      } else if (self2.listenerCount("data") > 0) {
        self2.resume();
      } else if (!state.readableListening) {
        state.flowing = null;
      }
    }
    function nReadingNextTick(self2) {
      debug("readable nexttick read 0");
      self2.read(0);
    }
    Readable2.prototype.resume = function() {
      const state = this._readableState;
      if (!state.flowing) {
        debug("resume");
        state.flowing = !state.readableListening;
        resume(this, state);
      }
      state[kPaused] = false;
      return this;
    };
    function resume(stream, state) {
      if (!state.resumeScheduled) {
        state.resumeScheduled = true;
        process.nextTick(resume_, stream, state);
      }
    }
    function resume_(stream, state) {
      debug("resume", state.reading);
      if (!state.reading) {
        stream.read(0);
      }
      state.resumeScheduled = false;
      stream.emit("resume");
      flow(stream);
      if (state.flowing && !state.reading) stream.read(0);
    }
    Readable2.prototype.pause = function() {
      debug("call pause flowing=%j", this._readableState.flowing);
      if (this._readableState.flowing !== false) {
        debug("pause");
        this._readableState.flowing = false;
        this.emit("pause");
      }
      this._readableState[kPaused] = true;
      return this;
    };
    function flow(stream) {
      const state = stream._readableState;
      debug("flow", state.flowing);
      while (state.flowing && stream.read() !== null) ;
    }
    Readable2.prototype.wrap = function(stream) {
      let paused = false;
      stream.on("data", (chunk) => {
        if (!this.push(chunk) && stream.pause) {
          paused = true;
          stream.pause();
        }
      });
      stream.on("end", () => {
        this.push(null);
      });
      stream.on("error", (err) => {
        errorOrDestroy(this, err);
      });
      stream.on("close", () => {
        this.destroy();
      });
      stream.on("destroy", () => {
        this.destroy();
      });
      this._read = () => {
        if (paused && stream.resume) {
          paused = false;
          stream.resume();
        }
      };
      const streamKeys = ObjectKeys(stream);
      for (let j = 1; j < streamKeys.length; j++) {
        const i = streamKeys[j];
        if (this[i] === void 0 && typeof stream[i] === "function") {
          this[i] = stream[i].bind(stream);
        }
      }
      return this;
    };
    Readable2.prototype[SymbolAsyncIterator] = function() {
      return streamToAsyncIterator(this);
    };
    Readable2.prototype.iterator = function(options) {
      if (options !== void 0) {
        validateObject(options, "options");
      }
      return streamToAsyncIterator(this, options);
    };
    function streamToAsyncIterator(stream, options) {
      if (typeof stream.read !== "function") {
        stream = Readable2.wrap(stream, {
          objectMode: true
        });
      }
      const iter = createAsyncIterator(stream, options);
      iter.stream = stream;
      return iter;
    }
    async function* createAsyncIterator(stream, options) {
      let callback = nop;
      function next(resolve) {
        if (this === stream) {
          callback();
          callback = nop;
        } else {
          callback = resolve;
        }
      }
      stream.on("readable", next);
      let error46;
      const cleanup = eos(
        stream,
        {
          writable: false
        },
        (err) => {
          error46 = err ? aggregateTwoErrors(error46, err) : null;
          callback();
          callback = nop;
        }
      );
      try {
        while (true) {
          const chunk = stream.destroyed ? null : stream.read();
          if (chunk !== null) {
            yield chunk;
          } else if (error46) {
            throw error46;
          } else if (error46 === null) {
            return;
          } else {
            await new Promise2(next);
          }
        }
      } catch (err) {
        error46 = aggregateTwoErrors(error46, err);
        throw error46;
      } finally {
        if ((error46 || (options === null || options === void 0 ? void 0 : options.destroyOnReturn) !== false) && (error46 === void 0 || stream._readableState.autoDestroy)) {
          destroyImpl.destroyer(stream, null);
        } else {
          stream.off("readable", next);
          cleanup();
        }
      }
    }
    ObjectDefineProperties(Readable2.prototype, {
      readable: {
        __proto__: null,
        get() {
          const r = this._readableState;
          return !!r && r.readable !== false && !r.destroyed && !r.errorEmitted && !r.endEmitted;
        },
        set(val) {
          if (this._readableState) {
            this._readableState.readable = !!val;
          }
        }
      },
      readableDidRead: {
        __proto__: null,
        enumerable: false,
        get: function() {
          return this._readableState.dataEmitted;
        }
      },
      readableAborted: {
        __proto__: null,
        enumerable: false,
        get: function() {
          return !!(this._readableState.readable !== false && (this._readableState.destroyed || this._readableState.errored) && !this._readableState.endEmitted);
        }
      },
      readableHighWaterMark: {
        __proto__: null,
        enumerable: false,
        get: function() {
          return this._readableState.highWaterMark;
        }
      },
      readableBuffer: {
        __proto__: null,
        enumerable: false,
        get: function() {
          return this._readableState && this._readableState.buffer;
        }
      },
      readableFlowing: {
        __proto__: null,
        enumerable: false,
        get: function() {
          return this._readableState.flowing;
        },
        set: function(state) {
          if (this._readableState) {
            this._readableState.flowing = state;
          }
        }
      },
      readableLength: {
        __proto__: null,
        enumerable: false,
        get() {
          return this._readableState.length;
        }
      },
      readableObjectMode: {
        __proto__: null,
        enumerable: false,
        get() {
          return this._readableState ? this._readableState.objectMode : false;
        }
      },
      readableEncoding: {
        __proto__: null,
        enumerable: false,
        get() {
          return this._readableState ? this._readableState.encoding : null;
        }
      },
      errored: {
        __proto__: null,
        enumerable: false,
        get() {
          return this._readableState ? this._readableState.errored : null;
        }
      },
      closed: {
        __proto__: null,
        get() {
          return this._readableState ? this._readableState.closed : false;
        }
      },
      destroyed: {
        __proto__: null,
        enumerable: false,
        get() {
          return this._readableState ? this._readableState.destroyed : false;
        },
        set(value) {
          if (!this._readableState) {
            return;
          }
          this._readableState.destroyed = value;
        }
      },
      readableEnded: {
        __proto__: null,
        enumerable: false,
        get() {
          return this._readableState ? this._readableState.endEmitted : false;
        }
      }
    });
    ObjectDefineProperties(ReadableState.prototype, {
      // Legacy getter for `pipesCount`.
      pipesCount: {
        __proto__: null,
        get() {
          return this.pipes.length;
        }
      },
      // Legacy property for `paused`.
      paused: {
        __proto__: null,
        get() {
          return this[kPaused] !== false;
        },
        set(value) {
          this[kPaused] = !!value;
        }
      }
    });
    Readable2._fromList = fromList;
    function fromList(n, state) {
      if (state.length === 0) return null;
      let ret;
      if (state.objectMode) ret = state.buffer.shift();
      else if (!n || n >= state.length) {
        if (state.decoder) ret = state.buffer.join("");
        else if (state.buffer.length === 1) ret = state.buffer.first();
        else ret = state.buffer.concat(state.length);
        state.buffer.clear();
      } else {
        ret = state.buffer.consume(n, state.decoder);
      }
      return ret;
    }
    function endReadable(stream) {
      const state = stream._readableState;
      debug("endReadable", state.endEmitted);
      if (!state.endEmitted) {
        state.ended = true;
        process.nextTick(endReadableNT, state, stream);
      }
    }
    function endReadableNT(state, stream) {
      debug("endReadableNT", state.endEmitted, state.length);
      if (!state.errored && !state.closeEmitted && !state.endEmitted && state.length === 0) {
        state.endEmitted = true;
        stream.emit("end");
        if (stream.writable && stream.allowHalfOpen === false) {
          process.nextTick(endWritableNT, stream);
        } else if (state.autoDestroy) {
          const wState = stream._writableState;
          const autoDestroy = !wState || wState.autoDestroy && // We don't expect the writable to ever 'finish'
          // if writable is explicitly set to false.
          (wState.finished || wState.writable === false);
          if (autoDestroy) {
            stream.destroy();
          }
        }
      }
    }
    function endWritableNT(stream) {
      const writable = stream.writable && !stream.writableEnded && !stream.destroyed;
      if (writable) {
        stream.end();
      }
    }
    Readable2.from = function(iterable, opts) {
      return from(Readable2, iterable, opts);
    };
    var webStreamsAdapters;
    function lazyWebStreams() {
      if (webStreamsAdapters === void 0) webStreamsAdapters = {};
      return webStreamsAdapters;
    }
    Readable2.fromWeb = function(readableStream, options) {
      return lazyWebStreams().newStreamReadableFromReadableStream(readableStream, options);
    };
    Readable2.toWeb = function(streamReadable, options) {
      return lazyWebStreams().newReadableStreamFromStreamReadable(streamReadable, options);
    };
    Readable2.wrap = function(src, options) {
      var _ref, _src$readableObjectMo;
      return new Readable2({
        objectMode: (_ref = (_src$readableObjectMo = src.readableObjectMode) !== null && _src$readableObjectMo !== void 0 ? _src$readableObjectMo : src.objectMode) !== null && _ref !== void 0 ? _ref : true,
        ...options,
        destroy(err, callback) {
          destroyImpl.destroyer(src, err);
          callback(err);
        }
      }).wrap(src);
    };
  }
});

// node_modules/jsonld-streaming-parser/node_modules/readable-stream/lib/internal/streams/writable.js
var require_writable = __commonJS({
  "node_modules/jsonld-streaming-parser/node_modules/readable-stream/lib/internal/streams/writable.js"(exports, module) {
    "use strict";
    var process = require_browser2();
    var {
      ArrayPrototypeSlice,
      Error: Error2,
      FunctionPrototypeSymbolHasInstance,
      ObjectDefineProperty,
      ObjectDefineProperties,
      ObjectSetPrototypeOf,
      StringPrototypeToLowerCase,
      Symbol: Symbol2,
      SymbolHasInstance
    } = require_primordials();
    module.exports = Writable;
    Writable.WritableState = WritableState;
    var { EventEmitter: EE } = require_events();
    var Stream = require_legacy().Stream;
    var { Buffer: Buffer3 } = require_buffer();
    var destroyImpl = require_destroy();
    var { addAbortSignal } = require_add_abort_signal();
    var { getHighWaterMark, getDefaultHighWaterMark } = require_state();
    var {
      ERR_INVALID_ARG_TYPE,
      ERR_METHOD_NOT_IMPLEMENTED,
      ERR_MULTIPLE_CALLBACK,
      ERR_STREAM_CANNOT_PIPE,
      ERR_STREAM_DESTROYED,
      ERR_STREAM_ALREADY_FINISHED,
      ERR_STREAM_NULL_VALUES,
      ERR_STREAM_WRITE_AFTER_END,
      ERR_UNKNOWN_ENCODING
    } = require_errors().codes;
    var { errorOrDestroy } = destroyImpl;
    ObjectSetPrototypeOf(Writable.prototype, Stream.prototype);
    ObjectSetPrototypeOf(Writable, Stream);
    function nop() {
    }
    var kOnFinished = Symbol2("kOnFinished");
    function WritableState(options, stream, isDuplex) {
      if (typeof isDuplex !== "boolean") isDuplex = stream instanceof require_duplex();
      this.objectMode = !!(options && options.objectMode);
      if (isDuplex) this.objectMode = this.objectMode || !!(options && options.writableObjectMode);
      this.highWaterMark = options ? getHighWaterMark(this, options, "writableHighWaterMark", isDuplex) : getDefaultHighWaterMark(false);
      this.finalCalled = false;
      this.needDrain = false;
      this.ending = false;
      this.ended = false;
      this.finished = false;
      this.destroyed = false;
      const noDecode = !!(options && options.decodeStrings === false);
      this.decodeStrings = !noDecode;
      this.defaultEncoding = options && options.defaultEncoding || "utf8";
      this.length = 0;
      this.writing = false;
      this.corked = 0;
      this.sync = true;
      this.bufferProcessing = false;
      this.onwrite = onwrite.bind(void 0, stream);
      this.writecb = null;
      this.writelen = 0;
      this.afterWriteTickInfo = null;
      resetBuffer(this);
      this.pendingcb = 0;
      this.constructed = true;
      this.prefinished = false;
      this.errorEmitted = false;
      this.emitClose = !options || options.emitClose !== false;
      this.autoDestroy = !options || options.autoDestroy !== false;
      this.errored = null;
      this.closed = false;
      this.closeEmitted = false;
      this[kOnFinished] = [];
    }
    function resetBuffer(state) {
      state.buffered = [];
      state.bufferedIndex = 0;
      state.allBuffers = true;
      state.allNoop = true;
    }
    WritableState.prototype.getBuffer = function getBuffer() {
      return ArrayPrototypeSlice(this.buffered, this.bufferedIndex);
    };
    ObjectDefineProperty(WritableState.prototype, "bufferedRequestCount", {
      __proto__: null,
      get() {
        return this.buffered.length - this.bufferedIndex;
      }
    });
    function Writable(options) {
      const isDuplex = this instanceof require_duplex();
      if (!isDuplex && !FunctionPrototypeSymbolHasInstance(Writable, this)) return new Writable(options);
      this._writableState = new WritableState(options, this, isDuplex);
      if (options) {
        if (typeof options.write === "function") this._write = options.write;
        if (typeof options.writev === "function") this._writev = options.writev;
        if (typeof options.destroy === "function") this._destroy = options.destroy;
        if (typeof options.final === "function") this._final = options.final;
        if (typeof options.construct === "function") this._construct = options.construct;
        if (options.signal) addAbortSignal(options.signal, this);
      }
      Stream.call(this, options);
      destroyImpl.construct(this, () => {
        const state = this._writableState;
        if (!state.writing) {
          clearBuffer(this, state);
        }
        finishMaybe(this, state);
      });
    }
    ObjectDefineProperty(Writable, SymbolHasInstance, {
      __proto__: null,
      value: function(object2) {
        if (FunctionPrototypeSymbolHasInstance(this, object2)) return true;
        if (this !== Writable) return false;
        return object2 && object2._writableState instanceof WritableState;
      }
    });
    Writable.prototype.pipe = function() {
      errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE());
    };
    function _write(stream, chunk, encoding, cb) {
      const state = stream._writableState;
      if (typeof encoding === "function") {
        cb = encoding;
        encoding = state.defaultEncoding;
      } else {
        if (!encoding) encoding = state.defaultEncoding;
        else if (encoding !== "buffer" && !Buffer3.isEncoding(encoding)) throw new ERR_UNKNOWN_ENCODING(encoding);
        if (typeof cb !== "function") cb = nop;
      }
      if (chunk === null) {
        throw new ERR_STREAM_NULL_VALUES();
      } else if (!state.objectMode) {
        if (typeof chunk === "string") {
          if (state.decodeStrings !== false) {
            chunk = Buffer3.from(chunk, encoding);
            encoding = "buffer";
          }
        } else if (chunk instanceof Buffer3) {
          encoding = "buffer";
        } else if (Stream._isUint8Array(chunk)) {
          chunk = Stream._uint8ArrayToBuffer(chunk);
          encoding = "buffer";
        } else {
          throw new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer", "Uint8Array"], chunk);
        }
      }
      let err;
      if (state.ending) {
        err = new ERR_STREAM_WRITE_AFTER_END();
      } else if (state.destroyed) {
        err = new ERR_STREAM_DESTROYED("write");
      }
      if (err) {
        process.nextTick(cb, err);
        errorOrDestroy(stream, err, true);
        return err;
      }
      state.pendingcb++;
      return writeOrBuffer(stream, state, chunk, encoding, cb);
    }
    Writable.prototype.write = function(chunk, encoding, cb) {
      return _write(this, chunk, encoding, cb) === true;
    };
    Writable.prototype.cork = function() {
      this._writableState.corked++;
    };
    Writable.prototype.uncork = function() {
      const state = this._writableState;
      if (state.corked) {
        state.corked--;
        if (!state.writing) clearBuffer(this, state);
      }
    };
    Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
      if (typeof encoding === "string") encoding = StringPrototypeToLowerCase(encoding);
      if (!Buffer3.isEncoding(encoding)) throw new ERR_UNKNOWN_ENCODING(encoding);
      this._writableState.defaultEncoding = encoding;
      return this;
    };
    function writeOrBuffer(stream, state, chunk, encoding, callback) {
      const len = state.objectMode ? 1 : chunk.length;
      state.length += len;
      const ret = state.length < state.highWaterMark;
      if (!ret) state.needDrain = true;
      if (state.writing || state.corked || state.errored || !state.constructed) {
        state.buffered.push({
          chunk,
          encoding,
          callback
        });
        if (state.allBuffers && encoding !== "buffer") {
          state.allBuffers = false;
        }
        if (state.allNoop && callback !== nop) {
          state.allNoop = false;
        }
      } else {
        state.writelen = len;
        state.writecb = callback;
        state.writing = true;
        state.sync = true;
        stream._write(chunk, encoding, state.onwrite);
        state.sync = false;
      }
      return ret && !state.errored && !state.destroyed;
    }
    function doWrite(stream, state, writev, len, chunk, encoding, cb) {
      state.writelen = len;
      state.writecb = cb;
      state.writing = true;
      state.sync = true;
      if (state.destroyed) state.onwrite(new ERR_STREAM_DESTROYED("write"));
      else if (writev) stream._writev(chunk, state.onwrite);
      else stream._write(chunk, encoding, state.onwrite);
      state.sync = false;
    }
    function onwriteError(stream, state, er, cb) {
      --state.pendingcb;
      cb(er);
      errorBuffer(state);
      errorOrDestroy(stream, er);
    }
    function onwrite(stream, er) {
      const state = stream._writableState;
      const sync = state.sync;
      const cb = state.writecb;
      if (typeof cb !== "function") {
        errorOrDestroy(stream, new ERR_MULTIPLE_CALLBACK());
        return;
      }
      state.writing = false;
      state.writecb = null;
      state.length -= state.writelen;
      state.writelen = 0;
      if (er) {
        er.stack;
        if (!state.errored) {
          state.errored = er;
        }
        if (stream._readableState && !stream._readableState.errored) {
          stream._readableState.errored = er;
        }
        if (sync) {
          process.nextTick(onwriteError, stream, state, er, cb);
        } else {
          onwriteError(stream, state, er, cb);
        }
      } else {
        if (state.buffered.length > state.bufferedIndex) {
          clearBuffer(stream, state);
        }
        if (sync) {
          if (state.afterWriteTickInfo !== null && state.afterWriteTickInfo.cb === cb) {
            state.afterWriteTickInfo.count++;
          } else {
            state.afterWriteTickInfo = {
              count: 1,
              cb,
              stream,
              state
            };
            process.nextTick(afterWriteTick, state.afterWriteTickInfo);
          }
        } else {
          afterWrite(stream, state, 1, cb);
        }
      }
    }
    function afterWriteTick({ stream, state, count, cb }) {
      state.afterWriteTickInfo = null;
      return afterWrite(stream, state, count, cb);
    }
    function afterWrite(stream, state, count, cb) {
      const needDrain = !state.ending && !stream.destroyed && state.length === 0 && state.needDrain;
      if (needDrain) {
        state.needDrain = false;
        stream.emit("drain");
      }
      while (count-- > 0) {
        state.pendingcb--;
        cb();
      }
      if (state.destroyed) {
        errorBuffer(state);
      }
      finishMaybe(stream, state);
    }
    function errorBuffer(state) {
      if (state.writing) {
        return;
      }
      for (let n = state.bufferedIndex; n < state.buffered.length; ++n) {
        var _state$errored;
        const { chunk, callback } = state.buffered[n];
        const len = state.objectMode ? 1 : chunk.length;
        state.length -= len;
        callback(
          (_state$errored = state.errored) !== null && _state$errored !== void 0 ? _state$errored : new ERR_STREAM_DESTROYED("write")
        );
      }
      const onfinishCallbacks = state[kOnFinished].splice(0);
      for (let i = 0; i < onfinishCallbacks.length; i++) {
        var _state$errored2;
        onfinishCallbacks[i](
          (_state$errored2 = state.errored) !== null && _state$errored2 !== void 0 ? _state$errored2 : new ERR_STREAM_DESTROYED("end")
        );
      }
      resetBuffer(state);
    }
    function clearBuffer(stream, state) {
      if (state.corked || state.bufferProcessing || state.destroyed || !state.constructed) {
        return;
      }
      const { buffered, bufferedIndex, objectMode } = state;
      const bufferedLength = buffered.length - bufferedIndex;
      if (!bufferedLength) {
        return;
      }
      let i = bufferedIndex;
      state.bufferProcessing = true;
      if (bufferedLength > 1 && stream._writev) {
        state.pendingcb -= bufferedLength - 1;
        const callback = state.allNoop ? nop : (err) => {
          for (let n = i; n < buffered.length; ++n) {
            buffered[n].callback(err);
          }
        };
        const chunks = state.allNoop && i === 0 ? buffered : ArrayPrototypeSlice(buffered, i);
        chunks.allBuffers = state.allBuffers;
        doWrite(stream, state, true, state.length, chunks, "", callback);
        resetBuffer(state);
      } else {
        do {
          const { chunk, encoding, callback } = buffered[i];
          buffered[i++] = null;
          const len = objectMode ? 1 : chunk.length;
          doWrite(stream, state, false, len, chunk, encoding, callback);
        } while (i < buffered.length && !state.writing);
        if (i === buffered.length) {
          resetBuffer(state);
        } else if (i > 256) {
          buffered.splice(0, i);
          state.bufferedIndex = 0;
        } else {
          state.bufferedIndex = i;
        }
      }
      state.bufferProcessing = false;
    }
    Writable.prototype._write = function(chunk, encoding, cb) {
      if (this._writev) {
        this._writev(
          [
            {
              chunk,
              encoding
            }
          ],
          cb
        );
      } else {
        throw new ERR_METHOD_NOT_IMPLEMENTED("_write()");
      }
    };
    Writable.prototype._writev = null;
    Writable.prototype.end = function(chunk, encoding, cb) {
      const state = this._writableState;
      if (typeof chunk === "function") {
        cb = chunk;
        chunk = null;
        encoding = null;
      } else if (typeof encoding === "function") {
        cb = encoding;
        encoding = null;
      }
      let err;
      if (chunk !== null && chunk !== void 0) {
        const ret = _write(this, chunk, encoding);
        if (ret instanceof Error2) {
          err = ret;
        }
      }
      if (state.corked) {
        state.corked = 1;
        this.uncork();
      }
      if (err) {
      } else if (!state.errored && !state.ending) {
        state.ending = true;
        finishMaybe(this, state, true);
        state.ended = true;
      } else if (state.finished) {
        err = new ERR_STREAM_ALREADY_FINISHED("end");
      } else if (state.destroyed) {
        err = new ERR_STREAM_DESTROYED("end");
      }
      if (typeof cb === "function") {
        if (err || state.finished) {
          process.nextTick(cb, err);
        } else {
          state[kOnFinished].push(cb);
        }
      }
      return this;
    };
    function needFinish(state) {
      return state.ending && !state.destroyed && state.constructed && state.length === 0 && !state.errored && state.buffered.length === 0 && !state.finished && !state.writing && !state.errorEmitted && !state.closeEmitted;
    }
    function callFinal(stream, state) {
      let called = false;
      function onFinish(err) {
        if (called) {
          errorOrDestroy(stream, err !== null && err !== void 0 ? err : ERR_MULTIPLE_CALLBACK());
          return;
        }
        called = true;
        state.pendingcb--;
        if (err) {
          const onfinishCallbacks = state[kOnFinished].splice(0);
          for (let i = 0; i < onfinishCallbacks.length; i++) {
            onfinishCallbacks[i](err);
          }
          errorOrDestroy(stream, err, state.sync);
        } else if (needFinish(state)) {
          state.prefinished = true;
          stream.emit("prefinish");
          state.pendingcb++;
          process.nextTick(finish, stream, state);
        }
      }
      state.sync = true;
      state.pendingcb++;
      try {
        stream._final(onFinish);
      } catch (err) {
        onFinish(err);
      }
      state.sync = false;
    }
    function prefinish(stream, state) {
      if (!state.prefinished && !state.finalCalled) {
        if (typeof stream._final === "function" && !state.destroyed) {
          state.finalCalled = true;
          callFinal(stream, state);
        } else {
          state.prefinished = true;
          stream.emit("prefinish");
        }
      }
    }
    function finishMaybe(stream, state, sync) {
      if (needFinish(state)) {
        prefinish(stream, state);
        if (state.pendingcb === 0) {
          if (sync) {
            state.pendingcb++;
            process.nextTick(
              (stream2, state2) => {
                if (needFinish(state2)) {
                  finish(stream2, state2);
                } else {
                  state2.pendingcb--;
                }
              },
              stream,
              state
            );
          } else if (needFinish(state)) {
            state.pendingcb++;
            finish(stream, state);
          }
        }
      }
    }
    function finish(stream, state) {
      state.pendingcb--;
      state.finished = true;
      const onfinishCallbacks = state[kOnFinished].splice(0);
      for (let i = 0; i < onfinishCallbacks.length; i++) {
        onfinishCallbacks[i]();
      }
      stream.emit("finish");
      if (state.autoDestroy) {
        const rState = stream._readableState;
        const autoDestroy = !rState || rState.autoDestroy && // We don't expect the readable to ever 'end'
        // if readable is explicitly set to false.
        (rState.endEmitted || rState.readable === false);
        if (autoDestroy) {
          stream.destroy();
        }
      }
    }
    ObjectDefineProperties(Writable.prototype, {
      closed: {
        __proto__: null,
        get() {
          return this._writableState ? this._writableState.closed : false;
        }
      },
      destroyed: {
        __proto__: null,
        get() {
          return this._writableState ? this._writableState.destroyed : false;
        },
        set(value) {
          if (this._writableState) {
            this._writableState.destroyed = value;
          }
        }
      },
      writable: {
        __proto__: null,
        get() {
          const w = this._writableState;
          return !!w && w.writable !== false && !w.destroyed && !w.errored && !w.ending && !w.ended;
        },
        set(val) {
          if (this._writableState) {
            this._writableState.writable = !!val;
          }
        }
      },
      writableFinished: {
        __proto__: null,
        get() {
          return this._writableState ? this._writableState.finished : false;
        }
      },
      writableObjectMode: {
        __proto__: null,
        get() {
          return this._writableState ? this._writableState.objectMode : false;
        }
      },
      writableBuffer: {
        __proto__: null,
        get() {
          return this._writableState && this._writableState.getBuffer();
        }
      },
      writableEnded: {
        __proto__: null,
        get() {
          return this._writableState ? this._writableState.ending : false;
        }
      },
      writableNeedDrain: {
        __proto__: null,
        get() {
          const wState = this._writableState;
          if (!wState) return false;
          return !wState.destroyed && !wState.ending && wState.needDrain;
        }
      },
      writableHighWaterMark: {
        __proto__: null,
        get() {
          return this._writableState && this._writableState.highWaterMark;
        }
      },
      writableCorked: {
        __proto__: null,
        get() {
          return this._writableState ? this._writableState.corked : 0;
        }
      },
      writableLength: {
        __proto__: null,
        get() {
          return this._writableState && this._writableState.length;
        }
      },
      errored: {
        __proto__: null,
        enumerable: false,
        get() {
          return this._writableState ? this._writableState.errored : null;
        }
      },
      writableAborted: {
        __proto__: null,
        enumerable: false,
        get: function() {
          return !!(this._writableState.writable !== false && (this._writableState.destroyed || this._writableState.errored) && !this._writableState.finished);
        }
      }
    });
    var destroy = destroyImpl.destroy;
    Writable.prototype.destroy = function(err, cb) {
      const state = this._writableState;
      if (!state.destroyed && (state.bufferedIndex < state.buffered.length || state[kOnFinished].length)) {
        process.nextTick(errorBuffer, state);
      }
      destroy.call(this, err, cb);
      return this;
    };
    Writable.prototype._undestroy = destroyImpl.undestroy;
    Writable.prototype._destroy = function(err, cb) {
      cb(err);
    };
    Writable.prototype[EE.captureRejectionSymbol] = function(err) {
      this.destroy(err);
    };
    var webStreamsAdapters;
    function lazyWebStreams() {
      if (webStreamsAdapters === void 0) webStreamsAdapters = {};
      return webStreamsAdapters;
    }
    Writable.fromWeb = function(writableStream, options) {
      return lazyWebStreams().newStreamWritableFromWritableStream(writableStream, options);
    };
    Writable.toWeb = function(streamWritable) {
      return lazyWebStreams().newWritableStreamFromStreamWritable(streamWritable);
    };
  }
});

// node_modules/jsonld-streaming-parser/node_modules/readable-stream/lib/internal/streams/duplexify.js
var require_duplexify = __commonJS({
  "node_modules/jsonld-streaming-parser/node_modules/readable-stream/lib/internal/streams/duplexify.js"(exports, module) {
    var process = require_browser2();
    var bufferModule = require_buffer();
    var {
      isReadable,
      isWritable,
      isIterable,
      isNodeStream,
      isReadableNodeStream,
      isWritableNodeStream,
      isDuplexNodeStream,
      isReadableStream,
      isWritableStream
    } = require_utils();
    var eos = require_end_of_stream();
    var {
      AbortError,
      codes: { ERR_INVALID_ARG_TYPE, ERR_INVALID_RETURN_VALUE }
    } = require_errors();
    var { destroyer } = require_destroy();
    var Duplex = require_duplex();
    var Readable2 = require_readable();
    var Writable = require_writable();
    var { createDeferredPromise } = require_util();
    var from = require_from();
    var Blob2 = globalThis.Blob || bufferModule.Blob;
    var isBlob = typeof Blob2 !== "undefined" ? function isBlob2(b) {
      return b instanceof Blob2;
    } : function isBlob2(b) {
      return false;
    };
    var AbortController2 = globalThis.AbortController || require_browser().AbortController;
    var { FunctionPrototypeCall } = require_primordials();
    var Duplexify = class extends Duplex {
      constructor(options) {
        super(options);
        if ((options === null || options === void 0 ? void 0 : options.readable) === false) {
          this._readableState.readable = false;
          this._readableState.ended = true;
          this._readableState.endEmitted = true;
        }
        if ((options === null || options === void 0 ? void 0 : options.writable) === false) {
          this._writableState.writable = false;
          this._writableState.ending = true;
          this._writableState.ended = true;
          this._writableState.finished = true;
        }
      }
    };
    module.exports = function duplexify(body, name) {
      if (isDuplexNodeStream(body)) {
        return body;
      }
      if (isReadableNodeStream(body)) {
        return _duplexify({
          readable: body
        });
      }
      if (isWritableNodeStream(body)) {
        return _duplexify({
          writable: body
        });
      }
      if (isNodeStream(body)) {
        return _duplexify({
          writable: false,
          readable: false
        });
      }
      if (isReadableStream(body)) {
        return _duplexify({
          readable: Readable2.fromWeb(body)
        });
      }
      if (isWritableStream(body)) {
        return _duplexify({
          writable: Writable.fromWeb(body)
        });
      }
      if (typeof body === "function") {
        const { value, write, final, destroy } = fromAsyncGen(body);
        if (isIterable(value)) {
          return from(Duplexify, value, {
            // TODO (ronag): highWaterMark?
            objectMode: true,
            write,
            final,
            destroy
          });
        }
        const then2 = value === null || value === void 0 ? void 0 : value.then;
        if (typeof then2 === "function") {
          let d;
          const promise2 = FunctionPrototypeCall(
            then2,
            value,
            (val) => {
              if (val != null) {
                throw new ERR_INVALID_RETURN_VALUE("nully", "body", val);
              }
            },
            (err) => {
              destroyer(d, err);
            }
          );
          return d = new Duplexify({
            // TODO (ronag): highWaterMark?
            objectMode: true,
            readable: false,
            write,
            final(cb) {
              final(async () => {
                try {
                  await promise2;
                  process.nextTick(cb, null);
                } catch (err) {
                  process.nextTick(cb, err);
                }
              });
            },
            destroy
          });
        }
        throw new ERR_INVALID_RETURN_VALUE("Iterable, AsyncIterable or AsyncFunction", name, value);
      }
      if (isBlob(body)) {
        return duplexify(body.arrayBuffer());
      }
      if (isIterable(body)) {
        return from(Duplexify, body, {
          // TODO (ronag): highWaterMark?
          objectMode: true,
          writable: false
        });
      }
      if (isReadableStream(body === null || body === void 0 ? void 0 : body.readable) && isWritableStream(body === null || body === void 0 ? void 0 : body.writable)) {
        return Duplexify.fromWeb(body);
      }
      if (typeof (body === null || body === void 0 ? void 0 : body.writable) === "object" || typeof (body === null || body === void 0 ? void 0 : body.readable) === "object") {
        const readable = body !== null && body !== void 0 && body.readable ? isReadableNodeStream(body === null || body === void 0 ? void 0 : body.readable) ? body === null || body === void 0 ? void 0 : body.readable : duplexify(body.readable) : void 0;
        const writable = body !== null && body !== void 0 && body.writable ? isWritableNodeStream(body === null || body === void 0 ? void 0 : body.writable) ? body === null || body === void 0 ? void 0 : body.writable : duplexify(body.writable) : void 0;
        return _duplexify({
          readable,
          writable
        });
      }
      const then = body === null || body === void 0 ? void 0 : body.then;
      if (typeof then === "function") {
        let d;
        FunctionPrototypeCall(
          then,
          body,
          (val) => {
            if (val != null) {
              d.push(val);
            }
            d.push(null);
          },
          (err) => {
            destroyer(d, err);
          }
        );
        return d = new Duplexify({
          objectMode: true,
          writable: false,
          read() {
          }
        });
      }
      throw new ERR_INVALID_ARG_TYPE(
        name,
        [
          "Blob",
          "ReadableStream",
          "WritableStream",
          "Stream",
          "Iterable",
          "AsyncIterable",
          "Function",
          "{ readable, writable } pair",
          "Promise"
        ],
        body
      );
    };
    function fromAsyncGen(fn) {
      let { promise: promise2, resolve } = createDeferredPromise();
      const ac = new AbortController2();
      const signal = ac.signal;
      const value = fn(
        (async function* () {
          while (true) {
            const _promise2 = promise2;
            promise2 = null;
            const { chunk, done, cb } = await _promise2;
            process.nextTick(cb);
            if (done) return;
            if (signal.aborted)
              throw new AbortError(void 0, {
                cause: signal.reason
              });
            ({ promise: promise2, resolve } = createDeferredPromise());
            yield chunk;
          }
        })(),
        {
          signal
        }
      );
      return {
        value,
        write(chunk, encoding, cb) {
          const _resolve = resolve;
          resolve = null;
          _resolve({
            chunk,
            done: false,
            cb
          });
        },
        final(cb) {
          const _resolve = resolve;
          resolve = null;
          _resolve({
            done: true,
            cb
          });
        },
        destroy(err, cb) {
          ac.abort();
          cb(err);
        }
      };
    }
    function _duplexify(pair) {
      const r = pair.readable && typeof pair.readable.read !== "function" ? Readable2.wrap(pair.readable) : pair.readable;
      const w = pair.writable;
      let readable = !!isReadable(r);
      let writable = !!isWritable(w);
      let ondrain;
      let onfinish;
      let onreadable;
      let onclose;
      let d;
      function onfinished(err) {
        const cb = onclose;
        onclose = null;
        if (cb) {
          cb(err);
        } else if (err) {
          d.destroy(err);
        }
      }
      d = new Duplexify({
        // TODO (ronag): highWaterMark?
        readableObjectMode: !!(r !== null && r !== void 0 && r.readableObjectMode),
        writableObjectMode: !!(w !== null && w !== void 0 && w.writableObjectMode),
        readable,
        writable
      });
      if (writable) {
        eos(w, (err) => {
          writable = false;
          if (err) {
            destroyer(r, err);
          }
          onfinished(err);
        });
        d._write = function(chunk, encoding, callback) {
          if (w.write(chunk, encoding)) {
            callback();
          } else {
            ondrain = callback;
          }
        };
        d._final = function(callback) {
          w.end();
          onfinish = callback;
        };
        w.on("drain", function() {
          if (ondrain) {
            const cb = ondrain;
            ondrain = null;
            cb();
          }
        });
        w.on("finish", function() {
          if (onfinish) {
            const cb = onfinish;
            onfinish = null;
            cb();
          }
        });
      }
      if (readable) {
        eos(r, (err) => {
          readable = false;
          if (err) {
            destroyer(r, err);
          }
          onfinished(err);
        });
        r.on("readable", function() {
          if (onreadable) {
            const cb = onreadable;
            onreadable = null;
            cb();
          }
        });
        r.on("end", function() {
          d.push(null);
        });
        d._read = function() {
          while (true) {
            const buf = r.read();
            if (buf === null) {
              onreadable = d._read;
              return;
            }
            if (!d.push(buf)) {
              return;
            }
          }
        };
      }
      d._destroy = function(err, callback) {
        if (!err && onclose !== null) {
          err = new AbortError();
        }
        onreadable = null;
        ondrain = null;
        onfinish = null;
        if (onclose === null) {
          callback(err);
        } else {
          onclose = callback;
          destroyer(w, err);
          destroyer(r, err);
        }
      };
      return d;
    }
  }
});

// node_modules/jsonld-streaming-parser/node_modules/readable-stream/lib/internal/streams/duplex.js
var require_duplex = __commonJS({
  "node_modules/jsonld-streaming-parser/node_modules/readable-stream/lib/internal/streams/duplex.js"(exports, module) {
    "use strict";
    var {
      ObjectDefineProperties,
      ObjectGetOwnPropertyDescriptor,
      ObjectKeys,
      ObjectSetPrototypeOf
    } = require_primordials();
    module.exports = Duplex;
    var Readable2 = require_readable();
    var Writable = require_writable();
    ObjectSetPrototypeOf(Duplex.prototype, Readable2.prototype);
    ObjectSetPrototypeOf(Duplex, Readable2);
    {
      const keys = ObjectKeys(Writable.prototype);
      for (let i = 0; i < keys.length; i++) {
        const method = keys[i];
        if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];
      }
    }
    function Duplex(options) {
      if (!(this instanceof Duplex)) return new Duplex(options);
      Readable2.call(this, options);
      Writable.call(this, options);
      if (options) {
        this.allowHalfOpen = options.allowHalfOpen !== false;
        if (options.readable === false) {
          this._readableState.readable = false;
          this._readableState.ended = true;
          this._readableState.endEmitted = true;
        }
        if (options.writable === false) {
          this._writableState.writable = false;
          this._writableState.ending = true;
          this._writableState.ended = true;
          this._writableState.finished = true;
        }
      } else {
        this.allowHalfOpen = true;
      }
    }
    ObjectDefineProperties(Duplex.prototype, {
      writable: {
        __proto__: null,
        ...ObjectGetOwnPropertyDescriptor(Writable.prototype, "writable")
      },
      writableHighWaterMark: {
        __proto__: null,
        ...ObjectGetOwnPropertyDescriptor(Writable.prototype, "writableHighWaterMark")
      },
      writableObjectMode: {
        __proto__: null,
        ...ObjectGetOwnPropertyDescriptor(Writable.prototype, "writableObjectMode")
      },
      writableBuffer: {
        __proto__: null,
        ...ObjectGetOwnPropertyDescriptor(Writable.prototype, "writableBuffer")
      },
      writableLength: {
        __proto__: null,
        ...ObjectGetOwnPropertyDescriptor(Writable.prototype, "writableLength")
      },
      writableFinished: {
        __proto__: null,
        ...ObjectGetOwnPropertyDescriptor(Writable.prototype, "writableFinished")
      },
      writableCorked: {
        __proto__: null,
        ...ObjectGetOwnPropertyDescriptor(Writable.prototype, "writableCorked")
      },
      writableEnded: {
        __proto__: null,
        ...ObjectGetOwnPropertyDescriptor(Writable.prototype, "writableEnded")
      },
      writableNeedDrain: {
        __proto__: null,
        ...ObjectGetOwnPropertyDescriptor(Writable.prototype, "writableNeedDrain")
      },
      destroyed: {
        __proto__: null,
        get() {
          if (this._readableState === void 0 || this._writableState === void 0) {
            return false;
          }
          return this._readableState.destroyed && this._writableState.destroyed;
        },
        set(value) {
          if (this._readableState && this._writableState) {
            this._readableState.destroyed = value;
            this._writableState.destroyed = value;
          }
        }
      }
    });
    var webStreamsAdapters;
    function lazyWebStreams() {
      if (webStreamsAdapters === void 0) webStreamsAdapters = {};
      return webStreamsAdapters;
    }
    Duplex.fromWeb = function(pair, options) {
      return lazyWebStreams().newStreamDuplexFromReadableWritablePair(pair, options);
    };
    Duplex.toWeb = function(duplex) {
      return lazyWebStreams().newReadableWritablePairFromDuplex(duplex);
    };
    var duplexify;
    Duplex.from = function(body) {
      if (!duplexify) {
        duplexify = require_duplexify();
      }
      return duplexify(body, "body");
    };
  }
});

// node_modules/jsonld-streaming-parser/node_modules/readable-stream/lib/internal/streams/transform.js
var require_transform = __commonJS({
  "node_modules/jsonld-streaming-parser/node_modules/readable-stream/lib/internal/streams/transform.js"(exports, module) {
    "use strict";
    var { ObjectSetPrototypeOf, Symbol: Symbol2 } = require_primordials();
    module.exports = Transform;
    var { ERR_METHOD_NOT_IMPLEMENTED } = require_errors().codes;
    var Duplex = require_duplex();
    var { getHighWaterMark } = require_state();
    ObjectSetPrototypeOf(Transform.prototype, Duplex.prototype);
    ObjectSetPrototypeOf(Transform, Duplex);
    var kCallback = Symbol2("kCallback");
    function Transform(options) {
      if (!(this instanceof Transform)) return new Transform(options);
      const readableHighWaterMark = options ? getHighWaterMark(this, options, "readableHighWaterMark", true) : null;
      if (readableHighWaterMark === 0) {
        options = {
          ...options,
          highWaterMark: null,
          readableHighWaterMark,
          // TODO (ronag): 0 is not optimal since we have
          // a "bug" where we check needDrain before calling _write and not after.
          // Refs: https://github.com/nodejs/node/pull/32887
          // Refs: https://github.com/nodejs/node/pull/35941
          writableHighWaterMark: options.writableHighWaterMark || 0
        };
      }
      Duplex.call(this, options);
      this._readableState.sync = false;
      this[kCallback] = null;
      if (options) {
        if (typeof options.transform === "function") this._transform = options.transform;
        if (typeof options.flush === "function") this._flush = options.flush;
      }
      this.on("prefinish", prefinish);
    }
    function final(cb) {
      if (typeof this._flush === "function" && !this.destroyed) {
        this._flush((er, data) => {
          if (er) {
            if (cb) {
              cb(er);
            } else {
              this.destroy(er);
            }
            return;
          }
          if (data != null) {
            this.push(data);
          }
          this.push(null);
          if (cb) {
            cb();
          }
        });
      } else {
        this.push(null);
        if (cb) {
          cb();
        }
      }
    }
    function prefinish() {
      if (this._final !== final) {
        final.call(this);
      }
    }
    Transform.prototype._final = final;
    Transform.prototype._transform = function(chunk, encoding, callback) {
      throw new ERR_METHOD_NOT_IMPLEMENTED("_transform()");
    };
    Transform.prototype._write = function(chunk, encoding, callback) {
      const rState = this._readableState;
      const wState = this._writableState;
      const length = rState.length;
      this._transform(chunk, encoding, (err, val) => {
        if (err) {
          callback(err);
          return;
        }
        if (val != null) {
          this.push(val);
        }
        if (wState.ended || // Backwards compat.
        length === rState.length || // Backwards compat.
        rState.length < rState.highWaterMark) {
          callback();
        } else {
          this[kCallback] = callback;
        }
      });
    };
    Transform.prototype._read = function() {
      if (this[kCallback]) {
        const callback = this[kCallback];
        this[kCallback] = null;
        callback();
      }
    };
  }
});

// node_modules/jsonld-streaming-parser/node_modules/readable-stream/lib/internal/streams/passthrough.js
var require_passthrough = __commonJS({
  "node_modules/jsonld-streaming-parser/node_modules/readable-stream/lib/internal/streams/passthrough.js"(exports, module) {
    "use strict";
    var { ObjectSetPrototypeOf } = require_primordials();
    module.exports = PassThrough;
    var Transform = require_transform();
    ObjectSetPrototypeOf(PassThrough.prototype, Transform.prototype);
    ObjectSetPrototypeOf(PassThrough, Transform);
    function PassThrough(options) {
      if (!(this instanceof PassThrough)) return new PassThrough(options);
      Transform.call(this, options);
    }
    PassThrough.prototype._transform = function(chunk, encoding, cb) {
      cb(null, chunk);
    };
  }
});

// node_modules/jsonld-streaming-parser/node_modules/readable-stream/lib/internal/streams/pipeline.js
var require_pipeline = __commonJS({
  "node_modules/jsonld-streaming-parser/node_modules/readable-stream/lib/internal/streams/pipeline.js"(exports, module) {
    var process = require_browser2();
    var { ArrayIsArray, Promise: Promise2, SymbolAsyncIterator, SymbolDispose } = require_primordials();
    var eos = require_end_of_stream();
    var { once } = require_util();
    var destroyImpl = require_destroy();
    var Duplex = require_duplex();
    var {
      aggregateTwoErrors,
      codes: {
        ERR_INVALID_ARG_TYPE,
        ERR_INVALID_RETURN_VALUE,
        ERR_MISSING_ARGS,
        ERR_STREAM_DESTROYED,
        ERR_STREAM_PREMATURE_CLOSE
      },
      AbortError
    } = require_errors();
    var { validateFunction, validateAbortSignal } = require_validators();
    var {
      isIterable,
      isReadable,
      isReadableNodeStream,
      isNodeStream,
      isTransformStream,
      isWebStream,
      isReadableStream,
      isReadableFinished
    } = require_utils();
    var AbortController2 = globalThis.AbortController || require_browser().AbortController;
    var PassThrough;
    var Readable2;
    var addAbortListener;
    function destroyer(stream, reading, writing) {
      let finished = false;
      stream.on("close", () => {
        finished = true;
      });
      const cleanup = eos(
        stream,
        {
          readable: reading,
          writable: writing
        },
        (err) => {
          finished = !err;
        }
      );
      return {
        destroy: (err) => {
          if (finished) return;
          finished = true;
          destroyImpl.destroyer(stream, err || new ERR_STREAM_DESTROYED("pipe"));
        },
        cleanup
      };
    }
    function popCallback(streams) {
      validateFunction(streams[streams.length - 1], "streams[stream.length - 1]");
      return streams.pop();
    }
    function makeAsyncIterable(val) {
      if (isIterable(val)) {
        return val;
      } else if (isReadableNodeStream(val)) {
        return fromReadable(val);
      }
      throw new ERR_INVALID_ARG_TYPE("val", ["Readable", "Iterable", "AsyncIterable"], val);
    }
    async function* fromReadable(val) {
      if (!Readable2) {
        Readable2 = require_readable();
      }
      yield* Readable2.prototype[SymbolAsyncIterator].call(val);
    }
    async function pumpToNode(iterable, writable, finish, { end }) {
      let error46;
      let onresolve = null;
      const resume = (err) => {
        if (err) {
          error46 = err;
        }
        if (onresolve) {
          const callback = onresolve;
          onresolve = null;
          callback();
        }
      };
      const wait = () => new Promise2((resolve, reject2) => {
        if (error46) {
          reject2(error46);
        } else {
          onresolve = () => {
            if (error46) {
              reject2(error46);
            } else {
              resolve();
            }
          };
        }
      });
      writable.on("drain", resume);
      const cleanup = eos(
        writable,
        {
          readable: false
        },
        resume
      );
      try {
        if (writable.writableNeedDrain) {
          await wait();
        }
        for await (const chunk of iterable) {
          if (!writable.write(chunk)) {
            await wait();
          }
        }
        if (end) {
          writable.end();
          await wait();
        }
        finish();
      } catch (err) {
        finish(error46 !== err ? aggregateTwoErrors(error46, err) : err);
      } finally {
        cleanup();
        writable.off("drain", resume);
      }
    }
    async function pumpToWeb(readable, writable, finish, { end }) {
      if (isTransformStream(writable)) {
        writable = writable.writable;
      }
      const writer = writable.getWriter();
      try {
        for await (const chunk of readable) {
          await writer.ready;
          writer.write(chunk).catch(() => {
          });
        }
        await writer.ready;
        if (end) {
          await writer.close();
        }
        finish();
      } catch (err) {
        try {
          await writer.abort(err);
          finish(err);
        } catch (err2) {
          finish(err2);
        }
      }
    }
    function pipeline(...streams) {
      return pipelineImpl(streams, once(popCallback(streams)));
    }
    function pipelineImpl(streams, callback, opts) {
      if (streams.length === 1 && ArrayIsArray(streams[0])) {
        streams = streams[0];
      }
      if (streams.length < 2) {
        throw new ERR_MISSING_ARGS("streams");
      }
      const ac = new AbortController2();
      const signal = ac.signal;
      const outerSignal = opts === null || opts === void 0 ? void 0 : opts.signal;
      const lastStreamCleanup = [];
      validateAbortSignal(outerSignal, "options.signal");
      function abort() {
        finishImpl(new AbortError());
      }
      addAbortListener = addAbortListener || require_util().addAbortListener;
      let disposable;
      if (outerSignal) {
        disposable = addAbortListener(outerSignal, abort);
      }
      let error46;
      let value;
      const destroys = [];
      let finishCount = 0;
      function finish(err) {
        finishImpl(err, --finishCount === 0);
      }
      function finishImpl(err, final) {
        var _disposable;
        if (err && (!error46 || error46.code === "ERR_STREAM_PREMATURE_CLOSE")) {
          error46 = err;
        }
        if (!error46 && !final) {
          return;
        }
        while (destroys.length) {
          destroys.shift()(error46);
        }
        ;
        (_disposable = disposable) === null || _disposable === void 0 ? void 0 : _disposable[SymbolDispose]();
        ac.abort();
        if (final) {
          if (!error46) {
            lastStreamCleanup.forEach((fn) => fn());
          }
          process.nextTick(callback, error46, value);
        }
      }
      let ret;
      for (let i = 0; i < streams.length; i++) {
        const stream = streams[i];
        const reading = i < streams.length - 1;
        const writing = i > 0;
        const end = reading || (opts === null || opts === void 0 ? void 0 : opts.end) !== false;
        const isLastStream = i === streams.length - 1;
        if (isNodeStream(stream)) {
          let onError2 = function(err) {
            if (err && err.name !== "AbortError" && err.code !== "ERR_STREAM_PREMATURE_CLOSE") {
              finish(err);
            }
          };
          var onError = onError2;
          if (end) {
            const { destroy, cleanup } = destroyer(stream, reading, writing);
            destroys.push(destroy);
            if (isReadable(stream) && isLastStream) {
              lastStreamCleanup.push(cleanup);
            }
          }
          stream.on("error", onError2);
          if (isReadable(stream) && isLastStream) {
            lastStreamCleanup.push(() => {
              stream.removeListener("error", onError2);
            });
          }
        }
        if (i === 0) {
          if (typeof stream === "function") {
            ret = stream({
              signal
            });
            if (!isIterable(ret)) {
              throw new ERR_INVALID_RETURN_VALUE("Iterable, AsyncIterable or Stream", "source", ret);
            }
          } else if (isIterable(stream) || isReadableNodeStream(stream) || isTransformStream(stream)) {
            ret = stream;
          } else {
            ret = Duplex.from(stream);
          }
        } else if (typeof stream === "function") {
          if (isTransformStream(ret)) {
            var _ret;
            ret = makeAsyncIterable((_ret = ret) === null || _ret === void 0 ? void 0 : _ret.readable);
          } else {
            ret = makeAsyncIterable(ret);
          }
          ret = stream(ret, {
            signal
          });
          if (reading) {
            if (!isIterable(ret, true)) {
              throw new ERR_INVALID_RETURN_VALUE("AsyncIterable", `transform[${i - 1}]`, ret);
            }
          } else {
            var _ret2;
            if (!PassThrough) {
              PassThrough = require_passthrough();
            }
            const pt = new PassThrough({
              objectMode: true
            });
            const then = (_ret2 = ret) === null || _ret2 === void 0 ? void 0 : _ret2.then;
            if (typeof then === "function") {
              finishCount++;
              then.call(
                ret,
                (val) => {
                  value = val;
                  if (val != null) {
                    pt.write(val);
                  }
                  if (end) {
                    pt.end();
                  }
                  process.nextTick(finish);
                },
                (err) => {
                  pt.destroy(err);
                  process.nextTick(finish, err);
                }
              );
            } else if (isIterable(ret, true)) {
              finishCount++;
              pumpToNode(ret, pt, finish, {
                end
              });
            } else if (isReadableStream(ret) || isTransformStream(ret)) {
              const toRead = ret.readable || ret;
              finishCount++;
              pumpToNode(toRead, pt, finish, {
                end
              });
            } else {
              throw new ERR_INVALID_RETURN_VALUE("AsyncIterable or Promise", "destination", ret);
            }
            ret = pt;
            const { destroy, cleanup } = destroyer(ret, false, true);
            destroys.push(destroy);
            if (isLastStream) {
              lastStreamCleanup.push(cleanup);
            }
          }
        } else if (isNodeStream(stream)) {
          if (isReadableNodeStream(ret)) {
            finishCount += 2;
            const cleanup = pipe2(ret, stream, finish, {
              end
            });
            if (isReadable(stream) && isLastStream) {
              lastStreamCleanup.push(cleanup);
            }
          } else if (isTransformStream(ret) || isReadableStream(ret)) {
            const toRead = ret.readable || ret;
            finishCount++;
            pumpToNode(toRead, stream, finish, {
              end
            });
          } else if (isIterable(ret)) {
            finishCount++;
            pumpToNode(ret, stream, finish, {
              end
            });
          } else {
            throw new ERR_INVALID_ARG_TYPE(
              "val",
              ["Readable", "Iterable", "AsyncIterable", "ReadableStream", "TransformStream"],
              ret
            );
          }
          ret = stream;
        } else if (isWebStream(stream)) {
          if (isReadableNodeStream(ret)) {
            finishCount++;
            pumpToWeb(makeAsyncIterable(ret), stream, finish, {
              end
            });
          } else if (isReadableStream(ret) || isIterable(ret)) {
            finishCount++;
            pumpToWeb(ret, stream, finish, {
              end
            });
          } else if (isTransformStream(ret)) {
            finishCount++;
            pumpToWeb(ret.readable, stream, finish, {
              end
            });
          } else {
            throw new ERR_INVALID_ARG_TYPE(
              "val",
              ["Readable", "Iterable", "AsyncIterable", "ReadableStream", "TransformStream"],
              ret
            );
          }
          ret = stream;
        } else {
          ret = Duplex.from(stream);
        }
      }
      if (signal !== null && signal !== void 0 && signal.aborted || outerSignal !== null && outerSignal !== void 0 && outerSignal.aborted) {
        process.nextTick(abort);
      }
      return ret;
    }
    function pipe2(src, dst, finish, { end }) {
      let ended = false;
      dst.on("close", () => {
        if (!ended) {
          finish(new ERR_STREAM_PREMATURE_CLOSE());
        }
      });
      src.pipe(dst, {
        end: false
      });
      if (end) {
        let endFn2 = function() {
          ended = true;
          dst.end();
        };
        var endFn = endFn2;
        if (isReadableFinished(src)) {
          process.nextTick(endFn2);
        } else {
          src.once("end", endFn2);
        }
      } else {
        finish();
      }
      eos(
        src,
        {
          readable: true,
          writable: false
        },
        (err) => {
          const rState = src._readableState;
          if (err && err.code === "ERR_STREAM_PREMATURE_CLOSE" && rState && rState.ended && !rState.errored && !rState.errorEmitted) {
            src.once("end", finish).once("error", finish);
          } else {
            finish(err);
          }
        }
      );
      return eos(
        dst,
        {
          readable: false,
          writable: true
        },
        finish
      );
    }
    module.exports = {
      pipelineImpl,
      pipeline
    };
  }
});

// node_modules/jsonld-streaming-parser/node_modules/readable-stream/lib/internal/streams/compose.js
var require_compose = __commonJS({
  "node_modules/jsonld-streaming-parser/node_modules/readable-stream/lib/internal/streams/compose.js"(exports, module) {
    "use strict";
    var { pipeline } = require_pipeline();
    var Duplex = require_duplex();
    var { destroyer } = require_destroy();
    var {
      isNodeStream,
      isReadable,
      isWritable,
      isWebStream,
      isTransformStream,
      isWritableStream,
      isReadableStream
    } = require_utils();
    var {
      AbortError,
      codes: { ERR_INVALID_ARG_VALUE, ERR_MISSING_ARGS }
    } = require_errors();
    var eos = require_end_of_stream();
    module.exports = function compose(...streams) {
      if (streams.length === 0) {
        throw new ERR_MISSING_ARGS("streams");
      }
      if (streams.length === 1) {
        return Duplex.from(streams[0]);
      }
      const orgStreams = [...streams];
      if (typeof streams[0] === "function") {
        streams[0] = Duplex.from(streams[0]);
      }
      if (typeof streams[streams.length - 1] === "function") {
        const idx = streams.length - 1;
        streams[idx] = Duplex.from(streams[idx]);
      }
      for (let n = 0; n < streams.length; ++n) {
        if (!isNodeStream(streams[n]) && !isWebStream(streams[n])) {
          continue;
        }
        if (n < streams.length - 1 && !(isReadable(streams[n]) || isReadableStream(streams[n]) || isTransformStream(streams[n]))) {
          throw new ERR_INVALID_ARG_VALUE(`streams[${n}]`, orgStreams[n], "must be readable");
        }
        if (n > 0 && !(isWritable(streams[n]) || isWritableStream(streams[n]) || isTransformStream(streams[n]))) {
          throw new ERR_INVALID_ARG_VALUE(`streams[${n}]`, orgStreams[n], "must be writable");
        }
      }
      let ondrain;
      let onfinish;
      let onreadable;
      let onclose;
      let d;
      function onfinished(err) {
        const cb = onclose;
        onclose = null;
        if (cb) {
          cb(err);
        } else if (err) {
          d.destroy(err);
        } else if (!readable && !writable) {
          d.destroy();
        }
      }
      const head = streams[0];
      const tail = pipeline(streams, onfinished);
      const writable = !!(isWritable(head) || isWritableStream(head) || isTransformStream(head));
      const readable = !!(isReadable(tail) || isReadableStream(tail) || isTransformStream(tail));
      d = new Duplex({
        // TODO (ronag): highWaterMark?
        writableObjectMode: !!(head !== null && head !== void 0 && head.writableObjectMode),
        readableObjectMode: !!(tail !== null && tail !== void 0 && tail.readableObjectMode),
        writable,
        readable
      });
      if (writable) {
        if (isNodeStream(head)) {
          d._write = function(chunk, encoding, callback) {
            if (head.write(chunk, encoding)) {
              callback();
            } else {
              ondrain = callback;
            }
          };
          d._final = function(callback) {
            head.end();
            onfinish = callback;
          };
          head.on("drain", function() {
            if (ondrain) {
              const cb = ondrain;
              ondrain = null;
              cb();
            }
          });
        } else if (isWebStream(head)) {
          const writable2 = isTransformStream(head) ? head.writable : head;
          const writer = writable2.getWriter();
          d._write = async function(chunk, encoding, callback) {
            try {
              await writer.ready;
              writer.write(chunk).catch(() => {
              });
              callback();
            } catch (err) {
              callback(err);
            }
          };
          d._final = async function(callback) {
            try {
              await writer.ready;
              writer.close().catch(() => {
              });
              onfinish = callback;
            } catch (err) {
              callback(err);
            }
          };
        }
        const toRead = isTransformStream(tail) ? tail.readable : tail;
        eos(toRead, () => {
          if (onfinish) {
            const cb = onfinish;
            onfinish = null;
            cb();
          }
        });
      }
      if (readable) {
        if (isNodeStream(tail)) {
          tail.on("readable", function() {
            if (onreadable) {
              const cb = onreadable;
              onreadable = null;
              cb();
            }
          });
          tail.on("end", function() {
            d.push(null);
          });
          d._read = function() {
            while (true) {
              const buf = tail.read();
              if (buf === null) {
                onreadable = d._read;
                return;
              }
              if (!d.push(buf)) {
                return;
              }
            }
          };
        } else if (isWebStream(tail)) {
          const readable2 = isTransformStream(tail) ? tail.readable : tail;
          const reader = readable2.getReader();
          d._read = async function() {
            while (true) {
              try {
                const { value, done } = await reader.read();
                if (!d.push(value)) {
                  return;
                }
                if (done) {
                  d.push(null);
                  return;
                }
              } catch {
                return;
              }
            }
          };
        }
      }
      d._destroy = function(err, callback) {
        if (!err && onclose !== null) {
          err = new AbortError();
        }
        onreadable = null;
        ondrain = null;
        onfinish = null;
        if (onclose === null) {
          callback(err);
        } else {
          onclose = callback;
          if (isNodeStream(tail)) {
            destroyer(tail, err);
          }
        }
      };
      return d;
    };
  }
});

// node_modules/jsonld-streaming-parser/node_modules/readable-stream/lib/internal/streams/operators.js
var require_operators = __commonJS({
  "node_modules/jsonld-streaming-parser/node_modules/readable-stream/lib/internal/streams/operators.js"(exports, module) {
    "use strict";
    var AbortController2 = globalThis.AbortController || require_browser().AbortController;
    var {
      codes: { ERR_INVALID_ARG_VALUE, ERR_INVALID_ARG_TYPE, ERR_MISSING_ARGS, ERR_OUT_OF_RANGE },
      AbortError
    } = require_errors();
    var { validateAbortSignal, validateInteger, validateObject } = require_validators();
    var kWeakHandler = require_primordials().Symbol("kWeak");
    var kResistStopPropagation = require_primordials().Symbol("kResistStopPropagation");
    var { finished } = require_end_of_stream();
    var staticCompose = require_compose();
    var { addAbortSignalNoValidate } = require_add_abort_signal();
    var { isWritable, isNodeStream } = require_utils();
    var { deprecate } = require_util();
    var {
      ArrayPrototypePush,
      Boolean: Boolean2,
      MathFloor,
      Number: Number2,
      NumberIsNaN,
      Promise: Promise2,
      PromiseReject,
      PromiseResolve,
      PromisePrototypeThen,
      Symbol: Symbol2
    } = require_primordials();
    var kEmpty = Symbol2("kEmpty");
    var kEof = Symbol2("kEof");
    function compose(stream, options) {
      if (options != null) {
        validateObject(options, "options");
      }
      if ((options === null || options === void 0 ? void 0 : options.signal) != null) {
        validateAbortSignal(options.signal, "options.signal");
      }
      if (isNodeStream(stream) && !isWritable(stream)) {
        throw new ERR_INVALID_ARG_VALUE("stream", stream, "must be writable");
      }
      const composedStream = staticCompose(this, stream);
      if (options !== null && options !== void 0 && options.signal) {
        addAbortSignalNoValidate(options.signal, composedStream);
      }
      return composedStream;
    }
    function map3(fn, options) {
      if (typeof fn !== "function") {
        throw new ERR_INVALID_ARG_TYPE("fn", ["Function", "AsyncFunction"], fn);
      }
      if (options != null) {
        validateObject(options, "options");
      }
      if ((options === null || options === void 0 ? void 0 : options.signal) != null) {
        validateAbortSignal(options.signal, "options.signal");
      }
      let concurrency = 1;
      if ((options === null || options === void 0 ? void 0 : options.concurrency) != null) {
        concurrency = MathFloor(options.concurrency);
      }
      let highWaterMark = concurrency - 1;
      if ((options === null || options === void 0 ? void 0 : options.highWaterMark) != null) {
        highWaterMark = MathFloor(options.highWaterMark);
      }
      validateInteger(concurrency, "options.concurrency", 1);
      validateInteger(highWaterMark, "options.highWaterMark", 0);
      highWaterMark += concurrency;
      return async function* map4() {
        const signal = require_util().AbortSignalAny(
          [options === null || options === void 0 ? void 0 : options.signal].filter(Boolean2)
        );
        const stream = this;
        const queue = [];
        const signalOpt = {
          signal
        };
        let next;
        let resume;
        let done = false;
        let cnt = 0;
        function onCatch() {
          done = true;
          afterItemProcessed();
        }
        function afterItemProcessed() {
          cnt -= 1;
          maybeResume();
        }
        function maybeResume() {
          if (resume && !done && cnt < concurrency && queue.length < highWaterMark) {
            resume();
            resume = null;
          }
        }
        async function pump() {
          try {
            for await (let val of stream) {
              if (done) {
                return;
              }
              if (signal.aborted) {
                throw new AbortError();
              }
              try {
                val = fn(val, signalOpt);
                if (val === kEmpty) {
                  continue;
                }
                val = PromiseResolve(val);
              } catch (err) {
                val = PromiseReject(err);
              }
              cnt += 1;
              PromisePrototypeThen(val, afterItemProcessed, onCatch);
              queue.push(val);
              if (next) {
                next();
                next = null;
              }
              if (!done && (queue.length >= highWaterMark || cnt >= concurrency)) {
                await new Promise2((resolve) => {
                  resume = resolve;
                });
              }
            }
            queue.push(kEof);
          } catch (err) {
            const val = PromiseReject(err);
            PromisePrototypeThen(val, afterItemProcessed, onCatch);
            queue.push(val);
          } finally {
            done = true;
            if (next) {
              next();
              next = null;
            }
          }
        }
        pump();
        try {
          while (true) {
            while (queue.length > 0) {
              const val = await queue[0];
              if (val === kEof) {
                return;
              }
              if (signal.aborted) {
                throw new AbortError();
              }
              if (val !== kEmpty) {
                yield val;
              }
              queue.shift();
              maybeResume();
            }
            await new Promise2((resolve) => {
              next = resolve;
            });
          }
        } finally {
          done = true;
          if (resume) {
            resume();
            resume = null;
          }
        }
      }.call(this);
    }
    function asIndexedPairs(options = void 0) {
      if (options != null) {
        validateObject(options, "options");
      }
      if ((options === null || options === void 0 ? void 0 : options.signal) != null) {
        validateAbortSignal(options.signal, "options.signal");
      }
      return async function* asIndexedPairs2() {
        let index = 0;
        for await (const val of this) {
          var _options$signal;
          if (options !== null && options !== void 0 && (_options$signal = options.signal) !== null && _options$signal !== void 0 && _options$signal.aborted) {
            throw new AbortError({
              cause: options.signal.reason
            });
          }
          yield [index++, val];
        }
      }.call(this);
    }
    async function some(fn, options = void 0) {
      for await (const unused of filter.call(this, fn, options)) {
        return true;
      }
      return false;
    }
    async function every(fn, options = void 0) {
      if (typeof fn !== "function") {
        throw new ERR_INVALID_ARG_TYPE("fn", ["Function", "AsyncFunction"], fn);
      }
      return !await some.call(
        this,
        async (...args) => {
          return !await fn(...args);
        },
        options
      );
    }
    async function find(fn, options) {
      for await (const result of filter.call(this, fn, options)) {
        return result;
      }
      return void 0;
    }
    async function forEach(fn, options) {
      if (typeof fn !== "function") {
        throw new ERR_INVALID_ARG_TYPE("fn", ["Function", "AsyncFunction"], fn);
      }
      async function forEachFn(value, options2) {
        await fn(value, options2);
        return kEmpty;
      }
      for await (const unused of map3.call(this, forEachFn, options)) ;
    }
    function filter(fn, options) {
      if (typeof fn !== "function") {
        throw new ERR_INVALID_ARG_TYPE("fn", ["Function", "AsyncFunction"], fn);
      }
      async function filterFn(value, options2) {
        if (await fn(value, options2)) {
          return value;
        }
        return kEmpty;
      }
      return map3.call(this, filterFn, options);
    }
    var ReduceAwareErrMissingArgs = class extends ERR_MISSING_ARGS {
      constructor() {
        super("reduce");
        this.message = "Reduce of an empty stream requires an initial value";
      }
    };
    async function reduce(reducer, initialValue, options) {
      var _options$signal2;
      if (typeof reducer !== "function") {
        throw new ERR_INVALID_ARG_TYPE("reducer", ["Function", "AsyncFunction"], reducer);
      }
      if (options != null) {
        validateObject(options, "options");
      }
      if ((options === null || options === void 0 ? void 0 : options.signal) != null) {
        validateAbortSignal(options.signal, "options.signal");
      }
      let hasInitialValue = arguments.length > 1;
      if (options !== null && options !== void 0 && (_options$signal2 = options.signal) !== null && _options$signal2 !== void 0 && _options$signal2.aborted) {
        const err = new AbortError(void 0, {
          cause: options.signal.reason
        });
        this.once("error", () => {
        });
        await finished(this.destroy(err));
        throw err;
      }
      const ac = new AbortController2();
      const signal = ac.signal;
      if (options !== null && options !== void 0 && options.signal) {
        const opts = {
          once: true,
          [kWeakHandler]: this,
          [kResistStopPropagation]: true
        };
        options.signal.addEventListener("abort", () => ac.abort(), opts);
      }
      let gotAnyItemFromStream = false;
      try {
        for await (const value of this) {
          var _options$signal3;
          gotAnyItemFromStream = true;
          if (options !== null && options !== void 0 && (_options$signal3 = options.signal) !== null && _options$signal3 !== void 0 && _options$signal3.aborted) {
            throw new AbortError();
          }
          if (!hasInitialValue) {
            initialValue = value;
            hasInitialValue = true;
          } else {
            initialValue = await reducer(initialValue, value, {
              signal
            });
          }
        }
        if (!gotAnyItemFromStream && !hasInitialValue) {
          throw new ReduceAwareErrMissingArgs();
        }
      } finally {
        ac.abort();
      }
      return initialValue;
    }
    async function toArray2(options) {
      if (options != null) {
        validateObject(options, "options");
      }
      if ((options === null || options === void 0 ? void 0 : options.signal) != null) {
        validateAbortSignal(options.signal, "options.signal");
      }
      const result = [];
      for await (const val of this) {
        var _options$signal4;
        if (options !== null && options !== void 0 && (_options$signal4 = options.signal) !== null && _options$signal4 !== void 0 && _options$signal4.aborted) {
          throw new AbortError(void 0, {
            cause: options.signal.reason
          });
        }
        ArrayPrototypePush(result, val);
      }
      return result;
    }
    function flatMap(fn, options) {
      const values = map3.call(this, fn, options);
      return async function* flatMap2() {
        for await (const val of values) {
          yield* val;
        }
      }.call(this);
    }
    function toIntegerOrInfinity(number4) {
      number4 = Number2(number4);
      if (NumberIsNaN(number4)) {
        return 0;
      }
      if (number4 < 0) {
        throw new ERR_OUT_OF_RANGE("number", ">= 0", number4);
      }
      return number4;
    }
    function drop(number4, options = void 0) {
      if (options != null) {
        validateObject(options, "options");
      }
      if ((options === null || options === void 0 ? void 0 : options.signal) != null) {
        validateAbortSignal(options.signal, "options.signal");
      }
      number4 = toIntegerOrInfinity(number4);
      return async function* drop2() {
        var _options$signal5;
        if (options !== null && options !== void 0 && (_options$signal5 = options.signal) !== null && _options$signal5 !== void 0 && _options$signal5.aborted) {
          throw new AbortError();
        }
        for await (const val of this) {
          var _options$signal6;
          if (options !== null && options !== void 0 && (_options$signal6 = options.signal) !== null && _options$signal6 !== void 0 && _options$signal6.aborted) {
            throw new AbortError();
          }
          if (number4-- <= 0) {
            yield val;
          }
        }
      }.call(this);
    }
    function take(number4, options = void 0) {
      if (options != null) {
        validateObject(options, "options");
      }
      if ((options === null || options === void 0 ? void 0 : options.signal) != null) {
        validateAbortSignal(options.signal, "options.signal");
      }
      number4 = toIntegerOrInfinity(number4);
      return async function* take2() {
        var _options$signal7;
        if (options !== null && options !== void 0 && (_options$signal7 = options.signal) !== null && _options$signal7 !== void 0 && _options$signal7.aborted) {
          throw new AbortError();
        }
        for await (const val of this) {
          var _options$signal8;
          if (options !== null && options !== void 0 && (_options$signal8 = options.signal) !== null && _options$signal8 !== void 0 && _options$signal8.aborted) {
            throw new AbortError();
          }
          if (number4-- > 0) {
            yield val;
          }
          if (number4 <= 0) {
            return;
          }
        }
      }.call(this);
    }
    module.exports.streamReturningOperators = {
      asIndexedPairs: deprecate(asIndexedPairs, "readable.asIndexedPairs will be removed in a future version."),
      drop,
      filter,
      flatMap,
      map: map3,
      take,
      compose
    };
    module.exports.promiseReturningOperators = {
      every,
      forEach,
      reduce,
      toArray: toArray2,
      some,
      find
    };
  }
});

// node_modules/jsonld-streaming-parser/node_modules/readable-stream/lib/stream/promises.js
var require_promises = __commonJS({
  "node_modules/jsonld-streaming-parser/node_modules/readable-stream/lib/stream/promises.js"(exports, module) {
    "use strict";
    var { ArrayPrototypePop, Promise: Promise2 } = require_primordials();
    var { isIterable, isNodeStream, isWebStream } = require_utils();
    var { pipelineImpl: pl } = require_pipeline();
    var { finished } = require_end_of_stream();
    require_stream();
    function pipeline(...streams) {
      return new Promise2((resolve, reject2) => {
        let signal;
        let end;
        const lastArg = streams[streams.length - 1];
        if (lastArg && typeof lastArg === "object" && !isNodeStream(lastArg) && !isIterable(lastArg) && !isWebStream(lastArg)) {
          const options = ArrayPrototypePop(streams);
          signal = options.signal;
          end = options.end;
        }
        pl(
          streams,
          (err, value) => {
            if (err) {
              reject2(err);
            } else {
              resolve(value);
            }
          },
          {
            signal,
            end
          }
        );
      });
    }
    module.exports = {
      finished,
      pipeline
    };
  }
});

// node_modules/jsonld-streaming-parser/node_modules/readable-stream/lib/stream.js
var require_stream = __commonJS({
  "node_modules/jsonld-streaming-parser/node_modules/readable-stream/lib/stream.js"(exports, module) {
    "use strict";
    var { Buffer: Buffer3 } = require_buffer();
    var { ObjectDefineProperty, ObjectKeys, ReflectApply } = require_primordials();
    var {
      promisify: { custom: customPromisify }
    } = require_util();
    var { streamReturningOperators, promiseReturningOperators } = require_operators();
    var {
      codes: { ERR_ILLEGAL_CONSTRUCTOR }
    } = require_errors();
    var compose = require_compose();
    var { setDefaultHighWaterMark, getDefaultHighWaterMark } = require_state();
    var { pipeline } = require_pipeline();
    var { destroyer } = require_destroy();
    var eos = require_end_of_stream();
    var promises = require_promises();
    var utils = require_utils();
    var Stream = module.exports = require_legacy().Stream;
    Stream.isDestroyed = utils.isDestroyed;
    Stream.isDisturbed = utils.isDisturbed;
    Stream.isErrored = utils.isErrored;
    Stream.isReadable = utils.isReadable;
    Stream.isWritable = utils.isWritable;
    Stream.Readable = require_readable();
    for (const key of ObjectKeys(streamReturningOperators)) {
      let fn = function(...args) {
        if (new.target) {
          throw ERR_ILLEGAL_CONSTRUCTOR();
        }
        return Stream.Readable.from(ReflectApply(op, this, args));
      };
      const op = streamReturningOperators[key];
      ObjectDefineProperty(fn, "name", {
        __proto__: null,
        value: op.name
      });
      ObjectDefineProperty(fn, "length", {
        __proto__: null,
        value: op.length
      });
      ObjectDefineProperty(Stream.Readable.prototype, key, {
        __proto__: null,
        value: fn,
        enumerable: false,
        configurable: true,
        writable: true
      });
    }
    for (const key of ObjectKeys(promiseReturningOperators)) {
      let fn = function(...args) {
        if (new.target) {
          throw ERR_ILLEGAL_CONSTRUCTOR();
        }
        return ReflectApply(op, this, args);
      };
      const op = promiseReturningOperators[key];
      ObjectDefineProperty(fn, "name", {
        __proto__: null,
        value: op.name
      });
      ObjectDefineProperty(fn, "length", {
        __proto__: null,
        value: op.length
      });
      ObjectDefineProperty(Stream.Readable.prototype, key, {
        __proto__: null,
        value: fn,
        enumerable: false,
        configurable: true,
        writable: true
      });
    }
    Stream.Writable = require_writable();
    Stream.Duplex = require_duplex();
    Stream.Transform = require_transform();
    Stream.PassThrough = require_passthrough();
    Stream.pipeline = pipeline;
    var { addAbortSignal } = require_add_abort_signal();
    Stream.addAbortSignal = addAbortSignal;
    Stream.finished = eos;
    Stream.destroy = destroyer;
    Stream.compose = compose;
    Stream.setDefaultHighWaterMark = setDefaultHighWaterMark;
    Stream.getDefaultHighWaterMark = getDefaultHighWaterMark;
    ObjectDefineProperty(Stream, "promises", {
      __proto__: null,
      configurable: true,
      enumerable: true,
      get() {
        return promises;
      }
    });
    ObjectDefineProperty(pipeline, customPromisify, {
      __proto__: null,
      enumerable: true,
      get() {
        return promises.pipeline;
      }
    });
    ObjectDefineProperty(eos, customPromisify, {
      __proto__: null,
      enumerable: true,
      get() {
        return promises.finished;
      }
    });
    Stream.Stream = Stream;
    Stream._isUint8Array = function isUint8Array(value) {
      return value instanceof Uint8Array;
    };
    Stream._uint8ArrayToBuffer = function _uint8ArrayToBuffer(chunk) {
      return Buffer3.from(chunk.buffer, chunk.byteOffset, chunk.byteLength);
    };
  }
});

// node_modules/jsonld-streaming-parser/node_modules/readable-stream/lib/ours/browser.js
var require_browser3 = __commonJS({
  "node_modules/jsonld-streaming-parser/node_modules/readable-stream/lib/ours/browser.js"(exports, module) {
    "use strict";
    var CustomStream = require_stream();
    var promises = require_promises();
    var originalDestroy = CustomStream.Readable.destroy;
    module.exports = CustomStream.Readable;
    module.exports._uint8ArrayToBuffer = CustomStream._uint8ArrayToBuffer;
    module.exports._isUint8Array = CustomStream._isUint8Array;
    module.exports.isDisturbed = CustomStream.isDisturbed;
    module.exports.isErrored = CustomStream.isErrored;
    module.exports.isReadable = CustomStream.isReadable;
    module.exports.Readable = CustomStream.Readable;
    module.exports.Writable = CustomStream.Writable;
    module.exports.Duplex = CustomStream.Duplex;
    module.exports.Transform = CustomStream.Transform;
    module.exports.PassThrough = CustomStream.PassThrough;
    module.exports.addAbortSignal = CustomStream.addAbortSignal;
    module.exports.finished = CustomStream.finished;
    module.exports.destroy = CustomStream.destroy;
    module.exports.destroy = originalDestroy;
    module.exports.pipeline = CustomStream.pipeline;
    module.exports.compose = CustomStream.compose;
    Object.defineProperty(CustomStream, "promises", {
      configurable: true,
      enumerable: true,
      get() {
        return promises;
      }
    });
    module.exports.Stream = CustomStream.Stream;
    module.exports.default = module.exports;
  }
});

// node_modules/rdf-data-factory/lib/BlankNode.js
var require_BlankNode = __commonJS({
  "node_modules/rdf-data-factory/lib/BlankNode.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BlankNode = void 0;
    var BlankNode2 = class {
      constructor(value) {
        this.termType = "BlankNode";
        this.value = value;
      }
      equals(other) {
        return !!other && other.termType === "BlankNode" && other.value === this.value;
      }
    };
    exports.BlankNode = BlankNode2;
  }
});

// node_modules/rdf-data-factory/lib/DefaultGraph.js
var require_DefaultGraph = __commonJS({
  "node_modules/rdf-data-factory/lib/DefaultGraph.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DefaultGraph = void 0;
    var DefaultGraph2 = class {
      constructor() {
        this.termType = "DefaultGraph";
        this.value = "";
      }
      equals(other) {
        return !!other && other.termType === "DefaultGraph";
      }
    };
    exports.DefaultGraph = DefaultGraph2;
    DefaultGraph2.INSTANCE = new DefaultGraph2();
  }
});

// node_modules/rdf-data-factory/lib/NamedNode.js
var require_NamedNode = __commonJS({
  "node_modules/rdf-data-factory/lib/NamedNode.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.NamedNode = void 0;
    var NamedNode2 = class {
      constructor(value) {
        this.termType = "NamedNode";
        this.value = value;
      }
      equals(other) {
        return !!other && other.termType === "NamedNode" && other.value === this.value;
      }
    };
    exports.NamedNode = NamedNode2;
  }
});

// node_modules/rdf-data-factory/lib/Literal.js
var require_Literal = __commonJS({
  "node_modules/rdf-data-factory/lib/Literal.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Literal = void 0;
    var NamedNode_1 = require_NamedNode();
    var Literal2 = class _Literal {
      constructor(value, languageOrDatatype) {
        this.termType = "Literal";
        this.value = value;
        if (typeof languageOrDatatype === "string") {
          this.language = languageOrDatatype;
          this.datatype = _Literal.RDF_LANGUAGE_STRING;
          this.direction = "";
        } else if (languageOrDatatype) {
          if ("termType" in languageOrDatatype) {
            this.language = "";
            this.datatype = languageOrDatatype;
            this.direction = "";
          } else {
            this.language = languageOrDatatype.language;
            this.datatype = languageOrDatatype.direction ? _Literal.RDF_DIRECTIONAL_LANGUAGE_STRING : _Literal.RDF_LANGUAGE_STRING;
            this.direction = languageOrDatatype.direction || "";
          }
        } else {
          this.language = "";
          this.datatype = _Literal.XSD_STRING;
          this.direction = "";
        }
      }
      equals(other) {
        return !!other && other.termType === "Literal" && other.value === this.value && other.language === this.language && (other.direction === this.direction || !other.direction && this.direction === "") && this.datatype.equals(other.datatype);
      }
    };
    exports.Literal = Literal2;
    Literal2.RDF_LANGUAGE_STRING = new NamedNode_1.NamedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#langString");
    Literal2.RDF_DIRECTIONAL_LANGUAGE_STRING = new NamedNode_1.NamedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#dirLangString");
    Literal2.XSD_STRING = new NamedNode_1.NamedNode("http://www.w3.org/2001/XMLSchema#string");
  }
});

// node_modules/rdf-data-factory/lib/Quad.js
var require_Quad = __commonJS({
  "node_modules/rdf-data-factory/lib/Quad.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Quad = void 0;
    var Quad2 = class {
      constructor(subject, predicate, object2, graph) {
        this.termType = "Quad";
        this.value = "";
        this.subject = subject;
        this.predicate = predicate;
        this.object = object2;
        this.graph = graph;
      }
      equals(other) {
        return !!other && (other.termType === "Quad" || !other.termType) && this.subject.equals(other.subject) && this.predicate.equals(other.predicate) && this.object.equals(other.object) && this.graph.equals(other.graph);
      }
    };
    exports.Quad = Quad2;
  }
});

// node_modules/rdf-data-factory/lib/Variable.js
var require_Variable = __commonJS({
  "node_modules/rdf-data-factory/lib/Variable.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Variable = void 0;
    var Variable2 = class {
      constructor(value) {
        this.termType = "Variable";
        this.value = value;
      }
      equals(other) {
        return !!other && other.termType === "Variable" && other.value === this.value;
      }
    };
    exports.Variable = Variable2;
  }
});

// node_modules/rdf-data-factory/lib/DataFactory.js
var require_DataFactory = __commonJS({
  "node_modules/rdf-data-factory/lib/DataFactory.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DataFactory = void 0;
    var BlankNode_1 = require_BlankNode();
    var DefaultGraph_1 = require_DefaultGraph();
    var Literal_1 = require_Literal();
    var NamedNode_1 = require_NamedNode();
    var Quad_1 = require_Quad();
    var Variable_1 = require_Variable();
    var dataFactoryCounter = 0;
    var DataFactory2 = class {
      constructor(options) {
        this.blankNodeCounter = 0;
        options = options || {};
        this.blankNodePrefix = options.blankNodePrefix || `df_${dataFactoryCounter++}_`;
      }
      /**
       * @param value The IRI for the named node.
       * @return A new instance of NamedNode.
       * @see NamedNode
       */
      namedNode(value) {
        return new NamedNode_1.NamedNode(value);
      }
      /**
       * @param value The optional blank node identifier.
       * @return A new instance of BlankNode.
       *         If the `value` parameter is undefined a new identifier
       *         for the blank node is generated for each call.
       * @see BlankNode
       */
      blankNode(value) {
        return new BlankNode_1.BlankNode(value || `${this.blankNodePrefix}${this.blankNodeCounter++}`);
      }
      /**
       * @param value              The literal value.
       * @param languageOrDatatype The optional language, datatype, or directional language.
       *                           If `languageOrDatatype` is a NamedNode,
       *                           then it is used for the value of `NamedNode.datatype`.
       *                           If `languageOrDatatype` is a NamedNode, it is used for the value
       *                           of `NamedNode.language`.
       *                           Otherwise, it is used as a directional language,
       *                           from which the language is set to `languageOrDatatype.language`
       *                           and the direction to `languageOrDatatype.direction`.
       * @return A new instance of Literal.
       * @see Literal
       */
      literal(value, languageOrDatatype) {
        return new Literal_1.Literal(value, languageOrDatatype);
      }
      /**
       * This method is optional.
       * @param value The variable name
       * @return A new instance of Variable.
       * @see Variable
       */
      variable(value) {
        return new Variable_1.Variable(value);
      }
      /**
       * @return An instance of DefaultGraph.
       */
      defaultGraph() {
        return DefaultGraph_1.DefaultGraph.INSTANCE;
      }
      /**
       * @param subject   The quad subject term.
       * @param predicate The quad predicate term.
       * @param object    The quad object term.
       * @param graph     The quad graph term.
       * @return A new instance of Quad.
       * @see Quad
       */
      quad(subject, predicate, object2, graph) {
        return new Quad_1.Quad(subject, predicate, object2, graph || this.defaultGraph());
      }
      /**
       * Create a deep copy of the given term using this data factory.
       * @param original An RDF term.
       * @return A deep copy of the given term.
       */
      fromTerm(original) {
        switch (original.termType) {
          case "NamedNode":
            return this.namedNode(original.value);
          case "BlankNode":
            return this.blankNode(original.value);
          case "Literal":
            if (original.language) {
              return this.literal(original.value, original.language);
            }
            if (!original.datatype.equals(Literal_1.Literal.XSD_STRING)) {
              return this.literal(original.value, this.fromTerm(original.datatype));
            }
            return this.literal(original.value);
          case "Variable":
            return this.variable(original.value);
          case "DefaultGraph":
            return this.defaultGraph();
          case "Quad":
            return this.quad(this.fromTerm(original.subject), this.fromTerm(original.predicate), this.fromTerm(original.object), this.fromTerm(original.graph));
        }
      }
      /**
       * Create a deep copy of the given quad using this data factory.
       * @param original An RDF quad.
       * @return A deep copy of the given quad.
       */
      fromQuad(original) {
        return this.fromTerm(original);
      }
      /**
       * Reset the internal blank node counter.
       */
      resetBlankNodeCounter() {
        this.blankNodeCounter = 0;
      }
    };
    exports.DataFactory = DataFactory2;
  }
});

// node_modules/rdf-data-factory/index.js
var require_rdf_data_factory = __commonJS({
  "node_modules/rdf-data-factory/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    }) : (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    }));
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p)) __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_BlankNode(), exports);
    __exportStar(require_DataFactory(), exports);
    __exportStar(require_DefaultGraph(), exports);
    __exportStar(require_Literal(), exports);
    __exportStar(require_NamedNode(), exports);
    __exportStar(require_Quad(), exports);
    __exportStar(require_Variable(), exports);
  }
});

// node_modules/jsonld-streaming-parser/lib/containerhandler/ContainerHandlerIdentifier.js
var require_ContainerHandlerIdentifier = __commonJS({
  "node_modules/jsonld-streaming-parser/lib/containerhandler/ContainerHandlerIdentifier.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ContainerHandlerIdentifier = void 0;
    var ContainerHandlerIdentifier = class {
      canCombineWithGraph() {
        return true;
      }
      async handle(containers, parsingContext, util, keys, value, depth) {
        let id;
        if (parsingContext.emittedStack[depth + 1] && parsingContext.idStack[depth + 1]) {
          id = parsingContext.idStack[depth + 1][0];
        } else {
          const keyUnaliased = await util.getContainerKey(keys[depth], keys, depth);
          const maybeId = keyUnaliased !== null ? await util.resourceToTerm(await parsingContext.getContext(keys), keys[depth]) : util.dataFactory.blankNode();
          if (!maybeId) {
            parsingContext.emittedStack[depth] = false;
            return;
          }
          id = maybeId;
          parsingContext.idStack[depth + 1] = [id];
        }
        let ids = parsingContext.idStack[depth];
        if (!ids) {
          ids = parsingContext.idStack[depth] = [];
        }
        if (!ids.some((term) => term.equals(id))) {
          ids.push(id);
        }
        if (!await parsingContext.handlePendingContainerFlushBuffers()) {
          parsingContext.emittedStack[depth] = false;
        }
      }
    };
    exports.ContainerHandlerIdentifier = ContainerHandlerIdentifier;
  }
});

// node_modules/jsonld-streaming-parser/lib/entryhandler/EntryHandlerPredicate.js
var require_EntryHandlerPredicate = __commonJS({
  "node_modules/jsonld-streaming-parser/lib/entryhandler/EntryHandlerPredicate.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.EntryHandlerPredicate = void 0;
    var jsonld_context_parser_1 = require_jsonld_context_parser();
    var Util_1 = require_Util2();
    var EntryHandlerPredicate = class _EntryHandlerPredicate {
      /**
       * Handle the given predicate-object by either emitting it,
       * or by placing it in the appropriate stack for later emission when no @graph and/or @id has been defined.
       * @param {ParsingContext} parsingContext A parsing context.
       * @param {Util} util A utility instance.
       * @param {any[]} keys A stack of keys.
       * @param {number} depth The current depth.
       * @param {Term} predicate The predicate.
       * @param {Term} object The object.
       * @param {boolean} reverse If the property is reversed.
       * @param {boolean} isEmbedded If the property exists in an embedded node as direct child.
       * @param {boolean} isAnnotation If the property exists in an annotation object.
       * @return {Promise<void>} A promise resolving when handling is done.
       */
      static async handlePredicateObject(parsingContext, util, keys, depth, predicate, object2, reverse, isEmbedded, isAnnotation) {
        const depthProperties = await util.getPropertiesDepth(keys, depth);
        const depthOffsetGraph = await util.getDepthOffsetGraph(depth, keys);
        const depthPropertiesGraph = depth - depthOffsetGraph;
        const subjects = parsingContext.idStack[depthProperties];
        if (subjects && !isAnnotation) {
          for (const subject of subjects) {
            const atGraph = depthOffsetGraph >= 0;
            if (atGraph) {
              const graphs = parsingContext.idStack[depthPropertiesGraph - 1];
              if (graphs) {
                for (const graph of graphs) {
                  util.emitQuadChecked(depth, subject, predicate, object2, graph, reverse, isEmbedded);
                }
              } else {
                if (reverse) {
                  util.validateReverseSubject(object2);
                  parsingContext.getUnidentifiedGraphBufferSafe(depthPropertiesGraph - 1).push({ subject: object2, predicate, object: subject, isEmbedded });
                } else {
                  parsingContext.getUnidentifiedGraphBufferSafe(depthPropertiesGraph - 1).push({ subject, predicate, object: object2, isEmbedded });
                }
              }
            } else {
              const graph = await util.getGraphContainerValue(keys, depthProperties);
              util.emitQuadChecked(depth, subject, predicate, object2, graph, reverse, isEmbedded);
            }
          }
        } else {
          if (reverse) {
            util.validateReverseSubject(object2);
          }
          if (isAnnotation) {
            if (parsingContext.rdfstar) {
              if (parsingContext.idStack[depth]) {
                parsingContext.emitError(new jsonld_context_parser_1.ErrorCoded(`Found an illegal @id inside an annotation: ${parsingContext.idStack[depth][0].value}`, jsonld_context_parser_1.ERROR_CODES.INVALID_ANNOTATION));
              }
              for (let i = 0; i < depth; i++) {
                if (await util.unaliasKeyword(keys[i], keys, i) === "@id") {
                  parsingContext.emitError(new jsonld_context_parser_1.ErrorCoded(`Found an illegal annotation inside an embedded node`, jsonld_context_parser_1.ERROR_CODES.INVALID_ANNOTATION));
                }
              }
              const annotationsBuffer = parsingContext.getAnnotationsBufferSafe(depthProperties);
              const newAnnotation = { predicate, object: object2, reverse, nestedAnnotations: [], depth: depthProperties };
              annotationsBuffer.push(newAnnotation);
              for (let i = annotationsBuffer.length - 2; i >= 0; i--) {
                const existingAnnotation = annotationsBuffer[i];
                if (existingAnnotation.depth > depthProperties) {
                  newAnnotation.nestedAnnotations.push(existingAnnotation);
                  annotationsBuffer.splice(i, 1);
                }
              }
            }
          } else {
            parsingContext.getUnidentifiedValueBufferSafe(depthProperties).push({ predicate, object: object2, reverse, isEmbedded });
          }
        }
      }
      isPropertyHandler() {
        return true;
      }
      isStackProcessor() {
        return true;
      }
      async validate(parsingContext, util, keys, depth, inProperty) {
        const key = keys[depth];
        if (key) {
          const context = await parsingContext.getContext(keys);
          if (!parsingContext.jsonLiteralStack[depth] && await util.predicateToTerm(context, keys[depth])) {
            if (Util_1.Util.getContextValueType(context, key) === "@json") {
              parsingContext.jsonLiteralStack[depth + 1] = true;
            }
            return true;
          }
        }
        return false;
      }
      async test(parsingContext, util, key, keys, depth) {
        return keys[depth];
      }
      async handle(parsingContext, util, key, keys, value, depth, testResult) {
        const keyOriginal = keys[depth];
        const context = await parsingContext.getContext(keys);
        const predicate = await util.predicateToTerm(context, key);
        if (predicate) {
          const objects = await util.valueToTerm(context, key, value, depth, keys);
          if (objects.length) {
            for (let object2 of objects) {
              let parentKey = await util.unaliasKeywordParent(keys, depth);
              const reverse = Util_1.Util.isPropertyReverse(context, keyOriginal, parentKey);
              let parentDepthOffset = 0;
              while (parentKey === "@reverse" || typeof parentKey === "number") {
                if (typeof parentKey === "number") {
                  parentDepthOffset++;
                } else {
                  depth--;
                }
                parentKey = await util.unaliasKeywordParent(keys, depth - parentDepthOffset);
              }
              const isEmbedded = Util_1.Util.isPropertyInEmbeddedNode(parentKey);
              util.validateReverseInEmbeddedNode(key, reverse, isEmbedded);
              const isAnnotation = Util_1.Util.isPropertyInAnnotationObject(parentKey);
              if (value) {
                const listValueContainer = "@list" in Util_1.Util.getContextValueContainer(context, key);
                if (listValueContainer || value["@list"]) {
                  if ((listValueContainer && !Array.isArray(value) && !value["@list"] || value["@list"] && !Array.isArray(value["@list"])) && object2 !== util.rdfNil) {
                    const listPointer = util.dataFactory.blankNode();
                    parsingContext.emitQuad(depth, util.dataFactory.quad(listPointer, util.rdfRest, util.rdfNil, util.getDefaultGraph()));
                    parsingContext.emitQuad(depth, util.dataFactory.quad(listPointer, util.rdfFirst, object2, util.getDefaultGraph()));
                    object2 = listPointer;
                  }
                  if (reverse && !parsingContext.allowSubjectList) {
                    throw new jsonld_context_parser_1.ErrorCoded(`Found illegal list value in subject position at ${key}`, jsonld_context_parser_1.ERROR_CODES.INVALID_REVERSE_PROPERTY_VALUE);
                  }
                }
              }
              await _EntryHandlerPredicate.handlePredicateObject(parsingContext, util, keys, depth, predicate, object2, reverse, isEmbedded, isAnnotation);
            }
          }
        }
      }
    };
    exports.EntryHandlerPredicate = EntryHandlerPredicate;
  }
});

// node_modules/jsonld-streaming-parser/lib/containerhandler/ContainerHandlerIndex.js
var require_ContainerHandlerIndex = __commonJS({
  "node_modules/jsonld-streaming-parser/lib/containerhandler/ContainerHandlerIndex.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ContainerHandlerIndex = void 0;
    var jsonld_context_parser_1 = require_jsonld_context_parser();
    var EntryHandlerPredicate_1 = require_EntryHandlerPredicate();
    var Util_1 = require_Util2();
    var ContainerHandlerIndex = class {
      canCombineWithGraph() {
        return true;
      }
      async handle(containers, parsingContext, util, keys, value, depth) {
        if (!Array.isArray(value)) {
          const graphContainer = "@graph" in containers;
          const context = await parsingContext.getContext(keys);
          const indexKey = keys[depth - 1];
          const indexPropertyRaw = Util_1.Util.getContextValueIndex(context, indexKey);
          if (indexPropertyRaw) {
            if (jsonld_context_parser_1.Util.isPotentialKeyword(indexPropertyRaw)) {
              throw new jsonld_context_parser_1.ErrorCoded(`Keywords can not be used as @index value, got: ${indexPropertyRaw}`, jsonld_context_parser_1.ERROR_CODES.INVALID_TERM_DEFINITION);
            }
            if (typeof indexPropertyRaw !== "string") {
              throw new jsonld_context_parser_1.ErrorCoded(`@index values must be strings, got: ${indexPropertyRaw}`, jsonld_context_parser_1.ERROR_CODES.INVALID_TERM_DEFINITION);
            }
            if (typeof value !== "object") {
              if (Util_1.Util.getContextValueType(context, indexKey) !== "@id") {
                throw new jsonld_context_parser_1.ErrorCoded(`Property-based index containers require nodes as values or strings with @type: @id, but got: ${value}`, jsonld_context_parser_1.ERROR_CODES.INVALID_VALUE_OBJECT);
              }
              const id = util.resourceToTerm(context, value);
              if (id) {
                parsingContext.idStack[depth + 1] = [id];
              }
            }
            const indexProperty = util.createVocabOrBaseTerm(context, indexPropertyRaw);
            if (indexProperty) {
              const indexValues = await util.valueToTerm(context, indexPropertyRaw, await util.getContainerKey(keys[depth], keys, depth), depth, keys);
              if (graphContainer) {
                const graphId = await util.getGraphContainerValue(keys, depth + 1);
                for (const indexValue of indexValues) {
                  parsingContext.emitQuad(depth, util.dataFactory.quad(graphId, indexProperty, indexValue, util.getDefaultGraph()));
                }
              } else {
                for (const indexValue of indexValues) {
                  await EntryHandlerPredicate_1.EntryHandlerPredicate.handlePredicateObject(parsingContext, util, keys, depth + 1, indexProperty, indexValue, false, false, false);
                }
              }
            }
          }
          const depthOffset = graphContainer ? 2 : 1;
          await parsingContext.newOnValueJob(keys.slice(0, keys.length - depthOffset), value, depth - depthOffset, true);
          await parsingContext.handlePendingContainerFlushBuffers();
        }
        parsingContext.emittedStack[depth] = false;
      }
    };
    exports.ContainerHandlerIndex = ContainerHandlerIndex;
  }
});

// node_modules/jsonld-streaming-parser/lib/containerhandler/ContainerHandlerLanguage.js
var require_ContainerHandlerLanguage = __commonJS({
  "node_modules/jsonld-streaming-parser/lib/containerhandler/ContainerHandlerLanguage.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ContainerHandlerLanguage = void 0;
    var jsonld_context_parser_1 = require_jsonld_context_parser();
    var ContainerHandlerLanguage = class {
      canCombineWithGraph() {
        return false;
      }
      async handle(containers, parsingContext, util, keys, value, depth) {
        const language = await util.getContainerKey(keys[depth], keys, depth);
        if (Array.isArray(value)) {
          value = value.map((subValue) => ({ "@value": subValue, "@language": language }));
        } else {
          if (typeof value !== "string") {
            throw new jsonld_context_parser_1.ErrorCoded(`Got invalid language map value, got '${JSON.stringify(value)}', but expected string`, jsonld_context_parser_1.ERROR_CODES.INVALID_LANGUAGE_MAP_VALUE);
          }
          value = { "@value": value, "@language": language };
        }
        await parsingContext.newOnValueJob(keys.slice(0, keys.length - 1), value, depth - 1, true);
        parsingContext.emittedStack[depth] = false;
      }
    };
    exports.ContainerHandlerLanguage = ContainerHandlerLanguage;
  }
});

// node_modules/jsonld-streaming-parser/lib/containerhandler/ContainerHandlerType.js
var require_ContainerHandlerType = __commonJS({
  "node_modules/jsonld-streaming-parser/lib/containerhandler/ContainerHandlerType.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ContainerHandlerType = void 0;
    var EntryHandlerPredicate_1 = require_EntryHandlerPredicate();
    var Util_1 = require_Util2();
    var ContainerHandlerType = class {
      canCombineWithGraph() {
        return false;
      }
      async handle(containers, parsingContext, util, keys, value, depth) {
        if (!Array.isArray(value)) {
          if (typeof value === "string") {
            const context = await parsingContext.getContext(keys);
            const containerTypeType = Util_1.Util.getContextValueType(context, keys[depth - 1]);
            const id = containerTypeType === "@vocab" ? await util.createVocabOrBaseTerm(context, value) : await util.resourceToTerm(context, value);
            if (id) {
              const subValue = { "@id": id.termType === "NamedNode" ? id.value : value };
              await parsingContext.newOnValueJob(keys.slice(0, keys.length - 1), subValue, depth - 1, true);
              parsingContext.idStack[depth + 1] = [id];
            }
          } else {
            const entryHasIdentifier = !!parsingContext.idStack[depth + 1];
            if (!entryHasIdentifier) {
              delete parsingContext.idStack[depth];
            }
            await parsingContext.newOnValueJob(keys.slice(0, keys.length - 1), value, depth - 1, true);
            if (!entryHasIdentifier) {
              parsingContext.idStack[depth + 1] = parsingContext.idStack[depth];
            }
          }
          const keyOriginal = await util.getContainerKey(keys[depth], keys, depth);
          const type2 = keyOriginal !== null ? util.createVocabOrBaseTerm(await parsingContext.getContext(keys), keyOriginal) : null;
          if (type2) {
            await EntryHandlerPredicate_1.EntryHandlerPredicate.handlePredicateObject(parsingContext, util, keys, depth + 1, util.rdfType, type2, false, false, false);
          }
          await parsingContext.handlePendingContainerFlushBuffers();
        }
        parsingContext.emittedStack[depth] = false;
      }
    };
    exports.ContainerHandlerType = ContainerHandlerType;
  }
});

// node_modules/jsonld-streaming-parser/lib/entryhandler/EntryHandlerContainer.js
var require_EntryHandlerContainer = __commonJS({
  "node_modules/jsonld-streaming-parser/lib/entryhandler/EntryHandlerContainer.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.EntryHandlerContainer = void 0;
    var ContainerHandlerIdentifier_1 = require_ContainerHandlerIdentifier();
    var ContainerHandlerIndex_1 = require_ContainerHandlerIndex();
    var ContainerHandlerLanguage_1 = require_ContainerHandlerLanguage();
    var ContainerHandlerType_1 = require_ContainerHandlerType();
    var Util_1 = require_Util2();
    var EntryHandlerContainer = class _EntryHandlerContainer {
      /**
       * Check fit the given container is a simple @graph container.
       * Concretely, it will check if no @index or @id is active as well.
       * @param containers A container hash.
       */
      static isSimpleGraphContainer(containers) {
        return "@graph" in containers && ("@set" in containers && Object.keys(containers).length === 2 || Object.keys(containers).length === 1);
      }
      /**
       * Check fit the given container is a complex @graph container.
       * Concretely, it will check if @index or @id is active as well next to @graph.
       * @param containers A container hash.
       */
      static isComplexGraphContainer(containers) {
        return "@graph" in containers && ("@set" in containers && Object.keys(containers).length > 2 || !("@set" in containers) && Object.keys(containers).length > 1);
      }
      /**
       * Create an graph container index that can be used for identifying a graph term inside the graphContainerTermStack.
       * @param containers The applicable containers.
       * @param depth The container depth.
       * @param keys The array of keys.
       * @return The graph index.
       */
      static getContainerGraphIndex(containers, depth, keys) {
        let isSimpleGraphContainer = _EntryHandlerContainer.isSimpleGraphContainer(containers);
        let index = "";
        for (let i = depth; i < keys.length; i++) {
          if (!isSimpleGraphContainer || typeof keys[i] === "number") {
            index += ":" + keys[i];
          }
          if (!isSimpleGraphContainer && typeof keys[i] !== "number") {
            isSimpleGraphContainer = true;
          }
        }
        return index;
      }
      /**
       * Return the applicable container type at the given depth.
       *
       * This will ignore any arrays in the key chain.
       *
       * @param {ParsingContext} parsingContext A parsing context.
       * @param {any[]} keys The array of keys.
       * @param {number} depth The current depth.
       * @return {Promise<{ containers: {[typeName: string]: boolean}, depth: number, fallback: boolean }>}
       *          All applicable containers for the given depth,
       *          the `depth` of the container root (can change when arrays are in the key chain),
       *          and the `fallback` flag that indicates if the default container type was returned
       *            (i.e., no dedicated container type is defined).
       */
      static async getContainerHandler(parsingContext, keys, depth) {
        const fallback = {
          containers: { "@set": true },
          depth,
          fallback: true
        };
        let checkGraphContainer = false;
        const context = await parsingContext.getContext(keys, 2);
        for (let i = depth - 1; i >= 0; i--) {
          if (typeof keys[i] !== "number") {
            const containersSelf = Util_1.Util.getContextValue(context, "@container", keys[i], false);
            if (containersSelf && _EntryHandlerContainer.isSimpleGraphContainer(containersSelf)) {
              return {
                containers: containersSelf,
                depth: i + 1,
                fallback: false
              };
            }
            const containersParent = Util_1.Util.getContextValue(context, "@container", keys[i - 1], false);
            if (!containersParent) {
              if (checkGraphContainer) {
                return fallback;
              }
              checkGraphContainer = true;
            } else {
              const graphContainer = "@graph" in containersParent;
              for (const containerHandleName in _EntryHandlerContainer.CONTAINER_HANDLERS) {
                if (containersParent[containerHandleName]) {
                  if (graphContainer) {
                    if (_EntryHandlerContainer.CONTAINER_HANDLERS[containerHandleName].canCombineWithGraph()) {
                      return {
                        containers: containersParent,
                        depth: i,
                        fallback: false
                      };
                    } else {
                      return fallback;
                    }
                  } else {
                    if (checkGraphContainer) {
                      return fallback;
                    } else {
                      return {
                        containers: containersParent,
                        depth: i,
                        fallback: false
                      };
                    }
                  }
                }
              }
              return fallback;
            }
          }
        }
        return fallback;
      }
      /**
       * Check if we are handling a value at the given depth
       * that is part of something that should be handled as a container,
       * AND if this container should be buffered, so that it can be handled by a dedicated container handler.
       *
       * For instance, any container with @graph will NOT be buffered.
       *
       * This will ignore any arrays in the key chain.
       *
       * @param {ParsingContext} parsingContext A parsing context.
       * @param {any[]} keys The array of keys.
       * @param {number} depth The current depth.
       * @return {Promise<boolean>} If we are in the scope of a container handler.
       */
      static async isBufferableContainerHandler(parsingContext, keys, depth) {
        const handler = await _EntryHandlerContainer.getContainerHandler(parsingContext, keys, depth);
        return !handler.fallback && !("@graph" in handler.containers);
      }
      isPropertyHandler() {
        return false;
      }
      isStackProcessor() {
        return true;
      }
      async validate(parsingContext, util, keys, depth, inProperty) {
        return !!await this.test(parsingContext, util, null, keys, depth);
      }
      async test(parsingContext, util, key, keys, depth) {
        const containers = Util_1.Util.getContextValueContainer(await parsingContext.getContext(keys, 2), keys[depth - 1]);
        for (const containerName in _EntryHandlerContainer.CONTAINER_HANDLERS) {
          if (containers[containerName]) {
            return {
              containers,
              handler: _EntryHandlerContainer.CONTAINER_HANDLERS[containerName]
            };
          }
        }
        return null;
      }
      async handle(parsingContext, util, key, keys, value, depth, testResult) {
        return testResult.handler.handle(testResult.containers, parsingContext, util, keys, value, depth);
      }
    };
    exports.EntryHandlerContainer = EntryHandlerContainer;
    EntryHandlerContainer.CONTAINER_HANDLERS = {
      "@id": new ContainerHandlerIdentifier_1.ContainerHandlerIdentifier(),
      "@index": new ContainerHandlerIndex_1.ContainerHandlerIndex(),
      "@language": new ContainerHandlerLanguage_1.ContainerHandlerLanguage(),
      "@type": new ContainerHandlerType_1.ContainerHandlerType()
    };
  }
});

// node_modules/canonicalize/lib/canonicalize.js
var require_canonicalize = __commonJS({
  "node_modules/canonicalize/lib/canonicalize.js"(exports, module) {
    "use strict";
    module.exports = function serialize(object2) {
      if (object2 === null || typeof object2 !== "object" || object2.toJSON != null) {
        return JSON.stringify(object2);
      }
      if (Array.isArray(object2)) {
        return "[" + object2.reduce((t, cv, ci) => {
          const comma = ci === 0 ? "" : ",";
          const value = cv === void 0 || typeof cv === "symbol" ? null : cv;
          return t + comma + serialize(value);
        }, "") + "]";
      }
      return "{" + Object.keys(object2).sort().reduce((t, cv, ci) => {
        if (object2[cv] === void 0 || typeof object2[cv] === "symbol") {
          return t;
        }
        const comma = t.length === 0 ? "" : ",";
        return t + comma + serialize(cv) + ":" + serialize(object2[cv]);
      }, "") + "}";
    };
  }
});

// node_modules/jsonld-streaming-parser/lib/Util.js
var require_Util2 = __commonJS({
  "node_modules/jsonld-streaming-parser/lib/Util.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Util = void 0;
    var jsonld_context_parser_1 = require_jsonld_context_parser();
    var rdf_data_factory_1 = require_rdf_data_factory();
    var EntryHandlerContainer_1 = require_EntryHandlerContainer();
    var canonicalizeJson = require_canonicalize();
    var Util = class _Util {
      constructor(options) {
        this.parsingContext = options.parsingContext;
        this.dataFactory = options.dataFactory || new rdf_data_factory_1.DataFactory();
        this.rdfFirst = this.dataFactory.namedNode(_Util.RDF + "first");
        this.rdfRest = this.dataFactory.namedNode(_Util.RDF + "rest");
        this.rdfNil = this.dataFactory.namedNode(_Util.RDF + "nil");
        this.rdfType = this.dataFactory.namedNode(_Util.RDF + "type");
        this.rdfJson = this.dataFactory.namedNode(_Util.RDF + "JSON");
      }
      /**
       * Helper function to get the value of a context entry,
       * or fallback to a certain value.
       * @param {JsonLdContextNormalized} context A JSON-LD context.
       * @param {string} contextKey A pre-defined JSON-LD key in context entries.
       * @param {string} key A context entry key.
       * @param {string} fallback A fallback value for when the given contextKey
       *                          could not be found in the value with the given key.
       * @return {string} The value of the given contextKey in the entry behind key in the given context,
       *                  or the given fallback value.
       */
      static getContextValue(context, contextKey, key, fallback) {
        const entry = context.getContextRaw()[key];
        if (!entry) {
          return fallback;
        }
        const type2 = entry[contextKey];
        return type2 === void 0 ? fallback : type2;
      }
      /**
       * Get the container type of the given key in the context.
       *
       * Should any context-scoping bugs should occur related to this in the future,
       * it may be required to increase the offset from the depth at which the context is retrieved by one (to 2).
       * This is because containers act 2 levels deep.
       *
       * @param {JsonLdContextNormalized} context A JSON-LD context.
       * @param {string} key A context entry key.
       * @return {string} The container type.
       */
      static getContextValueContainer(context, key) {
        return _Util.getContextValue(context, "@container", key, { "@set": true });
      }
      /**
       * Get the value type of the given key in the context.
       * @param {JsonLdContextNormalized} context A JSON-LD context.
       * @param {string} key A context entry key.
       * @return {string} The node type.
       */
      static getContextValueType(context, key) {
        const valueType = _Util.getContextValue(context, "@type", key, null);
        if (valueType === "@none") {
          return null;
        }
        return valueType;
      }
      /**
       * Get the language of the given key in the context.
       * @param {JsonLdContextNormalized} context A JSON-LD context.
       * @param {string} key A context entry key.
       * @return {string} The node type.
       */
      static getContextValueLanguage(context, key) {
        return _Util.getContextValue(context, "@language", key, context.getContextRaw()["@language"] || null);
      }
      /**
       * Get the direction of the given key in the context.
       * @param {JsonLdContextNormalized} context A JSON-LD context.
       * @param {string} key A context entry key.
       * @return {string} The node type.
       */
      static getContextValueDirection(context, key) {
        return _Util.getContextValue(context, "@direction", key, context.getContextRaw()["@direction"] || null);
      }
      /**
       * Check if the given key in the context is a reversed property.
       * @param {JsonLdContextNormalized} context A JSON-LD context.
       * @param {string} key A context entry key.
       * @return {boolean} If the context value has a @reverse key.
       */
      static isContextValueReverse(context, key) {
        return !!_Util.getContextValue(context, "@reverse", key, null);
      }
      /**
       * Get the @index of the given key in the context.
       * @param {JsonLdContextNormalized} context A JSON-LD context.
       * @param {string} key A context entry key.
       * @return {string} The index.
       */
      static getContextValueIndex(context, key) {
        return _Util.getContextValue(context, "@index", key, context.getContextRaw()["@index"] || null);
      }
      /**
       * Check if the given key refers to a reversed property.
       * @param {JsonLdContextNormalized} context A JSON-LD context.
       * @param {string} key The property key.
       * @param {string} parentKey The parent key.
       * @return {boolean} If the property must be reversed.
       */
      static isPropertyReverse(context, key, parentKey) {
        return parentKey === "@reverse" !== _Util.isContextValueReverse(context, key);
      }
      /**
       * Check if the given key exists inside an embedded node as direct child.
       * @param {string} parentKey The parent key.
       * @return {boolean} If the property is embedded.
       */
      static isPropertyInEmbeddedNode(parentKey) {
        return parentKey === "@id";
      }
      /**
       * Check if the given key exists inside an annotation object as direct child.
       * @param {string} parentKey The parent key.
       * @return {boolean} If the property is an annotation.
       */
      static isPropertyInAnnotationObject(parentKey) {
        return parentKey === "@annotation";
      }
      /**
       * Check if the given IRI is valid.
       * @param {string} iri A potential IRI.
       * @return {boolean} If the given IRI is valid.
       */
      static isValidIri(iri) {
        return iri !== null && jsonld_context_parser_1.Util.isValidIri(iri);
      }
      /**
       * Check if the given first array (needle) is a prefix of the given second array (haystack).
       * @param needle An array to check if it is a prefix.
       * @param haystack An array to look in.
       */
      static isPrefixArray(needle, haystack) {
        if (needle.length > haystack.length) {
          return false;
        }
        for (let i = 0; i < needle.length; i++) {
          if (needle[i] !== haystack[i]) {
            return false;
          }
        }
        return true;
      }
      /**
       * Make sure that @id-@index pairs are equal over all array values.
       * Reject otherwise.
       * @param {any[]} value An array value.
       * @return {Promise<void>} A promise rejecting if conflicts are present.
       */
      async validateValueIndexes(value) {
        if (this.parsingContext.validateValueIndexes) {
          const indexHashes = {};
          for (const entry of value) {
            if (entry && typeof entry === "object") {
              const id = entry["@id"];
              const index = entry["@index"];
              if (id && index) {
                const existingIndexValue = indexHashes[id];
                if (existingIndexValue && existingIndexValue !== index) {
                  throw new jsonld_context_parser_1.ErrorCoded(`Conflicting @index value for ${id}`, jsonld_context_parser_1.ERROR_CODES.CONFLICTING_INDEXES);
                }
                indexHashes[id] = index;
              }
            }
          }
        }
      }
      /**
       * Convert a given JSON value to an RDF term.
       * @param {JsonLdContextNormalized} context A JSON-LD context.
       * @param {string} key The current JSON key.
       * @param value A JSON value.
       * @param {number} depth The depth the value is at.
       * @param {string[]} keys The path of keys.
       * @return {Promise<RDF.Term[]>} An RDF term array.
       */
      async valueToTerm(context, key, value, depth, keys) {
        if (_Util.getContextValueType(context, key) === "@json") {
          return [this.dataFactory.literal(this.valueToJsonString(value), this.rdfJson)];
        }
        const type2 = typeof value;
        switch (type2) {
          case "object":
            if (value === null || value === void 0) {
              return [];
            }
            if (Array.isArray(value)) {
              if ("@list" in _Util.getContextValueContainer(context, key)) {
                if (value.length === 0) {
                  return [this.rdfNil];
                } else {
                  return this.parsingContext.idStack[depth + 1] || [];
                }
              }
              await this.validateValueIndexes(value);
              return [];
            }
            context = await this.getContextSelfOrPropertyScoped(context, key);
            if ("@context" in value) {
              context = await this.parsingContext.parseContext(value["@context"], (await this.parsingContext.getContext(keys, 0)).getContextRaw());
            }
            value = await this.unaliasKeywords(value, keys, depth, context);
            if ("@value" in value) {
              let val;
              let valueLanguage;
              let valueDirection;
              let valueType;
              let valueIndex;
              for (key in value) {
                const subValue = value[key];
                switch (key) {
                  case "@value":
                    val = subValue;
                    break;
                  case "@language":
                    valueLanguage = subValue;
                    break;
                  case "@direction":
                    valueDirection = subValue;
                    break;
                  case "@type":
                    valueType = subValue;
                    break;
                  case "@index":
                    valueIndex = subValue;
                    break;
                  case "@annotation":
                    break;
                  default:
                    throw new jsonld_context_parser_1.ErrorCoded(`Unknown value entry '${key}' in @value: ${JSON.stringify(value)}`, jsonld_context_parser_1.ERROR_CODES.INVALID_VALUE_OBJECT);
                }
              }
              if (await this.unaliasKeyword(valueType, keys, depth, true, context) === "@json") {
                return [this.dataFactory.literal(this.valueToJsonString(val), this.rdfJson)];
              }
              if (val === null) {
                return [];
              }
              if (typeof val === "object") {
                throw new jsonld_context_parser_1.ErrorCoded(`The value of an '@value' can not be an object, got '${JSON.stringify(val)}'`, jsonld_context_parser_1.ERROR_CODES.INVALID_VALUE_OBJECT_VALUE);
              }
              if (this.parsingContext.validateValueIndexes && valueIndex && typeof valueIndex !== "string") {
                throw new jsonld_context_parser_1.ErrorCoded(`The value of an '@index' must be a string, got '${JSON.stringify(valueIndex)}'`, jsonld_context_parser_1.ERROR_CODES.INVALID_INDEX_VALUE);
              }
              if (valueLanguage) {
                if (typeof val !== "string") {
                  throw new jsonld_context_parser_1.ErrorCoded(`When an '@language' is set, the value of '@value' must be a string, got '${JSON.stringify(val)}'`, jsonld_context_parser_1.ERROR_CODES.INVALID_LANGUAGE_TAGGED_VALUE);
                }
                if (!jsonld_context_parser_1.ContextParser.validateLanguage(valueLanguage, this.parsingContext.strictValues, jsonld_context_parser_1.ERROR_CODES.INVALID_LANGUAGE_TAGGED_STRING)) {
                  return [];
                }
                if (this.parsingContext.normalizeLanguageTags || this.parsingContext.activeProcessingMode === 1) {
                  valueLanguage = valueLanguage.toLowerCase();
                }
              }
              if (valueDirection) {
                if (typeof val !== "string") {
                  throw new Error(`When an '@direction' is set, the value of '@value' must be a string, got '${JSON.stringify(val)}'`);
                }
                if (!jsonld_context_parser_1.ContextParser.validateDirection(valueDirection, this.parsingContext.strictValues)) {
                  return [];
                }
              }
              if (valueLanguage && valueDirection) {
                if (valueType) {
                  throw new jsonld_context_parser_1.ErrorCoded(`Can not have '@language', '@direction' and '@type' in a value: '${JSON.stringify(value)}'`, jsonld_context_parser_1.ERROR_CODES.INVALID_VALUE_OBJECT);
                }
                return this.nullableTermToArray(this.createLanguageDirectionLiteral(depth, val, valueLanguage, valueDirection));
              } else if (valueLanguage) {
                if (valueType) {
                  throw new jsonld_context_parser_1.ErrorCoded(`Can not have both '@language' and '@type' in a value: '${JSON.stringify(value)}'`, jsonld_context_parser_1.ERROR_CODES.INVALID_VALUE_OBJECT);
                }
                return [this.dataFactory.literal(val, valueLanguage)];
              } else if (valueDirection) {
                if (valueType) {
                  throw new jsonld_context_parser_1.ErrorCoded(`Can not have both '@direction' and '@type' in a value: '${JSON.stringify(value)}'`, jsonld_context_parser_1.ERROR_CODES.INVALID_VALUE_OBJECT);
                }
                return this.nullableTermToArray(this.createLanguageDirectionLiteral(depth, val, valueLanguage, valueDirection));
              } else if (valueType) {
                if (typeof valueType !== "string") {
                  throw new jsonld_context_parser_1.ErrorCoded(`The value of an '@type' must be a string, got '${JSON.stringify(valueType)}'`, jsonld_context_parser_1.ERROR_CODES.INVALID_TYPED_VALUE);
                }
                const typeTerm = this.createVocabOrBaseTerm(context, valueType);
                if (!typeTerm) {
                  throw new jsonld_context_parser_1.ErrorCoded(`Invalid '@type' value, got '${JSON.stringify(valueType)}'`, jsonld_context_parser_1.ERROR_CODES.INVALID_TYPED_VALUE);
                }
                if (typeTerm.termType !== "NamedNode") {
                  throw new jsonld_context_parser_1.ErrorCoded(`Illegal value type (${typeTerm.termType}): ${valueType}`, jsonld_context_parser_1.ERROR_CODES.INVALID_TYPED_VALUE);
                }
                return [this.dataFactory.literal(val, typeTerm)];
              }
              return await this.valueToTerm(new jsonld_context_parser_1.JsonLdContextNormalized({}), key, val, depth, keys);
            } else if ("@set" in value) {
              if (Object.keys(value).length > 1) {
                throw new jsonld_context_parser_1.ErrorCoded(`Found illegal neighbouring entries next to @set for key: '${key}'`, jsonld_context_parser_1.ERROR_CODES.INVALID_SET_OR_LIST_OBJECT);
              }
              return [];
            } else if ("@list" in value) {
              if (Object.keys(value).length > 1) {
                throw new jsonld_context_parser_1.ErrorCoded(`Found illegal neighbouring entries next to @list for key: '${key}'`, jsonld_context_parser_1.ERROR_CODES.INVALID_SET_OR_LIST_OBJECT);
              }
              const listValue = value["@list"];
              if (Array.isArray(listValue)) {
                if (listValue.length === 0) {
                  return [this.rdfNil];
                } else {
                  return this.parsingContext.idStack[depth + 1] || [];
                }
              } else {
                return await this.valueToTerm(await this.parsingContext.getContext(keys), key, listValue, depth - 1, keys.slice(0, -1));
              }
            } else if ("@reverse" in value && typeof value["@reverse"] === "boolean") {
              return [];
            } else if ("@graph" in _Util.getContextValueContainer(await this.parsingContext.getContext(keys), key)) {
              const graphContainerEntries = this.parsingContext.graphContainerTermStack[depth + 1];
              return graphContainerEntries ? Object.values(graphContainerEntries) : [this.dataFactory.blankNode()];
            } else if ("@id" in value) {
              if (Object.keys(value).length > 1) {
                context = await this.parsingContext.getContext(keys, 0);
              }
              if ("@context" in value) {
                context = await this.parsingContext.parseContext(value["@context"], context.getContextRaw());
              }
              if (value["@type"] === "@vocab") {
                return this.nullableTermToArray(this.createVocabOrBaseTerm(context, value["@id"]));
              } else {
                const valueId = value["@id"];
                let valueTerm;
                if (typeof valueId === "object") {
                  if (this.parsingContext.rdfstar) {
                    valueTerm = this.parsingContext.idStack[depth + 1][0];
                  } else {
                    throw new jsonld_context_parser_1.ErrorCoded(`Found illegal @id '${value}'`, jsonld_context_parser_1.ERROR_CODES.INVALID_ID_VALUE);
                  }
                } else {
                  valueTerm = this.resourceToTerm(context, valueId);
                }
                return this.nullableTermToArray(valueTerm);
              }
            } else {
              if (this.parsingContext.emittedStack[depth + 1] || value && typeof value === "object" && Object.keys(value).length === 0) {
                return this.parsingContext.idStack[depth + 1] || (this.parsingContext.idStack[depth + 1] = [this.dataFactory.blankNode()]);
              } else {
                return [];
              }
            }
          case "string":
            return this.nullableTermToArray(this.stringValueToTerm(depth, await this.getContextSelfOrPropertyScoped(context, key), key, value, null));
          case "boolean":
            return this.nullableTermToArray(this.stringValueToTerm(depth, await this.getContextSelfOrPropertyScoped(context, key), key, Boolean(value).toString(), this.dataFactory.namedNode(_Util.XSD_BOOLEAN)));
          case "number":
            return this.nullableTermToArray(this.stringValueToTerm(depth, await this.getContextSelfOrPropertyScoped(context, key), key, value, this.dataFactory.namedNode(value % 1 === 0 && value < 1e21 ? _Util.XSD_INTEGER : _Util.XSD_DOUBLE)));
          default:
            this.parsingContext.emitError(new Error(`Could not determine the RDF type of a ${type2}`));
            return [];
        }
      }
      /**
       * If the context defines a property-scoped context for the given key,
       * that context will be returned.
       * Otherwise, the given context will be returned as-is.
       *
       * This should be used for valueToTerm cases that are not objects.
       * @param context A context.
       * @param key A JSON key.
       */
      async getContextSelfOrPropertyScoped(context, key) {
        const contextKeyEntry = context.getContextRaw()[key];
        if (contextKeyEntry && typeof contextKeyEntry === "object" && "@context" in contextKeyEntry) {
          context = await this.parsingContext.parseContext(contextKeyEntry, context.getContextRaw(), true);
        }
        return context;
      }
      /**
       * If the given term is null, return an empty array, otherwise return an array with the single given term.
       * @param term A term.
       */
      nullableTermToArray(term) {
        return term ? [term] : [];
      }
      /**
       * Convert a given JSON key to an RDF predicate term,
       * based on @vocab.
       * @param {JsonLdContextNormalized} context A JSON-LD context.
       * @param key A JSON key.
       * @return {RDF.NamedNode} An RDF named node.
       */
      predicateToTerm(context, key) {
        const expanded = context.expandTerm(key, true, this.parsingContext.getExpandOptions());
        if (!expanded) {
          return null;
        }
        if (expanded[0] === "_" && expanded[1] === ":") {
          if (this.parsingContext.produceGeneralizedRdf) {
            return this.dataFactory.blankNode(expanded.substr(2));
          } else {
            return null;
          }
        }
        if (_Util.isValidIri(expanded)) {
          return this.dataFactory.namedNode(expanded);
        } else {
          if (expanded && this.parsingContext.strictValues) {
            this.parsingContext.emitError(new jsonld_context_parser_1.ErrorCoded(`Invalid predicate IRI: ${expanded}`, jsonld_context_parser_1.ERROR_CODES.INVALID_IRI_MAPPING));
          } else {
            return null;
          }
        }
        return null;
      }
      /**
       * Convert a given JSON key to an RDF resource term or blank node,
       * based on @base.
       * @param {JsonLdContextNormalized} context A JSON-LD context.
       * @param key A JSON key.
       * @return {RDF.NamedNode} An RDF named node or null.
       */
      resourceToTerm(context, key) {
        if (key.startsWith("_:")) {
          return this.dataFactory.blankNode(key.substr(2));
        }
        const iri = context.expandTerm(key, false, this.parsingContext.getExpandOptions());
        if (!_Util.isValidIri(iri)) {
          if (iri && this.parsingContext.strictValues) {
            this.parsingContext.emitError(new Error(`Invalid resource IRI: ${iri}`));
          } else {
            return null;
          }
        }
        return this.dataFactory.namedNode(iri);
      }
      /**
       * Convert a given JSON key to an RDF resource term.
       * It will do this based on the @vocab,
       * and fallback to @base.
       * @param {JsonLdContextNormalized} context A JSON-LD context.
       * @param key A JSON key.
       * @return {RDF.NamedNode} An RDF named node or null.
       */
      createVocabOrBaseTerm(context, key) {
        if (key.startsWith("_:")) {
          return this.dataFactory.blankNode(key.substr(2));
        }
        const expandOptions = this.parsingContext.getExpandOptions();
        let expanded = context.expandTerm(key, true, expandOptions);
        if (expanded === key) {
          expanded = context.expandTerm(key, false, expandOptions);
        }
        if (!_Util.isValidIri(expanded)) {
          if (expanded && this.parsingContext.strictValues && !expanded.startsWith("@")) {
            this.parsingContext.emitError(new Error(`Invalid term IRI: ${expanded}`));
          } else {
            return null;
          }
        }
        return this.dataFactory.namedNode(expanded);
      }
      /**
       * Ensure that the given value becomes a string.
       * @param {string | number} value A string or number.
       * @param {NamedNode} datatype The intended datatype.
       * @return {string} The returned string.
       */
      intToString(value, datatype) {
        if (typeof value === "number") {
          if (Number.isFinite(value)) {
            const isInteger2 = value % 1 === 0;
            if (isInteger2 && (!datatype || datatype.value !== _Util.XSD_DOUBLE)) {
              return Number(value).toString();
            } else {
              return value.toExponential(15).replace(/(\d)0*e\+?/, "$1E");
            }
          } else {
            return value > 0 ? "INF" : "-INF";
          }
        } else {
          return value;
        }
      }
      /**
       * Convert a given JSON string value to an RDF term.
       * @param {number} depth The current stack depth.
       * @param {JsonLdContextNormalized} context A JSON-LD context.
       * @param {string} key The current JSON key.
       * @param {string} value A JSON value.
       * @param {NamedNode} defaultDatatype The default datatype for the given value.
       * @return {RDF.Term} An RDF term or null.
       */
      stringValueToTerm(depth, context, key, value, defaultDatatype) {
        const contextType = _Util.getContextValueType(context, key);
        if (contextType) {
          if (contextType === "@id") {
            if (!defaultDatatype) {
              return this.resourceToTerm(context, this.intToString(value, defaultDatatype));
            }
          } else if (contextType === "@vocab") {
            if (!defaultDatatype) {
              return this.createVocabOrBaseTerm(context, this.intToString(value, defaultDatatype));
            }
          } else {
            defaultDatatype = this.dataFactory.namedNode(contextType);
          }
        }
        if (!defaultDatatype) {
          const contextLanguage = _Util.getContextValueLanguage(context, key);
          const contextDirection = _Util.getContextValueDirection(context, key);
          if (contextDirection) {
            return this.createLanguageDirectionLiteral(depth, this.intToString(value, defaultDatatype), contextLanguage, contextDirection);
          } else {
            return this.dataFactory.literal(this.intToString(value, defaultDatatype), contextLanguage);
          }
        }
        return this.dataFactory.literal(this.intToString(value, defaultDatatype), defaultDatatype);
      }
      /**
       * Create a literal for the given value with the given language and direction.
       * Auxiliary quads may be emitted.
       * @param {number} depth The current stack depth.
       * @param {string} value A string value.
       * @param {string} language A language tag.
       * @param {string} direction A direction.
       * @return {Term} An RDF term.
       */
      createLanguageDirectionLiteral(depth, value, language, direction) {
        if (this.parsingContext.rdfDirection === "i18n-datatype") {
          if (!language) {
            language = "";
          }
          return this.dataFactory.literal(value, this.dataFactory.namedNode(`https://www.w3.org/ns/i18n#${language}_${direction}`));
        } else if (this.parsingContext.rdfDirection === "compound-literal") {
          const valueNode = this.dataFactory.blankNode();
          const graph = this.getDefaultGraph();
          this.parsingContext.emitQuad(depth, this.dataFactory.quad(valueNode, this.dataFactory.namedNode(_Util.RDF + "value"), this.dataFactory.literal(value), graph));
          if (language) {
            this.parsingContext.emitQuad(depth, this.dataFactory.quad(valueNode, this.dataFactory.namedNode(_Util.RDF + "language"), this.dataFactory.literal(language), graph));
          }
          this.parsingContext.emitQuad(depth, this.dataFactory.quad(valueNode, this.dataFactory.namedNode(_Util.RDF + "direction"), this.dataFactory.literal(direction), graph));
          return valueNode;
        } else {
          return this.dataFactory.literal(value, { language: language || "", direction });
        }
      }
      /**
       * Stringify the given JSON object to a canonical JSON string.
       * @param value Any valid JSON value.
       * @return {string} A canonical JSON string.
       */
      valueToJsonString(value) {
        return canonicalizeJson(value);
      }
      /**
       * If the key is not a keyword, try to check if it is an alias for a keyword,
       * and if so, un-alias it.
       * @param {string} key A key, can be falsy.
       * @param {string[]} keys The path of keys.
       * @param {number} depth The depth to
       * @param {boolean} disableCache If the cache should be disabled
       * @param {JsonLdContextNormalized} context A context to unalias with,
       *                                           will fallback to retrieving the context for the given keys.
       * @return {Promise<string>} A promise resolving to the key itself, or another key.
       */
      async unaliasKeyword(key, keys, depth, disableCache, context) {
        if (Number.isInteger(key)) {
          return key;
        }
        if (!disableCache) {
          const cachedUnaliasedKeyword = this.parsingContext.unaliasedKeywordCacheStack[depth];
          if (cachedUnaliasedKeyword) {
            return cachedUnaliasedKeyword;
          }
        }
        if (!jsonld_context_parser_1.Util.isPotentialKeyword(key)) {
          context = context || await this.parsingContext.getContext(keys);
          let unliased = context.getContextRaw()[key];
          if (unliased && typeof unliased === "object") {
            unliased = unliased["@id"];
          }
          if (jsonld_context_parser_1.Util.isValidKeyword(unliased)) {
            key = unliased;
          }
        }
        return disableCache ? key : this.parsingContext.unaliasedKeywordCacheStack[depth] = key;
      }
      /**
       * Unalias the keyword of the parent.
       * This adds a safety check if no parent exist.
       * @param {any[]} keys A stack of keys.
       * @param {number} depth The current depth.
       * @return {Promise<any>} A promise resolving to the parent key, or another key.
       */
      async unaliasKeywordParent(keys, depth) {
        return await this.unaliasKeyword(depth > 0 && keys[depth - 1], keys, depth - 1);
      }
      /**
       * Un-alias all keywords in the given hash.
       * @param {{[p: string]: any}} hash A hash object.
       * @param {string[]} keys The path of keys.
       * @param {number} depth The depth.
       * @param {JsonLdContextNormalized} context A context to unalias with,
       *                                           will fallback to retrieving the context for the given keys.
       * @return {Promise<{[p: string]: any}>} A promise resolving to the new hash.
       */
      async unaliasKeywords(hash2, keys, depth, context) {
        const newHash = {};
        for (const key in hash2) {
          newHash[await this.unaliasKeyword(key, keys, depth + 1, true, context)] = hash2[key];
        }
        return newHash;
      }
      /**
       * Check if we are processing a literal (including JSON literals) at the given depth.
       * This will also check higher levels,
       * because if a parent is a literal,
       * then the deeper levels are definitely a literal as well.
       * @param {any[]} keys The keys.
       * @param {number} depth The depth.
       * @return {boolean} If we are processing a literal.
       */
      async isLiteral(keys, depth) {
        for (let i = depth; i >= 0; i--) {
          if (await this.unaliasKeyword(keys[i], keys, i) === "@annotation") {
            return false;
          }
          if (this.parsingContext.literalStack[i] || this.parsingContext.jsonLiteralStack[i]) {
            return true;
          }
        }
        return false;
      }
      /**
       * Check how many parents should be skipped for checking the @graph for the given node.
       *
       * @param {number} depth The depth of the node.
       * @param {any[]} keys An array of keys.
       * @return {number} The graph depth offset.
       */
      async getDepthOffsetGraph(depth, keys) {
        for (let i = depth - 1; i > 0; i--) {
          if (await this.unaliasKeyword(keys[i], keys, i) === "@graph") {
            const containers = (await EntryHandlerContainer_1.EntryHandlerContainer.getContainerHandler(this.parsingContext, keys, i)).containers;
            if (EntryHandlerContainer_1.EntryHandlerContainer.isComplexGraphContainer(containers)) {
              return -1;
            }
            return depth - i - 1;
          }
        }
        return -1;
      }
      /**
       * Check if the given subject is of a valid type.
       * This should be called when applying @reverse'd properties.
       * @param {Term} subject A subject.
       */
      validateReverseSubject(subject) {
        if (subject.termType === "Literal") {
          throw new jsonld_context_parser_1.ErrorCoded(`Found illegal literal in subject position: ${subject.value}`, jsonld_context_parser_1.ERROR_CODES.INVALID_REVERSE_PROPERTY_VALUE);
        }
      }
      /**
       * Get the default graph.
       * @return {Term} An RDF term.
       */
      getDefaultGraph() {
        return this.parsingContext.defaultGraph || this.dataFactory.defaultGraph();
      }
      /**
       * Get the current graph, while taking into account a graph that can be defined via @container: @graph.
       * If not within a graph container, the default graph will be returned.
       * @param keys The current keys.
       * @param depth The current depth.
       */
      async getGraphContainerValue(keys, depth) {
        let graph = this.getDefaultGraph();
        const { containers, depth: depthContainer } = await EntryHandlerContainer_1.EntryHandlerContainer.getContainerHandler(this.parsingContext, keys, depth);
        if ("@graph" in containers) {
          const graphContainerIndex = EntryHandlerContainer_1.EntryHandlerContainer.getContainerGraphIndex(containers, depthContainer, keys);
          const entry = this.parsingContext.graphContainerTermStack[depthContainer];
          graph = entry ? entry[graphContainerIndex] : null;
          if (!graph) {
            let graphId = null;
            if ("@id" in containers) {
              const keyUnaliased = await this.getContainerKey(keys[depthContainer], keys, depthContainer);
              if (keyUnaliased !== null) {
                graphId = await this.resourceToTerm(await this.parsingContext.getContext(keys), keyUnaliased);
              }
            }
            if (!graphId) {
              graphId = this.dataFactory.blankNode();
            }
            if (!this.parsingContext.graphContainerTermStack[depthContainer]) {
              this.parsingContext.graphContainerTermStack[depthContainer] = {};
            }
            graph = this.parsingContext.graphContainerTermStack[depthContainer][graphContainerIndex] = graphId;
          }
        }
        return graph;
      }
      /**
       * Get the properties depth for retrieving properties.
       *
       * Typically, the properties depth will be identical to the given depth.
       *
       * The following exceptions apply:
       * * When the parent is @reverse, the depth is decremented by one.
       * * When @nest parents are found, the depth is decremented by the number of @nest parents.
       * If in combination with the exceptions above an intermediary array is discovered,
       * the depth is also decremented by this number of arrays.
       *
       * @param keys The current key chain.
       * @param depth The current depth.
       */
      async getPropertiesDepth(keys, depth) {
        let lastValidDepth = depth;
        for (let i = depth - 1; i > 0; i--) {
          if (typeof keys[i] !== "number") {
            const parentKey = await this.unaliasKeyword(keys[i], keys, i);
            if (parentKey === "@reverse") {
              return i;
            } else if (parentKey === "@nest") {
              lastValidDepth = i;
            } else {
              return lastValidDepth;
            }
          }
        }
        return lastValidDepth;
      }
      /**
       * Get the key for the current container entry.
       * @param key A key, can be falsy.
       * @param keys The key chain.
       * @param depth The current depth to get the key from.
       * @return Promise resolving to the key.
       *         Null will be returned for @none entries, with aliasing taken into account.
       */
      async getContainerKey(key, keys, depth) {
        const keyUnaliased = await this.unaliasKeyword(key, keys, depth);
        return keyUnaliased === "@none" ? null : keyUnaliased;
      }
      /**
       * Check if no reverse properties are present in embedded nodes.
       * @param key The current key.
       * @param reverse If a reverse property is active.
       * @param isEmbedded If we're in an embedded node.
       */
      validateReverseInEmbeddedNode(key, reverse, isEmbedded) {
        if (isEmbedded && reverse && !this.parsingContext.rdfstarReverseInEmbedded) {
          throw new jsonld_context_parser_1.ErrorCoded(`Illegal reverse property in embedded node in ${key}`, jsonld_context_parser_1.ERROR_CODES.INVALID_EMBEDDED_NODE);
        }
      }
      /**
       * Emit a quad, with checks.
       * @param depth The current depth.
       * @param subject S
       * @param predicate P
       * @param object O
       * @param graph G
       * @param reverse If a reverse property is active.
       * @param isEmbedded If we're in an embedded node.
       */
      emitQuadChecked(depth, subject, predicate, object2, graph, reverse, isEmbedded) {
        let quad2;
        if (reverse) {
          this.validateReverseSubject(object2);
          quad2 = this.dataFactory.quad(object2, predicate, subject, graph);
        } else {
          quad2 = this.dataFactory.quad(subject, predicate, object2, graph);
        }
        if (isEmbedded) {
          if (quad2.graph.termType !== "DefaultGraph") {
            quad2 = this.dataFactory.quad(quad2.subject, quad2.predicate, quad2.object);
          }
          if (this.parsingContext.idStack[depth - 1]) {
            throw new jsonld_context_parser_1.ErrorCoded(`Illegal multiple properties in an embedded node`, jsonld_context_parser_1.ERROR_CODES.INVALID_EMBEDDED_NODE);
          }
          this.parsingContext.idStack[depth - 1] = [quad2];
        } else {
          this.parsingContext.emitQuad(depth, quad2);
        }
        const annotationsBuffer = this.parsingContext.annotationsBuffer[depth];
        if (annotationsBuffer) {
          for (const annotation of annotationsBuffer) {
            this.emitAnnotation(depth, quad2, annotation);
          }
          delete this.parsingContext.annotationsBuffer[depth];
        }
      }
      // This is a separate function to enable recursion
      emitAnnotation(depth, quad2, annotation) {
        let annotationQuad;
        if (annotation.reverse) {
          this.validateReverseSubject(annotation.object);
          annotationQuad = this.dataFactory.quad(annotation.object, annotation.predicate, quad2);
        } else {
          annotationQuad = this.dataFactory.quad(quad2, annotation.predicate, annotation.object);
        }
        this.parsingContext.emitQuad(depth, annotationQuad);
        for (const nestedAnnotation of annotation.nestedAnnotations) {
          this.emitAnnotation(depth, annotationQuad, nestedAnnotation);
        }
      }
    };
    exports.Util = Util;
    Util.XSD = "http://www.w3.org/2001/XMLSchema#";
    Util.XSD_BOOLEAN = Util.XSD + "boolean";
    Util.XSD_INTEGER = Util.XSD + "integer";
    Util.XSD_DOUBLE = Util.XSD + "double";
    Util.RDF = "http://www.w3.org/1999/02/22-rdf-syntax-ns#";
  }
});

// node_modules/jsonld-streaming-parser/lib/entryhandler/EntryHandlerArrayValue.js
var require_EntryHandlerArrayValue = __commonJS({
  "node_modules/jsonld-streaming-parser/lib/entryhandler/EntryHandlerArrayValue.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.EntryHandlerArrayValue = void 0;
    var Util_1 = require_Util2();
    var jsonld_context_parser_1 = require_jsonld_context_parser();
    var EntryHandlerArrayValue = class {
      isPropertyHandler() {
        return false;
      }
      isStackProcessor() {
        return true;
      }
      async validate(parsingContext, util, keys, depth, inProperty) {
        return this.test(parsingContext, util, null, keys, depth);
      }
      async test(parsingContext, util, key, keys, depth) {
        return typeof keys[depth] === "number";
      }
      async handle(parsingContext, util, key, keys, value, depth) {
        let parentKey = await util.unaliasKeywordParent(keys, depth);
        if (parentKey === "@list") {
          let listRootKey = null;
          let listRootDepth = 0;
          for (let i = depth - 2; i > 0; i--) {
            const keyOption = keys[i];
            if (typeof keyOption === "string" || typeof keyOption === "number") {
              listRootDepth = i;
              listRootKey = keyOption;
              break;
            }
          }
          if (listRootKey !== null) {
            const values = await util.valueToTerm(await parsingContext.getContext(keys), listRootKey, value, depth, keys);
            for (const object2 of values) {
              await this.handleListElement(parsingContext, util, object2, value, depth, keys.slice(0, listRootDepth), listRootDepth);
            }
            if (values.length === 0) {
              await this.handleListElement(parsingContext, util, null, value, depth, keys.slice(0, listRootDepth), listRootDepth);
            }
          }
        } else if (parentKey === "@set") {
          await parsingContext.newOnValueJob(keys.slice(0, -2), value, depth - 2, false);
        } else if (parentKey !== void 0 && parentKey !== "@type") {
          for (let i = depth - 1; i > 0; i--) {
            if (typeof keys[i] !== "number") {
              parentKey = await util.unaliasKeyword(keys[i], keys, i);
              break;
            }
          }
          const parentContext = await parsingContext.getContext(keys.slice(0, -1));
          if ("@list" in Util_1.Util.getContextValueContainer(parentContext, parentKey)) {
            parsingContext.emittedStack[depth + 1] = true;
            const values = await util.valueToTerm(await parsingContext.getContext(keys), parentKey, value, depth, keys);
            for (const object2 of values) {
              await this.handleListElement(parsingContext, util, object2, value, depth, keys.slice(0, -1), depth - 1);
            }
            if (values.length === 0) {
              await this.handleListElement(parsingContext, util, null, value, depth, keys.slice(0, -1), depth - 1);
            }
          } else {
            parsingContext.shiftStack(depth, 1);
            await parsingContext.newOnValueJob(keys.slice(0, -1), value, depth - 1, false);
            parsingContext.contextTree.removeContext(keys.slice(0, -1));
          }
        }
      }
      async handleListElement(parsingContext, util, value, valueOriginal, depth, listRootKeys, listRootDepth) {
        let listPointer = parsingContext.listPointerStack[depth];
        if (valueOriginal !== null && (await util.unaliasKeywords(valueOriginal, listRootKeys, depth))["@value"] !== null) {
          if (!listPointer || !listPointer.value) {
            const linkTerm = util.dataFactory.blankNode();
            listPointer = { value: linkTerm, listRootDepth, listId: linkTerm };
          } else {
            const newLinkTerm = util.dataFactory.blankNode();
            parsingContext.emitQuad(depth, util.dataFactory.quad(listPointer.value, util.rdfRest, newLinkTerm, util.getDefaultGraph()));
            listPointer.value = newLinkTerm;
          }
          if (value) {
            parsingContext.emitQuad(depth, util.dataFactory.quad(listPointer.value, util.rdfFirst, value, util.getDefaultGraph()));
          }
        } else {
          if (!listPointer) {
            listPointer = { listRootDepth, listId: util.rdfNil };
          }
        }
        parsingContext.listPointerStack[depth] = listPointer;
        if (parsingContext.rdfstar && parsingContext.annotationsBuffer[depth]) {
          parsingContext.emitError(new jsonld_context_parser_1.ErrorCoded(`Found an illegal annotation inside a list`, jsonld_context_parser_1.ERROR_CODES.INVALID_ANNOTATION));
        }
      }
    };
    exports.EntryHandlerArrayValue = EntryHandlerArrayValue;
  }
});

// node_modules/jsonld-streaming-parser/lib/entryhandler/EntryHandlerInvalidFallback.js
var require_EntryHandlerInvalidFallback = __commonJS({
  "node_modules/jsonld-streaming-parser/lib/entryhandler/EntryHandlerInvalidFallback.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.EntryHandlerInvalidFallback = void 0;
    var EntryHandlerInvalidFallback = class {
      isPropertyHandler() {
        return false;
      }
      isStackProcessor() {
        return true;
      }
      async validate(parsingContext, util, keys, depth, inProperty) {
        return false;
      }
      async test(parsingContext, util, key, keys, depth) {
        return true;
      }
      async handle(parsingContext, util, key, keys, value, depth) {
        parsingContext.emittedStack[depth] = false;
      }
    };
    exports.EntryHandlerInvalidFallback = EntryHandlerInvalidFallback;
  }
});

// node_modules/jsonld-streaming-parser/lib/entryhandler/keyword/EntryHandlerKeyword.js
var require_EntryHandlerKeyword = __commonJS({
  "node_modules/jsonld-streaming-parser/lib/entryhandler/keyword/EntryHandlerKeyword.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.EntryHandlerKeyword = void 0;
    var EntryHandlerKeyword = class {
      constructor(keyword) {
        this.keyword = keyword;
      }
      isPropertyHandler() {
        return false;
      }
      isStackProcessor() {
        return true;
      }
      async validate(parsingContext, util, keys, depth, inProperty) {
        return false;
      }
      async test(parsingContext, util, key, keys, depth) {
        return key === this.keyword;
      }
    };
    exports.EntryHandlerKeyword = EntryHandlerKeyword;
  }
});

// node_modules/jsonld-streaming-parser/lib/entryhandler/keyword/EntryHandlerKeywordContext.js
var require_EntryHandlerKeywordContext = __commonJS({
  "node_modules/jsonld-streaming-parser/lib/entryhandler/keyword/EntryHandlerKeywordContext.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.EntryHandlerKeywordContext = void 0;
    var jsonld_context_parser_1 = require_jsonld_context_parser();
    var EntryHandlerKeyword_1 = require_EntryHandlerKeyword();
    var EntryHandlerKeywordContext = class extends EntryHandlerKeyword_1.EntryHandlerKeyword {
      constructor() {
        super("@context");
      }
      isStackProcessor() {
        return false;
      }
      async handle(parsingContext, util, key, keys, value, depth) {
        if (parsingContext.streamingProfile && (parsingContext.processingStack[depth] || parsingContext.processingType[depth] || parsingContext.idStack[depth] !== void 0)) {
          parsingContext.emitError(new jsonld_context_parser_1.ErrorCoded("Found an out-of-order context, while streaming is enabled.(disable `streamingProfile`)", jsonld_context_parser_1.ERROR_CODES.INVALID_STREAMING_KEY_ORDER));
        }
        const parentContext = parsingContext.getContext(keys);
        const context = parsingContext.parseContext(value, (await parentContext).getContextRaw());
        parsingContext.contextTree.setContext(keys.slice(0, -1), context);
        parsingContext.emitContext(value);
        await parsingContext.validateContext(await context);
      }
    };
    exports.EntryHandlerKeywordContext = EntryHandlerKeywordContext;
  }
});

// node_modules/jsonld-streaming-parser/lib/entryhandler/keyword/EntryHandlerKeywordGraph.js
var require_EntryHandlerKeywordGraph = __commonJS({
  "node_modules/jsonld-streaming-parser/lib/entryhandler/keyword/EntryHandlerKeywordGraph.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.EntryHandlerKeywordGraph = void 0;
    var EntryHandlerKeyword_1 = require_EntryHandlerKeyword();
    var EntryHandlerKeywordGraph = class extends EntryHandlerKeyword_1.EntryHandlerKeyword {
      constructor() {
        super("@graph");
      }
      async handle(parsingContext, util, key, keys, value, depth) {
        parsingContext.graphStack[depth + 1] = true;
      }
    };
    exports.EntryHandlerKeywordGraph = EntryHandlerKeywordGraph;
  }
});

// node_modules/jsonld-streaming-parser/lib/entryhandler/keyword/EntryHandlerKeywordId.js
var require_EntryHandlerKeywordId = __commonJS({
  "node_modules/jsonld-streaming-parser/lib/entryhandler/keyword/EntryHandlerKeywordId.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.EntryHandlerKeywordId = void 0;
    var jsonld_context_parser_1 = require_jsonld_context_parser();
    var EntryHandlerKeyword_1 = require_EntryHandlerKeyword();
    var EntryHandlerKeywordId = class extends EntryHandlerKeyword_1.EntryHandlerKeyword {
      constructor() {
        super("@id");
      }
      isStackProcessor() {
        return false;
      }
      async handle(parsingContext, util, key, keys, value, depth) {
        if (typeof value !== "string") {
          if (parsingContext.rdfstar && typeof value === "object") {
            const valueKeys = Object.keys(value);
            if (valueKeys.length === 1 && valueKeys[0] === "@id") {
              parsingContext.emitError(new jsonld_context_parser_1.ErrorCoded(`Invalid embedded node without property with @id ${value["@id"]}`, jsonld_context_parser_1.ERROR_CODES.INVALID_EMBEDDED_NODE));
            }
          } else {
            parsingContext.emitError(new jsonld_context_parser_1.ErrorCoded(`Found illegal @id '${value}'`, jsonld_context_parser_1.ERROR_CODES.INVALID_ID_VALUE));
          }
          return;
        }
        const depthProperties = await util.getPropertiesDepth(keys, depth);
        if (parsingContext.idStack[depthProperties] !== void 0) {
          if (parsingContext.idStack[depthProperties][0].listHead) {
            parsingContext.emitError(new jsonld_context_parser_1.ErrorCoded(`Found illegal neighbouring entries next to @list for key: '${keys[depth - 1]}'`, jsonld_context_parser_1.ERROR_CODES.INVALID_SET_OR_LIST_OBJECT));
          } else {
            parsingContext.emitError(new jsonld_context_parser_1.ErrorCoded(`Found duplicate @ids '${parsingContext.idStack[depthProperties][0].value}' and '${value}'`, jsonld_context_parser_1.ERROR_CODES.COLLIDING_KEYWORDS));
          }
        }
        if (parsingContext.rdfstar && parsingContext.annotationsBuffer[depth]) {
          for (const annotation of parsingContext.annotationsBuffer[depth]) {
            if (annotation.depth === depth) {
              parsingContext.emitError(new jsonld_context_parser_1.ErrorCoded(`Found an illegal @id inside an annotation: ${value}`, jsonld_context_parser_1.ERROR_CODES.INVALID_ANNOTATION));
            }
          }
        }
        parsingContext.idStack[depthProperties] = util.nullableTermToArray(await util.resourceToTerm(await parsingContext.getContext(keys), value));
      }
    };
    exports.EntryHandlerKeywordId = EntryHandlerKeywordId;
  }
});

// node_modules/jsonld-streaming-parser/lib/entryhandler/keyword/EntryHandlerKeywordIncluded.js
var require_EntryHandlerKeywordIncluded = __commonJS({
  "node_modules/jsonld-streaming-parser/lib/entryhandler/keyword/EntryHandlerKeywordIncluded.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.EntryHandlerKeywordIncluded = void 0;
    var jsonld_context_parser_1 = require_jsonld_context_parser();
    var EntryHandlerKeyword_1 = require_EntryHandlerKeyword();
    var EntryHandlerKeywordIncluded = class extends EntryHandlerKeyword_1.EntryHandlerKeyword {
      constructor() {
        super("@included");
      }
      async handle(parsingContext, util, key, keys, value, depth) {
        if (typeof value !== "object") {
          parsingContext.emitError(new jsonld_context_parser_1.ErrorCoded(`Found illegal @included '${value}'`, jsonld_context_parser_1.ERROR_CODES.INVALID_INCLUDED_VALUE));
        }
        const valueUnliased = await util.unaliasKeywords(value, keys, depth, await parsingContext.getContext(keys));
        if ("@value" in valueUnliased) {
          parsingContext.emitError(new jsonld_context_parser_1.ErrorCoded(`Found an illegal @included @value node '${JSON.stringify(value)}'`, jsonld_context_parser_1.ERROR_CODES.INVALID_INCLUDED_VALUE));
        }
        if ("@list" in valueUnliased) {
          parsingContext.emitError(new jsonld_context_parser_1.ErrorCoded(`Found an illegal @included @list node '${JSON.stringify(value)}'`, jsonld_context_parser_1.ERROR_CODES.INVALID_INCLUDED_VALUE));
        }
        parsingContext.emittedStack[depth] = false;
      }
    };
    exports.EntryHandlerKeywordIncluded = EntryHandlerKeywordIncluded;
  }
});

// node_modules/jsonld-streaming-parser/lib/entryhandler/keyword/EntryHandlerKeywordNest.js
var require_EntryHandlerKeywordNest = __commonJS({
  "node_modules/jsonld-streaming-parser/lib/entryhandler/keyword/EntryHandlerKeywordNest.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.EntryHandlerKeywordNest = void 0;
    var jsonld_context_parser_1 = require_jsonld_context_parser();
    var EntryHandlerKeyword_1 = require_EntryHandlerKeyword();
    var EntryHandlerKeywordNest = class extends EntryHandlerKeyword_1.EntryHandlerKeyword {
      constructor() {
        super("@nest");
      }
      async handle(parsingContext, util, key, keys, value, depth) {
        if (typeof value !== "object") {
          parsingContext.emitError(new jsonld_context_parser_1.ErrorCoded(`Found invalid @nest entry for '${key}': '${value}'`, jsonld_context_parser_1.ERROR_CODES.INVALID_NEST_VALUE));
        }
        if ("@value" in await util.unaliasKeywords(value, keys, depth, await parsingContext.getContext(keys))) {
          parsingContext.emitError(new jsonld_context_parser_1.ErrorCoded(`Found an invalid @value node for '${key}'`, jsonld_context_parser_1.ERROR_CODES.INVALID_NEST_VALUE));
        }
        parsingContext.emittedStack[depth] = false;
      }
    };
    exports.EntryHandlerKeywordNest = EntryHandlerKeywordNest;
  }
});

// node_modules/jsonld-streaming-parser/lib/entryhandler/keyword/EntryHandlerKeywordType.js
var require_EntryHandlerKeywordType = __commonJS({
  "node_modules/jsonld-streaming-parser/lib/entryhandler/keyword/EntryHandlerKeywordType.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.EntryHandlerKeywordType = void 0;
    var jsonld_context_parser_1 = require_jsonld_context_parser();
    var Util_1 = require_Util2();
    var EntryHandlerPredicate_1 = require_EntryHandlerPredicate();
    var EntryHandlerKeyword_1 = require_EntryHandlerKeyword();
    var EntryHandlerKeywordType = class extends EntryHandlerKeyword_1.EntryHandlerKeyword {
      constructor() {
        super("@type");
      }
      isStackProcessor() {
        return false;
      }
      async handle(parsingContext, util, key, keys, value, depth) {
        const keyOriginal = keys[depth];
        const context = await parsingContext.getContext(keys);
        const predicate = util.rdfType;
        const parentKey = await util.unaliasKeywordParent(keys, depth);
        const reverse = Util_1.Util.isPropertyReverse(context, keyOriginal, parentKey);
        const isEmbedded = Util_1.Util.isPropertyInEmbeddedNode(parentKey);
        util.validateReverseInEmbeddedNode(key, reverse, isEmbedded);
        const isAnnotation = Util_1.Util.isPropertyInAnnotationObject(parentKey);
        const elements = Array.isArray(value) ? value : [value];
        for (const element of elements) {
          if (typeof element !== "string") {
            parsingContext.emitError(new jsonld_context_parser_1.ErrorCoded(`Found illegal @type '${element}'`, jsonld_context_parser_1.ERROR_CODES.INVALID_TYPE_VALUE));
          }
          const type2 = util.createVocabOrBaseTerm(context, element);
          if (type2) {
            await EntryHandlerPredicate_1.EntryHandlerPredicate.handlePredicateObject(parsingContext, util, keys, depth, predicate, type2, reverse, isEmbedded, isAnnotation);
          }
        }
        let scopedContext = Promise.resolve(context);
        let hasTypedScopedContext = false;
        for (const element of elements.sort()) {
          const typeContext = Util_1.Util.getContextValue(context, "@context", element, null);
          if (typeContext) {
            hasTypedScopedContext = true;
            scopedContext = scopedContext.then((c) => parsingContext.parseContext(typeContext, c.getContextRaw()));
          }
        }
        if (parsingContext.streamingProfile && (hasTypedScopedContext || !parsingContext.streamingProfileAllowOutOfOrderPlainType) && (parsingContext.processingStack[depth] || parsingContext.idStack[depth])) {
          parsingContext.emitError(new jsonld_context_parser_1.ErrorCoded("Found an out-of-order type-scoped context, while streaming is enabled.(disable `streamingProfile`)", jsonld_context_parser_1.ERROR_CODES.INVALID_STREAMING_KEY_ORDER));
        }
        if (hasTypedScopedContext) {
          scopedContext = scopedContext.then((c) => {
            if (c.getContextRaw()["@propagate"] !== true) {
              return new jsonld_context_parser_1.JsonLdContextNormalized(Object.assign(Object.assign({}, c.getContextRaw()), { "@propagate": false, "@__propagateFallback": context.getContextRaw() }));
            }
            return c;
          });
          parsingContext.contextTree.setContext(keys.slice(0, keys.length - 1), scopedContext);
        }
        parsingContext.processingType[depth] = true;
      }
    };
    exports.EntryHandlerKeywordType = EntryHandlerKeywordType;
  }
});

// node_modules/jsonld-streaming-parser/lib/entryhandler/keyword/EntryHandlerKeywordUnknownFallback.js
var require_EntryHandlerKeywordUnknownFallback = __commonJS({
  "node_modules/jsonld-streaming-parser/lib/entryhandler/keyword/EntryHandlerKeywordUnknownFallback.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.EntryHandlerKeywordUnknownFallback = void 0;
    var jsonld_context_parser_1 = require_jsonld_context_parser();
    var EntryHandlerKeywordUnknownFallback = class _EntryHandlerKeywordUnknownFallback {
      isPropertyHandler() {
        return false;
      }
      isStackProcessor() {
        return true;
      }
      async validate(parsingContext, util, keys, depth, inProperty) {
        const key = await util.unaliasKeyword(keys[depth], keys, depth);
        if (jsonld_context_parser_1.Util.isPotentialKeyword(key)) {
          if (!inProperty) {
            if (key === "@list") {
              return false;
            }
          }
          return true;
        }
        return false;
      }
      async test(parsingContext, util, key, keys, depth) {
        return jsonld_context_parser_1.Util.isPotentialKeyword(key);
      }
      async handle(parsingContext, util, key, keys, value, depth) {
        const keywordType = _EntryHandlerKeywordUnknownFallback.VALID_KEYWORDS_TYPES[key];
        if (keywordType !== void 0) {
          if (keywordType && typeof value !== keywordType.type) {
            parsingContext.emitError(new jsonld_context_parser_1.ErrorCoded(`Invalid value type for '${key}' with value '${value}'`, keywordType.errorCode));
          }
        } else if (parsingContext.strictValues) {
          parsingContext.emitError(new Error(`Unknown keyword '${key}' with value '${value}'`));
        }
        parsingContext.emittedStack[depth] = false;
      }
    };
    exports.EntryHandlerKeywordUnknownFallback = EntryHandlerKeywordUnknownFallback;
    EntryHandlerKeywordUnknownFallback.VALID_KEYWORDS_TYPES = {
      "@index": { type: "string", errorCode: jsonld_context_parser_1.ERROR_CODES.INVALID_INDEX_VALUE },
      "@list": null,
      "@reverse": { type: "object", errorCode: jsonld_context_parser_1.ERROR_CODES.INVALID_REVERSE_VALUE },
      "@set": null,
      "@value": null
    };
  }
});

// node_modules/jsonld-streaming-parser/lib/entryhandler/keyword/EntryHandlerKeywordValue.js
var require_EntryHandlerKeywordValue = __commonJS({
  "node_modules/jsonld-streaming-parser/lib/entryhandler/keyword/EntryHandlerKeywordValue.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.EntryHandlerKeywordValue = void 0;
    var EntryHandlerKeyword_1 = require_EntryHandlerKeyword();
    var EntryHandlerKeywordValue = class extends EntryHandlerKeyword_1.EntryHandlerKeyword {
      constructor() {
        super("@value");
      }
      async validate(parsingContext, util, keys, depth, inProperty) {
        const key = keys[depth];
        if (key && !parsingContext.literalStack[depth] && await this.test(parsingContext, util, key, keys, depth)) {
          parsingContext.literalStack[depth] = true;
        }
        return super.validate(parsingContext, util, keys, depth, inProperty);
      }
      async test(parsingContext, util, key, keys, depth) {
        return await util.unaliasKeyword(keys[depth], keys.slice(0, keys.length - 1), depth - 1, true) === "@value";
      }
      async handle(parsingContext, util, key, keys, value, depth) {
        parsingContext.literalStack[depth] = true;
        delete parsingContext.unidentifiedValuesBuffer[depth];
        delete parsingContext.unidentifiedGraphsBuffer[depth];
        parsingContext.emittedStack[depth] = false;
      }
    };
    exports.EntryHandlerKeywordValue = EntryHandlerKeywordValue;
  }
});

// node_modules/jsonld-streaming-parser/lib/ContextTree.js
var require_ContextTree = __commonJS({
  "node_modules/jsonld-streaming-parser/lib/ContextTree.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ContextTree = void 0;
    var ContextTree = class _ContextTree {
      constructor() {
        this.subTrees = {};
      }
      getContext(keys) {
        if (keys.length > 0) {
          const [head, ...tail] = keys;
          const subTree = this.subTrees[head];
          if (subTree) {
            const subContext = subTree.getContext(tail);
            if (subContext) {
              return subContext.then(({ context, depth }) => ({ context, depth: depth + 1 }));
            }
          }
        }
        return this.context ? this.context.then((context) => ({ context, depth: 0 })) : null;
      }
      setContext(keys, context) {
        if (keys.length === 0) {
          this.context = context;
        } else {
          const [head, ...tail] = keys;
          let subTree = this.subTrees[head];
          if (!subTree) {
            subTree = this.subTrees[head] = new _ContextTree();
          }
          subTree.setContext(tail, context);
        }
      }
      removeContext(path) {
        this.setContext(path, null);
      }
    };
    exports.ContextTree = ContextTree;
  }
});

// node_modules/jsonld-streaming-parser/lib/ParsingContext.js
var require_ParsingContext = __commonJS({
  "node_modules/jsonld-streaming-parser/lib/ParsingContext.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ParsingContext = void 0;
    var jsonld_context_parser_1 = require_jsonld_context_parser();
    var ErrorCoded_1 = require_ErrorCoded();
    var ContextTree_1 = require_ContextTree();
    var JsonLdParser_1 = require_JsonLdParser();
    var ParsingContext = class _ParsingContext {
      constructor(options) {
        this.contextParser = new jsonld_context_parser_1.ContextParser({ documentLoader: options.documentLoader, skipValidation: options.skipContextValidation });
        this.streamingProfile = !!options.streamingProfile;
        this.baseIRI = options.baseIRI;
        this.produceGeneralizedRdf = !!options.produceGeneralizedRdf;
        this.allowSubjectList = !!options.allowSubjectList;
        this.processingMode = options.processingMode || JsonLdParser_1.JsonLdParser.DEFAULT_PROCESSING_MODE;
        this.strictValues = !!options.strictValues;
        this.validateValueIndexes = !!options.validateValueIndexes;
        this.defaultGraph = options.defaultGraph;
        this.rdfDirection = options.rdfDirection;
        this.normalizeLanguageTags = options.normalizeLanguageTags;
        this.streamingProfileAllowOutOfOrderPlainType = options.streamingProfileAllowOutOfOrderPlainType;
        this.rdfstar = options.rdfstar !== false;
        this.rdfstarReverseInEmbedded = options.rdfstarReverseInEmbedded;
        this.topLevelProperties = false;
        this.activeProcessingMode = parseFloat(this.processingMode);
        this.processingStack = [];
        this.processingType = [];
        this.emittedStack = [];
        this.idStack = [];
        this.graphStack = [];
        this.graphContainerTermStack = [];
        this.listPointerStack = [];
        this.contextTree = new ContextTree_1.ContextTree();
        this.literalStack = [];
        this.validationStack = [];
        this.unaliasedKeywordCacheStack = [];
        this.jsonLiteralStack = [];
        this.unidentifiedValuesBuffer = [];
        this.unidentifiedGraphsBuffer = [];
        this.annotationsBuffer = [];
        this.pendingContainerFlushBuffers = [];
        this.parser = options.parser;
        if (options.context) {
          this.rootContext = this.parseContext(options.context);
          this.rootContext.then((context) => this.validateContext(context));
        } else {
          this.rootContext = Promise.resolve(new jsonld_context_parser_1.JsonLdContextNormalized(this.baseIRI ? { "@base": this.baseIRI, "@__baseDocument": true } : {}));
        }
      }
      /**
       * Parse the given context with the configured options.
       * @param {JsonLdContext} context A context to parse.
       * @param {JsonLdContextNormalized} parentContext An optional parent context.
       * @param {boolean} ignoreProtection If @protected term checks should be ignored.
       * @return {Promise<JsonLdContextNormalized>} A promise resolving to the parsed context.
       */
      async parseContext(context, parentContext, ignoreProtection) {
        return this.contextParser.parse(context, {
          baseIRI: this.baseIRI,
          ignoreProtection,
          normalizeLanguageTags: this.normalizeLanguageTags,
          parentContext,
          processingMode: this.activeProcessingMode
        });
      }
      /**
       * Check if the given context is valid.
       * If not, an error will be thrown.
       * @param {JsonLdContextNormalized} context A context.
       */
      validateContext(context) {
        const activeVersion = context.getContextRaw()["@version"];
        if (activeVersion) {
          if (this.activeProcessingMode && activeVersion > this.activeProcessingMode) {
            throw new ErrorCoded_1.ErrorCoded(`Unsupported JSON-LD version '${activeVersion}' under active processing mode ${this.activeProcessingMode}.`, ErrorCoded_1.ERROR_CODES.PROCESSING_MODE_CONFLICT);
          } else {
            if (this.activeProcessingMode && activeVersion < this.activeProcessingMode) {
              throw new ErrorCoded_1.ErrorCoded(`Invalid JSON-LD version ${activeVersion} under active processing mode ${this.activeProcessingMode}.`, ErrorCoded_1.ERROR_CODES.INVALID_VERSION_VALUE);
            }
            this.activeProcessingMode = activeVersion;
          }
        }
      }
      /**
       * Get the context at the given path.
       * @param {keys} keys The path of keys to get the context at.
       * @param {number} offset The path offset, defaults to 1.
       * @return {Promise<JsonLdContextNormalized>} A promise resolving to a context.
       */
      async getContext(keys, offset = 1) {
        const keysOriginal = keys;
        while (typeof keys[keys.length - 1] === "number") {
          keys = keys.slice(0, keys.length - 1);
        }
        if (offset) {
          keys = keys.slice(0, -offset);
        }
        const contextData = await this.getContextPropagationAware(keys);
        const context = contextData.context;
        let contextRaw = context.getContextRaw();
        for (let i = contextData.depth; i < keysOriginal.length - offset; i++) {
          const key = keysOriginal[i];
          const contextKeyEntry = contextRaw[key];
          if (contextKeyEntry && typeof contextKeyEntry === "object" && "@context" in contextKeyEntry) {
            const scopedContext = (await this.parseContext(contextKeyEntry, contextRaw, true)).getContextRaw();
            const propagate = !(key in scopedContext) || scopedContext[key]["@context"]["@propagate"];
            if (propagate !== false || i === keysOriginal.length - 1 - offset) {
              contextRaw = Object.assign({}, scopedContext);
              delete contextRaw["@propagate"];
              contextRaw[key] = Object.assign({}, contextRaw[key]);
              if ("@id" in contextKeyEntry) {
                contextRaw[key]["@id"] = contextKeyEntry["@id"];
              }
              delete contextRaw[key]["@context"];
              if (propagate !== false) {
                this.contextTree.setContext(keysOriginal.slice(0, i + offset), Promise.resolve(new jsonld_context_parser_1.JsonLdContextNormalized(contextRaw)));
              }
            }
          }
        }
        return new jsonld_context_parser_1.JsonLdContextNormalized(contextRaw);
      }
      /**
       * Get the context at the given path.
       * Non-propagating contexts will be skipped,
       * unless the context at that exact depth is retrieved.
       *
       * This ONLY takes into account context propagation logic,
       * so this should usually not be called directly,
       * call {@link #getContext} instead.
       *
       * @param keys The path of keys to get the context at.
       * @return {Promise<{ context: JsonLdContextNormalized, depth: number }>} A context and its depth.
       */
      async getContextPropagationAware(keys) {
        const originalDepth = keys.length;
        let contextData = null;
        let hasApplicablePropertyScopedContext;
        do {
          hasApplicablePropertyScopedContext = false;
          if (contextData && "@__propagateFallback" in contextData.context.getContextRaw()) {
            contextData.context = new jsonld_context_parser_1.JsonLdContextNormalized(contextData.context.getContextRaw()["@__propagateFallback"]);
          } else {
            if (contextData) {
              keys = keys.slice(0, contextData.depth - 1);
            }
            contextData = await this.contextTree.getContext(keys) || { context: await this.rootContext, depth: 0 };
          }
          const lastKey = keys[keys.length - 1];
          if (lastKey in contextData.context.getContextRaw()) {
            const lastKeyValue = contextData.context.getContextRaw()[lastKey];
            if (lastKeyValue && typeof lastKeyValue === "object" && "@context" in lastKeyValue) {
              hasApplicablePropertyScopedContext = true;
            }
          }
        } while (contextData.depth > 0 && contextData.context.getContextRaw()["@propagate"] === false && contextData.depth !== originalDepth && !hasApplicablePropertyScopedContext);
        if (contextData.depth === 0 && contextData.context.getContextRaw()["@propagate"] === false && contextData.depth !== originalDepth) {
          contextData.context = new jsonld_context_parser_1.JsonLdContextNormalized({});
        }
        return contextData;
      }
      /**
       * Start a new job for parsing the given value.
       * @param {any[]} keys The stack of keys.
       * @param value The value to parse.
       * @param {number} depth The depth to parse at.
       * @param {boolean} lastDepthCheck If the lastDepth check should be done for buffer draining.
       * @return {Promise<void>} A promise resolving when the job is done.
       */
      async newOnValueJob(keys, value, depth, lastDepthCheck) {
        await this.parser.newOnValueJob(keys, value, depth, lastDepthCheck);
      }
      /**
       * Flush the pending container flush buffers
       * @return {boolean} If any pending buffers were flushed.
       */
      async handlePendingContainerFlushBuffers() {
        if (this.pendingContainerFlushBuffers.length > 0) {
          for (const pendingFlushBuffer of this.pendingContainerFlushBuffers) {
            await this.parser.flushBuffer(pendingFlushBuffer.depth, pendingFlushBuffer.keys);
            this.parser.flushStacks(pendingFlushBuffer.depth);
          }
          this.pendingContainerFlushBuffers.splice(0, this.pendingContainerFlushBuffers.length);
          return true;
        } else {
          return false;
        }
      }
      /**
       * Emit the given quad into the output stream.
       * @param {number} depth The depth the quad was generated at.
       * @param {Quad} quad A quad to emit.
       */
      emitQuad(depth, quad2) {
        if (depth === 1) {
          this.topLevelProperties = true;
        }
        this.parser.push(quad2);
      }
      /**
       * Emit the given error into the output stream.
       * @param {Error} error An error to emit.
       */
      emitError(error46) {
        this.parser.emit("error", error46);
      }
      /**
       * Emit the given context into the output stream under the 'context' event.
       * @param {JsonLdContext} context A context to emit.
       */
      emitContext(context) {
        this.parser.emit("context", context);
      }
      /**
       * Safely get or create the depth value of {@link ParsingContext.unidentifiedValuesBuffer}.
       * @param {number} depth A depth.
       * @return {{predicate: Term; object: Term; reverse: boolean}[]} An element of
       *                                                               {@link ParsingContext.unidentifiedValuesBuffer}.
       */
      getUnidentifiedValueBufferSafe(depth) {
        let buffer = this.unidentifiedValuesBuffer[depth];
        if (!buffer) {
          buffer = [];
          this.unidentifiedValuesBuffer[depth] = buffer;
        }
        return buffer;
      }
      /**
       * Safely get or create the depth value of {@link ParsingContext.unidentifiedGraphsBuffer}.
       * @param {number} depth A depth.
       * @return {{predicate: Term; object: Term; reverse: boolean}[]} An element of
       *                                                               {@link ParsingContext.unidentifiedGraphsBuffer}.
       */
      getUnidentifiedGraphBufferSafe(depth) {
        let buffer = this.unidentifiedGraphsBuffer[depth];
        if (!buffer) {
          buffer = [];
          this.unidentifiedGraphsBuffer[depth] = buffer;
        }
        return buffer;
      }
      /**
       * Safely get or create the depth value of {@link ParsingContext.annotationsBuffer}.
       * @param {number} depth A depth.
       * @return {} An element of {@link ParsingContext.annotationsBuffer}.
       */
      getAnnotationsBufferSafe(depth) {
        let buffer = this.annotationsBuffer[depth];
        if (!buffer) {
          buffer = [];
          this.annotationsBuffer[depth] = buffer;
        }
        return buffer;
      }
      /**
       * @return IExpandOptions The expand options for the active processing mode.
       */
      getExpandOptions() {
        return _ParsingContext.EXPAND_OPTIONS[this.activeProcessingMode];
      }
      /**
       * Shift the stack at the given offset to the given depth.
       *
       * This will override anything in the stack at `depth`,
       * and this will remove anything at `depth + depthOffset`
       *
       * @param depth The target depth.
       * @param depthOffset The origin depth, relative to `depth`.
       */
      shiftStack(depth, depthOffset) {
        const deeperIdStack = this.idStack[depth + depthOffset];
        if (deeperIdStack) {
          this.idStack[depth] = deeperIdStack;
          this.emittedStack[depth] = true;
          delete this.idStack[depth + depthOffset];
        }
        if (this.pendingContainerFlushBuffers.length) {
          for (const buffer of this.pendingContainerFlushBuffers) {
            if (buffer.depth >= depth + depthOffset) {
              buffer.depth -= depthOffset;
              buffer.keys.splice(depth, depthOffset);
            }
          }
        }
        if (this.unidentifiedValuesBuffer[depth + depthOffset]) {
          this.unidentifiedValuesBuffer[depth] = this.unidentifiedValuesBuffer[depth + depthOffset];
          delete this.unidentifiedValuesBuffer[depth + depthOffset];
        }
        if (this.annotationsBuffer[depth + depthOffset - 1]) {
          if (!this.annotationsBuffer[depth - 1]) {
            this.annotationsBuffer[depth - 1] = [];
          }
          this.annotationsBuffer[depth - 1] = [
            ...this.annotationsBuffer[depth - 1],
            ...this.annotationsBuffer[depth + depthOffset - 1]
          ];
          delete this.annotationsBuffer[depth + depthOffset - 1];
        }
      }
    };
    exports.ParsingContext = ParsingContext;
    ParsingContext.EXPAND_OPTIONS = {
      1: {
        allowPrefixForcing: false,
        allowPrefixNonGenDelims: false,
        allowVocabRelativeToBase: false
      },
      1.1: {
        allowPrefixForcing: true,
        allowPrefixNonGenDelims: false,
        allowVocabRelativeToBase: true
      }
    };
  }
});

// node_modules/jsonld-streaming-parser/lib/entryhandler/keyword/EntryHandlerKeywordAnnotation.js
var require_EntryHandlerKeywordAnnotation = __commonJS({
  "node_modules/jsonld-streaming-parser/lib/entryhandler/keyword/EntryHandlerKeywordAnnotation.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.EntryHandlerKeywordAnnotation = void 0;
    var EntryHandlerKeyword_1 = require_EntryHandlerKeyword();
    var jsonld_context_parser_1 = require_jsonld_context_parser();
    var EntryHandlerKeywordAnnotation = class extends EntryHandlerKeyword_1.EntryHandlerKeyword {
      constructor() {
        super("@annotation");
      }
      async handle(parsingContext, util, key, keys, value, depth) {
        if (typeof value === "string" || typeof value === "object" && value["@value"]) {
          parsingContext.emitError(new jsonld_context_parser_1.ErrorCoded(`Found illegal annotation value: ${JSON.stringify(value)}`, jsonld_context_parser_1.ERROR_CODES.INVALID_ANNOTATION));
        }
      }
    };
    exports.EntryHandlerKeywordAnnotation = EntryHandlerKeywordAnnotation;
  }
});

// node_modules/jsonld-streaming-parser/lib/JsonLdParser.js
var require_JsonLdParser = __commonJS({
  "node_modules/jsonld-streaming-parser/lib/JsonLdParser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.JsonLdParser = void 0;
    var Parser = require_jsonparse();
    var jsonld_context_parser_1 = require_jsonld_context_parser();
    var readable_stream_1 = require_browser3();
    var EntryHandlerArrayValue_1 = require_EntryHandlerArrayValue();
    var EntryHandlerContainer_1 = require_EntryHandlerContainer();
    var EntryHandlerInvalidFallback_1 = require_EntryHandlerInvalidFallback();
    var EntryHandlerPredicate_1 = require_EntryHandlerPredicate();
    var EntryHandlerKeywordContext_1 = require_EntryHandlerKeywordContext();
    var EntryHandlerKeywordGraph_1 = require_EntryHandlerKeywordGraph();
    var EntryHandlerKeywordId_1 = require_EntryHandlerKeywordId();
    var EntryHandlerKeywordIncluded_1 = require_EntryHandlerKeywordIncluded();
    var EntryHandlerKeywordNest_1 = require_EntryHandlerKeywordNest();
    var EntryHandlerKeywordType_1 = require_EntryHandlerKeywordType();
    var EntryHandlerKeywordUnknownFallback_1 = require_EntryHandlerKeywordUnknownFallback();
    var EntryHandlerKeywordValue_1 = require_EntryHandlerKeywordValue();
    var ParsingContext_1 = require_ParsingContext();
    var Util_1 = require_Util2();
    var http_link_header_1 = require_link();
    var EntryHandlerKeywordAnnotation_1 = require_EntryHandlerKeywordAnnotation();
    var JsonLdParser2 = class _JsonLdParser extends readable_stream_1.Transform {
      constructor(options) {
        super({ readableObjectMode: true });
        options = options || {};
        this.options = options;
        this.parsingContext = new ParsingContext_1.ParsingContext(Object.assign({ parser: this }, options));
        this.util = new Util_1.Util({ dataFactory: options.dataFactory, parsingContext: this.parsingContext });
        this.jsonParser = new Parser();
        this.contextJobs = [];
        this.typeJobs = [];
        this.contextAwaitingJobs = [];
        this.lastDepth = 0;
        this.lastKeys = [];
        this.lastOnValueJob = Promise.resolve();
        this.attachJsonParserListeners();
        this.on("end", () => {
          if (typeof this.jsonParser.mode !== "undefined") {
            this.emit("error", new Error("Unclosed document"));
          }
        });
      }
      /**
       * Construct a JsonLdParser from the given HTTP response.
       *
       * This will throw an error if no valid JSON response is received
       * (application/ld+json, application/json, or something+json).
       *
       * For raw JSON responses, exactly one link header pointing to a JSON-LD context is required.
       *
       * This method is not responsible for handling redirects.
       *
       * @param baseIRI The URI of the received response.
       * @param mediaType The received content type.
       * @param headers Optional HTTP headers.
       * @param options Optional parser options.
       */
      static fromHttpResponse(baseIRI, mediaType, headers, options) {
        let context;
        let wellKnownMediaTypes = ["application/activity+json"];
        if (options && options.wellKnownMediaTypes) {
          wellKnownMediaTypes = options.wellKnownMediaTypes;
        }
        if (mediaType !== "application/ld+json" && !wellKnownMediaTypes.includes(mediaType)) {
          if (mediaType !== "application/json" && !mediaType.endsWith("+json")) {
            throw new jsonld_context_parser_1.ErrorCoded(`Unsupported JSON-LD media type ${mediaType}`, jsonld_context_parser_1.ERROR_CODES.LOADING_DOCUMENT_FAILED);
          }
          if (headers && headers.has("Link")) {
            headers.forEach((value, key) => {
              if (key === "link") {
                const linkHeader = (0, http_link_header_1.parse)(value);
                for (const link of linkHeader.get("rel", "http://www.w3.org/ns/json-ld#context")) {
                  if (context) {
                    throw new jsonld_context_parser_1.ErrorCoded("Multiple JSON-LD context link headers were found on " + baseIRI, jsonld_context_parser_1.ERROR_CODES.MULTIPLE_CONTEXT_LINK_HEADERS);
                  }
                  context = link.uri;
                }
              }
            });
          }
          if (!context && !(options === null || options === void 0 ? void 0 : options.ignoreMissingContextLinkHeader)) {
            throw new jsonld_context_parser_1.ErrorCoded(`Missing context link header for media type ${mediaType} on ${baseIRI}`, jsonld_context_parser_1.ERROR_CODES.LOADING_DOCUMENT_FAILED);
          }
        }
        let streamingProfile;
        if (headers && headers.has("Content-Type")) {
          const contentType = headers.get("Content-Type");
          const match = /; *profile=([^"]*)/.exec(contentType);
          if (match && match[1] === "http://www.w3.org/ns/json-ld#streaming") {
            streamingProfile = true;
          }
        }
        return new _JsonLdParser(Object.assign({
          baseIRI,
          context,
          streamingProfile
        }, options ? options : {}));
      }
      /**
       * Parses the given text stream into a quad stream.
       * @param {NodeJS.EventEmitter} stream A text stream.
       * @return {RDF.Stream} A quad stream.
       */
      import(stream) {
        if ("pipe" in stream) {
          stream.on("error", (error46) => parsed.emit("error", error46));
          const parsed = stream.pipe(new _JsonLdParser(this.options));
          return parsed;
        } else {
          const output = new readable_stream_1.PassThrough({ readableObjectMode: true });
          stream.on("error", (error46) => parsed.emit("error", error46));
          stream.on("data", (data) => output.push(data));
          stream.on("end", () => output.push(null));
          const parsed = output.pipe(new _JsonLdParser(this.options));
          return parsed;
        }
      }
      _transform(chunk, encoding, callback) {
        this.jsonParser.write(chunk);
        this.lastOnValueJob.then(() => callback(), (error46) => callback(error46));
      }
      /**
       * Start a new job for parsing the given value.
       *
       * This will let the first valid {@link IEntryHandler} handle the entry.
       *
       * @param {any[]} keys The stack of keys.
       * @param value The value to parse.
       * @param {number} depth The depth to parse at.
       * @param {boolean} lastDepthCheck If the lastDepth check should be done for buffer draining.
       * @return {Promise<void>} A promise resolving when the job is done.
       */
      async newOnValueJob(keys, value, depth, lastDepthCheck) {
        let flushStacks = true;
        if (lastDepthCheck && depth < this.lastDepth) {
          const listPointer = this.parsingContext.listPointerStack[this.lastDepth];
          if (listPointer) {
            if (listPointer.value) {
              this.push(this.util.dataFactory.quad(listPointer.value, this.util.rdfRest, this.util.rdfNil, this.util.getDefaultGraph()));
            }
            listPointer.listId.listHead = true;
            this.parsingContext.idStack[listPointer.listRootDepth + 1] = [listPointer.listId];
            this.parsingContext.listPointerStack.splice(this.lastDepth, 1);
          }
          if (await EntryHandlerContainer_1.EntryHandlerContainer.isBufferableContainerHandler(this.parsingContext, this.lastKeys, this.lastDepth)) {
            this.parsingContext.pendingContainerFlushBuffers.push({ depth: this.lastDepth, keys: this.lastKeys.slice(0, this.lastKeys.length) });
            flushStacks = false;
          } else {
            await this.flushBuffer(this.lastDepth, this.lastKeys);
          }
        }
        const key = await this.util.unaliasKeyword(keys[depth], keys, depth);
        const parentKey = await this.util.unaliasKeywordParent(keys, depth);
        this.parsingContext.emittedStack[depth] = true;
        let handleKey = true;
        if (jsonld_context_parser_1.Util.isValidKeyword(key) && parentKey === "@reverse" && key !== "@context") {
          this.emit("error", new jsonld_context_parser_1.ErrorCoded(`Found the @id '${value}' inside an @reverse property`, jsonld_context_parser_1.ERROR_CODES.INVALID_REVERSE_PROPERTY_MAP));
        }
        let inProperty = false;
        if (this.parsingContext.validationStack.length > 1) {
          inProperty = this.parsingContext.validationStack[this.parsingContext.validationStack.length - 1].property;
        }
        for (let i = Math.max(1, this.parsingContext.validationStack.length - 1); i < keys.length - 1; i++) {
          const validationResult = this.parsingContext.validationStack[i] || (this.parsingContext.validationStack[i] = await this.validateKey(keys.slice(0, i + 1), i, inProperty));
          if (!validationResult.valid) {
            this.parsingContext.emittedStack[depth] = false;
            handleKey = false;
            break;
          } else if (!inProperty && validationResult.property) {
            inProperty = true;
          }
        }
        if (await this.util.isLiteral(keys, depth)) {
          handleKey = false;
        }
        if (handleKey) {
          for (const entryHandler of _JsonLdParser.ENTRY_HANDLERS) {
            const testResult = await entryHandler.test(this.parsingContext, this.util, key, keys, depth);
            if (testResult) {
              await entryHandler.handle(this.parsingContext, this.util, key, keys, value, depth, testResult);
              if (entryHandler.isStackProcessor()) {
                this.parsingContext.processingStack[depth] = true;
              }
              break;
            }
          }
        }
        if (depth === 0 && Array.isArray(value)) {
          await this.util.validateValueIndexes(value);
        }
        if (flushStacks && depth < this.lastDepth) {
          this.flushStacks(this.lastDepth);
        }
        this.lastDepth = depth;
        this.lastKeys = keys;
        this.parsingContext.unaliasedKeywordCacheStack.splice(depth - 1);
      }
      /**
       * Flush the processing stacks at the given depth.
       * @param {number} depth A depth.
       */
      flushStacks(depth) {
        this.parsingContext.processingStack.splice(depth, 1);
        this.parsingContext.processingType.splice(depth, 1);
        this.parsingContext.emittedStack.splice(depth, 1);
        this.parsingContext.idStack.splice(depth, 1);
        this.parsingContext.graphStack.splice(depth + 1, 1);
        this.parsingContext.graphContainerTermStack.splice(depth, 1);
        this.parsingContext.jsonLiteralStack.splice(depth, 1);
        this.parsingContext.validationStack.splice(depth - 1, 2);
        this.parsingContext.literalStack.splice(depth, this.parsingContext.literalStack.length - depth);
        this.parsingContext.annotationsBuffer.splice(depth, 1);
      }
      /**
       * Flush buffers for the given depth.
       *
       * This should be called after the last entry at a given depth was processed.
       *
       * @param {number} depth A depth.
       * @param {any[]} keys A stack of keys.
       * @return {Promise<void>} A promise resolving if flushing is done.
       */
      async flushBuffer(depth, keys) {
        let subjects = this.parsingContext.idStack[depth];
        const subjectsWasDefined = !!subjects;
        if (!subjectsWasDefined) {
          subjects = this.parsingContext.idStack[depth] = [this.util.dataFactory.blankNode()];
        }
        const valueBuffer = this.parsingContext.unidentifiedValuesBuffer[depth];
        if (valueBuffer) {
          for (const subject of subjects) {
            const depthOffsetGraph = await this.util.getDepthOffsetGraph(depth, keys);
            const graphs = this.parsingContext.graphStack[depth] || depthOffsetGraph >= 0 ? this.parsingContext.idStack[depth - depthOffsetGraph - 1] : [await this.util.getGraphContainerValue(keys, depth)];
            if (graphs) {
              for (const graph of graphs) {
                this.parsingContext.emittedStack[depth] = true;
                for (const bufferedValue of valueBuffer) {
                  this.util.emitQuadChecked(depth, subject, bufferedValue.predicate, bufferedValue.object, graph, bufferedValue.reverse, bufferedValue.isEmbedded);
                }
              }
            } else {
              const subGraphBuffer = this.parsingContext.getUnidentifiedGraphBufferSafe(depth - await this.util.getDepthOffsetGraph(depth, keys) - 1);
              for (const bufferedValue of valueBuffer) {
                if (bufferedValue.reverse) {
                  subGraphBuffer.push({
                    object: subject,
                    predicate: bufferedValue.predicate,
                    subject: bufferedValue.object,
                    isEmbedded: bufferedValue.isEmbedded
                  });
                } else {
                  subGraphBuffer.push({
                    object: bufferedValue.object,
                    predicate: bufferedValue.predicate,
                    subject,
                    isEmbedded: bufferedValue.isEmbedded
                  });
                }
              }
            }
          }
          this.parsingContext.unidentifiedValuesBuffer.splice(depth, 1);
          this.parsingContext.literalStack.splice(depth, 1);
          this.parsingContext.jsonLiteralStack.splice(depth, 1);
        }
        const graphBuffer = this.parsingContext.unidentifiedGraphsBuffer[depth];
        if (graphBuffer) {
          for (const subject of subjects) {
            const graph = depth === 1 && subject.termType === "BlankNode" && !this.parsingContext.topLevelProperties ? this.util.getDefaultGraph() : subject;
            this.parsingContext.emittedStack[depth] = true;
            for (const bufferedValue of graphBuffer) {
              this.parsingContext.emitQuad(depth, this.util.dataFactory.quad(bufferedValue.subject, bufferedValue.predicate, bufferedValue.object, graph));
            }
          }
          this.parsingContext.unidentifiedGraphsBuffer.splice(depth, 1);
        }
        const annotationsBuffer = this.parsingContext.annotationsBuffer[depth];
        if (annotationsBuffer) {
          if (annotationsBuffer.length > 0 && depth === 1) {
            this.parsingContext.emitError(new jsonld_context_parser_1.ErrorCoded(`Annotations can not be made on top-level nodes`, jsonld_context_parser_1.ERROR_CODES.INVALID_ANNOTATION));
          }
          const annotationsBufferParent = this.parsingContext.getAnnotationsBufferSafe(depth - 1);
          for (const annotation of annotationsBuffer) {
            annotationsBufferParent.push(annotation);
          }
          delete this.parsingContext.annotationsBuffer[depth];
        }
      }
      /**
       * Check if at least one {@link IEntryHandler} validates the entry to true.
       * @param {any[]} keys A stack of keys.
       * @param {number} depth A depth.
       * @param {boolean} inProperty If the current depth is part of a valid property node.
       * @return {Promise<{ valid: boolean, property: boolean }>} A promise resolving to true or false.
       */
      async validateKey(keys, depth, inProperty) {
        for (const entryHandler of _JsonLdParser.ENTRY_HANDLERS) {
          if (await entryHandler.validate(this.parsingContext, this.util, keys, depth, inProperty)) {
            return { valid: true, property: inProperty || entryHandler.isPropertyHandler() };
          }
        }
        return { valid: false, property: false };
      }
      /**
       * Attach all required listeners to the JSON parser.
       *
       * This should only be called once.
       */
      attachJsonParserListeners() {
        this.jsonParser.onValue = (value) => {
          const depth = this.jsonParser.stack.length;
          const keys = new Array(depth + 1).fill(0).map((v, i) => {
            return i === depth ? this.jsonParser.key : this.jsonParser.stack[i].key;
          });
          if (!this.isParsingContextInner(depth)) {
            const valueJobCb = () => this.newOnValueJob(keys, value, depth, true);
            if (!this.parsingContext.streamingProfile && !this.parsingContext.contextTree.getContext(keys.slice(0, -1))) {
              if (keys[depth] === "@context") {
                let jobs = this.contextJobs[depth];
                if (!jobs) {
                  jobs = this.contextJobs[depth] = [];
                }
                jobs.push(valueJobCb);
              } else {
                this.contextAwaitingJobs.push({ job: valueJobCb, keys, depth });
              }
            } else {
              this.lastOnValueJob = this.lastOnValueJob.then(valueJobCb);
            }
            if (!this.parsingContext.streamingProfile && depth === 0) {
              this.lastOnValueJob = this.lastOnValueJob.then(() => this.executeBufferedJobs());
            }
          }
        };
        this.jsonParser.onError = (error46) => {
          this.emit("error", error46);
        };
      }
      /**
       * Check if the parser is currently parsing an element that is part of an @context entry.
       * @param {number} depth A depth.
       * @return {boolean} A boolean.
       */
      isParsingContextInner(depth) {
        for (let i = depth; i > 0; i--) {
          if (this.jsonParser.stack[i - 1].key === "@context") {
            return true;
          }
        }
        return false;
      }
      /**
       * Execute all buffered jobs.
       * @return {Promise<void>} A promise resolving if all jobs are finished.
       */
      async executeBufferedJobs() {
        for (const jobs of this.contextJobs) {
          if (jobs) {
            for (const job of jobs) {
              await job();
            }
          }
        }
        this.parsingContext.unaliasedKeywordCacheStack.splice(0);
        const contextAwaitingJobs = [];
        for (const job of this.contextAwaitingJobs) {
          if (await this.util.unaliasKeyword(job.keys[job.depth], job.keys, job.depth, true) === "@type" || typeof job.keys[job.depth] === "number" && await this.util.unaliasKeyword(job.keys[job.depth - 1], job.keys, job.depth - 1, true) === "@type") {
            this.typeJobs.push({ job: job.job, keys: job.keys.slice(0, job.keys.length - 1) });
          } else {
            contextAwaitingJobs.push(job);
          }
        }
        for (const job of contextAwaitingJobs) {
          if (this.typeJobs.length > 0) {
            const applicableTypeJobs = [];
            const applicableTypeJobIds = [];
            for (let i = 0; i < this.typeJobs.length; i++) {
              const typeJob = this.typeJobs[i];
              if (Util_1.Util.isPrefixArray(typeJob.keys, job.keys)) {
                applicableTypeJobs.push(typeJob);
                applicableTypeJobIds.push(i);
              }
            }
            const sortedTypeJobs = applicableTypeJobs.sort((job1, job2) => job1.keys.length - job2.keys.length);
            for (const typeJob of sortedTypeJobs) {
              await typeJob.job();
            }
            const sortedApplicableTypeJobIds = applicableTypeJobIds.sort().reverse();
            for (const jobId of sortedApplicableTypeJobIds) {
              this.typeJobs.splice(jobId, 1);
            }
          }
          await job.job();
        }
      }
    };
    exports.JsonLdParser = JsonLdParser2;
    JsonLdParser2.DEFAULT_PROCESSING_MODE = "1.1";
    JsonLdParser2.ENTRY_HANDLERS = [
      new EntryHandlerArrayValue_1.EntryHandlerArrayValue(),
      new EntryHandlerKeywordContext_1.EntryHandlerKeywordContext(),
      new EntryHandlerKeywordId_1.EntryHandlerKeywordId(),
      new EntryHandlerKeywordIncluded_1.EntryHandlerKeywordIncluded(),
      new EntryHandlerKeywordGraph_1.EntryHandlerKeywordGraph(),
      new EntryHandlerKeywordNest_1.EntryHandlerKeywordNest(),
      new EntryHandlerKeywordType_1.EntryHandlerKeywordType(),
      new EntryHandlerKeywordValue_1.EntryHandlerKeywordValue(),
      new EntryHandlerKeywordAnnotation_1.EntryHandlerKeywordAnnotation(),
      new EntryHandlerContainer_1.EntryHandlerContainer(),
      new EntryHandlerKeywordUnknownFallback_1.EntryHandlerKeywordUnknownFallback(),
      new EntryHandlerPredicate_1.EntryHandlerPredicate(),
      new EntryHandlerInvalidFallback_1.EntryHandlerInvalidFallback()
    ];
  }
});

// node_modules/jsonld-streaming-parser/index.js
var require_jsonld_streaming_parser = __commonJS({
  "node_modules/jsonld-streaming-parser/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    }) : (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    }));
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p)) __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_JsonLdParser(), exports);
  }
});

// node_modules/@inrupt/solid-client-errors/dist/clientError.mjs
var InruptClientError;
var init_clientError = __esm({
  "node_modules/@inrupt/solid-client-errors/dist/clientError.mjs"() {
    InruptClientError = class extends Error {
    };
  }
});

// node_modules/@inrupt/solid-client-errors/dist/http/problemDetails.mjs
function asUrl(url2, base) {
  if (url2 !== void 0) {
    try {
      return new URL(url2, base);
    } catch {
    }
  }
  return void 0;
}
function buildProblemDetails(response) {
  let type2;
  let title;
  let status;
  let detail;
  let instance;
  if (response.headers.get("Content-Type") === PROBLEM_DETAILS_MIME) {
    try {
      const responseBody = JSON.parse(response.body);
      const responseType = asUrl(responseBody.type, response.url);
      if (responseType !== void 0) {
        type2 = responseType;
      }
      if (typeof responseBody.title === "string") {
        title = responseBody.title;
      }
      if (typeof responseBody.status === "number") {
        status = responseBody.status;
      }
      if (typeof responseBody.detail === "string") {
        detail = responseBody.detail;
      }
      const responseInstance = asUrl(responseBody.instance, response.url);
      if (responseInstance !== void 0) {
        instance = responseInstance;
      }
    } catch {
    }
  }
  return Object.freeze({
    type: type2 ?? DEFAULT_TYPE,
    title: title ?? response.statusText,
    status: status ?? response.status,
    detail,
    instance
  });
}
var PROBLEM_DETAILS_MIME, DEFAULT_TYPE;
var init_problemDetails = __esm({
  "node_modules/@inrupt/solid-client-errors/dist/http/problemDetails.mjs"() {
    PROBLEM_DETAILS_MIME = "application/problem+json";
    DEFAULT_TYPE = new URL("about:blank");
  }
});

// node_modules/@inrupt/solid-client-errors/dist/http/httpError.mjs
var ClientHttpError;
var init_httpError = __esm({
  "node_modules/@inrupt/solid-client-errors/dist/http/httpError.mjs"() {
    init_clientError();
    init_problemDetails();
    ClientHttpError = class extends InruptClientError {
      constructor(responseMetadata, responseBody, message2, options) {
        super(message2, options);
        if (responseMetadata.status >= 200 && responseMetadata.status < 400) {
          throw new InruptClientError(`A ClientHttpError cannot be built from a success response, got ${responseMetadata.status} ${responseMetadata.statusText}`);
        }
        this.errorResponse = Object.freeze({
          status: responseMetadata.status,
          statusText: responseMetadata.statusText,
          headers: responseMetadata.headers,
          url: responseMetadata.url,
          body: responseBody,
          ok: false
        });
        this.details = buildProblemDetails(this.errorResponse);
      }
      get response() {
        return this.errorResponse;
      }
      get problemDetails() {
        return this.details;
      }
    };
  }
});

// node_modules/@inrupt/solid-client-errors/dist/http/wellKnown/badRequestError.mjs
var init_badRequestError = __esm({
  "node_modules/@inrupt/solid-client-errors/dist/http/wellKnown/badRequestError.mjs"() {
    init_clientError();
    init_httpError();
  }
});

// node_modules/@inrupt/solid-client-errors/dist/http/wellKnown/conflictError.mjs
var init_conflictError = __esm({
  "node_modules/@inrupt/solid-client-errors/dist/http/wellKnown/conflictError.mjs"() {
    init_clientError();
    init_httpError();
  }
});

// node_modules/@inrupt/solid-client-errors/dist/http/wellKnown/forbiddenError.mjs
var init_forbiddenError = __esm({
  "node_modules/@inrupt/solid-client-errors/dist/http/wellKnown/forbiddenError.mjs"() {
    init_clientError();
    init_httpError();
  }
});

// node_modules/@inrupt/solid-client-errors/dist/http/wellKnown/goneError.mjs
var init_goneError = __esm({
  "node_modules/@inrupt/solid-client-errors/dist/http/wellKnown/goneError.mjs"() {
    init_clientError();
    init_httpError();
  }
});

// node_modules/@inrupt/solid-client-errors/dist/http/wellKnown/internalServerError.mjs
var init_internalServerError = __esm({
  "node_modules/@inrupt/solid-client-errors/dist/http/wellKnown/internalServerError.mjs"() {
    init_clientError();
    init_httpError();
  }
});

// node_modules/@inrupt/solid-client-errors/dist/http/wellKnown/methodNotAllowedError.mjs
var init_methodNotAllowedError = __esm({
  "node_modules/@inrupt/solid-client-errors/dist/http/wellKnown/methodNotAllowedError.mjs"() {
    init_clientError();
    init_httpError();
  }
});

// node_modules/@inrupt/solid-client-errors/dist/http/wellKnown/notAcceptableError.mjs
var init_notAcceptableError = __esm({
  "node_modules/@inrupt/solid-client-errors/dist/http/wellKnown/notAcceptableError.mjs"() {
    init_clientError();
    init_httpError();
  }
});

// node_modules/@inrupt/solid-client-errors/dist/http/wellKnown/notFoundError.mjs
var init_notFoundError = __esm({
  "node_modules/@inrupt/solid-client-errors/dist/http/wellKnown/notFoundError.mjs"() {
    init_clientError();
    init_httpError();
  }
});

// node_modules/@inrupt/solid-client-errors/dist/http/wellKnown/preconditionFailedError.mjs
var init_preconditionFailedError = __esm({
  "node_modules/@inrupt/solid-client-errors/dist/http/wellKnown/preconditionFailedError.mjs"() {
    init_clientError();
    init_httpError();
  }
});

// node_modules/@inrupt/solid-client-errors/dist/http/wellKnown/tooManyRequestsError.mjs
var init_tooManyRequestsError = __esm({
  "node_modules/@inrupt/solid-client-errors/dist/http/wellKnown/tooManyRequestsError.mjs"() {
    init_clientError();
    init_httpError();
  }
});

// node_modules/@inrupt/solid-client-errors/dist/http/wellKnown/unauthorizedError.mjs
var init_unauthorizedError = __esm({
  "node_modules/@inrupt/solid-client-errors/dist/http/wellKnown/unauthorizedError.mjs"() {
    init_clientError();
    init_httpError();
  }
});

// node_modules/@inrupt/solid-client-errors/dist/http/wellKnown/unsupportedMediaTypeError.mjs
var init_unsupportedMediaTypeError = __esm({
  "node_modules/@inrupt/solid-client-errors/dist/http/wellKnown/unsupportedMediaTypeError.mjs"() {
    init_clientError();
    init_httpError();
  }
});

// node_modules/@inrupt/solid-client-errors/dist/http/handleErrorResponse.mjs
var init_handleErrorResponse = __esm({
  "node_modules/@inrupt/solid-client-errors/dist/http/handleErrorResponse.mjs"() {
    init_httpError();
    init_badRequestError();
    init_conflictError();
    init_forbiddenError();
    init_goneError();
    init_internalServerError();
    init_methodNotAllowedError();
    init_notAcceptableError();
    init_notFoundError();
    init_preconditionFailedError();
    init_tooManyRequestsError();
    init_unauthorizedError();
    init_unsupportedMediaTypeError();
  }
});

// node_modules/@inrupt/solid-client-errors/dist/http/errorResponse.mjs
var init_errorResponse = __esm({
  "node_modules/@inrupt/solid-client-errors/dist/http/errorResponse.mjs"() {
  }
});

// node_modules/@inrupt/solid-client-errors/dist/index.mjs
var init_dist = __esm({
  "node_modules/@inrupt/solid-client-errors/dist/index.mjs"() {
    init_clientError();
    init_httpError();
    init_handleErrorResponse();
    init_problemDetails();
    init_errorResponse();
    init_badRequestError();
    init_conflictError();
    init_forbiddenError();
    init_goneError();
    init_internalServerError();
    init_methodNotAllowedError();
    init_notAcceptableError();
    init_notFoundError();
    init_preconditionFailedError();
    init_tooManyRequestsError();
    init_unauthorizedError();
    init_unsupportedMediaTypeError();
  }
});

// node_modules/@inrupt/solid-client/dist/interfaces.mjs
function hasResourceInfo(resource) {
  const potentialResourceInfo = resource;
  return typeof potentialResourceInfo === "object" && typeof potentialResourceInfo.internal_resourceInfo === "object";
}
function hasServerResourceInfo(resource) {
  const potentialResourceInfo = resource;
  return typeof potentialResourceInfo === "object" && typeof potentialResourceInfo.internal_resourceInfo === "object" && typeof potentialResourceInfo.internal_resourceInfo.linkedResources === "object";
}
var SolidClientError;
var init_interfaces = __esm({
  "node_modules/@inrupt/solid-client/dist/interfaces.mjs"() {
    SolidClientError = class extends Error {
    };
  }
});

// node_modules/@inrupt/solid-client/dist/interfaces.internal.mjs
function internal_toIriString(iri) {
  return typeof iri === "string" ? iri : iri.value;
}
function normalizeUrl(inputUrl, options = {}) {
  const normalizedUrl = new URL(inputUrl);
  normalizedUrl.pathname = normalizedUrl.pathname.replace(/\/\/+/g, "/");
  if (options.trailingSlash === false && normalizedUrl.pathname.slice(-1) === "/") {
    normalizedUrl.pathname = normalizedUrl.pathname.slice(0, normalizedUrl.pathname.length - 1);
  }
  if (options.trailingSlash === true && normalizedUrl.pathname.slice(-1) !== "/") {
    normalizedUrl.pathname = `${normalizedUrl.pathname}/`;
  }
  return normalizedUrl.href;
}
var init_interfaces_internal = __esm({
  "node_modules/@inrupt/solid-client/dist/interfaces.internal.mjs"() {
  }
});

// node_modules/@inrupt/solid-client/dist/resource/resource.internal.mjs
function internal_parseResourceInfo(response) {
  var _a, _b, _c, _d, _e;
  const contentTypeParts = (_b = (_a = response.headers.get("Content-Type")) === null || _a === void 0 ? void 0 : _a.split(";")) !== null && _b !== void 0 ? _b : [];
  const isSolidDataset = contentTypeParts.length > 0 && ["text/turtle", "application/ld+json"].includes(contentTypeParts[0]);
  const resourceInfo = {
    sourceIri: response.url,
    isRawData: !isSolidDataset,
    contentLocation: (_c = response.headers.get("Content-Location")) !== null && _c !== void 0 ? _c : void 0,
    contentType: (_d = response.headers.get("Content-Type")) !== null && _d !== void 0 ? _d : void 0,
    linkedResources: {},
    location: (_e = response.headers.get("Location")) !== null && _e !== void 0 ? _e : void 0
  };
  const linkHeader = response.headers.get("Link");
  if (linkHeader) {
    const parsedLinks = import_http_link_header.default.parse(linkHeader);
    const aclLinks = parsedLinks.get("rel", "acl");
    if (aclLinks.length === 1) {
      resourceInfo.aclUrl = new URL(aclLinks[0].uri, resourceInfo.sourceIri).href;
    }
    resourceInfo.linkedResources = parsedLinks.refs.reduce((rels, ref) => {
      var _a2;
      var _b2;
      (_a2 = rels[_b2 = ref.rel]) !== null && _a2 !== void 0 ? _a2 : rels[_b2] = [];
      rels[ref.rel].push(new URL(ref.uri, resourceInfo.sourceIri).href);
      return rels;
    }, resourceInfo.linkedResources);
  }
  const wacAllowHeader = response.headers.get("WAC-Allow");
  if (wacAllowHeader) {
    resourceInfo.permissions = parseWacAllowHeader(wacAllowHeader);
  }
  return resourceInfo;
}
function parseWacAllowHeader(wacAllowHeader) {
  function parsePermissionStatement(permissionStatement) {
    const permissions = permissionStatement.split(" ");
    const writePermission = permissions.includes("write");
    return writePermission ? {
      read: permissions.includes("read"),
      append: true,
      write: true,
      control: permissions.includes("control")
    } : {
      read: permissions.includes("read"),
      append: permissions.includes("append"),
      write: false,
      control: permissions.includes("control")
    };
  }
  function getStatementFor(header, scope) {
    const relevantEntries = header.split(",").map((rawEntry) => rawEntry.split("=")).filter((parts) => parts.length === 2 && parts[0].trim() === scope);
    if (relevantEntries.length !== 1) {
      return "";
    }
    const relevantStatement = relevantEntries[0][1].trim();
    if (relevantStatement.charAt(0) !== '"' || relevantStatement.charAt(relevantStatement.length - 1) !== '"') {
      return "";
    }
    return relevantStatement.substring(1, relevantStatement.length - 1);
  }
  return {
    user: parsePermissionStatement(getStatementFor(wacAllowHeader, "user")),
    public: parsePermissionStatement(getStatementFor(wacAllowHeader, "public"))
  };
}
function internal_cloneResource(resource) {
  let clonedResource;
  if (typeof resource.slice === "function") {
    clonedResource = Object.assign(resource.slice(), { ...resource });
  } else {
    clonedResource = { ...resource };
  }
  return clonedResource;
}
function internal_isUnsuccessfulResponse(response) {
  return !response.ok;
}
function internal_isAuthenticationFailureResponse(response) {
  return response.status === 401 || response.status === 403;
}
var import_http_link_header;
var init_resource_internal = __esm({
  "node_modules/@inrupt/solid-client/dist/resource/resource.internal.mjs"() {
    import_http_link_header = __toESM(require_link(), 1);
  }
});

// node_modules/@inrupt/solid-client/dist/constants.mjs
var ldp;
var init_constants = __esm({
  "node_modules/@inrupt/solid-client/dist/constants.mjs"() {
    ldp = {
      BasicContainer: "http://www.w3.org/ns/ldp#BasicContainer",
      Container: "http://www.w3.org/ns/ldp#Container",
      Resource: "http://www.w3.org/ns/ldp#Resource",
      contains: "http://www.w3.org/ns/ldp#contains"
    };
  }
});

// node_modules/@inrupt/solid-client/dist/resource/resource.mjs
function responseToResourceInfo(response, options = { ignoreAuthenticationErrors: false }) {
  if (internal_isUnsuccessfulResponse(response) && (!internal_isAuthenticationFailureResponse(response) || !options.ignoreAuthenticationErrors)) {
    throw new FetchError(`Fetching the metadata of the Resource at [${response.url}] failed: [${response.status}] [${response.statusText}].`, response);
  }
  const resourceInfo = internal_parseResourceInfo(response);
  return { internal_resourceInfo: resourceInfo };
}
function getContentType(resource) {
  var _a;
  return (_a = resource.internal_resourceInfo.contentType) !== null && _a !== void 0 ? _a : null;
}
function getSourceUrl(resource) {
  if (hasResourceInfo(resource)) {
    return resource.internal_resourceInfo.sourceIri;
  }
  return null;
}
var getSourceIri, FetchError;
var init_resource = __esm({
  "node_modules/@inrupt/solid-client/dist/resource/resource.mjs"() {
    init_dist();
    init_interfaces();
    init_resource_internal();
    getSourceIri = getSourceUrl;
    FetchError = class extends SolidClientError {
      constructor(message2, errorResponse, responseBody) {
        super(message2);
        this.response = errorResponse;
        if (typeof responseBody === "string") {
          this.httpError = new ClientHttpError(errorResponse, responseBody, message2);
        } else {
          this.httpError = new ClientHttpError(errorResponse, "", message2);
        }
      }
      get statusCode() {
        return this.response.status;
      }
      get statusText() {
        return this.response.statusText;
      }
      get problemDetails() {
        return this.httpError.problemDetails;
      }
    };
  }
});

// node_modules/@inrupt/solid-client/dist/formats/jsonLd.mjs
var import_jsonld_streaming_parser, import_jsonld_context_parser, getJsonLdParser;
var init_jsonLd = __esm({
  "node_modules/@inrupt/solid-client/dist/formats/jsonLd.mjs"() {
    import_jsonld_streaming_parser = __toESM(require_jsonld_streaming_parser(), 1);
    import_jsonld_context_parser = __toESM(require_jsonld_context_parser(), 1);
    init_resource();
    getJsonLdParser = () => {
      const onQuadCallbacks = [];
      const onCompleteCallbacks = [];
      const onErrorCallbacks = [];
      return {
        onQuad: (callback) => {
          onQuadCallbacks.push(callback);
        },
        onError: (callback) => {
          onErrorCallbacks.push(callback);
        },
        onComplete: (callback) => {
          onCompleteCallbacks.push(callback);
        },
        // The following returns a Promise that can be awaited, which is undocumented
        // behavior that doesn't match the type signature. It prevents a potentially
        // breaking change, and will be updated on the next major release.
        parse: (source, resourceInfo) => new Promise((res) => {
          const parser = new import_jsonld_streaming_parser.JsonLdParser({
            baseIRI: getSourceUrl(resourceInfo),
            documentLoader: new import_jsonld_context_parser.FetchDocumentLoader((...args) => fetch(...args))
          });
          let endCalled = false;
          function end() {
            if (!endCalled) {
              endCalled = true;
              onCompleteCallbacks.forEach((callback) => callback());
              res();
            }
          }
          parser.on("end", end);
          parser.on("error", (err) => {
            onErrorCallbacks.forEach((callback) => callback(err));
            end();
          });
          onQuadCallbacks.forEach((callback) => parser.on("data", callback));
          parser.write(source);
          parser.end();
        })
      };
    };
  }
});

// node_modules/n3/src/IRIs.js
var RDF, XSD, SWAP, IRIs_default;
var init_IRIs = __esm({
  "node_modules/n3/src/IRIs.js"() {
    RDF = "http://www.w3.org/1999/02/22-rdf-syntax-ns#";
    XSD = "http://www.w3.org/2001/XMLSchema#";
    SWAP = "http://www.w3.org/2000/10/swap/";
    IRIs_default = {
      xsd: {
        decimal: `${XSD}decimal`,
        boolean: `${XSD}boolean`,
        double: `${XSD}double`,
        integer: `${XSD}integer`,
        string: `${XSD}string`
      },
      rdf: {
        type: `${RDF}type`,
        nil: `${RDF}nil`,
        first: `${RDF}first`,
        rest: `${RDF}rest`,
        langString: `${RDF}langString`
      },
      owl: {
        sameAs: "http://www.w3.org/2002/07/owl#sameAs"
      },
      r: {
        forSome: `${SWAP}reify#forSome`,
        forAll: `${SWAP}reify#forAll`
      },
      log: {
        implies: `${SWAP}log#implies`,
        isImpliedBy: `${SWAP}log#isImpliedBy`
      }
    };
  }
});

// node_modules/n3/src/N3Lexer.js
var import_buffer, xsd, escapeSequence, escapeReplacements, illegalIriChars, lineModeRegExps, invalidRegExp, N3Lexer;
var init_N3Lexer = __esm({
  "node_modules/n3/src/N3Lexer.js"() {
    import_buffer = __toESM(require_buffer());
    init_IRIs();
    ({ xsd } = IRIs_default);
    escapeSequence = /\\u([a-fA-F0-9]{4})|\\U([a-fA-F0-9]{8})|\\([^])/g;
    escapeReplacements = {
      "\\": "\\",
      "'": "'",
      '"': '"',
      "n": "\n",
      "r": "\r",
      "t": "	",
      "f": "\f",
      "b": "\b",
      "_": "_",
      "~": "~",
      ".": ".",
      "-": "-",
      "!": "!",
      "$": "$",
      "&": "&",
      "(": "(",
      ")": ")",
      "*": "*",
      "+": "+",
      ",": ",",
      ";": ";",
      "=": "=",
      "/": "/",
      "?": "?",
      "#": "#",
      "@": "@",
      "%": "%"
    };
    illegalIriChars = /[\x00-\x20<>\\"\{\}\|\^\`]/;
    lineModeRegExps = {
      _iri: true,
      _unescapedIri: true,
      _simpleQuotedString: true,
      _langcode: true,
      _blank: true,
      _newline: true,
      _comment: true,
      _whitespace: true,
      _endOfFile: true
    };
    invalidRegExp = /$0^/;
    N3Lexer = class {
      constructor(options) {
        this._iri = /^<((?:[^ <>{}\\]|\\[uU])+)>[ \t]*/;
        this._unescapedIri = /^<([^\x00-\x20<>\\"\{\}\|\^\`]*)>[ \t]*/;
        this._simpleQuotedString = /^"([^"\\\r\n]*)"(?=[^"])/;
        this._simpleApostropheString = /^'([^'\\\r\n]*)'(?=[^'])/;
        this._langcode = /^@([a-z]+(?:-[a-z0-9]+)*)(?=[^a-z0-9\-])/i;
        this._prefix = /^((?:[A-Za-z\xc0-\xd6\xd8-\xf6\xf8-\u02ff\u0370-\u037d\u037f-\u1fff\u200c\u200d\u2070-\u218f\u2c00-\u2fef\u3001-\ud7ff\uf900-\ufdcf\ufdf0-\ufffd]|[\ud800-\udb7f][\udc00-\udfff])(?:\.?[\-0-9A-Z_a-z\xb7\xc0-\xd6\xd8-\xf6\xf8-\u037d\u037f-\u1fff\u200c\u200d\u203f\u2040\u2070-\u218f\u2c00-\u2fef\u3001-\ud7ff\uf900-\ufdcf\ufdf0-\ufffd]|[\ud800-\udb7f][\udc00-\udfff])*)?:(?=[#\s<])/;
        this._prefixed = /^((?:[A-Za-z\xc0-\xd6\xd8-\xf6\xf8-\u02ff\u0370-\u037d\u037f-\u1fff\u200c\u200d\u2070-\u218f\u2c00-\u2fef\u3001-\ud7ff\uf900-\ufdcf\ufdf0-\ufffd]|[\ud800-\udb7f][\udc00-\udfff])(?:\.?[\-0-9A-Z_a-z\xb7\xc0-\xd6\xd8-\xf6\xf8-\u037d\u037f-\u1fff\u200c\u200d\u203f\u2040\u2070-\u218f\u2c00-\u2fef\u3001-\ud7ff\uf900-\ufdcf\ufdf0-\ufffd]|[\ud800-\udb7f][\udc00-\udfff])*)?:((?:(?:[0-:A-Z_a-z\xc0-\xd6\xd8-\xf6\xf8-\u02ff\u0370-\u037d\u037f-\u1fff\u200c\u200d\u2070-\u218f\u2c00-\u2fef\u3001-\ud7ff\uf900-\ufdcf\ufdf0-\ufffd]|[\ud800-\udb7f][\udc00-\udfff]|%[0-9a-fA-F]{2}|\\[!#-\/;=?\-@_~])(?:(?:[\.\-0-:A-Z_a-z\xb7\xc0-\xd6\xd8-\xf6\xf8-\u037d\u037f-\u1fff\u200c\u200d\u203f\u2040\u2070-\u218f\u2c00-\u2fef\u3001-\ud7ff\uf900-\ufdcf\ufdf0-\ufffd]|[\ud800-\udb7f][\udc00-\udfff]|%[0-9a-fA-F]{2}|\\[!#-\/;=?\-@_~])*(?:[\-0-:A-Z_a-z\xb7\xc0-\xd6\xd8-\xf6\xf8-\u037d\u037f-\u1fff\u200c\u200d\u203f\u2040\u2070-\u218f\u2c00-\u2fef\u3001-\ud7ff\uf900-\ufdcf\ufdf0-\ufffd]|[\ud800-\udb7f][\udc00-\udfff]|%[0-9a-fA-F]{2}|\\[!#-\/;=?\-@_~]))?)?)(?:[ \t]+|(?=\.?[,;!\^\s#()\[\]\{\}"'<>]))/;
        this._variable = /^\?(?:(?:[A-Z_a-z\xc0-\xd6\xd8-\xf6\xf8-\u02ff\u0370-\u037d\u037f-\u1fff\u200c\u200d\u2070-\u218f\u2c00-\u2fef\u3001-\ud7ff\uf900-\ufdcf\ufdf0-\ufffd]|[\ud800-\udb7f][\udc00-\udfff])(?:[\-0-:A-Z_a-z\xb7\xc0-\xd6\xd8-\xf6\xf8-\u037d\u037f-\u1fff\u200c\u200d\u203f\u2040\u2070-\u218f\u2c00-\u2fef\u3001-\ud7ff\uf900-\ufdcf\ufdf0-\ufffd]|[\ud800-\udb7f][\udc00-\udfff])*)(?=[.,;!\^\s#()\[\]\{\}"'<>])/;
        this._blank = /^_:((?:[0-9A-Z_a-z\xc0-\xd6\xd8-\xf6\xf8-\u02ff\u0370-\u037d\u037f-\u1fff\u200c\u200d\u2070-\u218f\u2c00-\u2fef\u3001-\ud7ff\uf900-\ufdcf\ufdf0-\ufffd]|[\ud800-\udb7f][\udc00-\udfff])(?:\.?[\-0-9A-Z_a-z\xb7\xc0-\xd6\xd8-\xf6\xf8-\u037d\u037f-\u1fff\u200c\u200d\u203f\u2040\u2070-\u218f\u2c00-\u2fef\u3001-\ud7ff\uf900-\ufdcf\ufdf0-\ufffd]|[\ud800-\udb7f][\udc00-\udfff])*)(?:[ \t]+|(?=\.?[,;:\s#()\[\]\{\}"'<>]))/;
        this._number = /^[\-+]?(?:(\d+\.\d*|\.?\d+)[eE][\-+]?|\d*(\.)?)\d+(?=\.?[,;:\s#()\[\]\{\}"'<>])/;
        this._boolean = /^(?:true|false)(?=[.,;\s#()\[\]\{\}"'<>])/;
        this._keyword = /^@[a-z]+(?=[\s#<:])/i;
        this._sparqlKeyword = /^(?:PREFIX|BASE|GRAPH)(?=[\s#<])/i;
        this._shortPredicates = /^a(?=[\s#()\[\]\{\}"'<>])/;
        this._newline = /^[ \t]*(?:#[^\n\r]*)?(?:\r\n|\n|\r)[ \t]*/;
        this._comment = /#([^\n\r]*)/;
        this._whitespace = /^[ \t]+/;
        this._endOfFile = /^(?:#[^\n\r]*)?$/;
        options = options || {};
        this._isImpliedBy = options.isImpliedBy;
        if (this._lineMode = !!options.lineMode) {
          this._n3Mode = false;
          for (const key in this) {
            if (!(key in lineModeRegExps) && this[key] instanceof RegExp)
              this[key] = invalidRegExp;
          }
        } else {
          this._n3Mode = options.n3 !== false;
        }
        this.comments = !!options.comments;
        this._literalClosingPos = 0;
      }
      // ## Private methods
      // ### `_tokenizeToEnd` tokenizes as for as possible, emitting tokens through the callback
      _tokenizeToEnd(callback, inputFinished) {
        let input = this._input;
        let currentLineLength = input.length;
        while (true) {
          let whiteSpaceMatch, comment;
          while (whiteSpaceMatch = this._newline.exec(input)) {
            if (this.comments && (comment = this._comment.exec(whiteSpaceMatch[0])))
              emitToken("comment", comment[1], "", this._line, whiteSpaceMatch[0].length);
            input = input.substr(whiteSpaceMatch[0].length, input.length);
            currentLineLength = input.length;
            this._line++;
          }
          if (!whiteSpaceMatch && (whiteSpaceMatch = this._whitespace.exec(input)))
            input = input.substr(whiteSpaceMatch[0].length, input.length);
          if (this._endOfFile.test(input)) {
            if (inputFinished) {
              if (this.comments && (comment = this._comment.exec(input)))
                emitToken("comment", comment[1], "", this._line, input.length);
              input = null;
              emitToken("eof", "", "", this._line, 0);
            }
            return this._input = input;
          }
          const line = this._line, firstChar = input[0];
          let type2 = "", value = "", prefix = "", match = null, matchLength = 0, inconclusive = false;
          switch (firstChar) {
            case "^":
              if (input.length < 3)
                break;
              else if (input[1] === "^") {
                this._previousMarker = "^^";
                input = input.substr(2);
                if (input[0] !== "<") {
                  inconclusive = true;
                  break;
                }
              } else {
                if (this._n3Mode) {
                  matchLength = 1;
                  type2 = "^";
                }
                break;
              }
            // Fall through in case the type is an IRI
            case "<":
              if (match = this._unescapedIri.exec(input))
                type2 = "IRI", value = match[1];
              else if (match = this._iri.exec(input)) {
                value = this._unescape(match[1]);
                if (value === null || illegalIriChars.test(value))
                  return reportSyntaxError(this);
                type2 = "IRI";
              } else if (input.length > 1 && input[1] === "<")
                type2 = "<<", matchLength = 2;
              else if (this._n3Mode && input.length > 1 && input[1] === "=") {
                matchLength = 2;
                if (this._isImpliedBy) type2 = "abbreviation", value = "<";
                else type2 = "inverse", value = ">";
              }
              break;
            case ">":
              if (input.length > 1 && input[1] === ">")
                type2 = ">>", matchLength = 2;
              break;
            case "_":
              if ((match = this._blank.exec(input)) || inputFinished && (match = this._blank.exec(`${input} `)))
                type2 = "blank", prefix = "_", value = match[1];
              break;
            case '"':
              if (match = this._simpleQuotedString.exec(input))
                value = match[1];
              else {
                ({ value, matchLength } = this._parseLiteral(input));
                if (value === null)
                  return reportSyntaxError(this);
              }
              if (match !== null || matchLength !== 0) {
                type2 = "literal";
                this._literalClosingPos = 0;
              }
              break;
            case "'":
              if (!this._lineMode) {
                if (match = this._simpleApostropheString.exec(input))
                  value = match[1];
                else {
                  ({ value, matchLength } = this._parseLiteral(input));
                  if (value === null)
                    return reportSyntaxError(this);
                }
                if (match !== null || matchLength !== 0) {
                  type2 = "literal";
                  this._literalClosingPos = 0;
                }
              }
              break;
            case "?":
              if (this._n3Mode && (match = this._variable.exec(input)))
                type2 = "var", value = match[0];
              break;
            case "@":
              if (this._previousMarker === "literal" && (match = this._langcode.exec(input)))
                type2 = "langcode", value = match[1];
              else if (match = this._keyword.exec(input))
                type2 = match[0];
              break;
            case ".":
              if (input.length === 1 ? inputFinished : input[1] < "0" || input[1] > "9") {
                type2 = ".";
                matchLength = 1;
                break;
              }
            // Fall through to numerical case (could be a decimal dot)
            case "0":
            case "1":
            case "2":
            case "3":
            case "4":
            case "5":
            case "6":
            case "7":
            case "8":
            case "9":
            case "+":
            case "-":
              if (match = this._number.exec(input) || inputFinished && (match = this._number.exec(`${input} `))) {
                type2 = "literal", value = match[0];
                prefix = typeof match[1] === "string" ? xsd.double : typeof match[2] === "string" ? xsd.decimal : xsd.integer;
              }
              break;
            case "B":
            case "b":
            case "p":
            case "P":
            case "G":
            case "g":
              if (match = this._sparqlKeyword.exec(input))
                type2 = match[0].toUpperCase();
              else
                inconclusive = true;
              break;
            case "f":
            case "t":
              if (match = this._boolean.exec(input))
                type2 = "literal", value = match[0], prefix = xsd.boolean;
              else
                inconclusive = true;
              break;
            case "a":
              if (match = this._shortPredicates.exec(input))
                type2 = "abbreviation", value = "a";
              else
                inconclusive = true;
              break;
            case "=":
              if (this._n3Mode && input.length > 1) {
                type2 = "abbreviation";
                if (input[1] !== ">")
                  matchLength = 1, value = "=";
                else
                  matchLength = 2, value = ">";
              }
              break;
            case "!":
              if (!this._n3Mode)
                break;
            case ",":
            case ";":
            case "[":
            case "]":
            case "(":
            case ")":
            case "}":
              if (!this._lineMode) {
                matchLength = 1;
                type2 = firstChar;
              }
              break;
            case "{":
              if (!this._lineMode && input.length >= 2) {
                if (input[1] === "|")
                  type2 = "{|", matchLength = 2;
                else
                  type2 = firstChar, matchLength = 1;
              }
              break;
            case "|":
              if (input.length >= 2 && input[1] === "}")
                type2 = "|}", matchLength = 2;
              break;
            default:
              inconclusive = true;
          }
          if (inconclusive) {
            if ((this._previousMarker === "@prefix" || this._previousMarker === "PREFIX") && (match = this._prefix.exec(input)))
              type2 = "prefix", value = match[1] || "";
            else if ((match = this._prefixed.exec(input)) || inputFinished && (match = this._prefixed.exec(`${input} `)))
              type2 = "prefixed", prefix = match[1] || "", value = this._unescape(match[2]);
          }
          if (this._previousMarker === "^^") {
            switch (type2) {
              case "prefixed":
                type2 = "type";
                break;
              case "IRI":
                type2 = "typeIRI";
                break;
              default:
                type2 = "";
            }
          }
          if (!type2) {
            if (inputFinished || !/^'''|^"""/.test(input) && /\n|\r/.test(input))
              return reportSyntaxError(this);
            else
              return this._input = input;
          }
          const length = matchLength || match[0].length;
          const token = emitToken(type2, value, prefix, line, length);
          this.previousToken = token;
          this._previousMarker = type2;
          input = input.substr(length, input.length);
        }
        function emitToken(type2, value, prefix, line, length) {
          const start = input ? currentLineLength - input.length : currentLineLength;
          const end = start + length;
          const token = { type: type2, value, prefix, line, start, end };
          callback(null, token);
          return token;
        }
        function reportSyntaxError(self2) {
          callback(self2._syntaxError(/^\S*/.exec(input)[0]));
        }
      }
      // ### `_unescape` replaces N3 escape codes by their corresponding characters
      _unescape(item) {
        let invalid = false;
        const replaced = item.replace(escapeSequence, (sequence, unicode4, unicode8, escapedChar) => {
          if (typeof unicode4 === "string")
            return String.fromCharCode(Number.parseInt(unicode4, 16));
          if (typeof unicode8 === "string") {
            let charCode = Number.parseInt(unicode8, 16);
            return charCode <= 65535 ? String.fromCharCode(Number.parseInt(unicode8, 16)) : String.fromCharCode(55296 + ((charCode -= 65536) >> 10), 56320 + (charCode & 1023));
          }
          if (escapedChar in escapeReplacements)
            return escapeReplacements[escapedChar];
          invalid = true;
          return "";
        });
        return invalid ? null : replaced;
      }
      // ### `_parseLiteral` parses a literal into an unescaped value
      _parseLiteral(input) {
        if (input.length >= 3) {
          const opening = input.match(/^(?:"""|"|'''|'|)/)[0];
          const openingLength = opening.length;
          let closingPos = Math.max(this._literalClosingPos, openingLength);
          while ((closingPos = input.indexOf(opening, closingPos)) > 0) {
            let backslashCount = 0;
            while (input[closingPos - backslashCount - 1] === "\\")
              backslashCount++;
            if (backslashCount % 2 === 0) {
              const raw = input.substring(openingLength, closingPos);
              const lines = raw.split(/\r\n|\r|\n/).length - 1;
              const matchLength = closingPos + openingLength;
              if (openingLength === 1 && lines !== 0 || openingLength === 3 && this._lineMode)
                break;
              this._line += lines;
              return { value: this._unescape(raw), matchLength };
            }
            closingPos++;
          }
          this._literalClosingPos = input.length - openingLength + 1;
        }
        return { value: "", matchLength: 0 };
      }
      // ### `_syntaxError` creates a syntax error for the given issue
      _syntaxError(issue2) {
        this._input = null;
        const err = new Error(`Unexpected "${issue2}" on line ${this._line}.`);
        err.context = {
          token: void 0,
          line: this._line,
          previousToken: this.previousToken
        };
        return err;
      }
      // ### Strips off any starting UTF BOM mark.
      _readStartingBom(input) {
        return input.startsWith("\uFEFF") ? input.substr(1) : input;
      }
      // ## Public methods
      // ### `tokenize` starts the transformation of an N3 document into an array of tokens.
      // The input can be a string or a stream.
      tokenize(input, callback) {
        this._line = 1;
        if (typeof input === "string") {
          this._input = this._readStartingBom(input);
          if (typeof callback === "function")
            queueMicrotask(() => this._tokenizeToEnd(callback, true));
          else {
            const tokens = [];
            let error46;
            this._tokenizeToEnd((e, t) => e ? error46 = e : tokens.push(t), true);
            if (error46) throw error46;
            return tokens;
          }
        } else {
          this._pendingBuffer = null;
          if (typeof input.setEncoding === "function")
            input.setEncoding("utf8");
          input.on("data", (data) => {
            if (this._input !== null && data.length !== 0) {
              if (this._pendingBuffer) {
                data = import_buffer.Buffer.concat([this._pendingBuffer, data]);
                this._pendingBuffer = null;
              }
              if (data[data.length - 1] & 128) {
                this._pendingBuffer = data;
              } else {
                if (typeof this._input === "undefined")
                  this._input = this._readStartingBom(typeof data === "string" ? data : data.toString());
                else
                  this._input += data;
                this._tokenizeToEnd(callback, false);
              }
            }
          });
          input.on("end", () => {
            if (typeof this._input === "string")
              this._tokenizeToEnd(callback, true);
          });
          input.on("error", callback);
        }
      }
    };
  }
});

// node_modules/n3/src/N3DataFactory.js
function termFromId(id, factory, nested) {
  factory = factory || DataFactory;
  if (!id)
    return factory.defaultGraph();
  switch (id[0]) {
    case "?":
      return factory.variable(id.substr(1));
    case "_":
      return factory.blankNode(id.substr(2));
    case '"':
      if (factory === DataFactory)
        return new Literal(id);
      if (id[id.length - 1] === '"')
        return factory.literal(id.substr(1, id.length - 2));
      const endPos = id.lastIndexOf('"', id.length - 1);
      return factory.literal(
        id.substr(1, endPos - 1),
        id[endPos + 1] === "@" ? id.substr(endPos + 2) : factory.namedNode(id.substr(endPos + 3))
      );
    case "[":
      id = JSON.parse(id);
      break;
    default:
      if (!nested || !Array.isArray(id)) {
        return factory.namedNode(id);
      }
  }
  return factory.quad(
    termFromId(id[0], factory, true),
    termFromId(id[1], factory, true),
    termFromId(id[2], factory, true),
    id[3] && termFromId(id[3], factory, true)
  );
}
function termToId(term, nested) {
  if (typeof term === "string")
    return term;
  if (term instanceof Term && term.termType !== "Quad")
    return term.id;
  if (!term)
    return DEFAULTGRAPH.id;
  switch (term.termType) {
    case "NamedNode":
      return term.value;
    case "BlankNode":
      return `_:${term.value}`;
    case "Variable":
      return `?${term.value}`;
    case "DefaultGraph":
      return "";
    case "Literal":
      return `"${term.value}"${term.language ? `@${term.language}` : term.datatype && term.datatype.value !== xsd2.string ? `^^${term.datatype.value}` : ""}`;
    case "Quad":
      const res = [
        termToId(term.subject, true),
        termToId(term.predicate, true),
        termToId(term.object, true)
      ];
      if (term.graph && term.graph.termType !== "DefaultGraph") {
        res.push(termToId(term.graph, true));
      }
      return nested ? res : JSON.stringify(res);
    default:
      throw new Error(`Unexpected termType: ${term.termType}`);
  }
}
function namedNode(iri) {
  return new NamedNode(iri);
}
function blankNode(name) {
  return new BlankNode(name || `n3-${_blankNodeCounter++}`);
}
function literal(value, languageOrDataType) {
  if (typeof languageOrDataType === "string")
    return new Literal(`"${value}"@${languageOrDataType.toLowerCase()}`);
  let datatype = languageOrDataType ? languageOrDataType.value : "";
  if (datatype === "") {
    if (typeof value === "boolean")
      datatype = xsd2.boolean;
    else if (typeof value === "number") {
      if (Number.isFinite(value))
        datatype = Number.isInteger(value) ? xsd2.integer : xsd2.double;
      else {
        datatype = xsd2.double;
        if (!Number.isNaN(value))
          value = value > 0 ? "INF" : "-INF";
      }
    }
  }
  return datatype === "" || datatype === xsd2.string ? new Literal(`"${value}"`) : new Literal(`"${value}"^^${datatype}`);
}
function variable(name) {
  return new Variable(name);
}
function defaultGraph() {
  return DEFAULTGRAPH;
}
function quad(subject, predicate, object2, graph) {
  return new Quad(subject, predicate, object2, graph);
}
function fromTerm(term) {
  if (term instanceof Term)
    return term;
  switch (term.termType) {
    case "NamedNode":
      return namedNode(term.value);
    case "BlankNode":
      return blankNode(term.value);
    case "Variable":
      return variable(term.value);
    case "DefaultGraph":
      return DEFAULTGRAPH;
    case "Literal":
      return literal(term.value, term.language || term.datatype);
    case "Quad":
      return fromQuad(term);
    default:
      throw new Error(`Unexpected termType: ${term.termType}`);
  }
}
function fromQuad(inQuad) {
  if (inQuad instanceof Quad)
    return inQuad;
  if (inQuad.termType !== "Quad")
    throw new Error(`Unexpected termType: ${inQuad.termType}`);
  return quad(fromTerm(inQuad.subject), fromTerm(inQuad.predicate), fromTerm(inQuad.object), fromTerm(inQuad.graph));
}
var rdf, xsd2, DEFAULTGRAPH, _blankNodeCounter, DataFactory, N3DataFactory_default, Term, NamedNode, Literal, BlankNode, Variable, DefaultGraph, Quad;
var init_N3DataFactory = __esm({
  "node_modules/n3/src/N3DataFactory.js"() {
    init_IRIs();
    ({ rdf, xsd: xsd2 } = IRIs_default);
    _blankNodeCounter = 0;
    DataFactory = {
      namedNode,
      blankNode,
      variable,
      literal,
      defaultGraph,
      quad,
      triple: quad,
      fromTerm,
      fromQuad
    };
    N3DataFactory_default = DataFactory;
    Term = class _Term {
      constructor(id) {
        this.id = id;
      }
      // ### The value of this term
      get value() {
        return this.id;
      }
      // ### Returns whether this object represents the same term as the other
      equals(other) {
        if (other instanceof _Term)
          return this.id === other.id;
        return !!other && this.termType === other.termType && this.value === other.value;
      }
      // ### Implement hashCode for Immutable.js, since we implement `equals`
      // https://immutable-js.com/docs/v4.0.0/ValueObject/#hashCode()
      hashCode() {
        return 0;
      }
      // ### Returns a plain object representation of this term
      toJSON() {
        return {
          termType: this.termType,
          value: this.value
        };
      }
    };
    NamedNode = class extends Term {
      // ### The term type of this term
      get termType() {
        return "NamedNode";
      }
    };
    Literal = class _Literal extends Term {
      // ### The term type of this term
      get termType() {
        return "Literal";
      }
      // ### The text value of this literal
      get value() {
        return this.id.substring(1, this.id.lastIndexOf('"'));
      }
      // ### The language of this literal
      get language() {
        const id = this.id;
        let atPos = id.lastIndexOf('"') + 1;
        return atPos < id.length && id[atPos++] === "@" ? id.substr(atPos).toLowerCase() : "";
      }
      // ### The datatype IRI of this literal
      get datatype() {
        return new NamedNode(this.datatypeString);
      }
      // ### The datatype string of this literal
      get datatypeString() {
        const id = this.id, dtPos = id.lastIndexOf('"') + 1;
        const char = dtPos < id.length ? id[dtPos] : "";
        return char === "^" ? id.substr(dtPos + 2) : (
          // If "@" follows, return rdf:langString; xsd:string otherwise
          char !== "@" ? xsd2.string : rdf.langString
        );
      }
      // ### Returns whether this object represents the same term as the other
      equals(other) {
        if (other instanceof _Literal)
          return this.id === other.id;
        return !!other && !!other.datatype && this.termType === other.termType && this.value === other.value && this.language === other.language && this.datatype.value === other.datatype.value;
      }
      toJSON() {
        return {
          termType: this.termType,
          value: this.value,
          language: this.language,
          datatype: { termType: "NamedNode", value: this.datatypeString }
        };
      }
    };
    BlankNode = class extends Term {
      constructor(name) {
        super(`_:${name}`);
      }
      // ### The term type of this term
      get termType() {
        return "BlankNode";
      }
      // ### The name of this blank node
      get value() {
        return this.id.substr(2);
      }
    };
    Variable = class extends Term {
      constructor(name) {
        super(`?${name}`);
      }
      // ### The term type of this term
      get termType() {
        return "Variable";
      }
      // ### The name of this variable
      get value() {
        return this.id.substr(1);
      }
    };
    DefaultGraph = class extends Term {
      constructor() {
        super("");
        return DEFAULTGRAPH || this;
      }
      // ### The term type of this term
      get termType() {
        return "DefaultGraph";
      }
      // ### Returns whether this object represents the same term as the other
      equals(other) {
        return this === other || !!other && this.termType === other.termType;
      }
    };
    DEFAULTGRAPH = new DefaultGraph();
    Quad = class extends Term {
      constructor(subject, predicate, object2, graph) {
        super("");
        this._subject = subject;
        this._predicate = predicate;
        this._object = object2;
        this._graph = graph || DEFAULTGRAPH;
      }
      // ### The term type of this term
      get termType() {
        return "Quad";
      }
      get subject() {
        return this._subject;
      }
      get predicate() {
        return this._predicate;
      }
      get object() {
        return this._object;
      }
      get graph() {
        return this._graph;
      }
      // ### Returns a plain object representation of this quad
      toJSON() {
        return {
          termType: this.termType,
          subject: this._subject.toJSON(),
          predicate: this._predicate.toJSON(),
          object: this._object.toJSON(),
          graph: this._graph.toJSON()
        };
      }
      // ### Returns whether this object represents the same quad as the other
      equals(other) {
        return !!other && this._subject.equals(other.subject) && this._predicate.equals(other.predicate) && this._object.equals(other.object) && this._graph.equals(other.graph);
      }
    };
  }
});

// node_modules/n3/src/N3Parser.js
function noop() {
}
function initDataFactory(parser, factory) {
  parser._factory = factory;
  parser.DEFAULTGRAPH = factory.defaultGraph();
  parser.RDF_FIRST = factory.namedNode(IRIs_default.rdf.first);
  parser.RDF_REST = factory.namedNode(IRIs_default.rdf.rest);
  parser.RDF_NIL = factory.namedNode(IRIs_default.rdf.nil);
  parser.N3_FORALL = factory.namedNode(IRIs_default.r.forAll);
  parser.N3_FORSOME = factory.namedNode(IRIs_default.r.forSome);
  parser.ABBREVIATIONS = {
    "a": factory.namedNode(IRIs_default.rdf.type),
    "=": factory.namedNode(IRIs_default.owl.sameAs),
    ">": factory.namedNode(IRIs_default.log.implies),
    "<": factory.namedNode(IRIs_default.log.isImpliedBy)
  };
  parser.QUANTIFIERS_GRAPH = factory.namedNode("urn:n3:quantifiers");
}
var blankNodePrefix, N3Parser;
var init_N3Parser = __esm({
  "node_modules/n3/src/N3Parser.js"() {
    init_N3Lexer();
    init_N3DataFactory();
    init_IRIs();
    blankNodePrefix = 0;
    N3Parser = class {
      constructor(options) {
        this._contextStack = [];
        this._graph = null;
        options = options || {};
        this._setBase(options.baseIRI);
        options.factory && initDataFactory(this, options.factory);
        const format = typeof options.format === "string" ? options.format.match(/\w*$/)[0].toLowerCase() : "", isTurtle = /turtle/.test(format), isTriG = /trig/.test(format), isNTriples = /triple/.test(format), isNQuads = /quad/.test(format), isN3 = this._n3Mode = /n3/.test(format), isLineMode = isNTriples || isNQuads;
        if (!(this._supportsNamedGraphs = !(isTurtle || isN3)))
          this._readPredicateOrNamedGraph = this._readPredicate;
        this._supportsQuads = !(isTurtle || isTriG || isNTriples || isN3);
        this._isImpliedBy = options.isImpliedBy;
        this._supportsRDFStar = format === "" || /star|\*$/.test(format);
        if (isLineMode)
          this._resolveRelativeIRI = (iri) => {
            return null;
          };
        this._blankNodePrefix = typeof options.blankNodePrefix !== "string" ? "" : options.blankNodePrefix.replace(/^(?!_:)/, "_:");
        this._lexer = options.lexer || new N3Lexer({ lineMode: isLineMode, n3: isN3, isImpliedBy: this._isImpliedBy });
        this._explicitQuantifiers = !!options.explicitQuantifiers;
      }
      // ## Static class methods
      // ### `_resetBlankNodePrefix` restarts blank node prefix identification
      static _resetBlankNodePrefix() {
        blankNodePrefix = 0;
      }
      // ## Private methods
      // ### `_setBase` sets the base IRI to resolve relative IRIs
      _setBase(baseIRI) {
        if (!baseIRI) {
          this._base = "";
          this._basePath = "";
        } else {
          const fragmentPos = baseIRI.indexOf("#");
          if (fragmentPos >= 0)
            baseIRI = baseIRI.substr(0, fragmentPos);
          this._base = baseIRI;
          this._basePath = baseIRI.indexOf("/") < 0 ? baseIRI : baseIRI.replace(/[^\/?]*(?:\?.*)?$/, "");
          baseIRI = baseIRI.match(/^(?:([a-z][a-z0-9+.-]*:))?(?:\/\/[^\/]*)?/i);
          this._baseRoot = baseIRI[0];
          this._baseScheme = baseIRI[1];
        }
      }
      // ### `_saveContext` stores the current parsing context
      // when entering a new scope (list, blank node, formula)
      _saveContext(type2, graph, subject, predicate, object2) {
        const n3Mode = this._n3Mode;
        this._contextStack.push({
          type: type2,
          subject,
          predicate,
          object: object2,
          graph,
          inverse: n3Mode ? this._inversePredicate : false,
          blankPrefix: n3Mode ? this._prefixes._ : "",
          quantified: n3Mode ? this._quantified : null
        });
        if (n3Mode) {
          this._inversePredicate = false;
          this._prefixes._ = this._graph ? `${this._graph.value}.` : ".";
          this._quantified = Object.create(this._quantified);
        }
      }
      // ### `_restoreContext` restores the parent context
      // when leaving a scope (list, blank node, formula)
      _restoreContext(type2, token) {
        const context = this._contextStack.pop();
        if (!context || context.type !== type2)
          return this._error(`Unexpected ${token.type}`, token);
        this._subject = context.subject;
        this._predicate = context.predicate;
        this._object = context.object;
        this._graph = context.graph;
        if (this._n3Mode) {
          this._inversePredicate = context.inverse;
          this._prefixes._ = context.blankPrefix;
          this._quantified = context.quantified;
        }
      }
      // ### `_readInTopContext` reads a token when in the top context
      _readInTopContext(token) {
        switch (token.type) {
          // If an EOF token arrives in the top context, signal that we're done
          case "eof":
            if (this._graph !== null)
              return this._error("Unclosed graph", token);
            delete this._prefixes._;
            return this._callback(null, null, this._prefixes);
          // It could be a prefix declaration
          case "PREFIX":
            this._sparqlStyle = true;
          case "@prefix":
            return this._readPrefix;
          // It could be a base declaration
          case "BASE":
            this._sparqlStyle = true;
          case "@base":
            return this._readBaseIRI;
          // It could be a graph
          case "{":
            if (this._supportsNamedGraphs) {
              this._graph = "";
              this._subject = null;
              return this._readSubject;
            }
          case "GRAPH":
            if (this._supportsNamedGraphs)
              return this._readNamedGraphLabel;
          // Otherwise, the next token must be a subject
          default:
            return this._readSubject(token);
        }
      }
      // ### `_readEntity` reads an IRI, prefixed name, blank node, or variable
      _readEntity(token, quantifier) {
        let value;
        switch (token.type) {
          // Read a relative or absolute IRI
          case "IRI":
          case "typeIRI":
            const iri = this._resolveIRI(token.value);
            if (iri === null)
              return this._error("Invalid IRI", token);
            value = this._factory.namedNode(iri);
            break;
          // Read a prefixed name
          case "type":
          case "prefixed":
            const prefix = this._prefixes[token.prefix];
            if (prefix === void 0)
              return this._error(`Undefined prefix "${token.prefix}:"`, token);
            value = this._factory.namedNode(prefix + token.value);
            break;
          // Read a blank node
          case "blank":
            value = this._factory.blankNode(this._prefixes[token.prefix] + token.value);
            break;
          // Read a variable
          case "var":
            value = this._factory.variable(token.value.substr(1));
            break;
          // Everything else is not an entity
          default:
            return this._error(`Expected entity but got ${token.type}`, token);
        }
        if (!quantifier && this._n3Mode && value.id in this._quantified)
          value = this._quantified[value.id];
        return value;
      }
      // ### `_readSubject` reads a quad's subject
      _readSubject(token) {
        this._predicate = null;
        switch (token.type) {
          case "[":
            this._saveContext(
              "blank",
              this._graph,
              this._subject = this._factory.blankNode(),
              null,
              null
            );
            return this._readBlankNodeHead;
          case "(":
            this._saveContext("list", this._graph, this.RDF_NIL, null, null);
            this._subject = null;
            return this._readListItem;
          case "{":
            if (!this._n3Mode)
              return this._error("Unexpected graph", token);
            this._saveContext(
              "formula",
              this._graph,
              this._graph = this._factory.blankNode(),
              null,
              null
            );
            return this._readSubject;
          case "}":
            return this._readPunctuation(token);
          case "@forSome":
            if (!this._n3Mode)
              return this._error('Unexpected "@forSome"', token);
            this._subject = null;
            this._predicate = this.N3_FORSOME;
            this._quantifier = "blankNode";
            return this._readQuantifierList;
          case "@forAll":
            if (!this._n3Mode)
              return this._error('Unexpected "@forAll"', token);
            this._subject = null;
            this._predicate = this.N3_FORALL;
            this._quantifier = "variable";
            return this._readQuantifierList;
          case "literal":
            if (!this._n3Mode)
              return this._error("Unexpected literal", token);
            if (token.prefix.length === 0) {
              this._literalValue = token.value;
              return this._completeSubjectLiteral;
            } else
              this._subject = this._factory.literal(token.value, this._factory.namedNode(token.prefix));
            break;
          case "<<":
            if (!this._supportsRDFStar)
              return this._error("Unexpected RDF-star syntax", token);
            this._saveContext("<<", this._graph, null, null, null);
            this._graph = null;
            return this._readSubject;
          default:
            if ((this._subject = this._readEntity(token)) === void 0)
              return;
            if (this._n3Mode)
              return this._getPathReader(this._readPredicateOrNamedGraph);
        }
        return this._readPredicateOrNamedGraph;
      }
      // ### `_readPredicate` reads a quad's predicate
      _readPredicate(token) {
        const type2 = token.type;
        switch (type2) {
          case "inverse":
            this._inversePredicate = true;
          case "abbreviation":
            this._predicate = this.ABBREVIATIONS[token.value];
            break;
          case ".":
          case "]":
          case "}":
            if (this._predicate === null)
              return this._error(`Unexpected ${type2}`, token);
            this._subject = null;
            return type2 === "]" ? this._readBlankNodeTail(token) : this._readPunctuation(token);
          case ";":
            return this._predicate !== null ? this._readPredicate : this._error("Expected predicate but got ;", token);
          case "[":
            if (this._n3Mode) {
              this._saveContext(
                "blank",
                this._graph,
                this._subject,
                this._subject = this._factory.blankNode(),
                null
              );
              return this._readBlankNodeHead;
            }
          case "blank":
            if (!this._n3Mode)
              return this._error("Disallowed blank node as predicate", token);
          default:
            if ((this._predicate = this._readEntity(token)) === void 0)
              return;
        }
        return this._readObject;
      }
      // ### `_readObject` reads a quad's object
      _readObject(token) {
        switch (token.type) {
          case "literal":
            if (token.prefix.length === 0) {
              this._literalValue = token.value;
              return this._readDataTypeOrLang;
            } else
              this._object = this._factory.literal(token.value, this._factory.namedNode(token.prefix));
            break;
          case "[":
            this._saveContext(
              "blank",
              this._graph,
              this._subject,
              this._predicate,
              this._subject = this._factory.blankNode()
            );
            return this._readBlankNodeHead;
          case "(":
            this._saveContext("list", this._graph, this._subject, this._predicate, this.RDF_NIL);
            this._subject = null;
            return this._readListItem;
          case "{":
            if (!this._n3Mode)
              return this._error("Unexpected graph", token);
            this._saveContext(
              "formula",
              this._graph,
              this._subject,
              this._predicate,
              this._graph = this._factory.blankNode()
            );
            return this._readSubject;
          case "<<":
            if (!this._supportsRDFStar)
              return this._error("Unexpected RDF-star syntax", token);
            this._saveContext("<<", this._graph, this._subject, this._predicate, null);
            this._graph = null;
            return this._readSubject;
          default:
            if ((this._object = this._readEntity(token)) === void 0)
              return;
            if (this._n3Mode)
              return this._getPathReader(this._getContextEndReader());
        }
        return this._getContextEndReader();
      }
      // ### `_readPredicateOrNamedGraph` reads a quad's predicate, or a named graph
      _readPredicateOrNamedGraph(token) {
        return token.type === "{" ? this._readGraph(token) : this._readPredicate(token);
      }
      // ### `_readGraph` reads a graph
      _readGraph(token) {
        if (token.type !== "{")
          return this._error(`Expected graph but got ${token.type}`, token);
        this._graph = this._subject, this._subject = null;
        return this._readSubject;
      }
      // ### `_readBlankNodeHead` reads the head of a blank node
      _readBlankNodeHead(token) {
        if (token.type === "]") {
          this._subject = null;
          return this._readBlankNodeTail(token);
        } else {
          this._predicate = null;
          return this._readPredicate(token);
        }
      }
      // ### `_readBlankNodeTail` reads the end of a blank node
      _readBlankNodeTail(token) {
        if (token.type !== "]")
          return this._readBlankNodePunctuation(token);
        if (this._subject !== null)
          this._emit(this._subject, this._predicate, this._object, this._graph);
        const empty = this._predicate === null;
        this._restoreContext("blank", token);
        if (this._object !== null)
          return this._getContextEndReader();
        else if (this._predicate !== null)
          return this._readObject;
        else
          return empty ? this._readPredicateOrNamedGraph : this._readPredicateAfterBlank;
      }
      // ### `_readPredicateAfterBlank` reads a predicate after an anonymous blank node
      _readPredicateAfterBlank(token) {
        switch (token.type) {
          case ".":
          case "}":
            this._subject = null;
            return this._readPunctuation(token);
          default:
            return this._readPredicate(token);
        }
      }
      // ### `_readListItem` reads items from a list
      _readListItem(token) {
        let item = null, list = null, next = this._readListItem;
        const previousList = this._subject, stack = this._contextStack, parent = stack[stack.length - 1];
        switch (token.type) {
          case "[":
            this._saveContext(
              "blank",
              this._graph,
              list = this._factory.blankNode(),
              this.RDF_FIRST,
              this._subject = item = this._factory.blankNode()
            );
            next = this._readBlankNodeHead;
            break;
          case "(":
            this._saveContext(
              "list",
              this._graph,
              list = this._factory.blankNode(),
              this.RDF_FIRST,
              this.RDF_NIL
            );
            this._subject = null;
            break;
          case ")":
            this._restoreContext("list", token);
            if (stack.length !== 0 && stack[stack.length - 1].type === "list")
              this._emit(this._subject, this._predicate, this._object, this._graph);
            if (this._predicate === null) {
              next = this._readPredicate;
              if (this._subject === this.RDF_NIL)
                return next;
            } else {
              next = this._getContextEndReader();
              if (this._object === this.RDF_NIL)
                return next;
            }
            list = this.RDF_NIL;
            break;
          case "literal":
            if (token.prefix.length === 0) {
              this._literalValue = token.value;
              next = this._readListItemDataTypeOrLang;
            } else {
              item = this._factory.literal(token.value, this._factory.namedNode(token.prefix));
              next = this._getContextEndReader();
            }
            break;
          case "{":
            if (!this._n3Mode)
              return this._error("Unexpected graph", token);
            this._saveContext(
              "formula",
              this._graph,
              this._subject,
              this._predicate,
              this._graph = this._factory.blankNode()
            );
            return this._readSubject;
          default:
            if ((item = this._readEntity(token)) === void 0)
              return;
        }
        if (list === null)
          this._subject = list = this._factory.blankNode();
        if (previousList === null) {
          if (parent.predicate === null)
            parent.subject = list;
          else
            parent.object = list;
        } else {
          this._emit(previousList, this.RDF_REST, list, this._graph);
        }
        if (item !== null) {
          if (this._n3Mode && (token.type === "IRI" || token.type === "prefixed")) {
            this._saveContext("item", this._graph, list, this.RDF_FIRST, item);
            this._subject = item, this._predicate = null;
            return this._getPathReader(this._readListItem);
          }
          this._emit(list, this.RDF_FIRST, item, this._graph);
        }
        return next;
      }
      // ### `_readDataTypeOrLang` reads an _optional_ datatype or language
      _readDataTypeOrLang(token) {
        return this._completeObjectLiteral(token, false);
      }
      // ### `_readListItemDataTypeOrLang` reads an _optional_ datatype or language in a list
      _readListItemDataTypeOrLang(token) {
        return this._completeObjectLiteral(token, true);
      }
      // ### `_completeLiteral` completes a literal with an optional datatype or language
      _completeLiteral(token) {
        let literal3 = this._factory.literal(this._literalValue);
        switch (token.type) {
          // Create a datatyped literal
          case "type":
          case "typeIRI":
            const datatype = this._readEntity(token);
            if (datatype === void 0) return;
            literal3 = this._factory.literal(this._literalValue, datatype);
            token = null;
            break;
          // Create a language-tagged string
          case "langcode":
            literal3 = this._factory.literal(this._literalValue, token.value);
            token = null;
            break;
        }
        return { token, literal: literal3 };
      }
      // Completes a literal in subject position
      _completeSubjectLiteral(token) {
        this._subject = this._completeLiteral(token).literal;
        return this._readPredicateOrNamedGraph;
      }
      // Completes a literal in object position
      _completeObjectLiteral(token, listItem) {
        const completed = this._completeLiteral(token);
        if (!completed)
          return;
        this._object = completed.literal;
        if (listItem)
          this._emit(this._subject, this.RDF_FIRST, this._object, this._graph);
        if (completed.token === null)
          return this._getContextEndReader();
        else {
          this._readCallback = this._getContextEndReader();
          return this._readCallback(completed.token);
        }
      }
      // ### `_readFormulaTail` reads the end of a formula
      _readFormulaTail(token) {
        if (token.type !== "}")
          return this._readPunctuation(token);
        if (this._subject !== null)
          this._emit(this._subject, this._predicate, this._object, this._graph);
        this._restoreContext("formula", token);
        return this._object === null ? this._readPredicate : this._getContextEndReader();
      }
      // ### `_readPunctuation` reads punctuation between quads or quad parts
      _readPunctuation(token) {
        let next, graph = this._graph;
        const subject = this._subject, inversePredicate = this._inversePredicate;
        switch (token.type) {
          // A closing brace ends a graph
          case "}":
            if (this._graph === null)
              return this._error("Unexpected graph closing", token);
            if (this._n3Mode)
              return this._readFormulaTail(token);
            this._graph = null;
          // A dot just ends the statement, without sharing anything with the next
          case ".":
            this._subject = null;
            next = this._contextStack.length ? this._readSubject : this._readInTopContext;
            if (inversePredicate) this._inversePredicate = false;
            break;
          // Semicolon means the subject is shared; predicate and object are different
          case ";":
            next = this._readPredicate;
            break;
          // Comma means both the subject and predicate are shared; the object is different
          case ",":
            next = this._readObject;
            break;
          // {| means that the current triple is annotated with predicate-object pairs.
          case "{|":
            if (!this._supportsRDFStar)
              return this._error("Unexpected RDF-star syntax", token);
            const predicate = this._predicate, object2 = this._object;
            this._subject = this._factory.quad(subject, predicate, object2, this.DEFAULTGRAPH);
            next = this._readPredicate;
            break;
          // |} means that the current quoted triple in annotation syntax is finalized.
          case "|}":
            if (this._subject.termType !== "Quad")
              return this._error("Unexpected asserted triple closing", token);
            this._subject = null;
            next = this._readPunctuation;
            break;
          default:
            if (this._supportsQuads && this._graph === null && (graph = this._readEntity(token)) !== void 0) {
              next = this._readQuadPunctuation;
              break;
            }
            return this._error(`Expected punctuation to follow "${this._object.id}"`, token);
        }
        if (subject !== null) {
          const predicate = this._predicate, object2 = this._object;
          if (!inversePredicate)
            this._emit(subject, predicate, object2, graph);
          else
            this._emit(object2, predicate, subject, graph);
        }
        return next;
      }
      // ### `_readBlankNodePunctuation` reads punctuation in a blank node
      _readBlankNodePunctuation(token) {
        let next;
        switch (token.type) {
          // Semicolon means the subject is shared; predicate and object are different
          case ";":
            next = this._readPredicate;
            break;
          // Comma means both the subject and predicate are shared; the object is different
          case ",":
            next = this._readObject;
            break;
          default:
            return this._error(`Expected punctuation to follow "${this._object.id}"`, token);
        }
        this._emit(this._subject, this._predicate, this._object, this._graph);
        return next;
      }
      // ### `_readQuadPunctuation` reads punctuation after a quad
      _readQuadPunctuation(token) {
        if (token.type !== ".")
          return this._error("Expected dot to follow quad", token);
        return this._readInTopContext;
      }
      // ### `_readPrefix` reads the prefix of a prefix declaration
      _readPrefix(token) {
        if (token.type !== "prefix")
          return this._error("Expected prefix to follow @prefix", token);
        this._prefix = token.value;
        return this._readPrefixIRI;
      }
      // ### `_readPrefixIRI` reads the IRI of a prefix declaration
      _readPrefixIRI(token) {
        if (token.type !== "IRI")
          return this._error(`Expected IRI to follow prefix "${this._prefix}:"`, token);
        const prefixNode = this._readEntity(token);
        this._prefixes[this._prefix] = prefixNode.value;
        this._prefixCallback(this._prefix, prefixNode);
        return this._readDeclarationPunctuation;
      }
      // ### `_readBaseIRI` reads the IRI of a base declaration
      _readBaseIRI(token) {
        const iri = token.type === "IRI" && this._resolveIRI(token.value);
        if (!iri)
          return this._error("Expected valid IRI to follow base declaration", token);
        this._setBase(iri);
        return this._readDeclarationPunctuation;
      }
      // ### `_readNamedGraphLabel` reads the label of a named graph
      _readNamedGraphLabel(token) {
        switch (token.type) {
          case "IRI":
          case "blank":
          case "prefixed":
            return this._readSubject(token), this._readGraph;
          case "[":
            return this._readNamedGraphBlankLabel;
          default:
            return this._error("Invalid graph label", token);
        }
      }
      // ### `_readNamedGraphLabel` reads a blank node label of a named graph
      _readNamedGraphBlankLabel(token) {
        if (token.type !== "]")
          return this._error("Invalid graph label", token);
        this._subject = this._factory.blankNode();
        return this._readGraph;
      }
      // ### `_readDeclarationPunctuation` reads the punctuation of a declaration
      _readDeclarationPunctuation(token) {
        if (this._sparqlStyle) {
          this._sparqlStyle = false;
          return this._readInTopContext(token);
        }
        if (token.type !== ".")
          return this._error("Expected declaration to end with a dot", token);
        return this._readInTopContext;
      }
      // Reads a list of quantified symbols from a @forSome or @forAll statement
      _readQuantifierList(token) {
        let entity;
        switch (token.type) {
          case "IRI":
          case "prefixed":
            if ((entity = this._readEntity(token, true)) !== void 0)
              break;
          default:
            return this._error(`Unexpected ${token.type}`, token);
        }
        if (!this._explicitQuantifiers)
          this._quantified[entity.id] = this._factory[this._quantifier](this._factory.blankNode().value);
        else {
          if (this._subject === null)
            this._emit(
              this._graph || this.DEFAULTGRAPH,
              this._predicate,
              this._subject = this._factory.blankNode(),
              this.QUANTIFIERS_GRAPH
            );
          else
            this._emit(
              this._subject,
              this.RDF_REST,
              this._subject = this._factory.blankNode(),
              this.QUANTIFIERS_GRAPH
            );
          this._emit(this._subject, this.RDF_FIRST, entity, this.QUANTIFIERS_GRAPH);
        }
        return this._readQuantifierPunctuation;
      }
      // Reads punctuation from a @forSome or @forAll statement
      _readQuantifierPunctuation(token) {
        if (token.type === ",")
          return this._readQuantifierList;
        else {
          if (this._explicitQuantifiers) {
            this._emit(this._subject, this.RDF_REST, this.RDF_NIL, this.QUANTIFIERS_GRAPH);
            this._subject = null;
          }
          this._readCallback = this._getContextEndReader();
          return this._readCallback(token);
        }
      }
      // ### `_getPathReader` reads a potential path and then resumes with the given function
      _getPathReader(afterPath) {
        this._afterPath = afterPath;
        return this._readPath;
      }
      // ### `_readPath` reads a potential path
      _readPath(token) {
        switch (token.type) {
          // Forward path
          case "!":
            return this._readForwardPath;
          // Backward path
          case "^":
            return this._readBackwardPath;
          // Not a path; resume reading where we left off
          default:
            const stack = this._contextStack, parent = stack.length && stack[stack.length - 1];
            if (parent && parent.type === "item") {
              const item = this._subject;
              this._restoreContext("item", token);
              this._emit(this._subject, this.RDF_FIRST, item, this._graph);
            }
            return this._afterPath(token);
        }
      }
      // ### `_readForwardPath` reads a '!' path
      _readForwardPath(token) {
        let subject, predicate;
        const object2 = this._factory.blankNode();
        if ((predicate = this._readEntity(token)) === void 0)
          return;
        if (this._predicate === null)
          subject = this._subject, this._subject = object2;
        else
          subject = this._object, this._object = object2;
        this._emit(subject, predicate, object2, this._graph);
        return this._readPath;
      }
      // ### `_readBackwardPath` reads a '^' path
      _readBackwardPath(token) {
        const subject = this._factory.blankNode();
        let predicate, object2;
        if ((predicate = this._readEntity(token)) === void 0)
          return;
        if (this._predicate === null)
          object2 = this._subject, this._subject = subject;
        else
          object2 = this._object, this._object = subject;
        this._emit(subject, predicate, object2, this._graph);
        return this._readPath;
      }
      // ### `_readRDFStarTailOrGraph` reads the graph of a nested RDF-star quad or the end of a nested RDF-star triple
      _readRDFStarTailOrGraph(token) {
        if (token.type !== ">>") {
          if (this._supportsQuads && this._graph === null && (this._graph = this._readEntity(token)) !== void 0)
            return this._readRDFStarTail;
          return this._error(`Expected >> to follow "${this._object.id}"`, token);
        }
        return this._readRDFStarTail(token);
      }
      // ### `_readRDFStarTail` reads the end of a nested RDF-star triple
      _readRDFStarTail(token) {
        if (token.type !== ">>")
          return this._error(`Expected >> but got ${token.type}`, token);
        const quad2 = this._factory.quad(
          this._subject,
          this._predicate,
          this._object,
          this._graph || this.DEFAULTGRAPH
        );
        this._restoreContext("<<", token);
        if (this._subject === null) {
          this._subject = quad2;
          return this._readPredicate;
        } else {
          this._object = quad2;
          return this._getContextEndReader();
        }
      }
      // ### `_getContextEndReader` gets the next reader function at the end of a context
      _getContextEndReader() {
        const contextStack = this._contextStack;
        if (!contextStack.length)
          return this._readPunctuation;
        switch (contextStack[contextStack.length - 1].type) {
          case "blank":
            return this._readBlankNodeTail;
          case "list":
            return this._readListItem;
          case "formula":
            return this._readFormulaTail;
          case "<<":
            return this._readRDFStarTailOrGraph;
        }
      }
      // ### `_emit` sends a quad through the callback
      _emit(subject, predicate, object2, graph) {
        this._callback(null, this._factory.quad(subject, predicate, object2, graph || this.DEFAULTGRAPH));
      }
      // ### `_error` emits an error message through the callback
      _error(message2, token) {
        const err = new Error(`${message2} on line ${token.line}.`);
        err.context = {
          token,
          line: token.line,
          previousToken: this._lexer.previousToken
        };
        this._callback(err);
        this._callback = noop;
      }
      // ### `_resolveIRI` resolves an IRI against the base path
      _resolveIRI(iri) {
        return /^[a-z][a-z0-9+.-]*:/i.test(iri) ? iri : this._resolveRelativeIRI(iri);
      }
      // ### `_resolveRelativeIRI` resolves an IRI against the base path,
      // assuming that a base path has been set and that the IRI is indeed relative
      _resolveRelativeIRI(iri) {
        if (!iri.length)
          return this._base;
        switch (iri[0]) {
          // Resolve relative fragment IRIs against the base IRI
          case "#":
            return this._base + iri;
          // Resolve relative query string IRIs by replacing the query string
          case "?":
            return this._base.replace(/(?:\?.*)?$/, iri);
          // Resolve root-relative IRIs at the root of the base IRI
          case "/":
            return (iri[1] === "/" ? this._baseScheme : this._baseRoot) + this._removeDotSegments(iri);
          // Resolve all other IRIs at the base IRI's path
          default:
            return /^[^/:]*:/.test(iri) ? null : this._removeDotSegments(this._basePath + iri);
        }
      }
      // ### `_removeDotSegments` resolves './' and '../' path segments in an IRI as per RFC3986
      _removeDotSegments(iri) {
        if (!/(^|\/)\.\.?($|[/#?])/.test(iri))
          return iri;
        const length = iri.length;
        let result = "", i = -1, pathStart = -1, segmentStart = 0, next = "/";
        while (i < length) {
          switch (next) {
            // The path starts with the first slash after the authority
            case ":":
              if (pathStart < 0) {
                if (iri[++i] === "/" && iri[++i] === "/")
                  while ((pathStart = i + 1) < length && iri[pathStart] !== "/")
                    i = pathStart;
              }
              break;
            // Don't modify a query string or fragment
            case "?":
            case "#":
              i = length;
              break;
            // Handle '/.' or '/..' path segments
            case "/":
              if (iri[i + 1] === ".") {
                next = iri[++i + 1];
                switch (next) {
                  // Remove a '/.' segment
                  case "/":
                    result += iri.substring(segmentStart, i - 1);
                    segmentStart = i + 1;
                    break;
                  // Remove a trailing '/.' segment
                  case void 0:
                  case "?":
                  case "#":
                    return result + iri.substring(segmentStart, i) + iri.substr(i + 1);
                  // Remove a '/..' segment
                  case ".":
                    next = iri[++i + 1];
                    if (next === void 0 || next === "/" || next === "?" || next === "#") {
                      result += iri.substring(segmentStart, i - 2);
                      if ((segmentStart = result.lastIndexOf("/")) >= pathStart)
                        result = result.substr(0, segmentStart);
                      if (next !== "/")
                        return `${result}/${iri.substr(i + 1)}`;
                      segmentStart = i + 1;
                    }
                }
              }
          }
          next = iri[++i];
        }
        return result + iri.substring(segmentStart);
      }
      // ## Public methods
      // ### `parse` parses the N3 input and emits each parsed quad through the onQuad callback.
      parse(input, quadCallback, prefixCallback) {
        let onQuad, onPrefix, onComment;
        if (quadCallback && (quadCallback.onQuad || quadCallback.onPrefix || quadCallback.onComment)) {
          onQuad = quadCallback.onQuad;
          onPrefix = quadCallback.onPrefix;
          onComment = quadCallback.onComment;
        } else {
          onQuad = quadCallback;
          onPrefix = prefixCallback;
        }
        this._readCallback = this._readInTopContext;
        this._sparqlStyle = false;
        this._prefixes = /* @__PURE__ */ Object.create(null);
        this._prefixes._ = this._blankNodePrefix ? this._blankNodePrefix.substr(2) : `b${blankNodePrefix++}_`;
        this._prefixCallback = onPrefix || noop;
        this._inversePredicate = false;
        this._quantified = /* @__PURE__ */ Object.create(null);
        if (!onQuad) {
          const quads = [];
          let error46;
          this._callback = (e, t) => {
            e ? error46 = e : t && quads.push(t);
          };
          this._lexer.tokenize(input).every((token) => {
            return this._readCallback = this._readCallback(token);
          });
          if (error46) throw error46;
          return quads;
        }
        let processNextToken = (error46, token) => {
          if (error46 !== null)
            this._callback(error46), this._callback = noop;
          else if (this._readCallback)
            this._readCallback = this._readCallback(token);
        };
        if (onComment) {
          this._lexer.comments = true;
          processNextToken = (error46, token) => {
            if (error46 !== null)
              this._callback(error46), this._callback = noop;
            else if (this._readCallback) {
              if (token.type === "comment")
                onComment(token.value);
              else
                this._readCallback = this._readCallback(token);
            }
          };
        }
        this._callback = onQuad;
        this._lexer.tokenize(input, processNextToken);
      }
    };
    initDataFactory(N3Parser.prototype, N3DataFactory_default);
  }
});

// node_modules/n3/src/N3Util.js
function isDefaultGraph(term) {
  return !!term && term.termType === "DefaultGraph";
}
var init_N3Util = __esm({
  "node_modules/n3/src/N3Util.js"() {
  }
});

// node_modules/n3/src/Util.js
function escapeRegex(regex) {
  return regex.replace(/[\]\/\(\)\*\+\?\.\\\$]/g, "\\$&");
}
var init_Util = __esm({
  "node_modules/n3/src/Util.js"() {
  }
});

// node_modules/n3/src/BaseIRI.js
var BASE_UNSUPPORTED, SUFFIX_SUPPORTED, CURRENT, PARENT, QUERY, FRAGMENT, BaseIRI;
var init_BaseIRI = __esm({
  "node_modules/n3/src/BaseIRI.js"() {
    init_Util();
    BASE_UNSUPPORTED = /^:?[^:?#]*(?:[?#]|$)|^file:|^[^:]*:\/*[^?#]+?\/(?:\.\.?(?:\/|$)|\/)/i;
    SUFFIX_SUPPORTED = /^(?:(?:[^/?#]{3,}|\.?[^/?#.]\.?)(?:\/[^/?#]{3,}|\.?[^/?#.]\.?)*\/?)?(?:[?#]|$)/;
    CURRENT = "./";
    PARENT = "../";
    QUERY = "?";
    FRAGMENT = "#";
    BaseIRI = class _BaseIRI {
      constructor(base) {
        this.base = base;
        this._baseLength = 0;
        this._baseMatcher = null;
        this._pathReplacements = new Array(base.length + 1);
      }
      static supports(base) {
        return !BASE_UNSUPPORTED.test(base);
      }
      _getBaseMatcher() {
        if (this._baseMatcher)
          return this._baseMatcher;
        if (!_BaseIRI.supports(this.base))
          return this._baseMatcher = /.^/;
        const scheme = /^[^:]*:\/*/.exec(this.base)[0];
        const regexHead = ["^", escapeRegex(scheme)];
        const regexTail = [];
        const segments = [], segmenter = /[^/?#]*([/?#])/y;
        let segment, query = 0, fragment = 0, last = segmenter.lastIndex = scheme.length;
        while (!query && !fragment && (segment = segmenter.exec(this.base))) {
          if (segment[1] === FRAGMENT)
            fragment = segmenter.lastIndex - 1;
          else {
            regexHead.push(escapeRegex(segment[0]), "(?:");
            regexTail.push(")?");
            if (segment[1] !== QUERY)
              segments.push(last = segmenter.lastIndex);
            else {
              query = last = segmenter.lastIndex;
              fragment = this.base.indexOf(FRAGMENT, query);
              this._pathReplacements[query] = QUERY;
            }
          }
        }
        for (let i = 0; i < segments.length; i++)
          this._pathReplacements[segments[i]] = PARENT.repeat(segments.length - i - 1);
        this._pathReplacements[segments[segments.length - 1]] = CURRENT;
        this._baseLength = fragment > 0 ? fragment : this.base.length;
        regexHead.push(
          escapeRegex(this.base.substring(last, this._baseLength)),
          query ? "(?:#|$)" : "(?:[?#]|$)"
        );
        return this._baseMatcher = new RegExp([...regexHead, ...regexTail].join(""));
      }
      toRelative(iri) {
        const match = this._getBaseMatcher().exec(iri);
        if (!match)
          return iri;
        const length = match[0].length;
        if (length === this._baseLength && length === iri.length)
          return "";
        const parentPath = this._pathReplacements[length];
        if (parentPath) {
          const suffix = iri.substring(length);
          if (parentPath !== QUERY && !SUFFIX_SUPPORTED.test(suffix))
            return iri;
          if (parentPath === CURRENT && /^[^?#]/.test(suffix))
            return suffix;
          return parentPath + suffix;
        }
        return iri.substring(length - 1);
      }
    };
  }
});

// node_modules/n3/src/N3Writer.js
function characterReplacer(character) {
  let result = escapedCharacters[character];
  if (result === void 0) {
    if (character.length === 1) {
      result = character.charCodeAt(0).toString(16);
      result = "\\u0000".substr(0, 6 - result.length) + result;
    } else {
      result = ((character.charCodeAt(0) - 55296) * 1024 + character.charCodeAt(1) + 9216).toString(16);
      result = "\\U00000000".substr(0, 10 - result.length) + result;
    }
  }
  return result;
}
var DEFAULTGRAPH2, rdf2, xsd3, escape2, escapeAll, escapedCharacters, SerializedTerm, N3Writer;
var init_N3Writer = __esm({
  "node_modules/n3/src/N3Writer.js"() {
    init_IRIs();
    init_N3DataFactory();
    init_N3Util();
    init_BaseIRI();
    init_Util();
    DEFAULTGRAPH2 = N3DataFactory_default.defaultGraph();
    ({ rdf: rdf2, xsd: xsd3 } = IRIs_default);
    escape2 = /["\\\t\n\r\b\f\u0000-\u0019\ud800-\udbff]/;
    escapeAll = /["\\\t\n\r\b\f\u0000-\u0019]|[\ud800-\udbff][\udc00-\udfff]/g;
    escapedCharacters = {
      "\\": "\\\\",
      '"': '\\"',
      "	": "\\t",
      "\n": "\\n",
      "\r": "\\r",
      "\b": "\\b",
      "\f": "\\f"
    };
    SerializedTerm = class extends Term {
      // Pretty-printed nodes are not equal to any other node
      // (e.g., [] does not equal [])
      equals(other) {
        return other === this;
      }
    };
    N3Writer = class {
      constructor(outputStream, options) {
        this._prefixRegex = /$0^/;
        if (outputStream && typeof outputStream.write !== "function")
          options = outputStream, outputStream = null;
        options = options || {};
        this._lists = options.lists;
        if (!outputStream) {
          let output = "";
          this._outputStream = {
            write(chunk, encoding, done) {
              output += chunk;
              done && done();
            },
            end: (done) => {
              done && done(null, output);
            }
          };
          this._endStream = true;
        } else {
          this._outputStream = outputStream;
          this._endStream = options.end === void 0 ? true : !!options.end;
        }
        this._subject = null;
        if (!/triple|quad/i.test(options.format)) {
          this._lineMode = false;
          this._graph = DEFAULTGRAPH2;
          this._prefixIRIs = /* @__PURE__ */ Object.create(null);
          options.prefixes && this.addPrefixes(options.prefixes);
          if (options.baseIRI) {
            this._baseIri = new BaseIRI(options.baseIRI);
          }
        } else {
          this._lineMode = true;
          this._writeQuad = this._writeQuadLine;
        }
      }
      // ## Private methods
      // ### Whether the current graph is the default graph
      get _inDefaultGraph() {
        return DEFAULTGRAPH2.equals(this._graph);
      }
      // ### `_write` writes the argument to the output stream
      _write(string4, callback) {
        this._outputStream.write(string4, "utf8", callback);
      }
      // ### `_writeQuad` writes the quad to the output stream
      _writeQuad(subject, predicate, object2, graph, done) {
        try {
          if (!graph.equals(this._graph)) {
            this._write((this._subject === null ? "" : this._inDefaultGraph ? ".\n" : "\n}\n") + (DEFAULTGRAPH2.equals(graph) ? "" : `${this._encodeIriOrBlank(graph)} {
`));
            this._graph = graph;
            this._subject = null;
          }
          if (subject.equals(this._subject)) {
            if (predicate.equals(this._predicate))
              this._write(`, ${this._encodeObject(object2)}`, done);
            else
              this._write(`;
    ${this._encodePredicate(this._predicate = predicate)} ${this._encodeObject(object2)}`, done);
          } else
            this._write(`${(this._subject === null ? "" : ".\n") + this._encodeSubject(this._subject = subject)} ${this._encodePredicate(this._predicate = predicate)} ${this._encodeObject(object2)}`, done);
        } catch (error46) {
          done && done(error46);
        }
      }
      // ### `_writeQuadLine` writes the quad to the output stream as a single line
      _writeQuadLine(subject, predicate, object2, graph, done) {
        delete this._prefixMatch;
        this._write(this.quadToString(subject, predicate, object2, graph), done);
      }
      // ### `quadToString` serializes a quad as a string
      quadToString(subject, predicate, object2, graph) {
        return `${this._encodeSubject(subject)} ${this._encodeIriOrBlank(predicate)} ${this._encodeObject(object2)}${graph && graph.value ? ` ${this._encodeIriOrBlank(graph)} .
` : " .\n"}`;
      }
      // ### `quadsToString` serializes an array of quads as a string
      quadsToString(quads) {
        let quadsString = "";
        for (const quad2 of quads)
          quadsString += this.quadToString(quad2.subject, quad2.predicate, quad2.object, quad2.graph);
        return quadsString;
      }
      // ### `_encodeSubject` represents a subject
      _encodeSubject(entity) {
        return entity.termType === "Quad" ? this._encodeQuad(entity) : this._encodeIriOrBlank(entity);
      }
      // ### `_encodeIriOrBlank` represents an IRI or blank node
      _encodeIriOrBlank(entity) {
        if (entity.termType !== "NamedNode") {
          if (this._lists && entity.value in this._lists)
            entity = this.list(this._lists[entity.value]);
          return "id" in entity ? entity.id : `_:${entity.value}`;
        }
        let iri = entity.value;
        if (this._baseIri) {
          iri = this._baseIri.toRelative(iri);
        }
        if (escape2.test(iri))
          iri = iri.replace(escapeAll, characterReplacer);
        const prefixMatch = this._prefixRegex.exec(iri);
        return !prefixMatch ? `<${iri}>` : !prefixMatch[1] ? iri : this._prefixIRIs[prefixMatch[1]] + prefixMatch[2];
      }
      // ### `_encodeLiteral` represents a literal
      _encodeLiteral(literal3) {
        let value = literal3.value;
        if (escape2.test(value))
          value = value.replace(escapeAll, characterReplacer);
        if (literal3.language)
          return `"${value}"@${literal3.language}`;
        if (this._lineMode) {
          if (literal3.datatype.value === xsd3.string)
            return `"${value}"`;
        } else {
          switch (literal3.datatype.value) {
            case xsd3.string:
              return `"${value}"`;
            case xsd3.boolean:
              if (value === "true" || value === "false")
                return value;
              break;
            case xsd3.integer:
              if (/^[+-]?\d+$/.test(value))
                return value;
              break;
            case xsd3.decimal:
              if (/^[+-]?\d*\.\d+$/.test(value))
                return value;
              break;
            case xsd3.double:
              if (/^[+-]?(?:\d+\.\d*|\.?\d+)[eE][+-]?\d+$/.test(value))
                return value;
              break;
          }
        }
        return `"${value}"^^${this._encodeIriOrBlank(literal3.datatype)}`;
      }
      // ### `_encodePredicate` represents a predicate
      _encodePredicate(predicate) {
        return predicate.value === rdf2.type ? "a" : this._encodeIriOrBlank(predicate);
      }
      // ### `_encodeObject` represents an object
      _encodeObject(object2) {
        switch (object2.termType) {
          case "Quad":
            return this._encodeQuad(object2);
          case "Literal":
            return this._encodeLiteral(object2);
          default:
            return this._encodeIriOrBlank(object2);
        }
      }
      // ### `_encodeQuad` encodes an RDF-star quad
      _encodeQuad({ subject, predicate, object: object2, graph }) {
        return `<<${this._encodeSubject(subject)} ${this._encodePredicate(predicate)} ${this._encodeObject(object2)}${isDefaultGraph(graph) ? "" : ` ${this._encodeIriOrBlank(graph)}`}>>`;
      }
      // ### `_blockedWrite` replaces `_write` after the writer has been closed
      _blockedWrite() {
        throw new Error("Cannot write because the writer has been closed.");
      }
      // ### `addQuad` adds the quad to the output stream
      addQuad(subject, predicate, object2, graph, done) {
        if (object2 === void 0)
          this._writeQuad(subject.subject, subject.predicate, subject.object, subject.graph, predicate);
        else if (typeof graph === "function")
          this._writeQuad(subject, predicate, object2, DEFAULTGRAPH2, graph);
        else
          this._writeQuad(subject, predicate, object2, graph || DEFAULTGRAPH2, done);
      }
      // ### `addQuads` adds the quads to the output stream
      addQuads(quads) {
        for (let i = 0; i < quads.length; i++)
          this.addQuad(quads[i]);
      }
      // ### `addPrefix` adds the prefix to the output stream
      addPrefix(prefix, iri, done) {
        const prefixes2 = {};
        prefixes2[prefix] = iri;
        this.addPrefixes(prefixes2, done);
      }
      // ### `addPrefixes` adds the prefixes to the output stream
      addPrefixes(prefixes2, done) {
        if (!this._prefixIRIs)
          return done && done();
        let hasPrefixes = false;
        for (let prefix in prefixes2) {
          let iri = prefixes2[prefix];
          if (typeof iri !== "string")
            iri = iri.value;
          hasPrefixes = true;
          if (this._subject !== null) {
            this._write(this._inDefaultGraph ? ".\n" : "\n}\n");
            this._subject = null, this._graph = "";
          }
          this._prefixIRIs[iri] = prefix += ":";
          this._write(`@prefix ${prefix} <${iri}>.
`);
        }
        if (hasPrefixes) {
          let IRIlist = "", prefixList = "";
          for (const prefixIRI in this._prefixIRIs) {
            IRIlist += IRIlist ? `|${prefixIRI}` : prefixIRI;
            prefixList += (prefixList ? "|" : "") + this._prefixIRIs[prefixIRI];
          }
          IRIlist = escapeRegex(IRIlist, /[\]\/\(\)\*\+\?\.\\\$]/g, "\\$&");
          this._prefixRegex = new RegExp(`^(?:${prefixList})[^/]*$|^(${IRIlist})([_a-zA-Z0-9][\\-_a-zA-Z0-9]*)$`);
        }
        this._write(hasPrefixes ? "\n" : "", done);
      }
      // ### `blank` creates a blank node with the given content
      blank(predicate, object2) {
        let children = predicate, child, length;
        if (predicate === void 0)
          children = [];
        else if (predicate.termType)
          children = [{ predicate, object: object2 }];
        else if (!("length" in predicate))
          children = [predicate];
        switch (length = children.length) {
          // Generate an empty blank node
          case 0:
            return new SerializedTerm("[]");
          // Generate a non-nested one-triple blank node
          case 1:
            child = children[0];
            if (!(child.object instanceof SerializedTerm))
              return new SerializedTerm(`[ ${this._encodePredicate(child.predicate)} ${this._encodeObject(child.object)} ]`);
          // Generate a multi-triple or nested blank node
          default:
            let contents = "[";
            for (let i = 0; i < length; i++) {
              child = children[i];
              if (child.predicate.equals(predicate))
                contents += `, ${this._encodeObject(child.object)}`;
              else {
                contents += `${(i ? ";\n  " : "\n  ") + this._encodePredicate(child.predicate)} ${this._encodeObject(child.object)}`;
                predicate = child.predicate;
              }
            }
            return new SerializedTerm(`${contents}
]`);
        }
      }
      // ### `list` creates a list node with the given content
      list(elements) {
        const length = elements && elements.length || 0, contents = new Array(length);
        for (let i = 0; i < length; i++)
          contents[i] = this._encodeObject(elements[i]);
        return new SerializedTerm(`(${contents.join(" ")})`);
      }
      // ### `end` signals the end of the output stream
      end(done) {
        if (this._subject !== null) {
          this._write(this._inDefaultGraph ? ".\n" : "\n}\n");
          this._subject = null;
        }
        this._write = this._blockedWrite;
        let singleDone = done && ((error46, result) => {
          singleDone = null, done(error46, result);
        });
        if (this._endStream) {
          try {
            return this._outputStream.end(singleDone);
          } catch (error46) {
          }
        }
        singleDone && singleDone();
      }
    };
  }
});

// node_modules/n3/node_modules/readable-stream/lib/ours/primordials.js
var require_primordials2 = __commonJS({
  "node_modules/n3/node_modules/readable-stream/lib/ours/primordials.js"(exports, module) {
    "use strict";
    var AggregateError = class extends Error {
      constructor(errors) {
        if (!Array.isArray(errors)) {
          throw new TypeError(`Expected input to be an Array, got ${typeof errors}`);
        }
        let message2 = "";
        for (let i = 0; i < errors.length; i++) {
          message2 += `    ${errors[i].stack}
`;
        }
        super(message2);
        this.name = "AggregateError";
        this.errors = errors;
      }
    };
    module.exports = {
      AggregateError,
      ArrayIsArray(self2) {
        return Array.isArray(self2);
      },
      ArrayPrototypeIncludes(self2, el) {
        return self2.includes(el);
      },
      ArrayPrototypeIndexOf(self2, el) {
        return self2.indexOf(el);
      },
      ArrayPrototypeJoin(self2, sep) {
        return self2.join(sep);
      },
      ArrayPrototypeMap(self2, fn) {
        return self2.map(fn);
      },
      ArrayPrototypePop(self2, el) {
        return self2.pop(el);
      },
      ArrayPrototypePush(self2, el) {
        return self2.push(el);
      },
      ArrayPrototypeSlice(self2, start, end) {
        return self2.slice(start, end);
      },
      Error,
      FunctionPrototypeCall(fn, thisArgs, ...args) {
        return fn.call(thisArgs, ...args);
      },
      FunctionPrototypeSymbolHasInstance(self2, instance) {
        return Function.prototype[Symbol.hasInstance].call(self2, instance);
      },
      MathFloor: Math.floor,
      Number,
      NumberIsInteger: Number.isInteger,
      NumberIsNaN: Number.isNaN,
      NumberMAX_SAFE_INTEGER: Number.MAX_SAFE_INTEGER,
      NumberMIN_SAFE_INTEGER: Number.MIN_SAFE_INTEGER,
      NumberParseInt: Number.parseInt,
      ObjectDefineProperties(self2, props) {
        return Object.defineProperties(self2, props);
      },
      ObjectDefineProperty(self2, name, prop) {
        return Object.defineProperty(self2, name, prop);
      },
      ObjectGetOwnPropertyDescriptor(self2, name) {
        return Object.getOwnPropertyDescriptor(self2, name);
      },
      ObjectKeys(obj) {
        return Object.keys(obj);
      },
      ObjectSetPrototypeOf(target, proto) {
        return Object.setPrototypeOf(target, proto);
      },
      Promise,
      PromisePrototypeCatch(self2, fn) {
        return self2.catch(fn);
      },
      PromisePrototypeThen(self2, thenFn, catchFn) {
        return self2.then(thenFn, catchFn);
      },
      PromiseReject(err) {
        return Promise.reject(err);
      },
      PromiseResolve(val) {
        return Promise.resolve(val);
      },
      ReflectApply: Reflect.apply,
      RegExpPrototypeTest(self2, value) {
        return self2.test(value);
      },
      SafeSet: Set,
      String,
      StringPrototypeSlice(self2, start, end) {
        return self2.slice(start, end);
      },
      StringPrototypeToLowerCase(self2) {
        return self2.toLowerCase();
      },
      StringPrototypeToUpperCase(self2) {
        return self2.toUpperCase();
      },
      StringPrototypeTrim(self2) {
        return self2.trim();
      },
      Symbol,
      SymbolFor: Symbol.for,
      SymbolAsyncIterator: Symbol.asyncIterator,
      SymbolHasInstance: Symbol.hasInstance,
      SymbolIterator: Symbol.iterator,
      SymbolDispose: Symbol.dispose || Symbol("Symbol.dispose"),
      SymbolAsyncDispose: Symbol.asyncDispose || Symbol("Symbol.asyncDispose"),
      TypedArrayPrototypeSet(self2, buf, len) {
        return self2.set(buf, len);
      },
      Boolean,
      Uint8Array
    };
  }
});

// node_modules/n3/node_modules/readable-stream/lib/ours/util/inspect.js
var require_inspect2 = __commonJS({
  "node_modules/n3/node_modules/readable-stream/lib/ours/util/inspect.js"(exports, module) {
    "use strict";
    module.exports = {
      format(format, ...args) {
        return format.replace(/%([sdifj])/g, function(...[_unused, type2]) {
          const replacement = args.shift();
          if (type2 === "f") {
            return replacement.toFixed(6);
          } else if (type2 === "j") {
            return JSON.stringify(replacement);
          } else if (type2 === "s" && typeof replacement === "object") {
            const ctor = replacement.constructor !== Object ? replacement.constructor.name : "";
            return `${ctor} {}`.trim();
          } else {
            return replacement.toString();
          }
        });
      },
      inspect(value) {
        switch (typeof value) {
          case "string":
            if (value.includes("'")) {
              if (!value.includes('"')) {
                return `"${value}"`;
              } else if (!value.includes("`") && !value.includes("${")) {
                return `\`${value}\``;
              }
            }
            return `'${value}'`;
          case "number":
            if (isNaN(value)) {
              return "NaN";
            } else if (Object.is(value, -0)) {
              return String(value);
            }
            return value;
          case "bigint":
            return `${String(value)}n`;
          case "boolean":
          case "undefined":
            return String(value);
          case "object":
            return "{}";
        }
      }
    };
  }
});

// node_modules/n3/node_modules/readable-stream/lib/ours/errors.js
var require_errors2 = __commonJS({
  "node_modules/n3/node_modules/readable-stream/lib/ours/errors.js"(exports, module) {
    "use strict";
    var { format, inspect } = require_inspect2();
    var { AggregateError: CustomAggregateError } = require_primordials2();
    var AggregateError = globalThis.AggregateError || CustomAggregateError;
    var kIsNodeError = Symbol("kIsNodeError");
    var kTypes = [
      "string",
      "function",
      "number",
      "object",
      // Accept 'Function' and 'Object' as alternative to the lower cased version.
      "Function",
      "Object",
      "boolean",
      "bigint",
      "symbol"
    ];
    var classRegExp = /^([A-Z][a-z0-9]*)+$/;
    var nodeInternalPrefix = "__node_internal_";
    var codes = {};
    function assert2(value, message2) {
      if (!value) {
        throw new codes.ERR_INTERNAL_ASSERTION(message2);
      }
    }
    function addNumericalSeparator(val) {
      let res = "";
      let i = val.length;
      const start = val[0] === "-" ? 1 : 0;
      for (; i >= start + 4; i -= 3) {
        res = `_${val.slice(i - 3, i)}${res}`;
      }
      return `${val.slice(0, i)}${res}`;
    }
    function getMessage(key, msg, args) {
      if (typeof msg === "function") {
        assert2(
          msg.length <= args.length,
          // Default options do not count.
          `Code: ${key}; The provided arguments length (${args.length}) does not match the required ones (${msg.length}).`
        );
        return msg(...args);
      }
      const expectedLength = (msg.match(/%[dfijoOs]/g) || []).length;
      assert2(
        expectedLength === args.length,
        `Code: ${key}; The provided arguments length (${args.length}) does not match the required ones (${expectedLength}).`
      );
      if (args.length === 0) {
        return msg;
      }
      return format(msg, ...args);
    }
    function E(code, message2, Base) {
      if (!Base) {
        Base = Error;
      }
      class NodeError extends Base {
        constructor(...args) {
          super(getMessage(code, message2, args));
        }
        toString() {
          return `${this.name} [${code}]: ${this.message}`;
        }
      }
      Object.defineProperties(NodeError.prototype, {
        name: {
          value: Base.name,
          writable: true,
          enumerable: false,
          configurable: true
        },
        toString: {
          value() {
            return `${this.name} [${code}]: ${this.message}`;
          },
          writable: true,
          enumerable: false,
          configurable: true
        }
      });
      NodeError.prototype.code = code;
      NodeError.prototype[kIsNodeError] = true;
      codes[code] = NodeError;
    }
    function hideStackFrames(fn) {
      const hidden = nodeInternalPrefix + fn.name;
      Object.defineProperty(fn, "name", {
        value: hidden
      });
      return fn;
    }
    function aggregateTwoErrors(innerError, outerError) {
      if (innerError && outerError && innerError !== outerError) {
        if (Array.isArray(outerError.errors)) {
          outerError.errors.push(innerError);
          return outerError;
        }
        const err = new AggregateError([outerError, innerError], outerError.message);
        err.code = outerError.code;
        return err;
      }
      return innerError || outerError;
    }
    var AbortError = class extends Error {
      constructor(message2 = "The operation was aborted", options = void 0) {
        if (options !== void 0 && typeof options !== "object") {
          throw new codes.ERR_INVALID_ARG_TYPE("options", "Object", options);
        }
        super(message2, options);
        this.code = "ABORT_ERR";
        this.name = "AbortError";
      }
    };
    E("ERR_ASSERTION", "%s", Error);
    E(
      "ERR_INVALID_ARG_TYPE",
      (name, expected, actual) => {
        assert2(typeof name === "string", "'name' must be a string");
        if (!Array.isArray(expected)) {
          expected = [expected];
        }
        let msg = "The ";
        if (name.endsWith(" argument")) {
          msg += `${name} `;
        } else {
          msg += `"${name}" ${name.includes(".") ? "property" : "argument"} `;
        }
        msg += "must be ";
        const types3 = [];
        const instances = [];
        const other = [];
        for (const value of expected) {
          assert2(typeof value === "string", "All expected entries have to be of type string");
          if (kTypes.includes(value)) {
            types3.push(value.toLowerCase());
          } else if (classRegExp.test(value)) {
            instances.push(value);
          } else {
            assert2(value !== "object", 'The value "object" should be written as "Object"');
            other.push(value);
          }
        }
        if (instances.length > 0) {
          const pos = types3.indexOf("object");
          if (pos !== -1) {
            types3.splice(types3, pos, 1);
            instances.push("Object");
          }
        }
        if (types3.length > 0) {
          switch (types3.length) {
            case 1:
              msg += `of type ${types3[0]}`;
              break;
            case 2:
              msg += `one of type ${types3[0]} or ${types3[1]}`;
              break;
            default: {
              const last = types3.pop();
              msg += `one of type ${types3.join(", ")}, or ${last}`;
            }
          }
          if (instances.length > 0 || other.length > 0) {
            msg += " or ";
          }
        }
        if (instances.length > 0) {
          switch (instances.length) {
            case 1:
              msg += `an instance of ${instances[0]}`;
              break;
            case 2:
              msg += `an instance of ${instances[0]} or ${instances[1]}`;
              break;
            default: {
              const last = instances.pop();
              msg += `an instance of ${instances.join(", ")}, or ${last}`;
            }
          }
          if (other.length > 0) {
            msg += " or ";
          }
        }
        switch (other.length) {
          case 0:
            break;
          case 1:
            if (other[0].toLowerCase() !== other[0]) {
              msg += "an ";
            }
            msg += `${other[0]}`;
            break;
          case 2:
            msg += `one of ${other[0]} or ${other[1]}`;
            break;
          default: {
            const last = other.pop();
            msg += `one of ${other.join(", ")}, or ${last}`;
          }
        }
        if (actual == null) {
          msg += `. Received ${actual}`;
        } else if (typeof actual === "function" && actual.name) {
          msg += `. Received function ${actual.name}`;
        } else if (typeof actual === "object") {
          var _actual$constructor;
          if ((_actual$constructor = actual.constructor) !== null && _actual$constructor !== void 0 && _actual$constructor.name) {
            msg += `. Received an instance of ${actual.constructor.name}`;
          } else {
            const inspected = inspect(actual, {
              depth: -1
            });
            msg += `. Received ${inspected}`;
          }
        } else {
          let inspected = inspect(actual, {
            colors: false
          });
          if (inspected.length > 25) {
            inspected = `${inspected.slice(0, 25)}...`;
          }
          msg += `. Received type ${typeof actual} (${inspected})`;
        }
        return msg;
      },
      TypeError
    );
    E(
      "ERR_INVALID_ARG_VALUE",
      (name, value, reason = "is invalid") => {
        let inspected = inspect(value);
        if (inspected.length > 128) {
          inspected = inspected.slice(0, 128) + "...";
        }
        const type2 = name.includes(".") ? "property" : "argument";
        return `The ${type2} '${name}' ${reason}. Received ${inspected}`;
      },
      TypeError
    );
    E(
      "ERR_INVALID_RETURN_VALUE",
      (input, name, value) => {
        var _value$constructor;
        const type2 = value !== null && value !== void 0 && (_value$constructor = value.constructor) !== null && _value$constructor !== void 0 && _value$constructor.name ? `instance of ${value.constructor.name}` : `type ${typeof value}`;
        return `Expected ${input} to be returned from the "${name}" function but got ${type2}.`;
      },
      TypeError
    );
    E(
      "ERR_MISSING_ARGS",
      (...args) => {
        assert2(args.length > 0, "At least one arg needs to be specified");
        let msg;
        const len = args.length;
        args = (Array.isArray(args) ? args : [args]).map((a) => `"${a}"`).join(" or ");
        switch (len) {
          case 1:
            msg += `The ${args[0]} argument`;
            break;
          case 2:
            msg += `The ${args[0]} and ${args[1]} arguments`;
            break;
          default:
            {
              const last = args.pop();
              msg += `The ${args.join(", ")}, and ${last} arguments`;
            }
            break;
        }
        return `${msg} must be specified`;
      },
      TypeError
    );
    E(
      "ERR_OUT_OF_RANGE",
      (str2, range, input) => {
        assert2(range, 'Missing "range" argument');
        let received;
        if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {
          received = addNumericalSeparator(String(input));
        } else if (typeof input === "bigint") {
          received = String(input);
          const limit = BigInt(2) ** BigInt(32);
          if (input > limit || input < -limit) {
            received = addNumericalSeparator(received);
          }
          received += "n";
        } else {
          received = inspect(input);
        }
        return `The value of "${str2}" is out of range. It must be ${range}. Received ${received}`;
      },
      RangeError
    );
    E("ERR_MULTIPLE_CALLBACK", "Callback called multiple times", Error);
    E("ERR_METHOD_NOT_IMPLEMENTED", "The %s method is not implemented", Error);
    E("ERR_STREAM_ALREADY_FINISHED", "Cannot call %s after a stream was finished", Error);
    E("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable", Error);
    E("ERR_STREAM_DESTROYED", "Cannot call %s after a stream was destroyed", Error);
    E("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError);
    E("ERR_STREAM_PREMATURE_CLOSE", "Premature close", Error);
    E("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF", Error);
    E("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event", Error);
    E("ERR_STREAM_WRITE_AFTER_END", "write after end", Error);
    E("ERR_UNKNOWN_ENCODING", "Unknown encoding: %s", TypeError);
    module.exports = {
      AbortError,
      aggregateTwoErrors: hideStackFrames(aggregateTwoErrors),
      hideStackFrames,
      codes
    };
  }
});

// node_modules/n3/node_modules/readable-stream/lib/ours/util.js
var require_util2 = __commonJS({
  "node_modules/n3/node_modules/readable-stream/lib/ours/util.js"(exports, module) {
    "use strict";
    var bufferModule = require_buffer();
    var { format, inspect } = require_inspect2();
    var {
      codes: { ERR_INVALID_ARG_TYPE }
    } = require_errors2();
    var { kResistStopPropagation, AggregateError, SymbolDispose } = require_primordials2();
    var AbortSignal = globalThis.AbortSignal || require_browser().AbortSignal;
    var AbortController2 = globalThis.AbortController || require_browser().AbortController;
    var AsyncFunction = Object.getPrototypeOf(async function() {
    }).constructor;
    var Blob2 = globalThis.Blob || bufferModule.Blob;
    var isBlob = typeof Blob2 !== "undefined" ? function isBlob2(b) {
      return b instanceof Blob2;
    } : function isBlob2(b) {
      return false;
    };
    var validateAbortSignal = (signal, name) => {
      if (signal !== void 0 && (signal === null || typeof signal !== "object" || !("aborted" in signal))) {
        throw new ERR_INVALID_ARG_TYPE(name, "AbortSignal", signal);
      }
    };
    var validateFunction = (value, name) => {
      if (typeof value !== "function") {
        throw new ERR_INVALID_ARG_TYPE(name, "Function", value);
      }
    };
    module.exports = {
      AggregateError,
      kEmptyObject: Object.freeze({}),
      once(callback) {
        let called = false;
        return function(...args) {
          if (called) {
            return;
          }
          called = true;
          callback.apply(this, args);
        };
      },
      createDeferredPromise: function() {
        let resolve;
        let reject2;
        const promise2 = new Promise((res, rej) => {
          resolve = res;
          reject2 = rej;
        });
        return {
          promise: promise2,
          resolve,
          reject: reject2
        };
      },
      promisify(fn) {
        return new Promise((resolve, reject2) => {
          fn((err, ...args) => {
            if (err) {
              return reject2(err);
            }
            return resolve(...args);
          });
        });
      },
      debuglog() {
        return function() {
        };
      },
      format,
      inspect,
      types: {
        isAsyncFunction(fn) {
          return fn instanceof AsyncFunction;
        },
        isArrayBufferView(arr) {
          return ArrayBuffer.isView(arr);
        }
      },
      isBlob,
      deprecate(fn, message2) {
        return fn;
      },
      addAbortListener: require_events().addAbortListener || function addAbortListener(signal, listener) {
        if (signal === void 0) {
          throw new ERR_INVALID_ARG_TYPE("signal", "AbortSignal", signal);
        }
        validateAbortSignal(signal, "signal");
        validateFunction(listener, "listener");
        let removeEventListener;
        if (signal.aborted) {
          queueMicrotask(() => listener());
        } else {
          signal.addEventListener("abort", listener, {
            __proto__: null,
            once: true,
            [kResistStopPropagation]: true
          });
          removeEventListener = () => {
            signal.removeEventListener("abort", listener);
          };
        }
        return {
          __proto__: null,
          [SymbolDispose]() {
            var _removeEventListener;
            (_removeEventListener = removeEventListener) === null || _removeEventListener === void 0 ? void 0 : _removeEventListener();
          }
        };
      },
      AbortSignalAny: AbortSignal.any || function AbortSignalAny(signals) {
        if (signals.length === 1) {
          return signals[0];
        }
        const ac = new AbortController2();
        const abort = () => ac.abort();
        signals.forEach((signal) => {
          validateAbortSignal(signal, "signals");
          signal.addEventListener("abort", abort, {
            once: true
          });
        });
        ac.signal.addEventListener(
          "abort",
          () => {
            signals.forEach((signal) => signal.removeEventListener("abort", abort));
          },
          {
            once: true
          }
        );
        return ac.signal;
      }
    };
    module.exports.promisify.custom = Symbol.for("nodejs.util.promisify.custom");
  }
});

// node_modules/n3/node_modules/readable-stream/lib/internal/validators.js
var require_validators2 = __commonJS({
  "node_modules/n3/node_modules/readable-stream/lib/internal/validators.js"(exports, module) {
    "use strict";
    var {
      ArrayIsArray,
      ArrayPrototypeIncludes,
      ArrayPrototypeJoin,
      ArrayPrototypeMap,
      NumberIsInteger,
      NumberIsNaN,
      NumberMAX_SAFE_INTEGER,
      NumberMIN_SAFE_INTEGER,
      NumberParseInt,
      ObjectPrototypeHasOwnProperty,
      RegExpPrototypeExec,
      String: String2,
      StringPrototypeToUpperCase,
      StringPrototypeTrim
    } = require_primordials2();
    var {
      hideStackFrames,
      codes: { ERR_SOCKET_BAD_PORT, ERR_INVALID_ARG_TYPE, ERR_INVALID_ARG_VALUE, ERR_OUT_OF_RANGE, ERR_UNKNOWN_SIGNAL }
    } = require_errors2();
    var { normalizeEncoding } = require_util2();
    var { isAsyncFunction, isArrayBufferView } = require_util2().types;
    var signals = {};
    function isInt32(value) {
      return value === (value | 0);
    }
    function isUint32(value) {
      return value === value >>> 0;
    }
    var octalReg = /^[0-7]+$/;
    var modeDesc = "must be a 32-bit unsigned integer or an octal string";
    function parseFileMode(value, name, def) {
      if (typeof value === "undefined") {
        value = def;
      }
      if (typeof value === "string") {
        if (RegExpPrototypeExec(octalReg, value) === null) {
          throw new ERR_INVALID_ARG_VALUE(name, value, modeDesc);
        }
        value = NumberParseInt(value, 8);
      }
      validateUint32(value, name);
      return value;
    }
    var validateInteger = hideStackFrames((value, name, min = NumberMIN_SAFE_INTEGER, max = NumberMAX_SAFE_INTEGER) => {
      if (typeof value !== "number") throw new ERR_INVALID_ARG_TYPE(name, "number", value);
      if (!NumberIsInteger(value)) throw new ERR_OUT_OF_RANGE(name, "an integer", value);
      if (value < min || value > max) throw new ERR_OUT_OF_RANGE(name, `>= ${min} && <= ${max}`, value);
    });
    var validateInt32 = hideStackFrames((value, name, min = -2147483648, max = 2147483647) => {
      if (typeof value !== "number") {
        throw new ERR_INVALID_ARG_TYPE(name, "number", value);
      }
      if (!NumberIsInteger(value)) {
        throw new ERR_OUT_OF_RANGE(name, "an integer", value);
      }
      if (value < min || value > max) {
        throw new ERR_OUT_OF_RANGE(name, `>= ${min} && <= ${max}`, value);
      }
    });
    var validateUint32 = hideStackFrames((value, name, positive = false) => {
      if (typeof value !== "number") {
        throw new ERR_INVALID_ARG_TYPE(name, "number", value);
      }
      if (!NumberIsInteger(value)) {
        throw new ERR_OUT_OF_RANGE(name, "an integer", value);
      }
      const min = positive ? 1 : 0;
      const max = 4294967295;
      if (value < min || value > max) {
        throw new ERR_OUT_OF_RANGE(name, `>= ${min} && <= ${max}`, value);
      }
    });
    function validateString(value, name) {
      if (typeof value !== "string") throw new ERR_INVALID_ARG_TYPE(name, "string", value);
    }
    function validateNumber(value, name, min = void 0, max) {
      if (typeof value !== "number") throw new ERR_INVALID_ARG_TYPE(name, "number", value);
      if (min != null && value < min || max != null && value > max || (min != null || max != null) && NumberIsNaN(value)) {
        throw new ERR_OUT_OF_RANGE(
          name,
          `${min != null ? `>= ${min}` : ""}${min != null && max != null ? " && " : ""}${max != null ? `<= ${max}` : ""}`,
          value
        );
      }
    }
    var validateOneOf = hideStackFrames((value, name, oneOf) => {
      if (!ArrayPrototypeIncludes(oneOf, value)) {
        const allowed = ArrayPrototypeJoin(
          ArrayPrototypeMap(oneOf, (v) => typeof v === "string" ? `'${v}'` : String2(v)),
          ", "
        );
        const reason = "must be one of: " + allowed;
        throw new ERR_INVALID_ARG_VALUE(name, value, reason);
      }
    });
    function validateBoolean(value, name) {
      if (typeof value !== "boolean") throw new ERR_INVALID_ARG_TYPE(name, "boolean", value);
    }
    function getOwnPropertyValueOrDefault(options, key, defaultValue) {
      return options == null || !ObjectPrototypeHasOwnProperty(options, key) ? defaultValue : options[key];
    }
    var validateObject = hideStackFrames((value, name, options = null) => {
      const allowArray = getOwnPropertyValueOrDefault(options, "allowArray", false);
      const allowFunction = getOwnPropertyValueOrDefault(options, "allowFunction", false);
      const nullable2 = getOwnPropertyValueOrDefault(options, "nullable", false);
      if (!nullable2 && value === null || !allowArray && ArrayIsArray(value) || typeof value !== "object" && (!allowFunction || typeof value !== "function")) {
        throw new ERR_INVALID_ARG_TYPE(name, "Object", value);
      }
    });
    var validateDictionary = hideStackFrames((value, name) => {
      if (value != null && typeof value !== "object" && typeof value !== "function") {
        throw new ERR_INVALID_ARG_TYPE(name, "a dictionary", value);
      }
    });
    var validateArray = hideStackFrames((value, name, minLength = 0) => {
      if (!ArrayIsArray(value)) {
        throw new ERR_INVALID_ARG_TYPE(name, "Array", value);
      }
      if (value.length < minLength) {
        const reason = `must be longer than ${minLength}`;
        throw new ERR_INVALID_ARG_VALUE(name, value, reason);
      }
    });
    function validateStringArray(value, name) {
      validateArray(value, name);
      for (let i = 0; i < value.length; i++) {
        validateString(value[i], `${name}[${i}]`);
      }
    }
    function validateBooleanArray(value, name) {
      validateArray(value, name);
      for (let i = 0; i < value.length; i++) {
        validateBoolean(value[i], `${name}[${i}]`);
      }
    }
    function validateAbortSignalArray(value, name) {
      validateArray(value, name);
      for (let i = 0; i < value.length; i++) {
        const signal = value[i];
        const indexedName = `${name}[${i}]`;
        if (signal == null) {
          throw new ERR_INVALID_ARG_TYPE(indexedName, "AbortSignal", signal);
        }
        validateAbortSignal(signal, indexedName);
      }
    }
    function validateSignalName(signal, name = "signal") {
      validateString(signal, name);
      if (signals[signal] === void 0) {
        if (signals[StringPrototypeToUpperCase(signal)] !== void 0) {
          throw new ERR_UNKNOWN_SIGNAL(signal + " (signals must use all capital letters)");
        }
        throw new ERR_UNKNOWN_SIGNAL(signal);
      }
    }
    var validateBuffer = hideStackFrames((buffer, name = "buffer") => {
      if (!isArrayBufferView(buffer)) {
        throw new ERR_INVALID_ARG_TYPE(name, ["Buffer", "TypedArray", "DataView"], buffer);
      }
    });
    function validateEncoding(data, encoding) {
      const normalizedEncoding = normalizeEncoding(encoding);
      const length = data.length;
      if (normalizedEncoding === "hex" && length % 2 !== 0) {
        throw new ERR_INVALID_ARG_VALUE("encoding", encoding, `is invalid for data of length ${length}`);
      }
    }
    function validatePort(port, name = "Port", allowZero = true) {
      if (typeof port !== "number" && typeof port !== "string" || typeof port === "string" && StringPrototypeTrim(port).length === 0 || +port !== +port >>> 0 || port > 65535 || port === 0 && !allowZero) {
        throw new ERR_SOCKET_BAD_PORT(name, port, allowZero);
      }
      return port | 0;
    }
    var validateAbortSignal = hideStackFrames((signal, name) => {
      if (signal !== void 0 && (signal === null || typeof signal !== "object" || !("aborted" in signal))) {
        throw new ERR_INVALID_ARG_TYPE(name, "AbortSignal", signal);
      }
    });
    var validateFunction = hideStackFrames((value, name) => {
      if (typeof value !== "function") throw new ERR_INVALID_ARG_TYPE(name, "Function", value);
    });
    var validatePlainFunction = hideStackFrames((value, name) => {
      if (typeof value !== "function" || isAsyncFunction(value)) throw new ERR_INVALID_ARG_TYPE(name, "Function", value);
    });
    var validateUndefined = hideStackFrames((value, name) => {
      if (value !== void 0) throw new ERR_INVALID_ARG_TYPE(name, "undefined", value);
    });
    function validateUnion(value, name, union2) {
      if (!ArrayPrototypeIncludes(union2, value)) {
        throw new ERR_INVALID_ARG_TYPE(name, `('${ArrayPrototypeJoin(union2, "|")}')`, value);
      }
    }
    var linkValueRegExp = /^(?:<[^>]*>)(?:\s*;\s*[^;"\s]+(?:=(")?[^;"\s]*\1)?)*$/;
    function validateLinkHeaderFormat(value, name) {
      if (typeof value === "undefined" || !RegExpPrototypeExec(linkValueRegExp, value)) {
        throw new ERR_INVALID_ARG_VALUE(
          name,
          value,
          'must be an array or string of format "</styles.css>; rel=preload; as=style"'
        );
      }
    }
    function validateLinkHeaderValue(hints) {
      if (typeof hints === "string") {
        validateLinkHeaderFormat(hints, "hints");
        return hints;
      } else if (ArrayIsArray(hints)) {
        const hintsLength = hints.length;
        let result = "";
        if (hintsLength === 0) {
          return result;
        }
        for (let i = 0; i < hintsLength; i++) {
          const link = hints[i];
          validateLinkHeaderFormat(link, "hints");
          result += link;
          if (i !== hintsLength - 1) {
            result += ", ";
          }
        }
        return result;
      }
      throw new ERR_INVALID_ARG_VALUE(
        "hints",
        hints,
        'must be an array or string of format "</styles.css>; rel=preload; as=style"'
      );
    }
    module.exports = {
      isInt32,
      isUint32,
      parseFileMode,
      validateArray,
      validateStringArray,
      validateBooleanArray,
      validateAbortSignalArray,
      validateBoolean,
      validateBuffer,
      validateDictionary,
      validateEncoding,
      validateFunction,
      validateInt32,
      validateInteger,
      validateNumber,
      validateObject,
      validateOneOf,
      validatePlainFunction,
      validatePort,
      validateSignalName,
      validateString,
      validateUint32,
      validateUndefined,
      validateUnion,
      validateAbortSignal,
      validateLinkHeaderValue
    };
  }
});

// node_modules/n3/node_modules/readable-stream/lib/internal/streams/utils.js
var require_utils2 = __commonJS({
  "node_modules/n3/node_modules/readable-stream/lib/internal/streams/utils.js"(exports, module) {
    "use strict";
    var { SymbolAsyncIterator, SymbolIterator, SymbolFor } = require_primordials2();
    var kIsDestroyed = SymbolFor("nodejs.stream.destroyed");
    var kIsErrored = SymbolFor("nodejs.stream.errored");
    var kIsReadable = SymbolFor("nodejs.stream.readable");
    var kIsWritable = SymbolFor("nodejs.stream.writable");
    var kIsDisturbed = SymbolFor("nodejs.stream.disturbed");
    var kIsClosedPromise = SymbolFor("nodejs.webstream.isClosedPromise");
    var kControllerErrorFunction = SymbolFor("nodejs.webstream.controllerErrorFunction");
    function isReadableNodeStream(obj, strict = false) {
      var _obj$_readableState;
      return !!(obj && typeof obj.pipe === "function" && typeof obj.on === "function" && (!strict || typeof obj.pause === "function" && typeof obj.resume === "function") && (!obj._writableState || ((_obj$_readableState = obj._readableState) === null || _obj$_readableState === void 0 ? void 0 : _obj$_readableState.readable) !== false) && // Duplex
      (!obj._writableState || obj._readableState));
    }
    function isWritableNodeStream(obj) {
      var _obj$_writableState;
      return !!(obj && typeof obj.write === "function" && typeof obj.on === "function" && (!obj._readableState || ((_obj$_writableState = obj._writableState) === null || _obj$_writableState === void 0 ? void 0 : _obj$_writableState.writable) !== false));
    }
    function isDuplexNodeStream(obj) {
      return !!(obj && typeof obj.pipe === "function" && obj._readableState && typeof obj.on === "function" && typeof obj.write === "function");
    }
    function isNodeStream(obj) {
      return obj && (obj._readableState || obj._writableState || typeof obj.write === "function" && typeof obj.on === "function" || typeof obj.pipe === "function" && typeof obj.on === "function");
    }
    function isReadableStream(obj) {
      return !!(obj && !isNodeStream(obj) && typeof obj.pipeThrough === "function" && typeof obj.getReader === "function" && typeof obj.cancel === "function");
    }
    function isWritableStream(obj) {
      return !!(obj && !isNodeStream(obj) && typeof obj.getWriter === "function" && typeof obj.abort === "function");
    }
    function isTransformStream(obj) {
      return !!(obj && !isNodeStream(obj) && typeof obj.readable === "object" && typeof obj.writable === "object");
    }
    function isWebStream(obj) {
      return isReadableStream(obj) || isWritableStream(obj) || isTransformStream(obj);
    }
    function isIterable(obj, isAsync) {
      if (obj == null) return false;
      if (isAsync === true) return typeof obj[SymbolAsyncIterator] === "function";
      if (isAsync === false) return typeof obj[SymbolIterator] === "function";
      return typeof obj[SymbolAsyncIterator] === "function" || typeof obj[SymbolIterator] === "function";
    }
    function isDestroyed(stream) {
      if (!isNodeStream(stream)) return null;
      const wState = stream._writableState;
      const rState = stream._readableState;
      const state = wState || rState;
      return !!(stream.destroyed || stream[kIsDestroyed] || state !== null && state !== void 0 && state.destroyed);
    }
    function isWritableEnded(stream) {
      if (!isWritableNodeStream(stream)) return null;
      if (stream.writableEnded === true) return true;
      const wState = stream._writableState;
      if (wState !== null && wState !== void 0 && wState.errored) return false;
      if (typeof (wState === null || wState === void 0 ? void 0 : wState.ended) !== "boolean") return null;
      return wState.ended;
    }
    function isWritableFinished(stream, strict) {
      if (!isWritableNodeStream(stream)) return null;
      if (stream.writableFinished === true) return true;
      const wState = stream._writableState;
      if (wState !== null && wState !== void 0 && wState.errored) return false;
      if (typeof (wState === null || wState === void 0 ? void 0 : wState.finished) !== "boolean") return null;
      return !!(wState.finished || strict === false && wState.ended === true && wState.length === 0);
    }
    function isReadableEnded(stream) {
      if (!isReadableNodeStream(stream)) return null;
      if (stream.readableEnded === true) return true;
      const rState = stream._readableState;
      if (!rState || rState.errored) return false;
      if (typeof (rState === null || rState === void 0 ? void 0 : rState.ended) !== "boolean") return null;
      return rState.ended;
    }
    function isReadableFinished(stream, strict) {
      if (!isReadableNodeStream(stream)) return null;
      const rState = stream._readableState;
      if (rState !== null && rState !== void 0 && rState.errored) return false;
      if (typeof (rState === null || rState === void 0 ? void 0 : rState.endEmitted) !== "boolean") return null;
      return !!(rState.endEmitted || strict === false && rState.ended === true && rState.length === 0);
    }
    function isReadable(stream) {
      if (stream && stream[kIsReadable] != null) return stream[kIsReadable];
      if (typeof (stream === null || stream === void 0 ? void 0 : stream.readable) !== "boolean") return null;
      if (isDestroyed(stream)) return false;
      return isReadableNodeStream(stream) && stream.readable && !isReadableFinished(stream);
    }
    function isWritable(stream) {
      if (stream && stream[kIsWritable] != null) return stream[kIsWritable];
      if (typeof (stream === null || stream === void 0 ? void 0 : stream.writable) !== "boolean") return null;
      if (isDestroyed(stream)) return false;
      return isWritableNodeStream(stream) && stream.writable && !isWritableEnded(stream);
    }
    function isFinished(stream, opts) {
      if (!isNodeStream(stream)) {
        return null;
      }
      if (isDestroyed(stream)) {
        return true;
      }
      if ((opts === null || opts === void 0 ? void 0 : opts.readable) !== false && isReadable(stream)) {
        return false;
      }
      if ((opts === null || opts === void 0 ? void 0 : opts.writable) !== false && isWritable(stream)) {
        return false;
      }
      return true;
    }
    function isWritableErrored(stream) {
      var _stream$_writableStat, _stream$_writableStat2;
      if (!isNodeStream(stream)) {
        return null;
      }
      if (stream.writableErrored) {
        return stream.writableErrored;
      }
      return (_stream$_writableStat = (_stream$_writableStat2 = stream._writableState) === null || _stream$_writableStat2 === void 0 ? void 0 : _stream$_writableStat2.errored) !== null && _stream$_writableStat !== void 0 ? _stream$_writableStat : null;
    }
    function isReadableErrored(stream) {
      var _stream$_readableStat, _stream$_readableStat2;
      if (!isNodeStream(stream)) {
        return null;
      }
      if (stream.readableErrored) {
        return stream.readableErrored;
      }
      return (_stream$_readableStat = (_stream$_readableStat2 = stream._readableState) === null || _stream$_readableStat2 === void 0 ? void 0 : _stream$_readableStat2.errored) !== null && _stream$_readableStat !== void 0 ? _stream$_readableStat : null;
    }
    function isClosed(stream) {
      if (!isNodeStream(stream)) {
        return null;
      }
      if (typeof stream.closed === "boolean") {
        return stream.closed;
      }
      const wState = stream._writableState;
      const rState = stream._readableState;
      if (typeof (wState === null || wState === void 0 ? void 0 : wState.closed) === "boolean" || typeof (rState === null || rState === void 0 ? void 0 : rState.closed) === "boolean") {
        return (wState === null || wState === void 0 ? void 0 : wState.closed) || (rState === null || rState === void 0 ? void 0 : rState.closed);
      }
      if (typeof stream._closed === "boolean" && isOutgoingMessage(stream)) {
        return stream._closed;
      }
      return null;
    }
    function isOutgoingMessage(stream) {
      return typeof stream._closed === "boolean" && typeof stream._defaultKeepAlive === "boolean" && typeof stream._removedConnection === "boolean" && typeof stream._removedContLen === "boolean";
    }
    function isServerResponse(stream) {
      return typeof stream._sent100 === "boolean" && isOutgoingMessage(stream);
    }
    function isServerRequest(stream) {
      var _stream$req;
      return typeof stream._consuming === "boolean" && typeof stream._dumped === "boolean" && ((_stream$req = stream.req) === null || _stream$req === void 0 ? void 0 : _stream$req.upgradeOrConnect) === void 0;
    }
    function willEmitClose(stream) {
      if (!isNodeStream(stream)) return null;
      const wState = stream._writableState;
      const rState = stream._readableState;
      const state = wState || rState;
      return !state && isServerResponse(stream) || !!(state && state.autoDestroy && state.emitClose && state.closed === false);
    }
    function isDisturbed(stream) {
      var _stream$kIsDisturbed;
      return !!(stream && ((_stream$kIsDisturbed = stream[kIsDisturbed]) !== null && _stream$kIsDisturbed !== void 0 ? _stream$kIsDisturbed : stream.readableDidRead || stream.readableAborted));
    }
    function isErrored(stream) {
      var _ref, _ref2, _ref3, _ref4, _ref5, _stream$kIsErrored, _stream$_readableStat3, _stream$_writableStat3, _stream$_readableStat4, _stream$_writableStat4;
      return !!(stream && ((_ref = (_ref2 = (_ref3 = (_ref4 = (_ref5 = (_stream$kIsErrored = stream[kIsErrored]) !== null && _stream$kIsErrored !== void 0 ? _stream$kIsErrored : stream.readableErrored) !== null && _ref5 !== void 0 ? _ref5 : stream.writableErrored) !== null && _ref4 !== void 0 ? _ref4 : (_stream$_readableStat3 = stream._readableState) === null || _stream$_readableStat3 === void 0 ? void 0 : _stream$_readableStat3.errorEmitted) !== null && _ref3 !== void 0 ? _ref3 : (_stream$_writableStat3 = stream._writableState) === null || _stream$_writableStat3 === void 0 ? void 0 : _stream$_writableStat3.errorEmitted) !== null && _ref2 !== void 0 ? _ref2 : (_stream$_readableStat4 = stream._readableState) === null || _stream$_readableStat4 === void 0 ? void 0 : _stream$_readableStat4.errored) !== null && _ref !== void 0 ? _ref : (_stream$_writableStat4 = stream._writableState) === null || _stream$_writableStat4 === void 0 ? void 0 : _stream$_writableStat4.errored));
    }
    module.exports = {
      isDestroyed,
      kIsDestroyed,
      isDisturbed,
      kIsDisturbed,
      isErrored,
      kIsErrored,
      isReadable,
      kIsReadable,
      kIsClosedPromise,
      kControllerErrorFunction,
      kIsWritable,
      isClosed,
      isDuplexNodeStream,
      isFinished,
      isIterable,
      isReadableNodeStream,
      isReadableStream,
      isReadableEnded,
      isReadableFinished,
      isReadableErrored,
      isNodeStream,
      isWebStream,
      isWritable,
      isWritableNodeStream,
      isWritableStream,
      isWritableEnded,
      isWritableFinished,
      isWritableErrored,
      isServerRequest,
      isServerResponse,
      willEmitClose,
      isTransformStream
    };
  }
});

// node_modules/n3/node_modules/readable-stream/lib/internal/streams/end-of-stream.js
var require_end_of_stream2 = __commonJS({
  "node_modules/n3/node_modules/readable-stream/lib/internal/streams/end-of-stream.js"(exports, module) {
    "use strict";
    var process = require_browser2();
    var { AbortError, codes } = require_errors2();
    var { ERR_INVALID_ARG_TYPE, ERR_STREAM_PREMATURE_CLOSE } = codes;
    var { kEmptyObject, once } = require_util2();
    var { validateAbortSignal, validateFunction, validateObject, validateBoolean } = require_validators2();
    var { Promise: Promise2, PromisePrototypeThen, SymbolDispose } = require_primordials2();
    var {
      isClosed,
      isReadable,
      isReadableNodeStream,
      isReadableStream,
      isReadableFinished,
      isReadableErrored,
      isWritable,
      isWritableNodeStream,
      isWritableStream,
      isWritableFinished,
      isWritableErrored,
      isNodeStream,
      willEmitClose: _willEmitClose,
      kIsClosedPromise
    } = require_utils2();
    var addAbortListener;
    function isRequest(stream) {
      return stream.setHeader && typeof stream.abort === "function";
    }
    var nop = () => {
    };
    function eos(stream, options, callback) {
      var _options$readable, _options$writable;
      if (arguments.length === 2) {
        callback = options;
        options = kEmptyObject;
      } else if (options == null) {
        options = kEmptyObject;
      } else {
        validateObject(options, "options");
      }
      validateFunction(callback, "callback");
      validateAbortSignal(options.signal, "options.signal");
      callback = once(callback);
      if (isReadableStream(stream) || isWritableStream(stream)) {
        return eosWeb(stream, options, callback);
      }
      if (!isNodeStream(stream)) {
        throw new ERR_INVALID_ARG_TYPE("stream", ["ReadableStream", "WritableStream", "Stream"], stream);
      }
      const readable = (_options$readable = options.readable) !== null && _options$readable !== void 0 ? _options$readable : isReadableNodeStream(stream);
      const writable = (_options$writable = options.writable) !== null && _options$writable !== void 0 ? _options$writable : isWritableNodeStream(stream);
      const wState = stream._writableState;
      const rState = stream._readableState;
      const onlegacyfinish = () => {
        if (!stream.writable) {
          onfinish();
        }
      };
      let willEmitClose = _willEmitClose(stream) && isReadableNodeStream(stream) === readable && isWritableNodeStream(stream) === writable;
      let writableFinished = isWritableFinished(stream, false);
      const onfinish = () => {
        writableFinished = true;
        if (stream.destroyed) {
          willEmitClose = false;
        }
        if (willEmitClose && (!stream.readable || readable)) {
          return;
        }
        if (!readable || readableFinished) {
          callback.call(stream);
        }
      };
      let readableFinished = isReadableFinished(stream, false);
      const onend = () => {
        readableFinished = true;
        if (stream.destroyed) {
          willEmitClose = false;
        }
        if (willEmitClose && (!stream.writable || writable)) {
          return;
        }
        if (!writable || writableFinished) {
          callback.call(stream);
        }
      };
      const onerror = (err) => {
        callback.call(stream, err);
      };
      let closed = isClosed(stream);
      const onclose = () => {
        closed = true;
        const errored = isWritableErrored(stream) || isReadableErrored(stream);
        if (errored && typeof errored !== "boolean") {
          return callback.call(stream, errored);
        }
        if (readable && !readableFinished && isReadableNodeStream(stream, true)) {
          if (!isReadableFinished(stream, false)) return callback.call(stream, new ERR_STREAM_PREMATURE_CLOSE());
        }
        if (writable && !writableFinished) {
          if (!isWritableFinished(stream, false)) return callback.call(stream, new ERR_STREAM_PREMATURE_CLOSE());
        }
        callback.call(stream);
      };
      const onclosed = () => {
        closed = true;
        const errored = isWritableErrored(stream) || isReadableErrored(stream);
        if (errored && typeof errored !== "boolean") {
          return callback.call(stream, errored);
        }
        callback.call(stream);
      };
      const onrequest = () => {
        stream.req.on("finish", onfinish);
      };
      if (isRequest(stream)) {
        stream.on("complete", onfinish);
        if (!willEmitClose) {
          stream.on("abort", onclose);
        }
        if (stream.req) {
          onrequest();
        } else {
          stream.on("request", onrequest);
        }
      } else if (writable && !wState) {
        stream.on("end", onlegacyfinish);
        stream.on("close", onlegacyfinish);
      }
      if (!willEmitClose && typeof stream.aborted === "boolean") {
        stream.on("aborted", onclose);
      }
      stream.on("end", onend);
      stream.on("finish", onfinish);
      if (options.error !== false) {
        stream.on("error", onerror);
      }
      stream.on("close", onclose);
      if (closed) {
        process.nextTick(onclose);
      } else if (wState !== null && wState !== void 0 && wState.errorEmitted || rState !== null && rState !== void 0 && rState.errorEmitted) {
        if (!willEmitClose) {
          process.nextTick(onclosed);
        }
      } else if (!readable && (!willEmitClose || isReadable(stream)) && (writableFinished || isWritable(stream) === false)) {
        process.nextTick(onclosed);
      } else if (!writable && (!willEmitClose || isWritable(stream)) && (readableFinished || isReadable(stream) === false)) {
        process.nextTick(onclosed);
      } else if (rState && stream.req && stream.aborted) {
        process.nextTick(onclosed);
      }
      const cleanup = () => {
        callback = nop;
        stream.removeListener("aborted", onclose);
        stream.removeListener("complete", onfinish);
        stream.removeListener("abort", onclose);
        stream.removeListener("request", onrequest);
        if (stream.req) stream.req.removeListener("finish", onfinish);
        stream.removeListener("end", onlegacyfinish);
        stream.removeListener("close", onlegacyfinish);
        stream.removeListener("finish", onfinish);
        stream.removeListener("end", onend);
        stream.removeListener("error", onerror);
        stream.removeListener("close", onclose);
      };
      if (options.signal && !closed) {
        const abort = () => {
          const endCallback = callback;
          cleanup();
          endCallback.call(
            stream,
            new AbortError(void 0, {
              cause: options.signal.reason
            })
          );
        };
        if (options.signal.aborted) {
          process.nextTick(abort);
        } else {
          addAbortListener = addAbortListener || require_util2().addAbortListener;
          const disposable = addAbortListener(options.signal, abort);
          const originalCallback = callback;
          callback = once((...args) => {
            disposable[SymbolDispose]();
            originalCallback.apply(stream, args);
          });
        }
      }
      return cleanup;
    }
    function eosWeb(stream, options, callback) {
      let isAborted = false;
      let abort = nop;
      if (options.signal) {
        abort = () => {
          isAborted = true;
          callback.call(
            stream,
            new AbortError(void 0, {
              cause: options.signal.reason
            })
          );
        };
        if (options.signal.aborted) {
          process.nextTick(abort);
        } else {
          addAbortListener = addAbortListener || require_util2().addAbortListener;
          const disposable = addAbortListener(options.signal, abort);
          const originalCallback = callback;
          callback = once((...args) => {
            disposable[SymbolDispose]();
            originalCallback.apply(stream, args);
          });
        }
      }
      const resolverFn = (...args) => {
        if (!isAborted) {
          process.nextTick(() => callback.apply(stream, args));
        }
      };
      PromisePrototypeThen(stream[kIsClosedPromise].promise, resolverFn, resolverFn);
      return nop;
    }
    function finished(stream, opts) {
      var _opts;
      let autoCleanup = false;
      if (opts === null) {
        opts = kEmptyObject;
      }
      if ((_opts = opts) !== null && _opts !== void 0 && _opts.cleanup) {
        validateBoolean(opts.cleanup, "cleanup");
        autoCleanup = opts.cleanup;
      }
      return new Promise2((resolve, reject2) => {
        const cleanup = eos(stream, opts, (err) => {
          if (autoCleanup) {
            cleanup();
          }
          if (err) {
            reject2(err);
          } else {
            resolve();
          }
        });
      });
    }
    module.exports = eos;
    module.exports.finished = finished;
  }
});

// node_modules/n3/node_modules/readable-stream/lib/internal/streams/destroy.js
var require_destroy2 = __commonJS({
  "node_modules/n3/node_modules/readable-stream/lib/internal/streams/destroy.js"(exports, module) {
    "use strict";
    var process = require_browser2();
    var {
      aggregateTwoErrors,
      codes: { ERR_MULTIPLE_CALLBACK },
      AbortError
    } = require_errors2();
    var { Symbol: Symbol2 } = require_primordials2();
    var { kIsDestroyed, isDestroyed, isFinished, isServerRequest } = require_utils2();
    var kDestroy = Symbol2("kDestroy");
    var kConstruct = Symbol2("kConstruct");
    function checkError(err, w, r) {
      if (err) {
        err.stack;
        if (w && !w.errored) {
          w.errored = err;
        }
        if (r && !r.errored) {
          r.errored = err;
        }
      }
    }
    function destroy(err, cb) {
      const r = this._readableState;
      const w = this._writableState;
      const s = w || r;
      if (w !== null && w !== void 0 && w.destroyed || r !== null && r !== void 0 && r.destroyed) {
        if (typeof cb === "function") {
          cb();
        }
        return this;
      }
      checkError(err, w, r);
      if (w) {
        w.destroyed = true;
      }
      if (r) {
        r.destroyed = true;
      }
      if (!s.constructed) {
        this.once(kDestroy, function(er) {
          _destroy(this, aggregateTwoErrors(er, err), cb);
        });
      } else {
        _destroy(this, err, cb);
      }
      return this;
    }
    function _destroy(self2, err, cb) {
      let called = false;
      function onDestroy(err2) {
        if (called) {
          return;
        }
        called = true;
        const r = self2._readableState;
        const w = self2._writableState;
        checkError(err2, w, r);
        if (w) {
          w.closed = true;
        }
        if (r) {
          r.closed = true;
        }
        if (typeof cb === "function") {
          cb(err2);
        }
        if (err2) {
          process.nextTick(emitErrorCloseNT, self2, err2);
        } else {
          process.nextTick(emitCloseNT, self2);
        }
      }
      try {
        self2._destroy(err || null, onDestroy);
      } catch (err2) {
        onDestroy(err2);
      }
    }
    function emitErrorCloseNT(self2, err) {
      emitErrorNT(self2, err);
      emitCloseNT(self2);
    }
    function emitCloseNT(self2) {
      const r = self2._readableState;
      const w = self2._writableState;
      if (w) {
        w.closeEmitted = true;
      }
      if (r) {
        r.closeEmitted = true;
      }
      if (w !== null && w !== void 0 && w.emitClose || r !== null && r !== void 0 && r.emitClose) {
        self2.emit("close");
      }
    }
    function emitErrorNT(self2, err) {
      const r = self2._readableState;
      const w = self2._writableState;
      if (w !== null && w !== void 0 && w.errorEmitted || r !== null && r !== void 0 && r.errorEmitted) {
        return;
      }
      if (w) {
        w.errorEmitted = true;
      }
      if (r) {
        r.errorEmitted = true;
      }
      self2.emit("error", err);
    }
    function undestroy() {
      const r = this._readableState;
      const w = this._writableState;
      if (r) {
        r.constructed = true;
        r.closed = false;
        r.closeEmitted = false;
        r.destroyed = false;
        r.errored = null;
        r.errorEmitted = false;
        r.reading = false;
        r.ended = r.readable === false;
        r.endEmitted = r.readable === false;
      }
      if (w) {
        w.constructed = true;
        w.destroyed = false;
        w.closed = false;
        w.closeEmitted = false;
        w.errored = null;
        w.errorEmitted = false;
        w.finalCalled = false;
        w.prefinished = false;
        w.ended = w.writable === false;
        w.ending = w.writable === false;
        w.finished = w.writable === false;
      }
    }
    function errorOrDestroy(stream, err, sync) {
      const r = stream._readableState;
      const w = stream._writableState;
      if (w !== null && w !== void 0 && w.destroyed || r !== null && r !== void 0 && r.destroyed) {
        return this;
      }
      if (r !== null && r !== void 0 && r.autoDestroy || w !== null && w !== void 0 && w.autoDestroy)
        stream.destroy(err);
      else if (err) {
        err.stack;
        if (w && !w.errored) {
          w.errored = err;
        }
        if (r && !r.errored) {
          r.errored = err;
        }
        if (sync) {
          process.nextTick(emitErrorNT, stream, err);
        } else {
          emitErrorNT(stream, err);
        }
      }
    }
    function construct(stream, cb) {
      if (typeof stream._construct !== "function") {
        return;
      }
      const r = stream._readableState;
      const w = stream._writableState;
      if (r) {
        r.constructed = false;
      }
      if (w) {
        w.constructed = false;
      }
      stream.once(kConstruct, cb);
      if (stream.listenerCount(kConstruct) > 1) {
        return;
      }
      process.nextTick(constructNT, stream);
    }
    function constructNT(stream) {
      let called = false;
      function onConstruct(err) {
        if (called) {
          errorOrDestroy(stream, err !== null && err !== void 0 ? err : new ERR_MULTIPLE_CALLBACK());
          return;
        }
        called = true;
        const r = stream._readableState;
        const w = stream._writableState;
        const s = w || r;
        if (r) {
          r.constructed = true;
        }
        if (w) {
          w.constructed = true;
        }
        if (s.destroyed) {
          stream.emit(kDestroy, err);
        } else if (err) {
          errorOrDestroy(stream, err, true);
        } else {
          process.nextTick(emitConstructNT, stream);
        }
      }
      try {
        stream._construct((err) => {
          process.nextTick(onConstruct, err);
        });
      } catch (err) {
        process.nextTick(onConstruct, err);
      }
    }
    function emitConstructNT(stream) {
      stream.emit(kConstruct);
    }
    function isRequest(stream) {
      return (stream === null || stream === void 0 ? void 0 : stream.setHeader) && typeof stream.abort === "function";
    }
    function emitCloseLegacy(stream) {
      stream.emit("close");
    }
    function emitErrorCloseLegacy(stream, err) {
      stream.emit("error", err);
      process.nextTick(emitCloseLegacy, stream);
    }
    function destroyer(stream, err) {
      if (!stream || isDestroyed(stream)) {
        return;
      }
      if (!err && !isFinished(stream)) {
        err = new AbortError();
      }
      if (isServerRequest(stream)) {
        stream.socket = null;
        stream.destroy(err);
      } else if (isRequest(stream)) {
        stream.abort();
      } else if (isRequest(stream.req)) {
        stream.req.abort();
      } else if (typeof stream.destroy === "function") {
        stream.destroy(err);
      } else if (typeof stream.close === "function") {
        stream.close();
      } else if (err) {
        process.nextTick(emitErrorCloseLegacy, stream, err);
      } else {
        process.nextTick(emitCloseLegacy, stream);
      }
      if (!stream.destroyed) {
        stream[kIsDestroyed] = true;
      }
    }
    module.exports = {
      construct,
      destroyer,
      destroy,
      undestroy,
      errorOrDestroy
    };
  }
});

// node_modules/n3/node_modules/readable-stream/lib/internal/streams/legacy.js
var require_legacy2 = __commonJS({
  "node_modules/n3/node_modules/readable-stream/lib/internal/streams/legacy.js"(exports, module) {
    "use strict";
    var { ArrayIsArray, ObjectSetPrototypeOf } = require_primordials2();
    var { EventEmitter: EE } = require_events();
    function Stream(opts) {
      EE.call(this, opts);
    }
    ObjectSetPrototypeOf(Stream.prototype, EE.prototype);
    ObjectSetPrototypeOf(Stream, EE);
    Stream.prototype.pipe = function(dest, options) {
      const source = this;
      function ondata(chunk) {
        if (dest.writable && dest.write(chunk) === false && source.pause) {
          source.pause();
        }
      }
      source.on("data", ondata);
      function ondrain() {
        if (source.readable && source.resume) {
          source.resume();
        }
      }
      dest.on("drain", ondrain);
      if (!dest._isStdio && (!options || options.end !== false)) {
        source.on("end", onend);
        source.on("close", onclose);
      }
      let didOnEnd = false;
      function onend() {
        if (didOnEnd) return;
        didOnEnd = true;
        dest.end();
      }
      function onclose() {
        if (didOnEnd) return;
        didOnEnd = true;
        if (typeof dest.destroy === "function") dest.destroy();
      }
      function onerror(er) {
        cleanup();
        if (EE.listenerCount(this, "error") === 0) {
          this.emit("error", er);
        }
      }
      prependListener(source, "error", onerror);
      prependListener(dest, "error", onerror);
      function cleanup() {
        source.removeListener("data", ondata);
        dest.removeListener("drain", ondrain);
        source.removeListener("end", onend);
        source.removeListener("close", onclose);
        source.removeListener("error", onerror);
        dest.removeListener("error", onerror);
        source.removeListener("end", cleanup);
        source.removeListener("close", cleanup);
        dest.removeListener("close", cleanup);
      }
      source.on("end", cleanup);
      source.on("close", cleanup);
      dest.on("close", cleanup);
      dest.emit("pipe", source);
      return dest;
    };
    function prependListener(emitter, event, fn) {
      if (typeof emitter.prependListener === "function") return emitter.prependListener(event, fn);
      if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);
      else if (ArrayIsArray(emitter._events[event])) emitter._events[event].unshift(fn);
      else emitter._events[event] = [fn, emitter._events[event]];
    }
    module.exports = {
      Stream,
      prependListener
    };
  }
});

// node_modules/n3/node_modules/readable-stream/lib/internal/streams/add-abort-signal.js
var require_add_abort_signal2 = __commonJS({
  "node_modules/n3/node_modules/readable-stream/lib/internal/streams/add-abort-signal.js"(exports, module) {
    "use strict";
    var { SymbolDispose } = require_primordials2();
    var { AbortError, codes } = require_errors2();
    var { isNodeStream, isWebStream, kControllerErrorFunction } = require_utils2();
    var eos = require_end_of_stream2();
    var { ERR_INVALID_ARG_TYPE } = codes;
    var addAbortListener;
    var validateAbortSignal = (signal, name) => {
      if (typeof signal !== "object" || !("aborted" in signal)) {
        throw new ERR_INVALID_ARG_TYPE(name, "AbortSignal", signal);
      }
    };
    module.exports.addAbortSignal = function addAbortSignal(signal, stream) {
      validateAbortSignal(signal, "signal");
      if (!isNodeStream(stream) && !isWebStream(stream)) {
        throw new ERR_INVALID_ARG_TYPE("stream", ["ReadableStream", "WritableStream", "Stream"], stream);
      }
      return module.exports.addAbortSignalNoValidate(signal, stream);
    };
    module.exports.addAbortSignalNoValidate = function(signal, stream) {
      if (typeof signal !== "object" || !("aborted" in signal)) {
        return stream;
      }
      const onAbort = isNodeStream(stream) ? () => {
        stream.destroy(
          new AbortError(void 0, {
            cause: signal.reason
          })
        );
      } : () => {
        stream[kControllerErrorFunction](
          new AbortError(void 0, {
            cause: signal.reason
          })
        );
      };
      if (signal.aborted) {
        onAbort();
      } else {
        addAbortListener = addAbortListener || require_util2().addAbortListener;
        const disposable = addAbortListener(signal, onAbort);
        eos(stream, disposable[SymbolDispose]);
      }
      return stream;
    };
  }
});

// node_modules/n3/node_modules/readable-stream/lib/internal/streams/buffer_list.js
var require_buffer_list2 = __commonJS({
  "node_modules/n3/node_modules/readable-stream/lib/internal/streams/buffer_list.js"(exports, module) {
    "use strict";
    var { StringPrototypeSlice, SymbolIterator, TypedArrayPrototypeSet, Uint8Array: Uint8Array2 } = require_primordials2();
    var { Buffer: Buffer3 } = require_buffer();
    var { inspect } = require_util2();
    module.exports = class BufferList {
      constructor() {
        this.head = null;
        this.tail = null;
        this.length = 0;
      }
      push(v) {
        const entry = {
          data: v,
          next: null
        };
        if (this.length > 0) this.tail.next = entry;
        else this.head = entry;
        this.tail = entry;
        ++this.length;
      }
      unshift(v) {
        const entry = {
          data: v,
          next: this.head
        };
        if (this.length === 0) this.tail = entry;
        this.head = entry;
        ++this.length;
      }
      shift() {
        if (this.length === 0) return;
        const ret = this.head.data;
        if (this.length === 1) this.head = this.tail = null;
        else this.head = this.head.next;
        --this.length;
        return ret;
      }
      clear() {
        this.head = this.tail = null;
        this.length = 0;
      }
      join(s) {
        if (this.length === 0) return "";
        let p = this.head;
        let ret = "" + p.data;
        while ((p = p.next) !== null) ret += s + p.data;
        return ret;
      }
      concat(n) {
        if (this.length === 0) return Buffer3.alloc(0);
        const ret = Buffer3.allocUnsafe(n >>> 0);
        let p = this.head;
        let i = 0;
        while (p) {
          TypedArrayPrototypeSet(ret, p.data, i);
          i += p.data.length;
          p = p.next;
        }
        return ret;
      }
      // Consumes a specified amount of bytes or characters from the buffered data.
      consume(n, hasStrings) {
        const data = this.head.data;
        if (n < data.length) {
          const slice = data.slice(0, n);
          this.head.data = data.slice(n);
          return slice;
        }
        if (n === data.length) {
          return this.shift();
        }
        return hasStrings ? this._getString(n) : this._getBuffer(n);
      }
      first() {
        return this.head.data;
      }
      *[SymbolIterator]() {
        for (let p = this.head; p; p = p.next) {
          yield p.data;
        }
      }
      // Consumes a specified amount of characters from the buffered data.
      _getString(n) {
        let ret = "";
        let p = this.head;
        let c = 0;
        do {
          const str2 = p.data;
          if (n > str2.length) {
            ret += str2;
            n -= str2.length;
          } else {
            if (n === str2.length) {
              ret += str2;
              ++c;
              if (p.next) this.head = p.next;
              else this.head = this.tail = null;
            } else {
              ret += StringPrototypeSlice(str2, 0, n);
              this.head = p;
              p.data = StringPrototypeSlice(str2, n);
            }
            break;
          }
          ++c;
        } while ((p = p.next) !== null);
        this.length -= c;
        return ret;
      }
      // Consumes a specified amount of bytes from the buffered data.
      _getBuffer(n) {
        const ret = Buffer3.allocUnsafe(n);
        const retLen = n;
        let p = this.head;
        let c = 0;
        do {
          const buf = p.data;
          if (n > buf.length) {
            TypedArrayPrototypeSet(ret, buf, retLen - n);
            n -= buf.length;
          } else {
            if (n === buf.length) {
              TypedArrayPrototypeSet(ret, buf, retLen - n);
              ++c;
              if (p.next) this.head = p.next;
              else this.head = this.tail = null;
            } else {
              TypedArrayPrototypeSet(ret, new Uint8Array2(buf.buffer, buf.byteOffset, n), retLen - n);
              this.head = p;
              p.data = buf.slice(n);
            }
            break;
          }
          ++c;
        } while ((p = p.next) !== null);
        this.length -= c;
        return ret;
      }
      // Make sure the linked list only shows the minimal necessary information.
      [Symbol.for("nodejs.util.inspect.custom")](_, options) {
        return inspect(this, {
          ...options,
          // Only inspect one level.
          depth: 0,
          // It should not recurse.
          customInspect: false
        });
      }
    };
  }
});

// node_modules/n3/node_modules/readable-stream/lib/internal/streams/state.js
var require_state2 = __commonJS({
  "node_modules/n3/node_modules/readable-stream/lib/internal/streams/state.js"(exports, module) {
    "use strict";
    var { MathFloor, NumberIsInteger } = require_primordials2();
    var { validateInteger } = require_validators2();
    var { ERR_INVALID_ARG_VALUE } = require_errors2().codes;
    var defaultHighWaterMarkBytes = 16 * 1024;
    var defaultHighWaterMarkObjectMode = 16;
    function highWaterMarkFrom(options, isDuplex, duplexKey) {
      return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;
    }
    function getDefaultHighWaterMark(objectMode) {
      return objectMode ? defaultHighWaterMarkObjectMode : defaultHighWaterMarkBytes;
    }
    function setDefaultHighWaterMark(objectMode, value) {
      validateInteger(value, "value", 0);
      if (objectMode) {
        defaultHighWaterMarkObjectMode = value;
      } else {
        defaultHighWaterMarkBytes = value;
      }
    }
    function getHighWaterMark(state, options, duplexKey, isDuplex) {
      const hwm = highWaterMarkFrom(options, isDuplex, duplexKey);
      if (hwm != null) {
        if (!NumberIsInteger(hwm) || hwm < 0) {
          const name = isDuplex ? `options.${duplexKey}` : "options.highWaterMark";
          throw new ERR_INVALID_ARG_VALUE(name, hwm);
        }
        return MathFloor(hwm);
      }
      return getDefaultHighWaterMark(state.objectMode);
    }
    module.exports = {
      getHighWaterMark,
      getDefaultHighWaterMark,
      setDefaultHighWaterMark
    };
  }
});

// node_modules/n3/node_modules/string_decoder/lib/string_decoder.js
var require_string_decoder2 = __commonJS({
  "node_modules/n3/node_modules/string_decoder/lib/string_decoder.js"(exports) {
    "use strict";
    var Buffer3 = require_safe_buffer().Buffer;
    var isEncoding = Buffer3.isEncoding || function(encoding) {
      encoding = "" + encoding;
      switch (encoding && encoding.toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
        case "raw":
          return true;
        default:
          return false;
      }
    };
    function _normalizeEncoding(enc) {
      if (!enc) return "utf8";
      var retried;
      while (true) {
        switch (enc) {
          case "utf8":
          case "utf-8":
            return "utf8";
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return "utf16le";
          case "latin1":
          case "binary":
            return "latin1";
          case "base64":
          case "ascii":
          case "hex":
            return enc;
          default:
            if (retried) return;
            enc = ("" + enc).toLowerCase();
            retried = true;
        }
      }
    }
    function normalizeEncoding(enc) {
      var nenc = _normalizeEncoding(enc);
      if (typeof nenc !== "string" && (Buffer3.isEncoding === isEncoding || !isEncoding(enc))) throw new Error("Unknown encoding: " + enc);
      return nenc || enc;
    }
    exports.StringDecoder = StringDecoder;
    function StringDecoder(encoding) {
      this.encoding = normalizeEncoding(encoding);
      var nb;
      switch (this.encoding) {
        case "utf16le":
          this.text = utf16Text;
          this.end = utf16End;
          nb = 4;
          break;
        case "utf8":
          this.fillLast = utf8FillLast;
          nb = 4;
          break;
        case "base64":
          this.text = base64Text;
          this.end = base64End;
          nb = 3;
          break;
        default:
          this.write = simpleWrite;
          this.end = simpleEnd;
          return;
      }
      this.lastNeed = 0;
      this.lastTotal = 0;
      this.lastChar = Buffer3.allocUnsafe(nb);
    }
    StringDecoder.prototype.write = function(buf) {
      if (buf.length === 0) return "";
      var r;
      var i;
      if (this.lastNeed) {
        r = this.fillLast(buf);
        if (r === void 0) return "";
        i = this.lastNeed;
        this.lastNeed = 0;
      } else {
        i = 0;
      }
      if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);
      return r || "";
    };
    StringDecoder.prototype.end = utf8End;
    StringDecoder.prototype.text = utf8Text;
    StringDecoder.prototype.fillLast = function(buf) {
      if (this.lastNeed <= buf.length) {
        buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
        return this.lastChar.toString(this.encoding, 0, this.lastTotal);
      }
      buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
      this.lastNeed -= buf.length;
    };
    function utf8CheckByte(byte) {
      if (byte <= 127) return 0;
      else if (byte >> 5 === 6) return 2;
      else if (byte >> 4 === 14) return 3;
      else if (byte >> 3 === 30) return 4;
      return byte >> 6 === 2 ? -1 : -2;
    }
    function utf8CheckIncomplete(self2, buf, i) {
      var j = buf.length - 1;
      if (j < i) return 0;
      var nb = utf8CheckByte(buf[j]);
      if (nb >= 0) {
        if (nb > 0) self2.lastNeed = nb - 1;
        return nb;
      }
      if (--j < i || nb === -2) return 0;
      nb = utf8CheckByte(buf[j]);
      if (nb >= 0) {
        if (nb > 0) self2.lastNeed = nb - 2;
        return nb;
      }
      if (--j < i || nb === -2) return 0;
      nb = utf8CheckByte(buf[j]);
      if (nb >= 0) {
        if (nb > 0) {
          if (nb === 2) nb = 0;
          else self2.lastNeed = nb - 3;
        }
        return nb;
      }
      return 0;
    }
    function utf8CheckExtraBytes(self2, buf, p) {
      if ((buf[0] & 192) !== 128) {
        self2.lastNeed = 0;
        return "\uFFFD";
      }
      if (self2.lastNeed > 1 && buf.length > 1) {
        if ((buf[1] & 192) !== 128) {
          self2.lastNeed = 1;
          return "\uFFFD";
        }
        if (self2.lastNeed > 2 && buf.length > 2) {
          if ((buf[2] & 192) !== 128) {
            self2.lastNeed = 2;
            return "\uFFFD";
          }
        }
      }
    }
    function utf8FillLast(buf) {
      var p = this.lastTotal - this.lastNeed;
      var r = utf8CheckExtraBytes(this, buf, p);
      if (r !== void 0) return r;
      if (this.lastNeed <= buf.length) {
        buf.copy(this.lastChar, p, 0, this.lastNeed);
        return this.lastChar.toString(this.encoding, 0, this.lastTotal);
      }
      buf.copy(this.lastChar, p, 0, buf.length);
      this.lastNeed -= buf.length;
    }
    function utf8Text(buf, i) {
      var total = utf8CheckIncomplete(this, buf, i);
      if (!this.lastNeed) return buf.toString("utf8", i);
      this.lastTotal = total;
      var end = buf.length - (total - this.lastNeed);
      buf.copy(this.lastChar, 0, end);
      return buf.toString("utf8", i, end);
    }
    function utf8End(buf) {
      var r = buf && buf.length ? this.write(buf) : "";
      if (this.lastNeed) return r + "\uFFFD";
      return r;
    }
    function utf16Text(buf, i) {
      if ((buf.length - i) % 2 === 0) {
        var r = buf.toString("utf16le", i);
        if (r) {
          var c = r.charCodeAt(r.length - 1);
          if (c >= 55296 && c <= 56319) {
            this.lastNeed = 2;
            this.lastTotal = 4;
            this.lastChar[0] = buf[buf.length - 2];
            this.lastChar[1] = buf[buf.length - 1];
            return r.slice(0, -1);
          }
        }
        return r;
      }
      this.lastNeed = 1;
      this.lastTotal = 2;
      this.lastChar[0] = buf[buf.length - 1];
      return buf.toString("utf16le", i, buf.length - 1);
    }
    function utf16End(buf) {
      var r = buf && buf.length ? this.write(buf) : "";
      if (this.lastNeed) {
        var end = this.lastTotal - this.lastNeed;
        return r + this.lastChar.toString("utf16le", 0, end);
      }
      return r;
    }
    function base64Text(buf, i) {
      var n = (buf.length - i) % 3;
      if (n === 0) return buf.toString("base64", i);
      this.lastNeed = 3 - n;
      this.lastTotal = 3;
      if (n === 1) {
        this.lastChar[0] = buf[buf.length - 1];
      } else {
        this.lastChar[0] = buf[buf.length - 2];
        this.lastChar[1] = buf[buf.length - 1];
      }
      return buf.toString("base64", i, buf.length - n);
    }
    function base64End(buf) {
      var r = buf && buf.length ? this.write(buf) : "";
      if (this.lastNeed) return r + this.lastChar.toString("base64", 0, 3 - this.lastNeed);
      return r;
    }
    function simpleWrite(buf) {
      return buf.toString(this.encoding);
    }
    function simpleEnd(buf) {
      return buf && buf.length ? this.write(buf) : "";
    }
  }
});

// node_modules/n3/node_modules/readable-stream/lib/internal/streams/from.js
var require_from2 = __commonJS({
  "node_modules/n3/node_modules/readable-stream/lib/internal/streams/from.js"(exports, module) {
    "use strict";
    var process = require_browser2();
    var { PromisePrototypeThen, SymbolAsyncIterator, SymbolIterator } = require_primordials2();
    var { Buffer: Buffer3 } = require_buffer();
    var { ERR_INVALID_ARG_TYPE, ERR_STREAM_NULL_VALUES } = require_errors2().codes;
    function from(Readable2, iterable, opts) {
      let iterator;
      if (typeof iterable === "string" || iterable instanceof Buffer3) {
        return new Readable2({
          objectMode: true,
          ...opts,
          read() {
            this.push(iterable);
            this.push(null);
          }
        });
      }
      let isAsync;
      if (iterable && iterable[SymbolAsyncIterator]) {
        isAsync = true;
        iterator = iterable[SymbolAsyncIterator]();
      } else if (iterable && iterable[SymbolIterator]) {
        isAsync = false;
        iterator = iterable[SymbolIterator]();
      } else {
        throw new ERR_INVALID_ARG_TYPE("iterable", ["Iterable"], iterable);
      }
      const readable = new Readable2({
        objectMode: true,
        highWaterMark: 1,
        // TODO(ronag): What options should be allowed?
        ...opts
      });
      let reading = false;
      readable._read = function() {
        if (!reading) {
          reading = true;
          next();
        }
      };
      readable._destroy = function(error46, cb) {
        PromisePrototypeThen(
          close(error46),
          () => process.nextTick(cb, error46),
          // nextTick is here in case cb throws
          (e) => process.nextTick(cb, e || error46)
        );
      };
      async function close(error46) {
        const hadError = error46 !== void 0 && error46 !== null;
        const hasThrow = typeof iterator.throw === "function";
        if (hadError && hasThrow) {
          const { value, done } = await iterator.throw(error46);
          await value;
          if (done) {
            return;
          }
        }
        if (typeof iterator.return === "function") {
          const { value } = await iterator.return();
          await value;
        }
      }
      async function next() {
        for (; ; ) {
          try {
            const { value, done } = isAsync ? await iterator.next() : iterator.next();
            if (done) {
              readable.push(null);
            } else {
              const res = value && typeof value.then === "function" ? await value : value;
              if (res === null) {
                reading = false;
                throw new ERR_STREAM_NULL_VALUES();
              } else if (readable.push(res)) {
                continue;
              } else {
                reading = false;
              }
            }
          } catch (err) {
            readable.destroy(err);
          }
          break;
        }
      }
      return readable;
    }
    module.exports = from;
  }
});

// node_modules/n3/node_modules/readable-stream/lib/internal/streams/readable.js
var require_readable2 = __commonJS({
  "node_modules/n3/node_modules/readable-stream/lib/internal/streams/readable.js"(exports, module) {
    "use strict";
    var process = require_browser2();
    var {
      ArrayPrototypeIndexOf,
      NumberIsInteger,
      NumberIsNaN,
      NumberParseInt,
      ObjectDefineProperties,
      ObjectKeys,
      ObjectSetPrototypeOf,
      Promise: Promise2,
      SafeSet,
      SymbolAsyncDispose,
      SymbolAsyncIterator,
      Symbol: Symbol2
    } = require_primordials2();
    module.exports = Readable2;
    Readable2.ReadableState = ReadableState;
    var { EventEmitter: EE } = require_events();
    var { Stream, prependListener } = require_legacy2();
    var { Buffer: Buffer3 } = require_buffer();
    var { addAbortSignal } = require_add_abort_signal2();
    var eos = require_end_of_stream2();
    var debug = require_util2().debuglog("stream", (fn) => {
      debug = fn;
    });
    var BufferList = require_buffer_list2();
    var destroyImpl = require_destroy2();
    var { getHighWaterMark, getDefaultHighWaterMark } = require_state2();
    var {
      aggregateTwoErrors,
      codes: {
        ERR_INVALID_ARG_TYPE,
        ERR_METHOD_NOT_IMPLEMENTED,
        ERR_OUT_OF_RANGE,
        ERR_STREAM_PUSH_AFTER_EOF,
        ERR_STREAM_UNSHIFT_AFTER_END_EVENT
      },
      AbortError
    } = require_errors2();
    var { validateObject } = require_validators2();
    var kPaused = Symbol2("kPaused");
    var { StringDecoder } = require_string_decoder2();
    var from = require_from2();
    ObjectSetPrototypeOf(Readable2.prototype, Stream.prototype);
    ObjectSetPrototypeOf(Readable2, Stream);
    var nop = () => {
    };
    var { errorOrDestroy } = destroyImpl;
    var kObjectMode = 1 << 0;
    var kEnded = 1 << 1;
    var kEndEmitted = 1 << 2;
    var kReading = 1 << 3;
    var kConstructed = 1 << 4;
    var kSync = 1 << 5;
    var kNeedReadable = 1 << 6;
    var kEmittedReadable = 1 << 7;
    var kReadableListening = 1 << 8;
    var kResumeScheduled = 1 << 9;
    var kErrorEmitted = 1 << 10;
    var kEmitClose = 1 << 11;
    var kAutoDestroy = 1 << 12;
    var kDestroyed = 1 << 13;
    var kClosed = 1 << 14;
    var kCloseEmitted = 1 << 15;
    var kMultiAwaitDrain = 1 << 16;
    var kReadingMore = 1 << 17;
    var kDataEmitted = 1 << 18;
    function makeBitMapDescriptor(bit) {
      return {
        enumerable: false,
        get() {
          return (this.state & bit) !== 0;
        },
        set(value) {
          if (value) this.state |= bit;
          else this.state &= ~bit;
        }
      };
    }
    ObjectDefineProperties(ReadableState.prototype, {
      objectMode: makeBitMapDescriptor(kObjectMode),
      ended: makeBitMapDescriptor(kEnded),
      endEmitted: makeBitMapDescriptor(kEndEmitted),
      reading: makeBitMapDescriptor(kReading),
      // Stream is still being constructed and cannot be
      // destroyed until construction finished or failed.
      // Async construction is opt in, therefore we start as
      // constructed.
      constructed: makeBitMapDescriptor(kConstructed),
      // A flag to be able to tell if the event 'readable'/'data' is emitted
      // immediately, or on a later tick.  We set this to true at first, because
      // any actions that shouldn't happen until "later" should generally also
      // not happen before the first read call.
      sync: makeBitMapDescriptor(kSync),
      // Whenever we return null, then we set a flag to say
      // that we're awaiting a 'readable' event emission.
      needReadable: makeBitMapDescriptor(kNeedReadable),
      emittedReadable: makeBitMapDescriptor(kEmittedReadable),
      readableListening: makeBitMapDescriptor(kReadableListening),
      resumeScheduled: makeBitMapDescriptor(kResumeScheduled),
      // True if the error was already emitted and should not be thrown again.
      errorEmitted: makeBitMapDescriptor(kErrorEmitted),
      emitClose: makeBitMapDescriptor(kEmitClose),
      autoDestroy: makeBitMapDescriptor(kAutoDestroy),
      // Has it been destroyed.
      destroyed: makeBitMapDescriptor(kDestroyed),
      // Indicates whether the stream has finished destroying.
      closed: makeBitMapDescriptor(kClosed),
      // True if close has been emitted or would have been emitted
      // depending on emitClose.
      closeEmitted: makeBitMapDescriptor(kCloseEmitted),
      multiAwaitDrain: makeBitMapDescriptor(kMultiAwaitDrain),
      // If true, a maybeReadMore has been scheduled.
      readingMore: makeBitMapDescriptor(kReadingMore),
      dataEmitted: makeBitMapDescriptor(kDataEmitted)
    });
    function ReadableState(options, stream, isDuplex) {
      if (typeof isDuplex !== "boolean") isDuplex = stream instanceof require_duplex2();
      this.state = kEmitClose | kAutoDestroy | kConstructed | kSync;
      if (options && options.objectMode) this.state |= kObjectMode;
      if (isDuplex && options && options.readableObjectMode) this.state |= kObjectMode;
      this.highWaterMark = options ? getHighWaterMark(this, options, "readableHighWaterMark", isDuplex) : getDefaultHighWaterMark(false);
      this.buffer = new BufferList();
      this.length = 0;
      this.pipes = [];
      this.flowing = null;
      this[kPaused] = null;
      if (options && options.emitClose === false) this.state &= ~kEmitClose;
      if (options && options.autoDestroy === false) this.state &= ~kAutoDestroy;
      this.errored = null;
      this.defaultEncoding = options && options.defaultEncoding || "utf8";
      this.awaitDrainWriters = null;
      this.decoder = null;
      this.encoding = null;
      if (options && options.encoding) {
        this.decoder = new StringDecoder(options.encoding);
        this.encoding = options.encoding;
      }
    }
    function Readable2(options) {
      if (!(this instanceof Readable2)) return new Readable2(options);
      const isDuplex = this instanceof require_duplex2();
      this._readableState = new ReadableState(options, this, isDuplex);
      if (options) {
        if (typeof options.read === "function") this._read = options.read;
        if (typeof options.destroy === "function") this._destroy = options.destroy;
        if (typeof options.construct === "function") this._construct = options.construct;
        if (options.signal && !isDuplex) addAbortSignal(options.signal, this);
      }
      Stream.call(this, options);
      destroyImpl.construct(this, () => {
        if (this._readableState.needReadable) {
          maybeReadMore(this, this._readableState);
        }
      });
    }
    Readable2.prototype.destroy = destroyImpl.destroy;
    Readable2.prototype._undestroy = destroyImpl.undestroy;
    Readable2.prototype._destroy = function(err, cb) {
      cb(err);
    };
    Readable2.prototype[EE.captureRejectionSymbol] = function(err) {
      this.destroy(err);
    };
    Readable2.prototype[SymbolAsyncDispose] = function() {
      let error46;
      if (!this.destroyed) {
        error46 = this.readableEnded ? null : new AbortError();
        this.destroy(error46);
      }
      return new Promise2((resolve, reject2) => eos(this, (err) => err && err !== error46 ? reject2(err) : resolve(null)));
    };
    Readable2.prototype.push = function(chunk, encoding) {
      return readableAddChunk(this, chunk, encoding, false);
    };
    Readable2.prototype.unshift = function(chunk, encoding) {
      return readableAddChunk(this, chunk, encoding, true);
    };
    function readableAddChunk(stream, chunk, encoding, addToFront) {
      debug("readableAddChunk", chunk);
      const state = stream._readableState;
      let err;
      if ((state.state & kObjectMode) === 0) {
        if (typeof chunk === "string") {
          encoding = encoding || state.defaultEncoding;
          if (state.encoding !== encoding) {
            if (addToFront && state.encoding) {
              chunk = Buffer3.from(chunk, encoding).toString(state.encoding);
            } else {
              chunk = Buffer3.from(chunk, encoding);
              encoding = "";
            }
          }
        } else if (chunk instanceof Buffer3) {
          encoding = "";
        } else if (Stream._isUint8Array(chunk)) {
          chunk = Stream._uint8ArrayToBuffer(chunk);
          encoding = "";
        } else if (chunk != null) {
          err = new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer", "Uint8Array"], chunk);
        }
      }
      if (err) {
        errorOrDestroy(stream, err);
      } else if (chunk === null) {
        state.state &= ~kReading;
        onEofChunk(stream, state);
      } else if ((state.state & kObjectMode) !== 0 || chunk && chunk.length > 0) {
        if (addToFront) {
          if ((state.state & kEndEmitted) !== 0) errorOrDestroy(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());
          else if (state.destroyed || state.errored) return false;
          else addChunk(stream, state, chunk, true);
        } else if (state.ended) {
          errorOrDestroy(stream, new ERR_STREAM_PUSH_AFTER_EOF());
        } else if (state.destroyed || state.errored) {
          return false;
        } else {
          state.state &= ~kReading;
          if (state.decoder && !encoding) {
            chunk = state.decoder.write(chunk);
            if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);
            else maybeReadMore(stream, state);
          } else {
            addChunk(stream, state, chunk, false);
          }
        }
      } else if (!addToFront) {
        state.state &= ~kReading;
        maybeReadMore(stream, state);
      }
      return !state.ended && (state.length < state.highWaterMark || state.length === 0);
    }
    function addChunk(stream, state, chunk, addToFront) {
      if (state.flowing && state.length === 0 && !state.sync && stream.listenerCount("data") > 0) {
        if ((state.state & kMultiAwaitDrain) !== 0) {
          state.awaitDrainWriters.clear();
        } else {
          state.awaitDrainWriters = null;
        }
        state.dataEmitted = true;
        stream.emit("data", chunk);
      } else {
        state.length += state.objectMode ? 1 : chunk.length;
        if (addToFront) state.buffer.unshift(chunk);
        else state.buffer.push(chunk);
        if ((state.state & kNeedReadable) !== 0) emitReadable(stream);
      }
      maybeReadMore(stream, state);
    }
    Readable2.prototype.isPaused = function() {
      const state = this._readableState;
      return state[kPaused] === true || state.flowing === false;
    };
    Readable2.prototype.setEncoding = function(enc) {
      const decoder2 = new StringDecoder(enc);
      this._readableState.decoder = decoder2;
      this._readableState.encoding = this._readableState.decoder.encoding;
      const buffer = this._readableState.buffer;
      let content = "";
      for (const data of buffer) {
        content += decoder2.write(data);
      }
      buffer.clear();
      if (content !== "") buffer.push(content);
      this._readableState.length = content.length;
      return this;
    };
    var MAX_HWM = 1073741824;
    function computeNewHighWaterMark(n) {
      if (n > MAX_HWM) {
        throw new ERR_OUT_OF_RANGE("size", "<= 1GiB", n);
      } else {
        n--;
        n |= n >>> 1;
        n |= n >>> 2;
        n |= n >>> 4;
        n |= n >>> 8;
        n |= n >>> 16;
        n++;
      }
      return n;
    }
    function howMuchToRead(n, state) {
      if (n <= 0 || state.length === 0 && state.ended) return 0;
      if ((state.state & kObjectMode) !== 0) return 1;
      if (NumberIsNaN(n)) {
        if (state.flowing && state.length) return state.buffer.first().length;
        return state.length;
      }
      if (n <= state.length) return n;
      return state.ended ? state.length : 0;
    }
    Readable2.prototype.read = function(n) {
      debug("read", n);
      if (n === void 0) {
        n = NaN;
      } else if (!NumberIsInteger(n)) {
        n = NumberParseInt(n, 10);
      }
      const state = this._readableState;
      const nOrig = n;
      if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);
      if (n !== 0) state.state &= ~kEmittedReadable;
      if (n === 0 && state.needReadable && ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)) {
        debug("read: emitReadable", state.length, state.ended);
        if (state.length === 0 && state.ended) endReadable(this);
        else emitReadable(this);
        return null;
      }
      n = howMuchToRead(n, state);
      if (n === 0 && state.ended) {
        if (state.length === 0) endReadable(this);
        return null;
      }
      let doRead = (state.state & kNeedReadable) !== 0;
      debug("need readable", doRead);
      if (state.length === 0 || state.length - n < state.highWaterMark) {
        doRead = true;
        debug("length less than watermark", doRead);
      }
      if (state.ended || state.reading || state.destroyed || state.errored || !state.constructed) {
        doRead = false;
        debug("reading, ended or constructing", doRead);
      } else if (doRead) {
        debug("do read");
        state.state |= kReading | kSync;
        if (state.length === 0) state.state |= kNeedReadable;
        try {
          this._read(state.highWaterMark);
        } catch (err) {
          errorOrDestroy(this, err);
        }
        state.state &= ~kSync;
        if (!state.reading) n = howMuchToRead(nOrig, state);
      }
      let ret;
      if (n > 0) ret = fromList(n, state);
      else ret = null;
      if (ret === null) {
        state.needReadable = state.length <= state.highWaterMark;
        n = 0;
      } else {
        state.length -= n;
        if (state.multiAwaitDrain) {
          state.awaitDrainWriters.clear();
        } else {
          state.awaitDrainWriters = null;
        }
      }
      if (state.length === 0) {
        if (!state.ended) state.needReadable = true;
        if (nOrig !== n && state.ended) endReadable(this);
      }
      if (ret !== null && !state.errorEmitted && !state.closeEmitted) {
        state.dataEmitted = true;
        this.emit("data", ret);
      }
      return ret;
    };
    function onEofChunk(stream, state) {
      debug("onEofChunk");
      if (state.ended) return;
      if (state.decoder) {
        const chunk = state.decoder.end();
        if (chunk && chunk.length) {
          state.buffer.push(chunk);
          state.length += state.objectMode ? 1 : chunk.length;
        }
      }
      state.ended = true;
      if (state.sync) {
        emitReadable(stream);
      } else {
        state.needReadable = false;
        state.emittedReadable = true;
        emitReadable_(stream);
      }
    }
    function emitReadable(stream) {
      const state = stream._readableState;
      debug("emitReadable", state.needReadable, state.emittedReadable);
      state.needReadable = false;
      if (!state.emittedReadable) {
        debug("emitReadable", state.flowing);
        state.emittedReadable = true;
        process.nextTick(emitReadable_, stream);
      }
    }
    function emitReadable_(stream) {
      const state = stream._readableState;
      debug("emitReadable_", state.destroyed, state.length, state.ended);
      if (!state.destroyed && !state.errored && (state.length || state.ended)) {
        stream.emit("readable");
        state.emittedReadable = false;
      }
      state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark;
      flow(stream);
    }
    function maybeReadMore(stream, state) {
      if (!state.readingMore && state.constructed) {
        state.readingMore = true;
        process.nextTick(maybeReadMore_, stream, state);
      }
    }
    function maybeReadMore_(stream, state) {
      while (!state.reading && !state.ended && (state.length < state.highWaterMark || state.flowing && state.length === 0)) {
        const len = state.length;
        debug("maybeReadMore read 0");
        stream.read(0);
        if (len === state.length)
          break;
      }
      state.readingMore = false;
    }
    Readable2.prototype._read = function(n) {
      throw new ERR_METHOD_NOT_IMPLEMENTED("_read()");
    };
    Readable2.prototype.pipe = function(dest, pipeOpts) {
      const src = this;
      const state = this._readableState;
      if (state.pipes.length === 1) {
        if (!state.multiAwaitDrain) {
          state.multiAwaitDrain = true;
          state.awaitDrainWriters = new SafeSet(state.awaitDrainWriters ? [state.awaitDrainWriters] : []);
        }
      }
      state.pipes.push(dest);
      debug("pipe count=%d opts=%j", state.pipes.length, pipeOpts);
      const doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
      const endFn = doEnd ? onend : unpipe;
      if (state.endEmitted) process.nextTick(endFn);
      else src.once("end", endFn);
      dest.on("unpipe", onunpipe);
      function onunpipe(readable, unpipeInfo) {
        debug("onunpipe");
        if (readable === src) {
          if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
            unpipeInfo.hasUnpiped = true;
            cleanup();
          }
        }
      }
      function onend() {
        debug("onend");
        dest.end();
      }
      let ondrain;
      let cleanedUp = false;
      function cleanup() {
        debug("cleanup");
        dest.removeListener("close", onclose);
        dest.removeListener("finish", onfinish);
        if (ondrain) {
          dest.removeListener("drain", ondrain);
        }
        dest.removeListener("error", onerror);
        dest.removeListener("unpipe", onunpipe);
        src.removeListener("end", onend);
        src.removeListener("end", unpipe);
        src.removeListener("data", ondata);
        cleanedUp = true;
        if (ondrain && state.awaitDrainWriters && (!dest._writableState || dest._writableState.needDrain)) ondrain();
      }
      function pause() {
        if (!cleanedUp) {
          if (state.pipes.length === 1 && state.pipes[0] === dest) {
            debug("false write response, pause", 0);
            state.awaitDrainWriters = dest;
            state.multiAwaitDrain = false;
          } else if (state.pipes.length > 1 && state.pipes.includes(dest)) {
            debug("false write response, pause", state.awaitDrainWriters.size);
            state.awaitDrainWriters.add(dest);
          }
          src.pause();
        }
        if (!ondrain) {
          ondrain = pipeOnDrain(src, dest);
          dest.on("drain", ondrain);
        }
      }
      src.on("data", ondata);
      function ondata(chunk) {
        debug("ondata");
        const ret = dest.write(chunk);
        debug("dest.write", ret);
        if (ret === false) {
          pause();
        }
      }
      function onerror(er) {
        debug("onerror", er);
        unpipe();
        dest.removeListener("error", onerror);
        if (dest.listenerCount("error") === 0) {
          const s = dest._writableState || dest._readableState;
          if (s && !s.errorEmitted) {
            errorOrDestroy(dest, er);
          } else {
            dest.emit("error", er);
          }
        }
      }
      prependListener(dest, "error", onerror);
      function onclose() {
        dest.removeListener("finish", onfinish);
        unpipe();
      }
      dest.once("close", onclose);
      function onfinish() {
        debug("onfinish");
        dest.removeListener("close", onclose);
        unpipe();
      }
      dest.once("finish", onfinish);
      function unpipe() {
        debug("unpipe");
        src.unpipe(dest);
      }
      dest.emit("pipe", src);
      if (dest.writableNeedDrain === true) {
        pause();
      } else if (!state.flowing) {
        debug("pipe resume");
        src.resume();
      }
      return dest;
    };
    function pipeOnDrain(src, dest) {
      return function pipeOnDrainFunctionResult() {
        const state = src._readableState;
        if (state.awaitDrainWriters === dest) {
          debug("pipeOnDrain", 1);
          state.awaitDrainWriters = null;
        } else if (state.multiAwaitDrain) {
          debug("pipeOnDrain", state.awaitDrainWriters.size);
          state.awaitDrainWriters.delete(dest);
        }
        if ((!state.awaitDrainWriters || state.awaitDrainWriters.size === 0) && src.listenerCount("data")) {
          src.resume();
        }
      };
    }
    Readable2.prototype.unpipe = function(dest) {
      const state = this._readableState;
      const unpipeInfo = {
        hasUnpiped: false
      };
      if (state.pipes.length === 0) return this;
      if (!dest) {
        const dests = state.pipes;
        state.pipes = [];
        this.pause();
        for (let i = 0; i < dests.length; i++)
          dests[i].emit("unpipe", this, {
            hasUnpiped: false
          });
        return this;
      }
      const index = ArrayPrototypeIndexOf(state.pipes, dest);
      if (index === -1) return this;
      state.pipes.splice(index, 1);
      if (state.pipes.length === 0) this.pause();
      dest.emit("unpipe", this, unpipeInfo);
      return this;
    };
    Readable2.prototype.on = function(ev, fn) {
      const res = Stream.prototype.on.call(this, ev, fn);
      const state = this._readableState;
      if (ev === "data") {
        state.readableListening = this.listenerCount("readable") > 0;
        if (state.flowing !== false) this.resume();
      } else if (ev === "readable") {
        if (!state.endEmitted && !state.readableListening) {
          state.readableListening = state.needReadable = true;
          state.flowing = false;
          state.emittedReadable = false;
          debug("on readable", state.length, state.reading);
          if (state.length) {
            emitReadable(this);
          } else if (!state.reading) {
            process.nextTick(nReadingNextTick, this);
          }
        }
      }
      return res;
    };
    Readable2.prototype.addListener = Readable2.prototype.on;
    Readable2.prototype.removeListener = function(ev, fn) {
      const res = Stream.prototype.removeListener.call(this, ev, fn);
      if (ev === "readable") {
        process.nextTick(updateReadableListening, this);
      }
      return res;
    };
    Readable2.prototype.off = Readable2.prototype.removeListener;
    Readable2.prototype.removeAllListeners = function(ev) {
      const res = Stream.prototype.removeAllListeners.apply(this, arguments);
      if (ev === "readable" || ev === void 0) {
        process.nextTick(updateReadableListening, this);
      }
      return res;
    };
    function updateReadableListening(self2) {
      const state = self2._readableState;
      state.readableListening = self2.listenerCount("readable") > 0;
      if (state.resumeScheduled && state[kPaused] === false) {
        state.flowing = true;
      } else if (self2.listenerCount("data") > 0) {
        self2.resume();
      } else if (!state.readableListening) {
        state.flowing = null;
      }
    }
    function nReadingNextTick(self2) {
      debug("readable nexttick read 0");
      self2.read(0);
    }
    Readable2.prototype.resume = function() {
      const state = this._readableState;
      if (!state.flowing) {
        debug("resume");
        state.flowing = !state.readableListening;
        resume(this, state);
      }
      state[kPaused] = false;
      return this;
    };
    function resume(stream, state) {
      if (!state.resumeScheduled) {
        state.resumeScheduled = true;
        process.nextTick(resume_, stream, state);
      }
    }
    function resume_(stream, state) {
      debug("resume", state.reading);
      if (!state.reading) {
        stream.read(0);
      }
      state.resumeScheduled = false;
      stream.emit("resume");
      flow(stream);
      if (state.flowing && !state.reading) stream.read(0);
    }
    Readable2.prototype.pause = function() {
      debug("call pause flowing=%j", this._readableState.flowing);
      if (this._readableState.flowing !== false) {
        debug("pause");
        this._readableState.flowing = false;
        this.emit("pause");
      }
      this._readableState[kPaused] = true;
      return this;
    };
    function flow(stream) {
      const state = stream._readableState;
      debug("flow", state.flowing);
      while (state.flowing && stream.read() !== null) ;
    }
    Readable2.prototype.wrap = function(stream) {
      let paused = false;
      stream.on("data", (chunk) => {
        if (!this.push(chunk) && stream.pause) {
          paused = true;
          stream.pause();
        }
      });
      stream.on("end", () => {
        this.push(null);
      });
      stream.on("error", (err) => {
        errorOrDestroy(this, err);
      });
      stream.on("close", () => {
        this.destroy();
      });
      stream.on("destroy", () => {
        this.destroy();
      });
      this._read = () => {
        if (paused && stream.resume) {
          paused = false;
          stream.resume();
        }
      };
      const streamKeys = ObjectKeys(stream);
      for (let j = 1; j < streamKeys.length; j++) {
        const i = streamKeys[j];
        if (this[i] === void 0 && typeof stream[i] === "function") {
          this[i] = stream[i].bind(stream);
        }
      }
      return this;
    };
    Readable2.prototype[SymbolAsyncIterator] = function() {
      return streamToAsyncIterator(this);
    };
    Readable2.prototype.iterator = function(options) {
      if (options !== void 0) {
        validateObject(options, "options");
      }
      return streamToAsyncIterator(this, options);
    };
    function streamToAsyncIterator(stream, options) {
      if (typeof stream.read !== "function") {
        stream = Readable2.wrap(stream, {
          objectMode: true
        });
      }
      const iter = createAsyncIterator(stream, options);
      iter.stream = stream;
      return iter;
    }
    async function* createAsyncIterator(stream, options) {
      let callback = nop;
      function next(resolve) {
        if (this === stream) {
          callback();
          callback = nop;
        } else {
          callback = resolve;
        }
      }
      stream.on("readable", next);
      let error46;
      const cleanup = eos(
        stream,
        {
          writable: false
        },
        (err) => {
          error46 = err ? aggregateTwoErrors(error46, err) : null;
          callback();
          callback = nop;
        }
      );
      try {
        while (true) {
          const chunk = stream.destroyed ? null : stream.read();
          if (chunk !== null) {
            yield chunk;
          } else if (error46) {
            throw error46;
          } else if (error46 === null) {
            return;
          } else {
            await new Promise2(next);
          }
        }
      } catch (err) {
        error46 = aggregateTwoErrors(error46, err);
        throw error46;
      } finally {
        if ((error46 || (options === null || options === void 0 ? void 0 : options.destroyOnReturn) !== false) && (error46 === void 0 || stream._readableState.autoDestroy)) {
          destroyImpl.destroyer(stream, null);
        } else {
          stream.off("readable", next);
          cleanup();
        }
      }
    }
    ObjectDefineProperties(Readable2.prototype, {
      readable: {
        __proto__: null,
        get() {
          const r = this._readableState;
          return !!r && r.readable !== false && !r.destroyed && !r.errorEmitted && !r.endEmitted;
        },
        set(val) {
          if (this._readableState) {
            this._readableState.readable = !!val;
          }
        }
      },
      readableDidRead: {
        __proto__: null,
        enumerable: false,
        get: function() {
          return this._readableState.dataEmitted;
        }
      },
      readableAborted: {
        __proto__: null,
        enumerable: false,
        get: function() {
          return !!(this._readableState.readable !== false && (this._readableState.destroyed || this._readableState.errored) && !this._readableState.endEmitted);
        }
      },
      readableHighWaterMark: {
        __proto__: null,
        enumerable: false,
        get: function() {
          return this._readableState.highWaterMark;
        }
      },
      readableBuffer: {
        __proto__: null,
        enumerable: false,
        get: function() {
          return this._readableState && this._readableState.buffer;
        }
      },
      readableFlowing: {
        __proto__: null,
        enumerable: false,
        get: function() {
          return this._readableState.flowing;
        },
        set: function(state) {
          if (this._readableState) {
            this._readableState.flowing = state;
          }
        }
      },
      readableLength: {
        __proto__: null,
        enumerable: false,
        get() {
          return this._readableState.length;
        }
      },
      readableObjectMode: {
        __proto__: null,
        enumerable: false,
        get() {
          return this._readableState ? this._readableState.objectMode : false;
        }
      },
      readableEncoding: {
        __proto__: null,
        enumerable: false,
        get() {
          return this._readableState ? this._readableState.encoding : null;
        }
      },
      errored: {
        __proto__: null,
        enumerable: false,
        get() {
          return this._readableState ? this._readableState.errored : null;
        }
      },
      closed: {
        __proto__: null,
        get() {
          return this._readableState ? this._readableState.closed : false;
        }
      },
      destroyed: {
        __proto__: null,
        enumerable: false,
        get() {
          return this._readableState ? this._readableState.destroyed : false;
        },
        set(value) {
          if (!this._readableState) {
            return;
          }
          this._readableState.destroyed = value;
        }
      },
      readableEnded: {
        __proto__: null,
        enumerable: false,
        get() {
          return this._readableState ? this._readableState.endEmitted : false;
        }
      }
    });
    ObjectDefineProperties(ReadableState.prototype, {
      // Legacy getter for `pipesCount`.
      pipesCount: {
        __proto__: null,
        get() {
          return this.pipes.length;
        }
      },
      // Legacy property for `paused`.
      paused: {
        __proto__: null,
        get() {
          return this[kPaused] !== false;
        },
        set(value) {
          this[kPaused] = !!value;
        }
      }
    });
    Readable2._fromList = fromList;
    function fromList(n, state) {
      if (state.length === 0) return null;
      let ret;
      if (state.objectMode) ret = state.buffer.shift();
      else if (!n || n >= state.length) {
        if (state.decoder) ret = state.buffer.join("");
        else if (state.buffer.length === 1) ret = state.buffer.first();
        else ret = state.buffer.concat(state.length);
        state.buffer.clear();
      } else {
        ret = state.buffer.consume(n, state.decoder);
      }
      return ret;
    }
    function endReadable(stream) {
      const state = stream._readableState;
      debug("endReadable", state.endEmitted);
      if (!state.endEmitted) {
        state.ended = true;
        process.nextTick(endReadableNT, state, stream);
      }
    }
    function endReadableNT(state, stream) {
      debug("endReadableNT", state.endEmitted, state.length);
      if (!state.errored && !state.closeEmitted && !state.endEmitted && state.length === 0) {
        state.endEmitted = true;
        stream.emit("end");
        if (stream.writable && stream.allowHalfOpen === false) {
          process.nextTick(endWritableNT, stream);
        } else if (state.autoDestroy) {
          const wState = stream._writableState;
          const autoDestroy = !wState || wState.autoDestroy && // We don't expect the writable to ever 'finish'
          // if writable is explicitly set to false.
          (wState.finished || wState.writable === false);
          if (autoDestroy) {
            stream.destroy();
          }
        }
      }
    }
    function endWritableNT(stream) {
      const writable = stream.writable && !stream.writableEnded && !stream.destroyed;
      if (writable) {
        stream.end();
      }
    }
    Readable2.from = function(iterable, opts) {
      return from(Readable2, iterable, opts);
    };
    var webStreamsAdapters;
    function lazyWebStreams() {
      if (webStreamsAdapters === void 0) webStreamsAdapters = {};
      return webStreamsAdapters;
    }
    Readable2.fromWeb = function(readableStream, options) {
      return lazyWebStreams().newStreamReadableFromReadableStream(readableStream, options);
    };
    Readable2.toWeb = function(streamReadable, options) {
      return lazyWebStreams().newReadableStreamFromStreamReadable(streamReadable, options);
    };
    Readable2.wrap = function(src, options) {
      var _ref, _src$readableObjectMo;
      return new Readable2({
        objectMode: (_ref = (_src$readableObjectMo = src.readableObjectMode) !== null && _src$readableObjectMo !== void 0 ? _src$readableObjectMo : src.objectMode) !== null && _ref !== void 0 ? _ref : true,
        ...options,
        destroy(err, callback) {
          destroyImpl.destroyer(src, err);
          callback(err);
        }
      }).wrap(src);
    };
  }
});

// node_modules/n3/node_modules/readable-stream/lib/internal/streams/writable.js
var require_writable2 = __commonJS({
  "node_modules/n3/node_modules/readable-stream/lib/internal/streams/writable.js"(exports, module) {
    "use strict";
    var process = require_browser2();
    var {
      ArrayPrototypeSlice,
      Error: Error2,
      FunctionPrototypeSymbolHasInstance,
      ObjectDefineProperty,
      ObjectDefineProperties,
      ObjectSetPrototypeOf,
      StringPrototypeToLowerCase,
      Symbol: Symbol2,
      SymbolHasInstance
    } = require_primordials2();
    module.exports = Writable;
    Writable.WritableState = WritableState;
    var { EventEmitter: EE } = require_events();
    var Stream = require_legacy2().Stream;
    var { Buffer: Buffer3 } = require_buffer();
    var destroyImpl = require_destroy2();
    var { addAbortSignal } = require_add_abort_signal2();
    var { getHighWaterMark, getDefaultHighWaterMark } = require_state2();
    var {
      ERR_INVALID_ARG_TYPE,
      ERR_METHOD_NOT_IMPLEMENTED,
      ERR_MULTIPLE_CALLBACK,
      ERR_STREAM_CANNOT_PIPE,
      ERR_STREAM_DESTROYED,
      ERR_STREAM_ALREADY_FINISHED,
      ERR_STREAM_NULL_VALUES,
      ERR_STREAM_WRITE_AFTER_END,
      ERR_UNKNOWN_ENCODING
    } = require_errors2().codes;
    var { errorOrDestroy } = destroyImpl;
    ObjectSetPrototypeOf(Writable.prototype, Stream.prototype);
    ObjectSetPrototypeOf(Writable, Stream);
    function nop() {
    }
    var kOnFinished = Symbol2("kOnFinished");
    function WritableState(options, stream, isDuplex) {
      if (typeof isDuplex !== "boolean") isDuplex = stream instanceof require_duplex2();
      this.objectMode = !!(options && options.objectMode);
      if (isDuplex) this.objectMode = this.objectMode || !!(options && options.writableObjectMode);
      this.highWaterMark = options ? getHighWaterMark(this, options, "writableHighWaterMark", isDuplex) : getDefaultHighWaterMark(false);
      this.finalCalled = false;
      this.needDrain = false;
      this.ending = false;
      this.ended = false;
      this.finished = false;
      this.destroyed = false;
      const noDecode = !!(options && options.decodeStrings === false);
      this.decodeStrings = !noDecode;
      this.defaultEncoding = options && options.defaultEncoding || "utf8";
      this.length = 0;
      this.writing = false;
      this.corked = 0;
      this.sync = true;
      this.bufferProcessing = false;
      this.onwrite = onwrite.bind(void 0, stream);
      this.writecb = null;
      this.writelen = 0;
      this.afterWriteTickInfo = null;
      resetBuffer(this);
      this.pendingcb = 0;
      this.constructed = true;
      this.prefinished = false;
      this.errorEmitted = false;
      this.emitClose = !options || options.emitClose !== false;
      this.autoDestroy = !options || options.autoDestroy !== false;
      this.errored = null;
      this.closed = false;
      this.closeEmitted = false;
      this[kOnFinished] = [];
    }
    function resetBuffer(state) {
      state.buffered = [];
      state.bufferedIndex = 0;
      state.allBuffers = true;
      state.allNoop = true;
    }
    WritableState.prototype.getBuffer = function getBuffer() {
      return ArrayPrototypeSlice(this.buffered, this.bufferedIndex);
    };
    ObjectDefineProperty(WritableState.prototype, "bufferedRequestCount", {
      __proto__: null,
      get() {
        return this.buffered.length - this.bufferedIndex;
      }
    });
    function Writable(options) {
      const isDuplex = this instanceof require_duplex2();
      if (!isDuplex && !FunctionPrototypeSymbolHasInstance(Writable, this)) return new Writable(options);
      this._writableState = new WritableState(options, this, isDuplex);
      if (options) {
        if (typeof options.write === "function") this._write = options.write;
        if (typeof options.writev === "function") this._writev = options.writev;
        if (typeof options.destroy === "function") this._destroy = options.destroy;
        if (typeof options.final === "function") this._final = options.final;
        if (typeof options.construct === "function") this._construct = options.construct;
        if (options.signal) addAbortSignal(options.signal, this);
      }
      Stream.call(this, options);
      destroyImpl.construct(this, () => {
        const state = this._writableState;
        if (!state.writing) {
          clearBuffer(this, state);
        }
        finishMaybe(this, state);
      });
    }
    ObjectDefineProperty(Writable, SymbolHasInstance, {
      __proto__: null,
      value: function(object2) {
        if (FunctionPrototypeSymbolHasInstance(this, object2)) return true;
        if (this !== Writable) return false;
        return object2 && object2._writableState instanceof WritableState;
      }
    });
    Writable.prototype.pipe = function() {
      errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE());
    };
    function _write(stream, chunk, encoding, cb) {
      const state = stream._writableState;
      if (typeof encoding === "function") {
        cb = encoding;
        encoding = state.defaultEncoding;
      } else {
        if (!encoding) encoding = state.defaultEncoding;
        else if (encoding !== "buffer" && !Buffer3.isEncoding(encoding)) throw new ERR_UNKNOWN_ENCODING(encoding);
        if (typeof cb !== "function") cb = nop;
      }
      if (chunk === null) {
        throw new ERR_STREAM_NULL_VALUES();
      } else if (!state.objectMode) {
        if (typeof chunk === "string") {
          if (state.decodeStrings !== false) {
            chunk = Buffer3.from(chunk, encoding);
            encoding = "buffer";
          }
        } else if (chunk instanceof Buffer3) {
          encoding = "buffer";
        } else if (Stream._isUint8Array(chunk)) {
          chunk = Stream._uint8ArrayToBuffer(chunk);
          encoding = "buffer";
        } else {
          throw new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer", "Uint8Array"], chunk);
        }
      }
      let err;
      if (state.ending) {
        err = new ERR_STREAM_WRITE_AFTER_END();
      } else if (state.destroyed) {
        err = new ERR_STREAM_DESTROYED("write");
      }
      if (err) {
        process.nextTick(cb, err);
        errorOrDestroy(stream, err, true);
        return err;
      }
      state.pendingcb++;
      return writeOrBuffer(stream, state, chunk, encoding, cb);
    }
    Writable.prototype.write = function(chunk, encoding, cb) {
      return _write(this, chunk, encoding, cb) === true;
    };
    Writable.prototype.cork = function() {
      this._writableState.corked++;
    };
    Writable.prototype.uncork = function() {
      const state = this._writableState;
      if (state.corked) {
        state.corked--;
        if (!state.writing) clearBuffer(this, state);
      }
    };
    Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
      if (typeof encoding === "string") encoding = StringPrototypeToLowerCase(encoding);
      if (!Buffer3.isEncoding(encoding)) throw new ERR_UNKNOWN_ENCODING(encoding);
      this._writableState.defaultEncoding = encoding;
      return this;
    };
    function writeOrBuffer(stream, state, chunk, encoding, callback) {
      const len = state.objectMode ? 1 : chunk.length;
      state.length += len;
      const ret = state.length < state.highWaterMark;
      if (!ret) state.needDrain = true;
      if (state.writing || state.corked || state.errored || !state.constructed) {
        state.buffered.push({
          chunk,
          encoding,
          callback
        });
        if (state.allBuffers && encoding !== "buffer") {
          state.allBuffers = false;
        }
        if (state.allNoop && callback !== nop) {
          state.allNoop = false;
        }
      } else {
        state.writelen = len;
        state.writecb = callback;
        state.writing = true;
        state.sync = true;
        stream._write(chunk, encoding, state.onwrite);
        state.sync = false;
      }
      return ret && !state.errored && !state.destroyed;
    }
    function doWrite(stream, state, writev, len, chunk, encoding, cb) {
      state.writelen = len;
      state.writecb = cb;
      state.writing = true;
      state.sync = true;
      if (state.destroyed) state.onwrite(new ERR_STREAM_DESTROYED("write"));
      else if (writev) stream._writev(chunk, state.onwrite);
      else stream._write(chunk, encoding, state.onwrite);
      state.sync = false;
    }
    function onwriteError(stream, state, er, cb) {
      --state.pendingcb;
      cb(er);
      errorBuffer(state);
      errorOrDestroy(stream, er);
    }
    function onwrite(stream, er) {
      const state = stream._writableState;
      const sync = state.sync;
      const cb = state.writecb;
      if (typeof cb !== "function") {
        errorOrDestroy(stream, new ERR_MULTIPLE_CALLBACK());
        return;
      }
      state.writing = false;
      state.writecb = null;
      state.length -= state.writelen;
      state.writelen = 0;
      if (er) {
        er.stack;
        if (!state.errored) {
          state.errored = er;
        }
        if (stream._readableState && !stream._readableState.errored) {
          stream._readableState.errored = er;
        }
        if (sync) {
          process.nextTick(onwriteError, stream, state, er, cb);
        } else {
          onwriteError(stream, state, er, cb);
        }
      } else {
        if (state.buffered.length > state.bufferedIndex) {
          clearBuffer(stream, state);
        }
        if (sync) {
          if (state.afterWriteTickInfo !== null && state.afterWriteTickInfo.cb === cb) {
            state.afterWriteTickInfo.count++;
          } else {
            state.afterWriteTickInfo = {
              count: 1,
              cb,
              stream,
              state
            };
            process.nextTick(afterWriteTick, state.afterWriteTickInfo);
          }
        } else {
          afterWrite(stream, state, 1, cb);
        }
      }
    }
    function afterWriteTick({ stream, state, count, cb }) {
      state.afterWriteTickInfo = null;
      return afterWrite(stream, state, count, cb);
    }
    function afterWrite(stream, state, count, cb) {
      const needDrain = !state.ending && !stream.destroyed && state.length === 0 && state.needDrain;
      if (needDrain) {
        state.needDrain = false;
        stream.emit("drain");
      }
      while (count-- > 0) {
        state.pendingcb--;
        cb();
      }
      if (state.destroyed) {
        errorBuffer(state);
      }
      finishMaybe(stream, state);
    }
    function errorBuffer(state) {
      if (state.writing) {
        return;
      }
      for (let n = state.bufferedIndex; n < state.buffered.length; ++n) {
        var _state$errored;
        const { chunk, callback } = state.buffered[n];
        const len = state.objectMode ? 1 : chunk.length;
        state.length -= len;
        callback(
          (_state$errored = state.errored) !== null && _state$errored !== void 0 ? _state$errored : new ERR_STREAM_DESTROYED("write")
        );
      }
      const onfinishCallbacks = state[kOnFinished].splice(0);
      for (let i = 0; i < onfinishCallbacks.length; i++) {
        var _state$errored2;
        onfinishCallbacks[i](
          (_state$errored2 = state.errored) !== null && _state$errored2 !== void 0 ? _state$errored2 : new ERR_STREAM_DESTROYED("end")
        );
      }
      resetBuffer(state);
    }
    function clearBuffer(stream, state) {
      if (state.corked || state.bufferProcessing || state.destroyed || !state.constructed) {
        return;
      }
      const { buffered, bufferedIndex, objectMode } = state;
      const bufferedLength = buffered.length - bufferedIndex;
      if (!bufferedLength) {
        return;
      }
      let i = bufferedIndex;
      state.bufferProcessing = true;
      if (bufferedLength > 1 && stream._writev) {
        state.pendingcb -= bufferedLength - 1;
        const callback = state.allNoop ? nop : (err) => {
          for (let n = i; n < buffered.length; ++n) {
            buffered[n].callback(err);
          }
        };
        const chunks = state.allNoop && i === 0 ? buffered : ArrayPrototypeSlice(buffered, i);
        chunks.allBuffers = state.allBuffers;
        doWrite(stream, state, true, state.length, chunks, "", callback);
        resetBuffer(state);
      } else {
        do {
          const { chunk, encoding, callback } = buffered[i];
          buffered[i++] = null;
          const len = objectMode ? 1 : chunk.length;
          doWrite(stream, state, false, len, chunk, encoding, callback);
        } while (i < buffered.length && !state.writing);
        if (i === buffered.length) {
          resetBuffer(state);
        } else if (i > 256) {
          buffered.splice(0, i);
          state.bufferedIndex = 0;
        } else {
          state.bufferedIndex = i;
        }
      }
      state.bufferProcessing = false;
    }
    Writable.prototype._write = function(chunk, encoding, cb) {
      if (this._writev) {
        this._writev(
          [
            {
              chunk,
              encoding
            }
          ],
          cb
        );
      } else {
        throw new ERR_METHOD_NOT_IMPLEMENTED("_write()");
      }
    };
    Writable.prototype._writev = null;
    Writable.prototype.end = function(chunk, encoding, cb) {
      const state = this._writableState;
      if (typeof chunk === "function") {
        cb = chunk;
        chunk = null;
        encoding = null;
      } else if (typeof encoding === "function") {
        cb = encoding;
        encoding = null;
      }
      let err;
      if (chunk !== null && chunk !== void 0) {
        const ret = _write(this, chunk, encoding);
        if (ret instanceof Error2) {
          err = ret;
        }
      }
      if (state.corked) {
        state.corked = 1;
        this.uncork();
      }
      if (err) {
      } else if (!state.errored && !state.ending) {
        state.ending = true;
        finishMaybe(this, state, true);
        state.ended = true;
      } else if (state.finished) {
        err = new ERR_STREAM_ALREADY_FINISHED("end");
      } else if (state.destroyed) {
        err = new ERR_STREAM_DESTROYED("end");
      }
      if (typeof cb === "function") {
        if (err || state.finished) {
          process.nextTick(cb, err);
        } else {
          state[kOnFinished].push(cb);
        }
      }
      return this;
    };
    function needFinish(state) {
      return state.ending && !state.destroyed && state.constructed && state.length === 0 && !state.errored && state.buffered.length === 0 && !state.finished && !state.writing && !state.errorEmitted && !state.closeEmitted;
    }
    function callFinal(stream, state) {
      let called = false;
      function onFinish(err) {
        if (called) {
          errorOrDestroy(stream, err !== null && err !== void 0 ? err : ERR_MULTIPLE_CALLBACK());
          return;
        }
        called = true;
        state.pendingcb--;
        if (err) {
          const onfinishCallbacks = state[kOnFinished].splice(0);
          for (let i = 0; i < onfinishCallbacks.length; i++) {
            onfinishCallbacks[i](err);
          }
          errorOrDestroy(stream, err, state.sync);
        } else if (needFinish(state)) {
          state.prefinished = true;
          stream.emit("prefinish");
          state.pendingcb++;
          process.nextTick(finish, stream, state);
        }
      }
      state.sync = true;
      state.pendingcb++;
      try {
        stream._final(onFinish);
      } catch (err) {
        onFinish(err);
      }
      state.sync = false;
    }
    function prefinish(stream, state) {
      if (!state.prefinished && !state.finalCalled) {
        if (typeof stream._final === "function" && !state.destroyed) {
          state.finalCalled = true;
          callFinal(stream, state);
        } else {
          state.prefinished = true;
          stream.emit("prefinish");
        }
      }
    }
    function finishMaybe(stream, state, sync) {
      if (needFinish(state)) {
        prefinish(stream, state);
        if (state.pendingcb === 0) {
          if (sync) {
            state.pendingcb++;
            process.nextTick(
              (stream2, state2) => {
                if (needFinish(state2)) {
                  finish(stream2, state2);
                } else {
                  state2.pendingcb--;
                }
              },
              stream,
              state
            );
          } else if (needFinish(state)) {
            state.pendingcb++;
            finish(stream, state);
          }
        }
      }
    }
    function finish(stream, state) {
      state.pendingcb--;
      state.finished = true;
      const onfinishCallbacks = state[kOnFinished].splice(0);
      for (let i = 0; i < onfinishCallbacks.length; i++) {
        onfinishCallbacks[i]();
      }
      stream.emit("finish");
      if (state.autoDestroy) {
        const rState = stream._readableState;
        const autoDestroy = !rState || rState.autoDestroy && // We don't expect the readable to ever 'end'
        // if readable is explicitly set to false.
        (rState.endEmitted || rState.readable === false);
        if (autoDestroy) {
          stream.destroy();
        }
      }
    }
    ObjectDefineProperties(Writable.prototype, {
      closed: {
        __proto__: null,
        get() {
          return this._writableState ? this._writableState.closed : false;
        }
      },
      destroyed: {
        __proto__: null,
        get() {
          return this._writableState ? this._writableState.destroyed : false;
        },
        set(value) {
          if (this._writableState) {
            this._writableState.destroyed = value;
          }
        }
      },
      writable: {
        __proto__: null,
        get() {
          const w = this._writableState;
          return !!w && w.writable !== false && !w.destroyed && !w.errored && !w.ending && !w.ended;
        },
        set(val) {
          if (this._writableState) {
            this._writableState.writable = !!val;
          }
        }
      },
      writableFinished: {
        __proto__: null,
        get() {
          return this._writableState ? this._writableState.finished : false;
        }
      },
      writableObjectMode: {
        __proto__: null,
        get() {
          return this._writableState ? this._writableState.objectMode : false;
        }
      },
      writableBuffer: {
        __proto__: null,
        get() {
          return this._writableState && this._writableState.getBuffer();
        }
      },
      writableEnded: {
        __proto__: null,
        get() {
          return this._writableState ? this._writableState.ending : false;
        }
      },
      writableNeedDrain: {
        __proto__: null,
        get() {
          const wState = this._writableState;
          if (!wState) return false;
          return !wState.destroyed && !wState.ending && wState.needDrain;
        }
      },
      writableHighWaterMark: {
        __proto__: null,
        get() {
          return this._writableState && this._writableState.highWaterMark;
        }
      },
      writableCorked: {
        __proto__: null,
        get() {
          return this._writableState ? this._writableState.corked : 0;
        }
      },
      writableLength: {
        __proto__: null,
        get() {
          return this._writableState && this._writableState.length;
        }
      },
      errored: {
        __proto__: null,
        enumerable: false,
        get() {
          return this._writableState ? this._writableState.errored : null;
        }
      },
      writableAborted: {
        __proto__: null,
        enumerable: false,
        get: function() {
          return !!(this._writableState.writable !== false && (this._writableState.destroyed || this._writableState.errored) && !this._writableState.finished);
        }
      }
    });
    var destroy = destroyImpl.destroy;
    Writable.prototype.destroy = function(err, cb) {
      const state = this._writableState;
      if (!state.destroyed && (state.bufferedIndex < state.buffered.length || state[kOnFinished].length)) {
        process.nextTick(errorBuffer, state);
      }
      destroy.call(this, err, cb);
      return this;
    };
    Writable.prototype._undestroy = destroyImpl.undestroy;
    Writable.prototype._destroy = function(err, cb) {
      cb(err);
    };
    Writable.prototype[EE.captureRejectionSymbol] = function(err) {
      this.destroy(err);
    };
    var webStreamsAdapters;
    function lazyWebStreams() {
      if (webStreamsAdapters === void 0) webStreamsAdapters = {};
      return webStreamsAdapters;
    }
    Writable.fromWeb = function(writableStream, options) {
      return lazyWebStreams().newStreamWritableFromWritableStream(writableStream, options);
    };
    Writable.toWeb = function(streamWritable) {
      return lazyWebStreams().newWritableStreamFromStreamWritable(streamWritable);
    };
  }
});

// node_modules/n3/node_modules/readable-stream/lib/internal/streams/duplexify.js
var require_duplexify2 = __commonJS({
  "node_modules/n3/node_modules/readable-stream/lib/internal/streams/duplexify.js"(exports, module) {
    var process = require_browser2();
    var bufferModule = require_buffer();
    var {
      isReadable,
      isWritable,
      isIterable,
      isNodeStream,
      isReadableNodeStream,
      isWritableNodeStream,
      isDuplexNodeStream,
      isReadableStream,
      isWritableStream
    } = require_utils2();
    var eos = require_end_of_stream2();
    var {
      AbortError,
      codes: { ERR_INVALID_ARG_TYPE, ERR_INVALID_RETURN_VALUE }
    } = require_errors2();
    var { destroyer } = require_destroy2();
    var Duplex = require_duplex2();
    var Readable2 = require_readable2();
    var Writable = require_writable2();
    var { createDeferredPromise } = require_util2();
    var from = require_from2();
    var Blob2 = globalThis.Blob || bufferModule.Blob;
    var isBlob = typeof Blob2 !== "undefined" ? function isBlob2(b) {
      return b instanceof Blob2;
    } : function isBlob2(b) {
      return false;
    };
    var AbortController2 = globalThis.AbortController || require_browser().AbortController;
    var { FunctionPrototypeCall } = require_primordials2();
    var Duplexify = class extends Duplex {
      constructor(options) {
        super(options);
        if ((options === null || options === void 0 ? void 0 : options.readable) === false) {
          this._readableState.readable = false;
          this._readableState.ended = true;
          this._readableState.endEmitted = true;
        }
        if ((options === null || options === void 0 ? void 0 : options.writable) === false) {
          this._writableState.writable = false;
          this._writableState.ending = true;
          this._writableState.ended = true;
          this._writableState.finished = true;
        }
      }
    };
    module.exports = function duplexify(body, name) {
      if (isDuplexNodeStream(body)) {
        return body;
      }
      if (isReadableNodeStream(body)) {
        return _duplexify({
          readable: body
        });
      }
      if (isWritableNodeStream(body)) {
        return _duplexify({
          writable: body
        });
      }
      if (isNodeStream(body)) {
        return _duplexify({
          writable: false,
          readable: false
        });
      }
      if (isReadableStream(body)) {
        return _duplexify({
          readable: Readable2.fromWeb(body)
        });
      }
      if (isWritableStream(body)) {
        return _duplexify({
          writable: Writable.fromWeb(body)
        });
      }
      if (typeof body === "function") {
        const { value, write, final, destroy } = fromAsyncGen(body);
        if (isIterable(value)) {
          return from(Duplexify, value, {
            // TODO (ronag): highWaterMark?
            objectMode: true,
            write,
            final,
            destroy
          });
        }
        const then2 = value === null || value === void 0 ? void 0 : value.then;
        if (typeof then2 === "function") {
          let d;
          const promise2 = FunctionPrototypeCall(
            then2,
            value,
            (val) => {
              if (val != null) {
                throw new ERR_INVALID_RETURN_VALUE("nully", "body", val);
              }
            },
            (err) => {
              destroyer(d, err);
            }
          );
          return d = new Duplexify({
            // TODO (ronag): highWaterMark?
            objectMode: true,
            readable: false,
            write,
            final(cb) {
              final(async () => {
                try {
                  await promise2;
                  process.nextTick(cb, null);
                } catch (err) {
                  process.nextTick(cb, err);
                }
              });
            },
            destroy
          });
        }
        throw new ERR_INVALID_RETURN_VALUE("Iterable, AsyncIterable or AsyncFunction", name, value);
      }
      if (isBlob(body)) {
        return duplexify(body.arrayBuffer());
      }
      if (isIterable(body)) {
        return from(Duplexify, body, {
          // TODO (ronag): highWaterMark?
          objectMode: true,
          writable: false
        });
      }
      if (isReadableStream(body === null || body === void 0 ? void 0 : body.readable) && isWritableStream(body === null || body === void 0 ? void 0 : body.writable)) {
        return Duplexify.fromWeb(body);
      }
      if (typeof (body === null || body === void 0 ? void 0 : body.writable) === "object" || typeof (body === null || body === void 0 ? void 0 : body.readable) === "object") {
        const readable = body !== null && body !== void 0 && body.readable ? isReadableNodeStream(body === null || body === void 0 ? void 0 : body.readable) ? body === null || body === void 0 ? void 0 : body.readable : duplexify(body.readable) : void 0;
        const writable = body !== null && body !== void 0 && body.writable ? isWritableNodeStream(body === null || body === void 0 ? void 0 : body.writable) ? body === null || body === void 0 ? void 0 : body.writable : duplexify(body.writable) : void 0;
        return _duplexify({
          readable,
          writable
        });
      }
      const then = body === null || body === void 0 ? void 0 : body.then;
      if (typeof then === "function") {
        let d;
        FunctionPrototypeCall(
          then,
          body,
          (val) => {
            if (val != null) {
              d.push(val);
            }
            d.push(null);
          },
          (err) => {
            destroyer(d, err);
          }
        );
        return d = new Duplexify({
          objectMode: true,
          writable: false,
          read() {
          }
        });
      }
      throw new ERR_INVALID_ARG_TYPE(
        name,
        [
          "Blob",
          "ReadableStream",
          "WritableStream",
          "Stream",
          "Iterable",
          "AsyncIterable",
          "Function",
          "{ readable, writable } pair",
          "Promise"
        ],
        body
      );
    };
    function fromAsyncGen(fn) {
      let { promise: promise2, resolve } = createDeferredPromise();
      const ac = new AbortController2();
      const signal = ac.signal;
      const value = fn(
        (async function* () {
          while (true) {
            const _promise2 = promise2;
            promise2 = null;
            const { chunk, done, cb } = await _promise2;
            process.nextTick(cb);
            if (done) return;
            if (signal.aborted)
              throw new AbortError(void 0, {
                cause: signal.reason
              });
            ({ promise: promise2, resolve } = createDeferredPromise());
            yield chunk;
          }
        })(),
        {
          signal
        }
      );
      return {
        value,
        write(chunk, encoding, cb) {
          const _resolve = resolve;
          resolve = null;
          _resolve({
            chunk,
            done: false,
            cb
          });
        },
        final(cb) {
          const _resolve = resolve;
          resolve = null;
          _resolve({
            done: true,
            cb
          });
        },
        destroy(err, cb) {
          ac.abort();
          cb(err);
        }
      };
    }
    function _duplexify(pair) {
      const r = pair.readable && typeof pair.readable.read !== "function" ? Readable2.wrap(pair.readable) : pair.readable;
      const w = pair.writable;
      let readable = !!isReadable(r);
      let writable = !!isWritable(w);
      let ondrain;
      let onfinish;
      let onreadable;
      let onclose;
      let d;
      function onfinished(err) {
        const cb = onclose;
        onclose = null;
        if (cb) {
          cb(err);
        } else if (err) {
          d.destroy(err);
        }
      }
      d = new Duplexify({
        // TODO (ronag): highWaterMark?
        readableObjectMode: !!(r !== null && r !== void 0 && r.readableObjectMode),
        writableObjectMode: !!(w !== null && w !== void 0 && w.writableObjectMode),
        readable,
        writable
      });
      if (writable) {
        eos(w, (err) => {
          writable = false;
          if (err) {
            destroyer(r, err);
          }
          onfinished(err);
        });
        d._write = function(chunk, encoding, callback) {
          if (w.write(chunk, encoding)) {
            callback();
          } else {
            ondrain = callback;
          }
        };
        d._final = function(callback) {
          w.end();
          onfinish = callback;
        };
        w.on("drain", function() {
          if (ondrain) {
            const cb = ondrain;
            ondrain = null;
            cb();
          }
        });
        w.on("finish", function() {
          if (onfinish) {
            const cb = onfinish;
            onfinish = null;
            cb();
          }
        });
      }
      if (readable) {
        eos(r, (err) => {
          readable = false;
          if (err) {
            destroyer(r, err);
          }
          onfinished(err);
        });
        r.on("readable", function() {
          if (onreadable) {
            const cb = onreadable;
            onreadable = null;
            cb();
          }
        });
        r.on("end", function() {
          d.push(null);
        });
        d._read = function() {
          while (true) {
            const buf = r.read();
            if (buf === null) {
              onreadable = d._read;
              return;
            }
            if (!d.push(buf)) {
              return;
            }
          }
        };
      }
      d._destroy = function(err, callback) {
        if (!err && onclose !== null) {
          err = new AbortError();
        }
        onreadable = null;
        ondrain = null;
        onfinish = null;
        if (onclose === null) {
          callback(err);
        } else {
          onclose = callback;
          destroyer(w, err);
          destroyer(r, err);
        }
      };
      return d;
    }
  }
});

// node_modules/n3/node_modules/readable-stream/lib/internal/streams/duplex.js
var require_duplex2 = __commonJS({
  "node_modules/n3/node_modules/readable-stream/lib/internal/streams/duplex.js"(exports, module) {
    "use strict";
    var {
      ObjectDefineProperties,
      ObjectGetOwnPropertyDescriptor,
      ObjectKeys,
      ObjectSetPrototypeOf
    } = require_primordials2();
    module.exports = Duplex;
    var Readable2 = require_readable2();
    var Writable = require_writable2();
    ObjectSetPrototypeOf(Duplex.prototype, Readable2.prototype);
    ObjectSetPrototypeOf(Duplex, Readable2);
    {
      const keys = ObjectKeys(Writable.prototype);
      for (let i = 0; i < keys.length; i++) {
        const method = keys[i];
        if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];
      }
    }
    function Duplex(options) {
      if (!(this instanceof Duplex)) return new Duplex(options);
      Readable2.call(this, options);
      Writable.call(this, options);
      if (options) {
        this.allowHalfOpen = options.allowHalfOpen !== false;
        if (options.readable === false) {
          this._readableState.readable = false;
          this._readableState.ended = true;
          this._readableState.endEmitted = true;
        }
        if (options.writable === false) {
          this._writableState.writable = false;
          this._writableState.ending = true;
          this._writableState.ended = true;
          this._writableState.finished = true;
        }
      } else {
        this.allowHalfOpen = true;
      }
    }
    ObjectDefineProperties(Duplex.prototype, {
      writable: {
        __proto__: null,
        ...ObjectGetOwnPropertyDescriptor(Writable.prototype, "writable")
      },
      writableHighWaterMark: {
        __proto__: null,
        ...ObjectGetOwnPropertyDescriptor(Writable.prototype, "writableHighWaterMark")
      },
      writableObjectMode: {
        __proto__: null,
        ...ObjectGetOwnPropertyDescriptor(Writable.prototype, "writableObjectMode")
      },
      writableBuffer: {
        __proto__: null,
        ...ObjectGetOwnPropertyDescriptor(Writable.prototype, "writableBuffer")
      },
      writableLength: {
        __proto__: null,
        ...ObjectGetOwnPropertyDescriptor(Writable.prototype, "writableLength")
      },
      writableFinished: {
        __proto__: null,
        ...ObjectGetOwnPropertyDescriptor(Writable.prototype, "writableFinished")
      },
      writableCorked: {
        __proto__: null,
        ...ObjectGetOwnPropertyDescriptor(Writable.prototype, "writableCorked")
      },
      writableEnded: {
        __proto__: null,
        ...ObjectGetOwnPropertyDescriptor(Writable.prototype, "writableEnded")
      },
      writableNeedDrain: {
        __proto__: null,
        ...ObjectGetOwnPropertyDescriptor(Writable.prototype, "writableNeedDrain")
      },
      destroyed: {
        __proto__: null,
        get() {
          if (this._readableState === void 0 || this._writableState === void 0) {
            return false;
          }
          return this._readableState.destroyed && this._writableState.destroyed;
        },
        set(value) {
          if (this._readableState && this._writableState) {
            this._readableState.destroyed = value;
            this._writableState.destroyed = value;
          }
        }
      }
    });
    var webStreamsAdapters;
    function lazyWebStreams() {
      if (webStreamsAdapters === void 0) webStreamsAdapters = {};
      return webStreamsAdapters;
    }
    Duplex.fromWeb = function(pair, options) {
      return lazyWebStreams().newStreamDuplexFromReadableWritablePair(pair, options);
    };
    Duplex.toWeb = function(duplex) {
      return lazyWebStreams().newReadableWritablePairFromDuplex(duplex);
    };
    var duplexify;
    Duplex.from = function(body) {
      if (!duplexify) {
        duplexify = require_duplexify2();
      }
      return duplexify(body, "body");
    };
  }
});

// node_modules/n3/node_modules/readable-stream/lib/internal/streams/transform.js
var require_transform2 = __commonJS({
  "node_modules/n3/node_modules/readable-stream/lib/internal/streams/transform.js"(exports, module) {
    "use strict";
    var { ObjectSetPrototypeOf, Symbol: Symbol2 } = require_primordials2();
    module.exports = Transform;
    var { ERR_METHOD_NOT_IMPLEMENTED } = require_errors2().codes;
    var Duplex = require_duplex2();
    var { getHighWaterMark } = require_state2();
    ObjectSetPrototypeOf(Transform.prototype, Duplex.prototype);
    ObjectSetPrototypeOf(Transform, Duplex);
    var kCallback = Symbol2("kCallback");
    function Transform(options) {
      if (!(this instanceof Transform)) return new Transform(options);
      const readableHighWaterMark = options ? getHighWaterMark(this, options, "readableHighWaterMark", true) : null;
      if (readableHighWaterMark === 0) {
        options = {
          ...options,
          highWaterMark: null,
          readableHighWaterMark,
          // TODO (ronag): 0 is not optimal since we have
          // a "bug" where we check needDrain before calling _write and not after.
          // Refs: https://github.com/nodejs/node/pull/32887
          // Refs: https://github.com/nodejs/node/pull/35941
          writableHighWaterMark: options.writableHighWaterMark || 0
        };
      }
      Duplex.call(this, options);
      this._readableState.sync = false;
      this[kCallback] = null;
      if (options) {
        if (typeof options.transform === "function") this._transform = options.transform;
        if (typeof options.flush === "function") this._flush = options.flush;
      }
      this.on("prefinish", prefinish);
    }
    function final(cb) {
      if (typeof this._flush === "function" && !this.destroyed) {
        this._flush((er, data) => {
          if (er) {
            if (cb) {
              cb(er);
            } else {
              this.destroy(er);
            }
            return;
          }
          if (data != null) {
            this.push(data);
          }
          this.push(null);
          if (cb) {
            cb();
          }
        });
      } else {
        this.push(null);
        if (cb) {
          cb();
        }
      }
    }
    function prefinish() {
      if (this._final !== final) {
        final.call(this);
      }
    }
    Transform.prototype._final = final;
    Transform.prototype._transform = function(chunk, encoding, callback) {
      throw new ERR_METHOD_NOT_IMPLEMENTED("_transform()");
    };
    Transform.prototype._write = function(chunk, encoding, callback) {
      const rState = this._readableState;
      const wState = this._writableState;
      const length = rState.length;
      this._transform(chunk, encoding, (err, val) => {
        if (err) {
          callback(err);
          return;
        }
        if (val != null) {
          this.push(val);
        }
        if (wState.ended || // Backwards compat.
        length === rState.length || // Backwards compat.
        rState.length < rState.highWaterMark) {
          callback();
        } else {
          this[kCallback] = callback;
        }
      });
    };
    Transform.prototype._read = function() {
      if (this[kCallback]) {
        const callback = this[kCallback];
        this[kCallback] = null;
        callback();
      }
    };
  }
});

// node_modules/n3/node_modules/readable-stream/lib/internal/streams/passthrough.js
var require_passthrough2 = __commonJS({
  "node_modules/n3/node_modules/readable-stream/lib/internal/streams/passthrough.js"(exports, module) {
    "use strict";
    var { ObjectSetPrototypeOf } = require_primordials2();
    module.exports = PassThrough;
    var Transform = require_transform2();
    ObjectSetPrototypeOf(PassThrough.prototype, Transform.prototype);
    ObjectSetPrototypeOf(PassThrough, Transform);
    function PassThrough(options) {
      if (!(this instanceof PassThrough)) return new PassThrough(options);
      Transform.call(this, options);
    }
    PassThrough.prototype._transform = function(chunk, encoding, cb) {
      cb(null, chunk);
    };
  }
});

// node_modules/n3/node_modules/readable-stream/lib/internal/streams/pipeline.js
var require_pipeline2 = __commonJS({
  "node_modules/n3/node_modules/readable-stream/lib/internal/streams/pipeline.js"(exports, module) {
    var process = require_browser2();
    var { ArrayIsArray, Promise: Promise2, SymbolAsyncIterator, SymbolDispose } = require_primordials2();
    var eos = require_end_of_stream2();
    var { once } = require_util2();
    var destroyImpl = require_destroy2();
    var Duplex = require_duplex2();
    var {
      aggregateTwoErrors,
      codes: {
        ERR_INVALID_ARG_TYPE,
        ERR_INVALID_RETURN_VALUE,
        ERR_MISSING_ARGS,
        ERR_STREAM_DESTROYED,
        ERR_STREAM_PREMATURE_CLOSE
      },
      AbortError
    } = require_errors2();
    var { validateFunction, validateAbortSignal } = require_validators2();
    var {
      isIterable,
      isReadable,
      isReadableNodeStream,
      isNodeStream,
      isTransformStream,
      isWebStream,
      isReadableStream,
      isReadableFinished
    } = require_utils2();
    var AbortController2 = globalThis.AbortController || require_browser().AbortController;
    var PassThrough;
    var Readable2;
    var addAbortListener;
    function destroyer(stream, reading, writing) {
      let finished = false;
      stream.on("close", () => {
        finished = true;
      });
      const cleanup = eos(
        stream,
        {
          readable: reading,
          writable: writing
        },
        (err) => {
          finished = !err;
        }
      );
      return {
        destroy: (err) => {
          if (finished) return;
          finished = true;
          destroyImpl.destroyer(stream, err || new ERR_STREAM_DESTROYED("pipe"));
        },
        cleanup
      };
    }
    function popCallback(streams) {
      validateFunction(streams[streams.length - 1], "streams[stream.length - 1]");
      return streams.pop();
    }
    function makeAsyncIterable(val) {
      if (isIterable(val)) {
        return val;
      } else if (isReadableNodeStream(val)) {
        return fromReadable(val);
      }
      throw new ERR_INVALID_ARG_TYPE("val", ["Readable", "Iterable", "AsyncIterable"], val);
    }
    async function* fromReadable(val) {
      if (!Readable2) {
        Readable2 = require_readable2();
      }
      yield* Readable2.prototype[SymbolAsyncIterator].call(val);
    }
    async function pumpToNode(iterable, writable, finish, { end }) {
      let error46;
      let onresolve = null;
      const resume = (err) => {
        if (err) {
          error46 = err;
        }
        if (onresolve) {
          const callback = onresolve;
          onresolve = null;
          callback();
        }
      };
      const wait = () => new Promise2((resolve, reject2) => {
        if (error46) {
          reject2(error46);
        } else {
          onresolve = () => {
            if (error46) {
              reject2(error46);
            } else {
              resolve();
            }
          };
        }
      });
      writable.on("drain", resume);
      const cleanup = eos(
        writable,
        {
          readable: false
        },
        resume
      );
      try {
        if (writable.writableNeedDrain) {
          await wait();
        }
        for await (const chunk of iterable) {
          if (!writable.write(chunk)) {
            await wait();
          }
        }
        if (end) {
          writable.end();
          await wait();
        }
        finish();
      } catch (err) {
        finish(error46 !== err ? aggregateTwoErrors(error46, err) : err);
      } finally {
        cleanup();
        writable.off("drain", resume);
      }
    }
    async function pumpToWeb(readable, writable, finish, { end }) {
      if (isTransformStream(writable)) {
        writable = writable.writable;
      }
      const writer = writable.getWriter();
      try {
        for await (const chunk of readable) {
          await writer.ready;
          writer.write(chunk).catch(() => {
          });
        }
        await writer.ready;
        if (end) {
          await writer.close();
        }
        finish();
      } catch (err) {
        try {
          await writer.abort(err);
          finish(err);
        } catch (err2) {
          finish(err2);
        }
      }
    }
    function pipeline(...streams) {
      return pipelineImpl(streams, once(popCallback(streams)));
    }
    function pipelineImpl(streams, callback, opts) {
      if (streams.length === 1 && ArrayIsArray(streams[0])) {
        streams = streams[0];
      }
      if (streams.length < 2) {
        throw new ERR_MISSING_ARGS("streams");
      }
      const ac = new AbortController2();
      const signal = ac.signal;
      const outerSignal = opts === null || opts === void 0 ? void 0 : opts.signal;
      const lastStreamCleanup = [];
      validateAbortSignal(outerSignal, "options.signal");
      function abort() {
        finishImpl(new AbortError());
      }
      addAbortListener = addAbortListener || require_util2().addAbortListener;
      let disposable;
      if (outerSignal) {
        disposable = addAbortListener(outerSignal, abort);
      }
      let error46;
      let value;
      const destroys = [];
      let finishCount = 0;
      function finish(err) {
        finishImpl(err, --finishCount === 0);
      }
      function finishImpl(err, final) {
        var _disposable;
        if (err && (!error46 || error46.code === "ERR_STREAM_PREMATURE_CLOSE")) {
          error46 = err;
        }
        if (!error46 && !final) {
          return;
        }
        while (destroys.length) {
          destroys.shift()(error46);
        }
        ;
        (_disposable = disposable) === null || _disposable === void 0 ? void 0 : _disposable[SymbolDispose]();
        ac.abort();
        if (final) {
          if (!error46) {
            lastStreamCleanup.forEach((fn) => fn());
          }
          process.nextTick(callback, error46, value);
        }
      }
      let ret;
      for (let i = 0; i < streams.length; i++) {
        const stream = streams[i];
        const reading = i < streams.length - 1;
        const writing = i > 0;
        const end = reading || (opts === null || opts === void 0 ? void 0 : opts.end) !== false;
        const isLastStream = i === streams.length - 1;
        if (isNodeStream(stream)) {
          let onError2 = function(err) {
            if (err && err.name !== "AbortError" && err.code !== "ERR_STREAM_PREMATURE_CLOSE") {
              finish(err);
            }
          };
          var onError = onError2;
          if (end) {
            const { destroy, cleanup } = destroyer(stream, reading, writing);
            destroys.push(destroy);
            if (isReadable(stream) && isLastStream) {
              lastStreamCleanup.push(cleanup);
            }
          }
          stream.on("error", onError2);
          if (isReadable(stream) && isLastStream) {
            lastStreamCleanup.push(() => {
              stream.removeListener("error", onError2);
            });
          }
        }
        if (i === 0) {
          if (typeof stream === "function") {
            ret = stream({
              signal
            });
            if (!isIterable(ret)) {
              throw new ERR_INVALID_RETURN_VALUE("Iterable, AsyncIterable or Stream", "source", ret);
            }
          } else if (isIterable(stream) || isReadableNodeStream(stream) || isTransformStream(stream)) {
            ret = stream;
          } else {
            ret = Duplex.from(stream);
          }
        } else if (typeof stream === "function") {
          if (isTransformStream(ret)) {
            var _ret;
            ret = makeAsyncIterable((_ret = ret) === null || _ret === void 0 ? void 0 : _ret.readable);
          } else {
            ret = makeAsyncIterable(ret);
          }
          ret = stream(ret, {
            signal
          });
          if (reading) {
            if (!isIterable(ret, true)) {
              throw new ERR_INVALID_RETURN_VALUE("AsyncIterable", `transform[${i - 1}]`, ret);
            }
          } else {
            var _ret2;
            if (!PassThrough) {
              PassThrough = require_passthrough2();
            }
            const pt = new PassThrough({
              objectMode: true
            });
            const then = (_ret2 = ret) === null || _ret2 === void 0 ? void 0 : _ret2.then;
            if (typeof then === "function") {
              finishCount++;
              then.call(
                ret,
                (val) => {
                  value = val;
                  if (val != null) {
                    pt.write(val);
                  }
                  if (end) {
                    pt.end();
                  }
                  process.nextTick(finish);
                },
                (err) => {
                  pt.destroy(err);
                  process.nextTick(finish, err);
                }
              );
            } else if (isIterable(ret, true)) {
              finishCount++;
              pumpToNode(ret, pt, finish, {
                end
              });
            } else if (isReadableStream(ret) || isTransformStream(ret)) {
              const toRead = ret.readable || ret;
              finishCount++;
              pumpToNode(toRead, pt, finish, {
                end
              });
            } else {
              throw new ERR_INVALID_RETURN_VALUE("AsyncIterable or Promise", "destination", ret);
            }
            ret = pt;
            const { destroy, cleanup } = destroyer(ret, false, true);
            destroys.push(destroy);
            if (isLastStream) {
              lastStreamCleanup.push(cleanup);
            }
          }
        } else if (isNodeStream(stream)) {
          if (isReadableNodeStream(ret)) {
            finishCount += 2;
            const cleanup = pipe2(ret, stream, finish, {
              end
            });
            if (isReadable(stream) && isLastStream) {
              lastStreamCleanup.push(cleanup);
            }
          } else if (isTransformStream(ret) || isReadableStream(ret)) {
            const toRead = ret.readable || ret;
            finishCount++;
            pumpToNode(toRead, stream, finish, {
              end
            });
          } else if (isIterable(ret)) {
            finishCount++;
            pumpToNode(ret, stream, finish, {
              end
            });
          } else {
            throw new ERR_INVALID_ARG_TYPE(
              "val",
              ["Readable", "Iterable", "AsyncIterable", "ReadableStream", "TransformStream"],
              ret
            );
          }
          ret = stream;
        } else if (isWebStream(stream)) {
          if (isReadableNodeStream(ret)) {
            finishCount++;
            pumpToWeb(makeAsyncIterable(ret), stream, finish, {
              end
            });
          } else if (isReadableStream(ret) || isIterable(ret)) {
            finishCount++;
            pumpToWeb(ret, stream, finish, {
              end
            });
          } else if (isTransformStream(ret)) {
            finishCount++;
            pumpToWeb(ret.readable, stream, finish, {
              end
            });
          } else {
            throw new ERR_INVALID_ARG_TYPE(
              "val",
              ["Readable", "Iterable", "AsyncIterable", "ReadableStream", "TransformStream"],
              ret
            );
          }
          ret = stream;
        } else {
          ret = Duplex.from(stream);
        }
      }
      if (signal !== null && signal !== void 0 && signal.aborted || outerSignal !== null && outerSignal !== void 0 && outerSignal.aborted) {
        process.nextTick(abort);
      }
      return ret;
    }
    function pipe2(src, dst, finish, { end }) {
      let ended = false;
      dst.on("close", () => {
        if (!ended) {
          finish(new ERR_STREAM_PREMATURE_CLOSE());
        }
      });
      src.pipe(dst, {
        end: false
      });
      if (end) {
        let endFn2 = function() {
          ended = true;
          dst.end();
        };
        var endFn = endFn2;
        if (isReadableFinished(src)) {
          process.nextTick(endFn2);
        } else {
          src.once("end", endFn2);
        }
      } else {
        finish();
      }
      eos(
        src,
        {
          readable: true,
          writable: false
        },
        (err) => {
          const rState = src._readableState;
          if (err && err.code === "ERR_STREAM_PREMATURE_CLOSE" && rState && rState.ended && !rState.errored && !rState.errorEmitted) {
            src.once("end", finish).once("error", finish);
          } else {
            finish(err);
          }
        }
      );
      return eos(
        dst,
        {
          readable: false,
          writable: true
        },
        finish
      );
    }
    module.exports = {
      pipelineImpl,
      pipeline
    };
  }
});

// node_modules/n3/node_modules/readable-stream/lib/internal/streams/compose.js
var require_compose2 = __commonJS({
  "node_modules/n3/node_modules/readable-stream/lib/internal/streams/compose.js"(exports, module) {
    "use strict";
    var { pipeline } = require_pipeline2();
    var Duplex = require_duplex2();
    var { destroyer } = require_destroy2();
    var {
      isNodeStream,
      isReadable,
      isWritable,
      isWebStream,
      isTransformStream,
      isWritableStream,
      isReadableStream
    } = require_utils2();
    var {
      AbortError,
      codes: { ERR_INVALID_ARG_VALUE, ERR_MISSING_ARGS }
    } = require_errors2();
    var eos = require_end_of_stream2();
    module.exports = function compose(...streams) {
      if (streams.length === 0) {
        throw new ERR_MISSING_ARGS("streams");
      }
      if (streams.length === 1) {
        return Duplex.from(streams[0]);
      }
      const orgStreams = [...streams];
      if (typeof streams[0] === "function") {
        streams[0] = Duplex.from(streams[0]);
      }
      if (typeof streams[streams.length - 1] === "function") {
        const idx = streams.length - 1;
        streams[idx] = Duplex.from(streams[idx]);
      }
      for (let n = 0; n < streams.length; ++n) {
        if (!isNodeStream(streams[n]) && !isWebStream(streams[n])) {
          continue;
        }
        if (n < streams.length - 1 && !(isReadable(streams[n]) || isReadableStream(streams[n]) || isTransformStream(streams[n]))) {
          throw new ERR_INVALID_ARG_VALUE(`streams[${n}]`, orgStreams[n], "must be readable");
        }
        if (n > 0 && !(isWritable(streams[n]) || isWritableStream(streams[n]) || isTransformStream(streams[n]))) {
          throw new ERR_INVALID_ARG_VALUE(`streams[${n}]`, orgStreams[n], "must be writable");
        }
      }
      let ondrain;
      let onfinish;
      let onreadable;
      let onclose;
      let d;
      function onfinished(err) {
        const cb = onclose;
        onclose = null;
        if (cb) {
          cb(err);
        } else if (err) {
          d.destroy(err);
        } else if (!readable && !writable) {
          d.destroy();
        }
      }
      const head = streams[0];
      const tail = pipeline(streams, onfinished);
      const writable = !!(isWritable(head) || isWritableStream(head) || isTransformStream(head));
      const readable = !!(isReadable(tail) || isReadableStream(tail) || isTransformStream(tail));
      d = new Duplex({
        // TODO (ronag): highWaterMark?
        writableObjectMode: !!(head !== null && head !== void 0 && head.writableObjectMode),
        readableObjectMode: !!(tail !== null && tail !== void 0 && tail.readableObjectMode),
        writable,
        readable
      });
      if (writable) {
        if (isNodeStream(head)) {
          d._write = function(chunk, encoding, callback) {
            if (head.write(chunk, encoding)) {
              callback();
            } else {
              ondrain = callback;
            }
          };
          d._final = function(callback) {
            head.end();
            onfinish = callback;
          };
          head.on("drain", function() {
            if (ondrain) {
              const cb = ondrain;
              ondrain = null;
              cb();
            }
          });
        } else if (isWebStream(head)) {
          const writable2 = isTransformStream(head) ? head.writable : head;
          const writer = writable2.getWriter();
          d._write = async function(chunk, encoding, callback) {
            try {
              await writer.ready;
              writer.write(chunk).catch(() => {
              });
              callback();
            } catch (err) {
              callback(err);
            }
          };
          d._final = async function(callback) {
            try {
              await writer.ready;
              writer.close().catch(() => {
              });
              onfinish = callback;
            } catch (err) {
              callback(err);
            }
          };
        }
        const toRead = isTransformStream(tail) ? tail.readable : tail;
        eos(toRead, () => {
          if (onfinish) {
            const cb = onfinish;
            onfinish = null;
            cb();
          }
        });
      }
      if (readable) {
        if (isNodeStream(tail)) {
          tail.on("readable", function() {
            if (onreadable) {
              const cb = onreadable;
              onreadable = null;
              cb();
            }
          });
          tail.on("end", function() {
            d.push(null);
          });
          d._read = function() {
            while (true) {
              const buf = tail.read();
              if (buf === null) {
                onreadable = d._read;
                return;
              }
              if (!d.push(buf)) {
                return;
              }
            }
          };
        } else if (isWebStream(tail)) {
          const readable2 = isTransformStream(tail) ? tail.readable : tail;
          const reader = readable2.getReader();
          d._read = async function() {
            while (true) {
              try {
                const { value, done } = await reader.read();
                if (!d.push(value)) {
                  return;
                }
                if (done) {
                  d.push(null);
                  return;
                }
              } catch {
                return;
              }
            }
          };
        }
      }
      d._destroy = function(err, callback) {
        if (!err && onclose !== null) {
          err = new AbortError();
        }
        onreadable = null;
        ondrain = null;
        onfinish = null;
        if (onclose === null) {
          callback(err);
        } else {
          onclose = callback;
          if (isNodeStream(tail)) {
            destroyer(tail, err);
          }
        }
      };
      return d;
    };
  }
});

// node_modules/n3/node_modules/readable-stream/lib/internal/streams/operators.js
var require_operators2 = __commonJS({
  "node_modules/n3/node_modules/readable-stream/lib/internal/streams/operators.js"(exports, module) {
    "use strict";
    var AbortController2 = globalThis.AbortController || require_browser().AbortController;
    var {
      codes: { ERR_INVALID_ARG_VALUE, ERR_INVALID_ARG_TYPE, ERR_MISSING_ARGS, ERR_OUT_OF_RANGE },
      AbortError
    } = require_errors2();
    var { validateAbortSignal, validateInteger, validateObject } = require_validators2();
    var kWeakHandler = require_primordials2().Symbol("kWeak");
    var kResistStopPropagation = require_primordials2().Symbol("kResistStopPropagation");
    var { finished } = require_end_of_stream2();
    var staticCompose = require_compose2();
    var { addAbortSignalNoValidate } = require_add_abort_signal2();
    var { isWritable, isNodeStream } = require_utils2();
    var { deprecate } = require_util2();
    var {
      ArrayPrototypePush,
      Boolean: Boolean2,
      MathFloor,
      Number: Number2,
      NumberIsNaN,
      Promise: Promise2,
      PromiseReject,
      PromiseResolve,
      PromisePrototypeThen,
      Symbol: Symbol2
    } = require_primordials2();
    var kEmpty = Symbol2("kEmpty");
    var kEof = Symbol2("kEof");
    function compose(stream, options) {
      if (options != null) {
        validateObject(options, "options");
      }
      if ((options === null || options === void 0 ? void 0 : options.signal) != null) {
        validateAbortSignal(options.signal, "options.signal");
      }
      if (isNodeStream(stream) && !isWritable(stream)) {
        throw new ERR_INVALID_ARG_VALUE("stream", stream, "must be writable");
      }
      const composedStream = staticCompose(this, stream);
      if (options !== null && options !== void 0 && options.signal) {
        addAbortSignalNoValidate(options.signal, composedStream);
      }
      return composedStream;
    }
    function map3(fn, options) {
      if (typeof fn !== "function") {
        throw new ERR_INVALID_ARG_TYPE("fn", ["Function", "AsyncFunction"], fn);
      }
      if (options != null) {
        validateObject(options, "options");
      }
      if ((options === null || options === void 0 ? void 0 : options.signal) != null) {
        validateAbortSignal(options.signal, "options.signal");
      }
      let concurrency = 1;
      if ((options === null || options === void 0 ? void 0 : options.concurrency) != null) {
        concurrency = MathFloor(options.concurrency);
      }
      let highWaterMark = concurrency - 1;
      if ((options === null || options === void 0 ? void 0 : options.highWaterMark) != null) {
        highWaterMark = MathFloor(options.highWaterMark);
      }
      validateInteger(concurrency, "options.concurrency", 1);
      validateInteger(highWaterMark, "options.highWaterMark", 0);
      highWaterMark += concurrency;
      return async function* map4() {
        const signal = require_util2().AbortSignalAny(
          [options === null || options === void 0 ? void 0 : options.signal].filter(Boolean2)
        );
        const stream = this;
        const queue = [];
        const signalOpt = {
          signal
        };
        let next;
        let resume;
        let done = false;
        let cnt = 0;
        function onCatch() {
          done = true;
          afterItemProcessed();
        }
        function afterItemProcessed() {
          cnt -= 1;
          maybeResume();
        }
        function maybeResume() {
          if (resume && !done && cnt < concurrency && queue.length < highWaterMark) {
            resume();
            resume = null;
          }
        }
        async function pump() {
          try {
            for await (let val of stream) {
              if (done) {
                return;
              }
              if (signal.aborted) {
                throw new AbortError();
              }
              try {
                val = fn(val, signalOpt);
                if (val === kEmpty) {
                  continue;
                }
                val = PromiseResolve(val);
              } catch (err) {
                val = PromiseReject(err);
              }
              cnt += 1;
              PromisePrototypeThen(val, afterItemProcessed, onCatch);
              queue.push(val);
              if (next) {
                next();
                next = null;
              }
              if (!done && (queue.length >= highWaterMark || cnt >= concurrency)) {
                await new Promise2((resolve) => {
                  resume = resolve;
                });
              }
            }
            queue.push(kEof);
          } catch (err) {
            const val = PromiseReject(err);
            PromisePrototypeThen(val, afterItemProcessed, onCatch);
            queue.push(val);
          } finally {
            done = true;
            if (next) {
              next();
              next = null;
            }
          }
        }
        pump();
        try {
          while (true) {
            while (queue.length > 0) {
              const val = await queue[0];
              if (val === kEof) {
                return;
              }
              if (signal.aborted) {
                throw new AbortError();
              }
              if (val !== kEmpty) {
                yield val;
              }
              queue.shift();
              maybeResume();
            }
            await new Promise2((resolve) => {
              next = resolve;
            });
          }
        } finally {
          done = true;
          if (resume) {
            resume();
            resume = null;
          }
        }
      }.call(this);
    }
    function asIndexedPairs(options = void 0) {
      if (options != null) {
        validateObject(options, "options");
      }
      if ((options === null || options === void 0 ? void 0 : options.signal) != null) {
        validateAbortSignal(options.signal, "options.signal");
      }
      return async function* asIndexedPairs2() {
        let index = 0;
        for await (const val of this) {
          var _options$signal;
          if (options !== null && options !== void 0 && (_options$signal = options.signal) !== null && _options$signal !== void 0 && _options$signal.aborted) {
            throw new AbortError({
              cause: options.signal.reason
            });
          }
          yield [index++, val];
        }
      }.call(this);
    }
    async function some(fn, options = void 0) {
      for await (const unused of filter.call(this, fn, options)) {
        return true;
      }
      return false;
    }
    async function every(fn, options = void 0) {
      if (typeof fn !== "function") {
        throw new ERR_INVALID_ARG_TYPE("fn", ["Function", "AsyncFunction"], fn);
      }
      return !await some.call(
        this,
        async (...args) => {
          return !await fn(...args);
        },
        options
      );
    }
    async function find(fn, options) {
      for await (const result of filter.call(this, fn, options)) {
        return result;
      }
      return void 0;
    }
    async function forEach(fn, options) {
      if (typeof fn !== "function") {
        throw new ERR_INVALID_ARG_TYPE("fn", ["Function", "AsyncFunction"], fn);
      }
      async function forEachFn(value, options2) {
        await fn(value, options2);
        return kEmpty;
      }
      for await (const unused of map3.call(this, forEachFn, options)) ;
    }
    function filter(fn, options) {
      if (typeof fn !== "function") {
        throw new ERR_INVALID_ARG_TYPE("fn", ["Function", "AsyncFunction"], fn);
      }
      async function filterFn(value, options2) {
        if (await fn(value, options2)) {
          return value;
        }
        return kEmpty;
      }
      return map3.call(this, filterFn, options);
    }
    var ReduceAwareErrMissingArgs = class extends ERR_MISSING_ARGS {
      constructor() {
        super("reduce");
        this.message = "Reduce of an empty stream requires an initial value";
      }
    };
    async function reduce(reducer, initialValue, options) {
      var _options$signal2;
      if (typeof reducer !== "function") {
        throw new ERR_INVALID_ARG_TYPE("reducer", ["Function", "AsyncFunction"], reducer);
      }
      if (options != null) {
        validateObject(options, "options");
      }
      if ((options === null || options === void 0 ? void 0 : options.signal) != null) {
        validateAbortSignal(options.signal, "options.signal");
      }
      let hasInitialValue = arguments.length > 1;
      if (options !== null && options !== void 0 && (_options$signal2 = options.signal) !== null && _options$signal2 !== void 0 && _options$signal2.aborted) {
        const err = new AbortError(void 0, {
          cause: options.signal.reason
        });
        this.once("error", () => {
        });
        await finished(this.destroy(err));
        throw err;
      }
      const ac = new AbortController2();
      const signal = ac.signal;
      if (options !== null && options !== void 0 && options.signal) {
        const opts = {
          once: true,
          [kWeakHandler]: this,
          [kResistStopPropagation]: true
        };
        options.signal.addEventListener("abort", () => ac.abort(), opts);
      }
      let gotAnyItemFromStream = false;
      try {
        for await (const value of this) {
          var _options$signal3;
          gotAnyItemFromStream = true;
          if (options !== null && options !== void 0 && (_options$signal3 = options.signal) !== null && _options$signal3 !== void 0 && _options$signal3.aborted) {
            throw new AbortError();
          }
          if (!hasInitialValue) {
            initialValue = value;
            hasInitialValue = true;
          } else {
            initialValue = await reducer(initialValue, value, {
              signal
            });
          }
        }
        if (!gotAnyItemFromStream && !hasInitialValue) {
          throw new ReduceAwareErrMissingArgs();
        }
      } finally {
        ac.abort();
      }
      return initialValue;
    }
    async function toArray2(options) {
      if (options != null) {
        validateObject(options, "options");
      }
      if ((options === null || options === void 0 ? void 0 : options.signal) != null) {
        validateAbortSignal(options.signal, "options.signal");
      }
      const result = [];
      for await (const val of this) {
        var _options$signal4;
        if (options !== null && options !== void 0 && (_options$signal4 = options.signal) !== null && _options$signal4 !== void 0 && _options$signal4.aborted) {
          throw new AbortError(void 0, {
            cause: options.signal.reason
          });
        }
        ArrayPrototypePush(result, val);
      }
      return result;
    }
    function flatMap(fn, options) {
      const values = map3.call(this, fn, options);
      return async function* flatMap2() {
        for await (const val of values) {
          yield* val;
        }
      }.call(this);
    }
    function toIntegerOrInfinity(number4) {
      number4 = Number2(number4);
      if (NumberIsNaN(number4)) {
        return 0;
      }
      if (number4 < 0) {
        throw new ERR_OUT_OF_RANGE("number", ">= 0", number4);
      }
      return number4;
    }
    function drop(number4, options = void 0) {
      if (options != null) {
        validateObject(options, "options");
      }
      if ((options === null || options === void 0 ? void 0 : options.signal) != null) {
        validateAbortSignal(options.signal, "options.signal");
      }
      number4 = toIntegerOrInfinity(number4);
      return async function* drop2() {
        var _options$signal5;
        if (options !== null && options !== void 0 && (_options$signal5 = options.signal) !== null && _options$signal5 !== void 0 && _options$signal5.aborted) {
          throw new AbortError();
        }
        for await (const val of this) {
          var _options$signal6;
          if (options !== null && options !== void 0 && (_options$signal6 = options.signal) !== null && _options$signal6 !== void 0 && _options$signal6.aborted) {
            throw new AbortError();
          }
          if (number4-- <= 0) {
            yield val;
          }
        }
      }.call(this);
    }
    function take(number4, options = void 0) {
      if (options != null) {
        validateObject(options, "options");
      }
      if ((options === null || options === void 0 ? void 0 : options.signal) != null) {
        validateAbortSignal(options.signal, "options.signal");
      }
      number4 = toIntegerOrInfinity(number4);
      return async function* take2() {
        var _options$signal7;
        if (options !== null && options !== void 0 && (_options$signal7 = options.signal) !== null && _options$signal7 !== void 0 && _options$signal7.aborted) {
          throw new AbortError();
        }
        for await (const val of this) {
          var _options$signal8;
          if (options !== null && options !== void 0 && (_options$signal8 = options.signal) !== null && _options$signal8 !== void 0 && _options$signal8.aborted) {
            throw new AbortError();
          }
          if (number4-- > 0) {
            yield val;
          }
          if (number4 <= 0) {
            return;
          }
        }
      }.call(this);
    }
    module.exports.streamReturningOperators = {
      asIndexedPairs: deprecate(asIndexedPairs, "readable.asIndexedPairs will be removed in a future version."),
      drop,
      filter,
      flatMap,
      map: map3,
      take,
      compose
    };
    module.exports.promiseReturningOperators = {
      every,
      forEach,
      reduce,
      toArray: toArray2,
      some,
      find
    };
  }
});

// node_modules/n3/node_modules/readable-stream/lib/stream/promises.js
var require_promises2 = __commonJS({
  "node_modules/n3/node_modules/readable-stream/lib/stream/promises.js"(exports, module) {
    "use strict";
    var { ArrayPrototypePop, Promise: Promise2 } = require_primordials2();
    var { isIterable, isNodeStream, isWebStream } = require_utils2();
    var { pipelineImpl: pl } = require_pipeline2();
    var { finished } = require_end_of_stream2();
    require_stream2();
    function pipeline(...streams) {
      return new Promise2((resolve, reject2) => {
        let signal;
        let end;
        const lastArg = streams[streams.length - 1];
        if (lastArg && typeof lastArg === "object" && !isNodeStream(lastArg) && !isIterable(lastArg) && !isWebStream(lastArg)) {
          const options = ArrayPrototypePop(streams);
          signal = options.signal;
          end = options.end;
        }
        pl(
          streams,
          (err, value) => {
            if (err) {
              reject2(err);
            } else {
              resolve(value);
            }
          },
          {
            signal,
            end
          }
        );
      });
    }
    module.exports = {
      finished,
      pipeline
    };
  }
});

// node_modules/n3/node_modules/readable-stream/lib/stream.js
var require_stream2 = __commonJS({
  "node_modules/n3/node_modules/readable-stream/lib/stream.js"(exports, module) {
    "use strict";
    var { Buffer: Buffer3 } = require_buffer();
    var { ObjectDefineProperty, ObjectKeys, ReflectApply } = require_primordials2();
    var {
      promisify: { custom: customPromisify }
    } = require_util2();
    var { streamReturningOperators, promiseReturningOperators } = require_operators2();
    var {
      codes: { ERR_ILLEGAL_CONSTRUCTOR }
    } = require_errors2();
    var compose = require_compose2();
    var { setDefaultHighWaterMark, getDefaultHighWaterMark } = require_state2();
    var { pipeline } = require_pipeline2();
    var { destroyer } = require_destroy2();
    var eos = require_end_of_stream2();
    var promises = require_promises2();
    var utils = require_utils2();
    var Stream = module.exports = require_legacy2().Stream;
    Stream.isDestroyed = utils.isDestroyed;
    Stream.isDisturbed = utils.isDisturbed;
    Stream.isErrored = utils.isErrored;
    Stream.isReadable = utils.isReadable;
    Stream.isWritable = utils.isWritable;
    Stream.Readable = require_readable2();
    for (const key of ObjectKeys(streamReturningOperators)) {
      let fn = function(...args) {
        if (new.target) {
          throw ERR_ILLEGAL_CONSTRUCTOR();
        }
        return Stream.Readable.from(ReflectApply(op, this, args));
      };
      const op = streamReturningOperators[key];
      ObjectDefineProperty(fn, "name", {
        __proto__: null,
        value: op.name
      });
      ObjectDefineProperty(fn, "length", {
        __proto__: null,
        value: op.length
      });
      ObjectDefineProperty(Stream.Readable.prototype, key, {
        __proto__: null,
        value: fn,
        enumerable: false,
        configurable: true,
        writable: true
      });
    }
    for (const key of ObjectKeys(promiseReturningOperators)) {
      let fn = function(...args) {
        if (new.target) {
          throw ERR_ILLEGAL_CONSTRUCTOR();
        }
        return ReflectApply(op, this, args);
      };
      const op = promiseReturningOperators[key];
      ObjectDefineProperty(fn, "name", {
        __proto__: null,
        value: op.name
      });
      ObjectDefineProperty(fn, "length", {
        __proto__: null,
        value: op.length
      });
      ObjectDefineProperty(Stream.Readable.prototype, key, {
        __proto__: null,
        value: fn,
        enumerable: false,
        configurable: true,
        writable: true
      });
    }
    Stream.Writable = require_writable2();
    Stream.Duplex = require_duplex2();
    Stream.Transform = require_transform2();
    Stream.PassThrough = require_passthrough2();
    Stream.pipeline = pipeline;
    var { addAbortSignal } = require_add_abort_signal2();
    Stream.addAbortSignal = addAbortSignal;
    Stream.finished = eos;
    Stream.destroy = destroyer;
    Stream.compose = compose;
    Stream.setDefaultHighWaterMark = setDefaultHighWaterMark;
    Stream.getDefaultHighWaterMark = getDefaultHighWaterMark;
    ObjectDefineProperty(Stream, "promises", {
      __proto__: null,
      configurable: true,
      enumerable: true,
      get() {
        return promises;
      }
    });
    ObjectDefineProperty(pipeline, customPromisify, {
      __proto__: null,
      enumerable: true,
      get() {
        return promises.pipeline;
      }
    });
    ObjectDefineProperty(eos, customPromisify, {
      __proto__: null,
      enumerable: true,
      get() {
        return promises.finished;
      }
    });
    Stream.Stream = Stream;
    Stream._isUint8Array = function isUint8Array(value) {
      return value instanceof Uint8Array;
    };
    Stream._uint8ArrayToBuffer = function _uint8ArrayToBuffer(chunk) {
      return Buffer3.from(chunk.buffer, chunk.byteOffset, chunk.byteLength);
    };
  }
});

// node_modules/n3/node_modules/readable-stream/lib/ours/browser.js
var require_browser4 = __commonJS({
  "node_modules/n3/node_modules/readable-stream/lib/ours/browser.js"(exports, module) {
    "use strict";
    var CustomStream = require_stream2();
    var promises = require_promises2();
    var originalDestroy = CustomStream.Readable.destroy;
    module.exports = CustomStream.Readable;
    module.exports._uint8ArrayToBuffer = CustomStream._uint8ArrayToBuffer;
    module.exports._isUint8Array = CustomStream._isUint8Array;
    module.exports.isDisturbed = CustomStream.isDisturbed;
    module.exports.isErrored = CustomStream.isErrored;
    module.exports.isReadable = CustomStream.isReadable;
    module.exports.Readable = CustomStream.Readable;
    module.exports.Writable = CustomStream.Writable;
    module.exports.Duplex = CustomStream.Duplex;
    module.exports.Transform = CustomStream.Transform;
    module.exports.PassThrough = CustomStream.PassThrough;
    module.exports.addAbortSignal = CustomStream.addAbortSignal;
    module.exports.finished = CustomStream.finished;
    module.exports.destroy = CustomStream.destroy;
    module.exports.destroy = originalDestroy;
    module.exports.pipeline = CustomStream.pipeline;
    module.exports.compose = CustomStream.compose;
    Object.defineProperty(CustomStream, "promises", {
      configurable: true,
      enumerable: true,
      get() {
        return promises;
      }
    });
    module.exports.Stream = CustomStream.Stream;
    module.exports.default = module.exports;
  }
});

// node_modules/n3/src/N3Store.js
function merge(target, source, depth = 4) {
  if (depth === 0)
    return Object.assign(target, source);
  for (const key in source)
    target[key] = merge(target[key] || /* @__PURE__ */ Object.create(null), source[key], depth - 1);
  return target;
}
function intersect(s1, s2, depth = 4) {
  let target = false;
  for (const key in s1) {
    if (key in s2) {
      const intersection2 = depth === 0 ? null : intersect(s1[key], s2[key], depth - 1);
      if (intersection2 !== false) {
        target = target || /* @__PURE__ */ Object.create(null);
        target[key] = intersection2;
      } else if (depth === 3) {
        return false;
      }
    }
  }
  return target;
}
function difference(s1, s2, depth = 4) {
  let target = false;
  for (const key in s1) {
    if (!(key in s2)) {
      target = target || /* @__PURE__ */ Object.create(null);
      target[key] = depth === 0 ? null : merge({}, s1[key], depth - 1);
    } else if (depth !== 0) {
      const diff = difference(s1[key], s2[key], depth - 1);
      if (diff !== false) {
        target = target || /* @__PURE__ */ Object.create(null);
        target[key] = diff;
      } else if (depth === 3) {
        return false;
      }
    }
  }
  return target;
}
function indexMatch(index, ids, depth = 0) {
  const ind = ids[depth];
  if (ind && !(ind in index))
    return false;
  let target = false;
  for (const key in ind ? { [ind]: index[ind] } : index) {
    const result = depth === 2 ? null : indexMatch(index[key], ids, depth + 1);
    if (result !== false) {
      target = target || /* @__PURE__ */ Object.create(null);
      target[key] = result;
    }
  }
  return target;
}
var import_readable_stream, ITERATOR, N3EntityIndex, N3Store, DatasetCoreAndReadableStream;
var init_N3Store = __esm({
  "node_modules/n3/src/N3Store.js"() {
    import_readable_stream = __toESM(require_browser4());
    init_N3DataFactory();
    init_IRIs();
    init_N3Util();
    init_N3Writer();
    ITERATOR = Symbol("iter");
    N3EntityIndex = class {
      constructor(options = {}) {
        this._id = 1;
        this._ids = /* @__PURE__ */ Object.create(null);
        this._ids[""] = 1;
        this._entities = /* @__PURE__ */ Object.create(null);
        this._entities[1] = "";
        this._blankNodeIndex = 0;
        this._factory = options.factory || N3DataFactory_default;
      }
      _termFromId(id) {
        if (id[0] === ".") {
          const entities = this._entities;
          const terms = id.split(".");
          const q = this._factory.quad(
            this._termFromId(entities[terms[1]]),
            this._termFromId(entities[terms[2]]),
            this._termFromId(entities[terms[3]]),
            terms[4] && this._termFromId(entities[terms[4]])
          );
          return q;
        }
        return termFromId(id, this._factory);
      }
      _termToNumericId(term) {
        if (term.termType === "Quad") {
          const s = this._termToNumericId(term.subject), p = this._termToNumericId(term.predicate), o = this._termToNumericId(term.object);
          let g;
          return s && p && o && (isDefaultGraph(term.graph) || (g = this._termToNumericId(term.graph))) && this._ids[g ? `.${s}.${p}.${o}.${g}` : `.${s}.${p}.${o}`];
        }
        return this._ids[termToId(term)];
      }
      _termToNewNumericId(term) {
        const str2 = term && term.termType === "Quad" ? `.${this._termToNewNumericId(term.subject)}.${this._termToNewNumericId(term.predicate)}.${this._termToNewNumericId(term.object)}${isDefaultGraph(term.graph) ? "" : `.${this._termToNewNumericId(term.graph)}`}` : termToId(term);
        return this._ids[str2] || (this._ids[this._entities[++this._id] = str2] = this._id);
      }
      createBlankNode(suggestedName) {
        let name, index;
        if (suggestedName) {
          name = suggestedName = `_:${suggestedName}`, index = 1;
          while (this._ids[name])
            name = suggestedName + index++;
        } else {
          do {
            name = `_:b${this._blankNodeIndex++}`;
          } while (this._ids[name]);
        }
        this._ids[name] = ++this._id;
        this._entities[this._id] = name;
        return this._factory.blankNode(name.substr(2));
      }
    };
    N3Store = class _N3Store {
      constructor(quads, options) {
        this._size = 0;
        this._graphs = /* @__PURE__ */ Object.create(null);
        if (!options && quads && !quads[0] && !(typeof quads.match === "function"))
          options = quads, quads = null;
        options = options || {};
        this._factory = options.factory || N3DataFactory_default;
        this._entityIndex = options.entityIndex || new N3EntityIndex({ factory: this._factory });
        this._entities = this._entityIndex._entities;
        this._termFromId = this._entityIndex._termFromId.bind(this._entityIndex);
        this._termToNumericId = this._entityIndex._termToNumericId.bind(this._entityIndex);
        this._termToNewNumericId = this._entityIndex._termToNewNumericId.bind(this._entityIndex);
        if (quads)
          this.addAll(quads);
      }
      // ## Public properties
      // ### `size` returns the number of quads in the store
      get size() {
        let size = this._size;
        if (size !== null)
          return size;
        size = 0;
        const graphs = this._graphs;
        let subjects, subject;
        for (const graphKey in graphs)
          for (const subjectKey in subjects = graphs[graphKey].subjects)
            for (const predicateKey in subject = subjects[subjectKey])
              size += Object.keys(subject[predicateKey]).length;
        return this._size = size;
      }
      // ## Private methods
      // ### `_addToIndex` adds a quad to a three-layered index.
      // Returns if the index has changed, if the entry did not already exist.
      _addToIndex(index0, key0, key1, key2) {
        const index1 = index0[key0] || (index0[key0] = {});
        const index2 = index1[key1] || (index1[key1] = {});
        const existed = key2 in index2;
        if (!existed)
          index2[key2] = null;
        return !existed;
      }
      // ### `_removeFromIndex` removes a quad from a three-layered index
      _removeFromIndex(index0, key0, key1, key2) {
        const index1 = index0[key0], index2 = index1[key1];
        delete index2[key2];
        for (const key in index2) return;
        delete index1[key1];
        for (const key in index1) return;
        delete index0[key0];
      }
      // ### `_findInIndex` finds a set of quads in a three-layered index.
      // The index base is `index0` and the keys at each level are `key0`, `key1`, and `key2`.
      // Any of these keys can be undefined, which is interpreted as a wildcard.
      // `name0`, `name1`, and `name2` are the names of the keys at each level,
      // used when reconstructing the resulting quad
      // (for instance: _subject_, _predicate_, and _object_).
      // Finally, `graphId` will be the graph of the created quads.
      *_findInIndex(index0, key0, key1, key2, name0, name1, name2, graphId) {
        let tmp, index1, index2;
        const entityKeys = this._entities;
        const graph = this._termFromId(entityKeys[graphId]);
        const parts = { subject: null, predicate: null, object: null };
        if (key0) (tmp = index0, index0 = {})[key0] = tmp[key0];
        for (const value0 in index0) {
          if (index1 = index0[value0]) {
            parts[name0] = this._termFromId(entityKeys[value0]);
            if (key1) (tmp = index1, index1 = {})[key1] = tmp[key1];
            for (const value1 in index1) {
              if (index2 = index1[value1]) {
                parts[name1] = this._termFromId(entityKeys[value1]);
                const values = key2 ? key2 in index2 ? [key2] : [] : Object.keys(index2);
                for (let l = 0; l < values.length; l++) {
                  parts[name2] = this._termFromId(entityKeys[values[l]]);
                  yield this._factory.quad(parts.subject, parts.predicate, parts.object, graph);
                }
              }
            }
          }
        }
      }
      // ### `_loop` executes the callback on all keys of index 0
      _loop(index0, callback) {
        for (const key0 in index0)
          callback(key0);
      }
      // ### `_loopByKey0` executes the callback on all keys of a certain entry in index 0
      _loopByKey0(index0, key0, callback) {
        let index1, key1;
        if (index1 = index0[key0]) {
          for (key1 in index1)
            callback(key1);
        }
      }
      // ### `_loopByKey1` executes the callback on given keys of all entries in index 0
      _loopByKey1(index0, key1, callback) {
        let key0, index1;
        for (key0 in index0) {
          index1 = index0[key0];
          if (index1[key1])
            callback(key0);
        }
      }
      // ### `_loopBy2Keys` executes the callback on given keys of certain entries in index 2
      _loopBy2Keys(index0, key0, key1, callback) {
        let index1, index2, key2;
        if ((index1 = index0[key0]) && (index2 = index1[key1])) {
          for (key2 in index2)
            callback(key2);
        }
      }
      // ### `_countInIndex` counts matching quads in a three-layered index.
      // The index base is `index0` and the keys at each level are `key0`, `key1`, and `key2`.
      // Any of these keys can be undefined, which is interpreted as a wildcard.
      _countInIndex(index0, key0, key1, key2) {
        let count = 0, tmp, index1, index2;
        if (key0) (tmp = index0, index0 = {})[key0] = tmp[key0];
        for (const value0 in index0) {
          if (index1 = index0[value0]) {
            if (key1) (tmp = index1, index1 = {})[key1] = tmp[key1];
            for (const value1 in index1) {
              if (index2 = index1[value1]) {
                if (key2) key2 in index2 && count++;
                else count += Object.keys(index2).length;
              }
            }
          }
        }
        return count;
      }
      // ### `_getGraphs` returns an array with the given graph,
      // or all graphs if the argument is null or undefined.
      _getGraphs(graph) {
        graph = graph === "" ? 1 : graph && (this._termToNumericId(graph) || -1);
        return typeof graph !== "number" ? this._graphs : { [graph]: this._graphs[graph] };
      }
      // ### `_uniqueEntities` returns a function that accepts an entity ID
      // and passes the corresponding entity to callback if it hasn't occurred before.
      _uniqueEntities(callback) {
        const uniqueIds = /* @__PURE__ */ Object.create(null);
        return (id) => {
          if (!(id in uniqueIds)) {
            uniqueIds[id] = true;
            callback(this._termFromId(this._entities[id], this._factory));
          }
        };
      }
      // ## Public methods
      // ### `add` adds the specified quad to the dataset.
      // Returns the dataset instance it was called on.
      // Existing quads, as defined in Quad.equals, will be ignored.
      add(quad2) {
        this.addQuad(quad2);
        return this;
      }
      // ### `addQuad` adds a new quad to the store.
      // Returns if the quad index has changed, if the quad did not already exist.
      addQuad(subject, predicate, object2, graph) {
        if (!predicate)
          graph = subject.graph, object2 = subject.object, predicate = subject.predicate, subject = subject.subject;
        graph = graph ? this._termToNewNumericId(graph) : 1;
        let graphItem = this._graphs[graph];
        if (!graphItem) {
          graphItem = this._graphs[graph] = { subjects: {}, predicates: {}, objects: {} };
          Object.freeze(graphItem);
        }
        subject = this._termToNewNumericId(subject);
        predicate = this._termToNewNumericId(predicate);
        object2 = this._termToNewNumericId(object2);
        if (!this._addToIndex(graphItem.subjects, subject, predicate, object2))
          return false;
        this._addToIndex(graphItem.predicates, predicate, object2, subject);
        this._addToIndex(graphItem.objects, object2, subject, predicate);
        this._size = null;
        return true;
      }
      // ### `addQuads` adds multiple quads to the store
      addQuads(quads) {
        for (let i = 0; i < quads.length; i++)
          this.addQuad(quads[i]);
      }
      // ### `delete` removes the specified quad from the dataset.
      // Returns the dataset instance it was called on.
      delete(quad2) {
        this.removeQuad(quad2);
        return this;
      }
      // ### `has` determines whether a dataset includes a certain quad or quad pattern.
      has(subjectOrQuad, predicate, object2, graph) {
        if (subjectOrQuad && subjectOrQuad.subject)
          ({ subject: subjectOrQuad, predicate, object: object2, graph } = subjectOrQuad);
        return !this.readQuads(subjectOrQuad, predicate, object2, graph).next().done;
      }
      // ### `import` adds a stream of quads to the store
      import(stream) {
        stream.on("data", (quad2) => {
          this.addQuad(quad2);
        });
        return stream;
      }
      // ### `removeQuad` removes a quad from the store if it exists
      removeQuad(subject, predicate, object2, graph) {
        if (!predicate)
          ({ subject, predicate, object: object2, graph } = subject);
        graph = graph ? this._termToNumericId(graph) : 1;
        const graphs = this._graphs;
        let graphItem, subjects, predicates;
        if (!(subject = subject && this._termToNumericId(subject)) || !(predicate = predicate && this._termToNumericId(predicate)) || !(object2 = object2 && this._termToNumericId(object2)) || !(graphItem = graphs[graph]) || !(subjects = graphItem.subjects[subject]) || !(predicates = subjects[predicate]) || !(object2 in predicates))
          return false;
        this._removeFromIndex(graphItem.subjects, subject, predicate, object2);
        this._removeFromIndex(graphItem.predicates, predicate, object2, subject);
        this._removeFromIndex(graphItem.objects, object2, subject, predicate);
        if (this._size !== null) this._size--;
        for (subject in graphItem.subjects) return true;
        delete graphs[graph];
        return true;
      }
      // ### `removeQuads` removes multiple quads from the store
      removeQuads(quads) {
        for (let i = 0; i < quads.length; i++)
          this.removeQuad(quads[i]);
      }
      // ### `remove` removes a stream of quads from the store
      remove(stream) {
        stream.on("data", (quad2) => {
          this.removeQuad(quad2);
        });
        return stream;
      }
      // ### `removeMatches` removes all matching quads from the store
      // Setting any field to `undefined` or `null` indicates a wildcard.
      removeMatches(subject, predicate, object2, graph) {
        const stream = new import_readable_stream.Readable({ objectMode: true });
        const iterable = this.readQuads(subject, predicate, object2, graph);
        stream._read = (size) => {
          while (--size >= 0) {
            const { done, value } = iterable.next();
            if (done) {
              stream.push(null);
              return;
            }
            stream.push(value);
          }
        };
        return this.remove(stream);
      }
      // ### `deleteGraph` removes all triples with the given graph from the store
      deleteGraph(graph) {
        return this.removeMatches(null, null, null, graph);
      }
      // ### `getQuads` returns an array of quads matching a pattern.
      // Setting any field to `undefined` or `null` indicates a wildcard.
      getQuads(subject, predicate, object2, graph) {
        return [...this.readQuads(subject, predicate, object2, graph)];
      }
      /**
       * `readQuads` returns a generator of quads matching a pattern.
       * Setting any field to `undefined` or `null` indicates a wildcard.
       * @deprecated Use `match` instead.
       */
      *readQuads(subject, predicate, object2, graph) {
        const graphs = this._getGraphs(graph);
        let content, subjectId, predicateId, objectId;
        if (subject && !(subjectId = this._termToNumericId(subject)) || predicate && !(predicateId = this._termToNumericId(predicate)) || object2 && !(objectId = this._termToNumericId(object2)))
          return;
        for (const graphId in graphs) {
          if (content = graphs[graphId]) {
            if (subjectId) {
              if (objectId)
                yield* this._findInIndex(
                  content.objects,
                  objectId,
                  subjectId,
                  predicateId,
                  "object",
                  "subject",
                  "predicate",
                  graphId
                );
              else
                yield* this._findInIndex(
                  content.subjects,
                  subjectId,
                  predicateId,
                  null,
                  "subject",
                  "predicate",
                  "object",
                  graphId
                );
            } else if (predicateId)
              yield* this._findInIndex(
                content.predicates,
                predicateId,
                objectId,
                null,
                "predicate",
                "object",
                "subject",
                graphId
              );
            else if (objectId)
              yield* this._findInIndex(
                content.objects,
                objectId,
                null,
                null,
                "object",
                "subject",
                "predicate",
                graphId
              );
            else
              yield* this._findInIndex(
                content.subjects,
                null,
                null,
                null,
                "subject",
                "predicate",
                "object",
                graphId
              );
          }
        }
      }
      // ### `match` returns a new dataset that is comprised of all quads in the current instance matching the given arguments.
      // The logic described in Quad Matching is applied for each quad in this dataset to check if it should be included in the output dataset.
      // Note: This method always returns a new DatasetCore, even if that dataset contains no quads.
      // Note: Since a DatasetCore is an unordered set, the order of the quads within the returned sequence is arbitrary.
      // Setting any field to `undefined` or `null` indicates a wildcard.
      // For backwards compatibility, the object return also implements the Readable stream interface.
      match(subject, predicate, object2, graph) {
        return new DatasetCoreAndReadableStream(this, subject, predicate, object2, graph, { entityIndex: this._entityIndex });
      }
      // ### `countQuads` returns the number of quads matching a pattern.
      // Setting any field to `undefined` or `null` indicates a wildcard.
      countQuads(subject, predicate, object2, graph) {
        const graphs = this._getGraphs(graph);
        let count = 0, content, subjectId, predicateId, objectId;
        if (subject && !(subjectId = this._termToNumericId(subject)) || predicate && !(predicateId = this._termToNumericId(predicate)) || object2 && !(objectId = this._termToNumericId(object2)))
          return 0;
        for (const graphId in graphs) {
          if (content = graphs[graphId]) {
            if (subject) {
              if (object2)
                count += this._countInIndex(content.objects, objectId, subjectId, predicateId);
              else
                count += this._countInIndex(content.subjects, subjectId, predicateId, objectId);
            } else if (predicate) {
              count += this._countInIndex(content.predicates, predicateId, objectId, subjectId);
            } else {
              count += this._countInIndex(content.objects, objectId, subjectId, predicateId);
            }
          }
        }
        return count;
      }
      // ### `forEach` executes the callback on all quads.
      // Setting any field to `undefined` or `null` indicates a wildcard.
      forEach(callback, subject, predicate, object2, graph) {
        this.some((quad2) => {
          callback(quad2, this);
          return false;
        }, subject, predicate, object2, graph);
      }
      // ### `every` executes the callback on all quads,
      // and returns `true` if it returns truthy for all them.
      // Setting any field to `undefined` or `null` indicates a wildcard.
      every(callback, subject, predicate, object2, graph) {
        return !this.some((quad2) => !callback(quad2, this), subject, predicate, object2, graph);
      }
      // ### `some` executes the callback on all quads,
      // and returns `true` if it returns truthy for any of them.
      // Setting any field to `undefined` or `null` indicates a wildcard.
      some(callback, subject, predicate, object2, graph) {
        for (const quad2 of this.readQuads(subject, predicate, object2, graph))
          if (callback(quad2, this))
            return true;
        return false;
      }
      // ### `getSubjects` returns all subjects that match the pattern.
      // Setting any field to `undefined` or `null` indicates a wildcard.
      getSubjects(predicate, object2, graph) {
        const results = [];
        this.forSubjects((s) => {
          results.push(s);
        }, predicate, object2, graph);
        return results;
      }
      // ### `forSubjects` executes the callback on all subjects that match the pattern.
      // Setting any field to `undefined` or `null` indicates a wildcard.
      forSubjects(callback, predicate, object2, graph) {
        const graphs = this._getGraphs(graph);
        let content, predicateId, objectId;
        callback = this._uniqueEntities(callback);
        if (predicate && !(predicateId = this._termToNumericId(predicate)) || object2 && !(objectId = this._termToNumericId(object2)))
          return;
        for (graph in graphs) {
          if (content = graphs[graph]) {
            if (predicateId) {
              if (objectId)
                this._loopBy2Keys(content.predicates, predicateId, objectId, callback);
              else
                this._loopByKey1(content.subjects, predicateId, callback);
            } else if (objectId)
              this._loopByKey0(content.objects, objectId, callback);
            else
              this._loop(content.subjects, callback);
          }
        }
      }
      // ### `getPredicates` returns all predicates that match the pattern.
      // Setting any field to `undefined` or `null` indicates a wildcard.
      getPredicates(subject, object2, graph) {
        const results = [];
        this.forPredicates((p) => {
          results.push(p);
        }, subject, object2, graph);
        return results;
      }
      // ### `forPredicates` executes the callback on all predicates that match the pattern.
      // Setting any field to `undefined` or `null` indicates a wildcard.
      forPredicates(callback, subject, object2, graph) {
        const graphs = this._getGraphs(graph);
        let content, subjectId, objectId;
        callback = this._uniqueEntities(callback);
        if (subject && !(subjectId = this._termToNumericId(subject)) || object2 && !(objectId = this._termToNumericId(object2)))
          return;
        for (graph in graphs) {
          if (content = graphs[graph]) {
            if (subjectId) {
              if (objectId)
                this._loopBy2Keys(content.objects, objectId, subjectId, callback);
              else
                this._loopByKey0(content.subjects, subjectId, callback);
            } else if (objectId)
              this._loopByKey1(content.predicates, objectId, callback);
            else
              this._loop(content.predicates, callback);
          }
        }
      }
      // ### `getObjects` returns all objects that match the pattern.
      // Setting any field to `undefined` or `null` indicates a wildcard.
      getObjects(subject, predicate, graph) {
        const results = [];
        this.forObjects((o) => {
          results.push(o);
        }, subject, predicate, graph);
        return results;
      }
      // ### `forObjects` executes the callback on all objects that match the pattern.
      // Setting any field to `undefined` or `null` indicates a wildcard.
      forObjects(callback, subject, predicate, graph) {
        const graphs = this._getGraphs(graph);
        let content, subjectId, predicateId;
        callback = this._uniqueEntities(callback);
        if (subject && !(subjectId = this._termToNumericId(subject)) || predicate && !(predicateId = this._termToNumericId(predicate)))
          return;
        for (graph in graphs) {
          if (content = graphs[graph]) {
            if (subjectId) {
              if (predicateId)
                this._loopBy2Keys(content.subjects, subjectId, predicateId, callback);
              else
                this._loopByKey1(content.objects, subjectId, callback);
            } else if (predicateId)
              this._loopByKey0(content.predicates, predicateId, callback);
            else
              this._loop(content.objects, callback);
          }
        }
      }
      // ### `getGraphs` returns all graphs that match the pattern.
      // Setting any field to `undefined` or `null` indicates a wildcard.
      getGraphs(subject, predicate, object2) {
        const results = [];
        this.forGraphs((g) => {
          results.push(g);
        }, subject, predicate, object2);
        return results;
      }
      // ### `forGraphs` executes the callback on all graphs that match the pattern.
      // Setting any field to `undefined` or `null` indicates a wildcard.
      forGraphs(callback, subject, predicate, object2) {
        for (const graph in this._graphs) {
          this.some((quad2) => {
            callback(quad2.graph);
            return true;
          }, subject, predicate, object2, this._termFromId(this._entities[graph]));
        }
      }
      // ### `createBlankNode` creates a new blank node, returning its name
      createBlankNode(suggestedName) {
        return this._entityIndex.createBlankNode(suggestedName);
      }
      // ### `extractLists` finds and removes all list triples
      // and returns the items per list.
      extractLists({ remove = false, ignoreErrors = false } = {}) {
        const lists = {};
        const onError = ignoreErrors ? (() => true) : ((node, message2) => {
          throw new Error(`${node.value} ${message2}`);
        });
        const tails = this.getQuads(null, IRIs_default.rdf.rest, IRIs_default.rdf.nil, null);
        const toRemove = remove ? [...tails] : [];
        tails.forEach((tailQuad) => {
          const items = [];
          let malformed = false;
          let head;
          let headPos;
          const graph = tailQuad.graph;
          let current = tailQuad.subject;
          while (current && !malformed) {
            const objectQuads = this.getQuads(null, null, current, null);
            const subjectQuads = this.getQuads(current, null, null, null);
            let quad2, first = null, rest = null, parent = null;
            for (let i = 0; i < subjectQuads.length && !malformed; i++) {
              quad2 = subjectQuads[i];
              if (!quad2.graph.equals(graph))
                malformed = onError(current, "not confined to single graph");
              else if (head)
                malformed = onError(current, "has non-list arcs out");
              else if (quad2.predicate.value === IRIs_default.rdf.first) {
                if (first)
                  malformed = onError(current, "has multiple rdf:first arcs");
                else
                  toRemove.push(first = quad2);
              } else if (quad2.predicate.value === IRIs_default.rdf.rest) {
                if (rest)
                  malformed = onError(current, "has multiple rdf:rest arcs");
                else
                  toRemove.push(rest = quad2);
              } else if (objectQuads.length)
                malformed = onError(current, "can't be subject and object");
              else {
                head = quad2;
                headPos = "subject";
              }
            }
            for (let i = 0; i < objectQuads.length && !malformed; ++i) {
              quad2 = objectQuads[i];
              if (head)
                malformed = onError(current, "can't have coreferences");
              else if (quad2.predicate.value === IRIs_default.rdf.rest) {
                if (parent)
                  malformed = onError(current, "has incoming rdf:rest arcs");
                else
                  parent = quad2;
              } else {
                head = quad2;
                headPos = "object";
              }
            }
            if (!first)
              malformed = onError(current, "has no list head");
            else
              items.unshift(first.object);
            current = parent && parent.subject;
          }
          if (malformed)
            remove = false;
          else if (head)
            lists[head[headPos].value] = items;
        });
        if (remove)
          this.removeQuads(toRemove);
        return lists;
      }
      /**
       * Returns `true` if the current dataset is a superset of the given dataset; in other words, returns `true` if
       * the given dataset is a subset of, i.e., is contained within, the current dataset.
       *
       * Blank Nodes will be normalized.
       */
      addAll(quads) {
        if (quads instanceof DatasetCoreAndReadableStream)
          quads = quads.filtered;
        if (Array.isArray(quads))
          this.addQuads(quads);
        else if (quads instanceof _N3Store && quads._entityIndex === this._entityIndex) {
          if (quads._size !== 0) {
            this._graphs = merge(this._graphs, quads._graphs);
            this._size = null;
          }
        } else {
          for (const quad2 of quads)
            this.add(quad2);
        }
        return this;
      }
      /**
       * Returns `true` if the current dataset is a superset of the given dataset; in other words, returns `true` if
       * the given dataset is a subset of, i.e., is contained within, the current dataset.
       *
       * Blank Nodes will be normalized.
       */
      contains(other) {
        if (other instanceof DatasetCoreAndReadableStream)
          other = other.filtered;
        if (other === this)
          return true;
        if (!(other instanceof _N3Store) || this._entityIndex !== other._entityIndex)
          return other.every((quad2) => this.has(quad2));
        const g1 = this._graphs, g2 = other._graphs;
        let s1, s2, p1, p2, o1;
        for (const graph in g2) {
          if (!(s1 = g1[graph])) return false;
          s1 = s1.subjects;
          for (const subject in s2 = g2[graph].subjects) {
            if (!(p1 = s1[subject])) return false;
            for (const predicate in p2 = s2[subject]) {
              if (!(o1 = p1[predicate])) return false;
              for (const object2 in p2[predicate])
                if (!(object2 in o1)) return false;
            }
          }
        }
        return true;
      }
      /**
       * This method removes the quads in the current dataset that match the given arguments.
       *
       * The logic described in {@link https://rdf.js.org/dataset-spec/#quad-matching|Quad Matching} is applied for each
       * quad in this dataset, to select the quads which will be deleted.
       *
       * @param subject   The optional exact subject to match.
       * @param predicate The optional exact predicate to match.
       * @param object    The optional exact object to match.
       * @param graph     The optional exact graph to match.
       */
      deleteMatches(subject, predicate, object2, graph) {
        for (const quad2 of this.match(subject, predicate, object2, graph))
          this.removeQuad(quad2);
        return this;
      }
      /**
       * Returns a new dataset that contains all quads from the current dataset that are not included in the given dataset.
       */
      difference(other) {
        if (other && other instanceof DatasetCoreAndReadableStream)
          other = other.filtered;
        if (other === this)
          return new _N3Store({ entityIndex: this._entityIndex });
        if (other instanceof _N3Store && other._entityIndex === this._entityIndex) {
          const store = new _N3Store({ entityIndex: this._entityIndex });
          const graphs = difference(this._graphs, other._graphs);
          if (graphs) {
            store._graphs = graphs;
            store._size = null;
          }
          return store;
        }
        return this.filter((quad2) => !other.has(quad2));
      }
      /**
       * Returns true if the current dataset contains the same graph structure as the given dataset.
       *
       * Blank Nodes will be normalized.
       */
      equals(other) {
        if (other instanceof DatasetCoreAndReadableStream)
          other = other.filtered;
        return other === this || this.size === other.size && this.contains(other);
      }
      /**
       * Creates a new dataset with all the quads that pass the test implemented by the provided `iteratee`.
       *
       * This method is aligned with Array.prototype.filter() in ECMAScript-262.
       */
      filter(iteratee) {
        const store = new _N3Store({ entityIndex: this._entityIndex });
        for (const quad2 of this)
          if (iteratee(quad2, this))
            store.add(quad2);
        return store;
      }
      /**
       * Returns a new dataset containing all quads from the current dataset that are also included in the given dataset.
       */
      intersection(other) {
        if (other instanceof DatasetCoreAndReadableStream)
          other = other.filtered;
        if (other === this) {
          const store = new _N3Store({ entityIndex: this._entityIndex });
          store._graphs = merge(/* @__PURE__ */ Object.create(null), this._graphs);
          store._size = this._size;
          return store;
        } else if (other instanceof _N3Store && this._entityIndex === other._entityIndex) {
          const store = new _N3Store({ entityIndex: this._entityIndex });
          const graphs = intersect(other._graphs, this._graphs);
          if (graphs) {
            store._graphs = graphs;
            store._size = null;
          }
          return store;
        }
        return this.filter((quad2) => other.has(quad2));
      }
      /**
       * Returns a new dataset containing all quads returned by applying `iteratee` to each quad in the current dataset.
       */
      map(iteratee) {
        const store = new _N3Store({ entityIndex: this._entityIndex });
        for (const quad2 of this)
          store.add(iteratee(quad2, this));
        return store;
      }
      /**
       * This method calls the `iteratee` method on each `quad` of the `Dataset`. The first time the `iteratee` method
       * is called, the `accumulator` value is the `initialValue`, or, if not given, equals the first quad of the `Dataset`.
       * The return value of each call to the `iteratee` method is used as the `accumulator` value for the next call.
       *
       * This method returns the return value of the last `iteratee` call.
       *
       * This method is aligned with `Array.prototype.reduce()` in ECMAScript-262.
       */
      reduce(callback, initialValue) {
        const iter = this.readQuads();
        let accumulator = initialValue === void 0 ? iter.next().value : initialValue;
        for (const quad2 of iter)
          accumulator = callback(accumulator, quad2, this);
        return accumulator;
      }
      /**
       * Returns the set of quads within the dataset as a host-language-native sequence, for example an `Array` in
       * ECMAScript-262.
       *
       * Since a `Dataset` is an unordered set, the order of the quads within the returned sequence is arbitrary.
       */
      toArray() {
        return this.getQuads();
      }
      /**
       * Returns an N-Quads string representation of the dataset, preprocessed with the
       * {@link https://json-ld.github.io/normalization/spec/|RDF Dataset Normalization} algorithm.
       */
      toCanonical() {
        throw new Error("not implemented");
      }
      /**
       * Returns a stream that contains all quads of the dataset.
       */
      toStream() {
        return this.match();
      }
      /**
       * Returns an N-Quads string representation of the dataset.
       *
       * No prior normalization is required, therefore the results for the same quads may vary depending on the `Dataset`
       * implementation.
       */
      toString() {
        return new N3Writer().quadsToString(this);
      }
      /**
       * Returns a new `Dataset` that is a concatenation of this dataset and the quads given as an argument.
       */
      union(quads) {
        const store = new _N3Store({ entityIndex: this._entityIndex });
        store._graphs = merge(/* @__PURE__ */ Object.create(null), this._graphs);
        store._size = this._size;
        store.addAll(quads);
        return store;
      }
      // ### Store is an iterable.
      // Can be used where iterables are expected: for...of loops, array spread operator,
      // `yield*`, and destructuring assignment (order is not guaranteed).
      *[Symbol.iterator]() {
        yield* this.readQuads();
      }
    };
    DatasetCoreAndReadableStream = class _DatasetCoreAndReadableStream extends import_readable_stream.Readable {
      constructor(n3Store, subject, predicate, object2, graph, options) {
        super({ objectMode: true });
        Object.assign(this, { n3Store, subject, predicate, object: object2, graph, options });
      }
      get filtered() {
        if (!this._filtered) {
          const { n3Store, graph, object: object2, predicate, subject } = this;
          const newStore = this._filtered = new N3Store({ factory: n3Store._factory, entityIndex: this.options.entityIndex });
          let subjectId, predicateId, objectId;
          if (subject && !(subjectId = newStore._termToNumericId(subject)) || predicate && !(predicateId = newStore._termToNumericId(predicate)) || object2 && !(objectId = newStore._termToNumericId(object2)))
            return newStore;
          const graphs = n3Store._getGraphs(graph);
          for (const graphKey in graphs) {
            let subjects, predicates, objects, content;
            if (content = graphs[graphKey]) {
              if (!subjectId && predicateId) {
                if (predicates = indexMatch(content.predicates, [predicateId, objectId, subjectId])) {
                  subjects = indexMatch(content.subjects, [subjectId, predicateId, objectId]);
                  objects = indexMatch(content.objects, [objectId, subjectId, predicateId]);
                }
              } else if (objectId) {
                if (objects = indexMatch(content.objects, [objectId, subjectId, predicateId])) {
                  subjects = indexMatch(content.subjects, [subjectId, predicateId, objectId]);
                  predicates = indexMatch(content.predicates, [predicateId, objectId, subjectId]);
                }
              } else if (subjects = indexMatch(content.subjects, [subjectId, predicateId, objectId])) {
                predicates = indexMatch(content.predicates, [predicateId, objectId, subjectId]);
                objects = indexMatch(content.objects, [objectId, subjectId, predicateId]);
              }
              if (subjects)
                newStore._graphs[graphKey] = { subjects, predicates, objects };
            }
          }
          newStore._size = null;
        }
        return this._filtered;
      }
      get size() {
        return this.filtered.size;
      }
      _read(size) {
        if (size > 0 && !this[ITERATOR])
          this[ITERATOR] = this[Symbol.iterator]();
        const iterable = this[ITERATOR];
        while (--size >= 0) {
          const { done, value } = iterable.next();
          if (done) {
            this.push(null);
            return;
          }
          this.push(value);
        }
      }
      addAll(quads) {
        return this.filtered.addAll(quads);
      }
      contains(other) {
        return this.filtered.contains(other);
      }
      deleteMatches(subject, predicate, object2, graph) {
        return this.filtered.deleteMatches(subject, predicate, object2, graph);
      }
      difference(other) {
        return this.filtered.difference(other);
      }
      equals(other) {
        return this.filtered.equals(other);
      }
      every(callback, subject, predicate, object2, graph) {
        return this.filtered.every(callback, subject, predicate, object2, graph);
      }
      filter(iteratee) {
        return this.filtered.filter(iteratee);
      }
      forEach(callback, subject, predicate, object2, graph) {
        return this.filtered.forEach(callback, subject, predicate, object2, graph);
      }
      import(stream) {
        return this.filtered.import(stream);
      }
      intersection(other) {
        return this.filtered.intersection(other);
      }
      map(iteratee) {
        return this.filtered.map(iteratee);
      }
      some(callback, subject, predicate, object2, graph) {
        return this.filtered.some(callback, subject, predicate, object2, graph);
      }
      toCanonical() {
        return this.filtered.toCanonical();
      }
      toStream() {
        return this._filtered ? this._filtered.toStream() : this.n3Store.match(this.subject, this.predicate, this.object, this.graph);
      }
      union(quads) {
        return this._filtered ? this._filtered.union(quads) : this.n3Store.match(this.subject, this.predicate, this.object, this.graph).addAll(quads);
      }
      toArray() {
        return this._filtered ? this._filtered.toArray() : this.n3Store.getQuads(this.subject, this.predicate, this.object, this.graph);
      }
      reduce(callback, initialValue) {
        return this.filtered.reduce(callback, initialValue);
      }
      toString() {
        return new N3Writer().quadsToString(this);
      }
      add(quad2) {
        return this.filtered.add(quad2);
      }
      delete(quad2) {
        return this.filtered.delete(quad2);
      }
      has(quad2) {
        return this.filtered.has(quad2);
      }
      match(subject, predicate, object2, graph) {
        return new _DatasetCoreAndReadableStream(this.filtered, subject, predicate, object2, graph, this.options);
      }
      *[Symbol.iterator]() {
        yield* this._filtered || this.n3Store.readQuads(this.subject, this.predicate, this.object, this.graph);
      }
    };
  }
});

// node_modules/n3/src/index.js
var init_src = __esm({
  "node_modules/n3/src/index.js"() {
    init_N3Parser();
    init_N3Writer();
    init_N3Store();
    init_N3DataFactory();
  }
});

// node_modules/@inrupt/solid-client/dist/formats/turtle.mjs
function getParser(baseIri) {
  return new N3Parser({ format: "text/turtle", baseIRI: baseIri });
}
async function triplesToTurtle(quads, options) {
  const format = "text/turtle";
  const writer = new N3Writer({ format, prefixes: options === null || options === void 0 ? void 0 : options.prefixes });
  const triples = quads.map((quad2) => N3DataFactory_default.quad(quad2.subject, quad2.predicate, quad2.object, void 0));
  writer.addQuads(triples);
  const writePromise = new Promise((resolve, reject2) => {
    writer.end((error46, result) => {
      if (error46) {
        reject2(error46);
      } else {
        resolve(result);
      }
    });
  });
  const rawTurtle = await writePromise;
  return rawTurtle;
}
var getTurtleParser;
var init_turtle = __esm({
  "node_modules/@inrupt/solid-client/dist/formats/turtle.mjs"() {
    init_src();
    init_resource();
    getTurtleParser = () => {
      const onQuadCallbacks = [];
      const onCompleteCallbacks = [];
      const onErrorCallbacks = [];
      return {
        onQuad: (callback) => {
          onQuadCallbacks.push(callback);
        },
        onError: (callback) => {
          onErrorCallbacks.push(callback);
        },
        onComplete: (callback) => {
          onCompleteCallbacks.push(callback);
        },
        parse: (source, resourceInfo) => {
          getParser(getSourceUrl(resourceInfo)).parse(source, (error46, quad2) => {
            if (error46) {
              onErrorCallbacks.forEach((callback) => callback(error46));
            } else if (quad2) {
              onQuadCallbacks.forEach((callback) => callback(quad2));
            } else {
              onCompleteCallbacks.forEach((callback) => callback());
            }
          });
        }
      };
    };
  }
});

// node_modules/@inrupt/solid-client/dist/formats/prefixes.mjs
var prefixes;
var init_prefixes = __esm({
  "node_modules/@inrupt/solid-client/dist/formats/prefixes.mjs"() {
    prefixes = {
      acl: "http://www.w3.org/ns/auth/acl#",
      acp: "http://www.w3.org/ns/solid/acp#",
      cc: "http://creativecommons.org/ns#",
      cert: "http://www.w3.org/ns/auth/cert#",
      csvw: "http://www.w3.org/ns/csvw#",
      current: "#",
      dc: "http://purl.org/dc/terms/",
      dcam: "http://purl.org/dc/dcam/",
      dcat: "http://www.w3.org/ns/dcat#",
      dctype: "http://purl.org/dc/dcmitype/",
      foaf: "http://xmlns.com/foaf/0.1/",
      ldp: "http://www.w3.org/ns/ldp#",
      owl: "http://www.w3.org/2002/07/owl#",
      posixstat: "http://www.w3.org/ns/posix/stat#",
      rdf: "http://www.w3.org/1999/02/22-rdf-syntax-ns#",
      rdfs: "http://www.w3.org/2000/01/rdf-schema#",
      schema: "https://schema.org/",
      shacl: "http://www.w3.org/ns/shacl#",
      skos: "http://www.w3.org/2004/02/skos/core#",
      skosxl: "http://www.w3.org/2008/05/skos-xl#",
      solid: "http://www.w3.org/ns/solid/terms#",
      swapdoc: "http://www.w3.org/2000/10/swap/pim/doc#",
      ui: "http://www.w3.org/ns/ui#",
      vann: "http://purl.org/vocab/vann/",
      vcard: "http://www.w3.org/2006/vcard/ns#",
      ws: "http://www.w3.org/ns/pim/space#",
      xsd: "http://www.w3.org/2001/XMLSchema#"
    };
  }
});

// node_modules/@inrupt/solid-client/dist/rdf.internal.mjs
function isLocalNodeIri(iri) {
  return iri.substring(0, localNodeSkolemPrefix.length) === localNodeSkolemPrefix;
}
function getLocalNodeName(localNodeIri) {
  return localNodeIri.substring(localNodeSkolemPrefix.length);
}
function isBlankNodeId(value) {
  return typeof value === "string" && value.substring(0, 2) === "_:";
}
function getBlankNodeValue(blankNodeId) {
  return blankNodeId.substring(2);
}
function getBlankNodeId(blankNode2) {
  return `_:${blankNode2.value}`;
}
var rdfJsDataset, localNodeSkolemPrefix, freeze;
var init_rdf_internal = __esm({
  "node_modules/@inrupt/solid-client/dist/rdf.internal.mjs"() {
    init_src();
    rdfJsDataset = (quads) => new N3Store(quads);
    localNodeSkolemPrefix = "https://inrupt.com/.well-known/sdk-local-node/";
    ({ freeze } = Object);
  }
});

// node_modules/@inrupt/solid-client/dist/datatypes.mjs
function isNamedNode(value) {
  return isTerm(value) && value.termType === "NamedNode";
}
function isTerm(value) {
  return value !== null && typeof value === "object" && typeof value.termType === "string" && typeof value.value === "string" && typeof value.equals === "function";
}
function internal_isValidUrl(iri) {
  const iriString = internal_toIriString(iri);
  if (typeof URL !== "function") {
    return true;
  }
  try {
    new URL(iriString);
    return true;
  } catch (_a) {
    return false;
  }
}
function resolveLocalIri(name, resourceIri) {
  if (typeof URL !== "function") {
    throw new Error("The URL interface is not available, so an IRI cannot be determined.");
  }
  const thingIri = new URL(resourceIri);
  thingIri.hash = name;
  return thingIri.href;
}
var xmlSchemaTypes;
var init_datatypes = __esm({
  "node_modules/@inrupt/solid-client/dist/datatypes.mjs"() {
    init_interfaces_internal();
    xmlSchemaTypes = {
      boolean: "http://www.w3.org/2001/XMLSchema#boolean",
      dateTime: "http://www.w3.org/2001/XMLSchema#dateTime",
      date: "http://www.w3.org/2001/XMLSchema#date",
      time: "http://www.w3.org/2001/XMLSchema#time",
      decimal: "http://www.w3.org/2001/XMLSchema#decimal",
      integer: "http://www.w3.org/2001/XMLSchema#integer",
      string: "http://www.w3.org/2001/XMLSchema#string",
      langString: "http://www.w3.org/1999/02/22-rdf-syntax-ns#langString"
    };
  }
});

// node_modules/@inrupt/solid-client/dist/rdfjs.internal.mjs
function addRdfJsQuadToDataset(dataset, quad2) {
  var _a;
  const supportedGraphTypes = [
    "NamedNode",
    "DefaultGraph"
  ];
  if (!supportedGraphTypes.includes(quad2.graph.termType)) {
    throw new Error(`Cannot parse Quads with nodes of type [${quad2.graph.termType}] as their Graph node.`);
  }
  const graphId = quad2.graph.termType === "DefaultGraph" ? "default" : quad2.graph.value;
  const graph = (_a = dataset.graphs[graphId]) !== null && _a !== void 0 ? _a : {};
  return freeze({
    ...dataset,
    graphs: freeze({
      ...dataset.graphs,
      [graphId]: addRdfJsQuadToGraph(graph, quad2)
    })
  });
}
function addRdfJsQuadToGraph(graph, quad2) {
  var _a;
  const supportedSubjectTypes = [
    "NamedNode",
    "BlankNode"
  ];
  if (!supportedSubjectTypes.includes(quad2.subject.termType)) {
    throw new Error(`Cannot parse Quads with nodes of type [${quad2.subject.termType}] as their Subject node.`);
  }
  const subjectIri = quad2.subject.termType === "BlankNode" ? `_:${quad2.subject.value}` : quad2.subject.value;
  const subject = (_a = graph[subjectIri]) !== null && _a !== void 0 ? _a : {
    type: "Subject",
    url: subjectIri,
    predicates: {}
  };
  return freeze({
    ...graph,
    [subjectIri]: addRdfJsQuadToSubject(subject, quad2)
  });
}
function addRdfJsQuadToSubject(subject, quad2) {
  return freeze({
    ...subject,
    predicates: addRdfJsQuadToPredicates(subject.predicates, quad2)
  });
}
function addRdfJsQuadToPredicates(predicates, quad2) {
  var _a;
  const supportedPredicateTypes = [
    "NamedNode"
  ];
  if (!supportedPredicateTypes.includes(quad2.predicate.termType)) {
    throw new Error(`Cannot parse Quads with nodes of type [${quad2.predicate.termType}] as their Predicate node.`);
  }
  const predicateIri = quad2.predicate.value;
  const objects = (_a = predicates[predicateIri]) !== null && _a !== void 0 ? _a : {};
  return freeze({
    ...predicates,
    [predicateIri]: addRdfJsQuadToObjects(objects, quad2)
  });
}
function addRdfJsQuadToObjects(objects, quad2) {
  var _a, _b, _c, _d, _e, _f, _g, _h;
  if (quad2.object.termType === "NamedNode") {
    const namedNodes = freeze([
      ...(_a = objects.namedNodes) !== null && _a !== void 0 ? _a : [],
      quad2.object.value
    ]);
    return freeze({
      ...objects,
      namedNodes
    });
  }
  if (quad2.object.termType === "Literal") {
    if (quad2.object.datatype.value === xmlSchemaTypes.langString) {
      const locale = quad2.object.language.toLowerCase();
      const thisLocaleStrings = freeze([
        ...(_c = (_b = objects.langStrings) === null || _b === void 0 ? void 0 : _b[locale]) !== null && _c !== void 0 ? _c : [],
        quad2.object.value
      ]);
      const langStrings = freeze({
        ...(_d = objects.langStrings) !== null && _d !== void 0 ? _d : {},
        [locale]: thisLocaleStrings
      });
      return freeze({
        ...objects,
        langStrings
      });
    }
    const thisTypeValues = freeze([
      ...(_f = (_e = objects.literals) === null || _e === void 0 ? void 0 : _e[quad2.object.datatype.value]) !== null && _f !== void 0 ? _f : [],
      quad2.object.value
    ]);
    const literals = freeze({
      ...(_g = objects.literals) !== null && _g !== void 0 ? _g : {},
      [quad2.object.datatype.value]: thisTypeValues
    });
    return freeze({
      ...objects,
      literals
    });
  }
  if (quad2.object.termType === "BlankNode") {
    const blankNodes = freeze([
      ...(_h = objects.blankNodes) !== null && _h !== void 0 ? _h : [],
      getBlankNodeId(quad2.object)
    ]);
    return freeze({
      ...objects,
      blankNodes
    });
  }
  throw new Error(`Objects of type [${quad2.object.termType}] are not supported.`);
}
function toRdfJsQuads(dataset, options = {}) {
  var _a;
  const quads = [];
  const dataFactory = (_a = options.dataFactory) !== null && _a !== void 0 ? _a : N3DataFactory_default;
  Object.keys(dataset.graphs).forEach((graphIri) => {
    const graph = dataset.graphs[graphIri];
    const graphNode = graphIri === "default" ? dataFactory.defaultGraph() : dataFactory.namedNode(graphIri);
    Object.keys(graph).forEach((subjectIri) => {
      const { predicates } = graph[subjectIri];
      const subjectNode = isBlankNodeId(subjectIri) ? dataFactory.blankNode(getBlankNodeValue(subjectIri)) : dataFactory.namedNode(subjectIri);
      quads.push(...subjectToRdfJsQuads(predicates, subjectNode, graphNode, options));
    });
  });
  return quads;
}
function subjectToRdfJsQuads(predicates, subjectNode, graphNode, options = {}) {
  var _a;
  const quads = [];
  const dataFactory = (_a = options.dataFactory) !== null && _a !== void 0 ? _a : N3DataFactory_default;
  Object.keys(predicates).forEach((predicateIri) => {
    var _a2, _b, _c, _d;
    const predicateNode = dataFactory.namedNode(predicateIri);
    const langStrings = (_a2 = predicates[predicateIri].langStrings) !== null && _a2 !== void 0 ? _a2 : {};
    const namedNodes = (_b = predicates[predicateIri].namedNodes) !== null && _b !== void 0 ? _b : [];
    const literals = (_c = predicates[predicateIri].literals) !== null && _c !== void 0 ? _c : {};
    const blankNodes = (_d = predicates[predicateIri].blankNodes) !== null && _d !== void 0 ? _d : [];
    const literalTypes = Object.keys(literals);
    literalTypes.forEach((typeIri) => {
      const typeNode = dataFactory.namedNode(typeIri);
      const literalValues = literals[typeIri];
      literalValues.forEach((value) => {
        const literalNode = dataFactory.literal(value, typeNode);
        quads.push(dataFactory.quad(subjectNode, predicateNode, literalNode, graphNode));
      });
    });
    const locales = Object.keys(langStrings);
    locales.forEach((locale) => {
      const localeValues = langStrings[locale];
      localeValues.forEach((value) => {
        const langStringNode = dataFactory.literal(value, locale);
        quads.push(dataFactory.quad(subjectNode, predicateNode, langStringNode, graphNode));
      });
    });
    namedNodes.forEach((namedNodeIri) => {
      const node = dataFactory.namedNode(namedNodeIri);
      quads.push(dataFactory.quad(subjectNode, predicateNode, node, graphNode));
    });
    blankNodes.forEach((blankNodeIdOrPredicates) => {
      if (isBlankNodeId(blankNodeIdOrPredicates)) {
        const blankNode2 = dataFactory.blankNode(getBlankNodeValue(blankNodeIdOrPredicates));
        quads.push(dataFactory.quad(subjectNode, predicateNode, blankNode2, graphNode));
      } else {
        const node = dataFactory.blankNode();
        const blankNodeObjectQuad = dataFactory.quad(subjectNode, predicateNode, node, graphNode);
        const blankNodeSubjectQuads = subjectToRdfJsQuads(blankNodeIdOrPredicates, node, graphNode);
        quads.push(blankNodeObjectQuad);
        quads.push(...blankNodeSubjectQuads);
      }
    });
  });
  return quads;
}
var init_rdfjs_internal = __esm({
  "node_modules/@inrupt/solid-client/dist/rdfjs.internal.mjs"() {
    init_src();
    init_rdf_internal();
    init_datatypes();
  }
});

// node_modules/@inrupt/solid-client/dist/rdfjs.mjs
function fromRdfJsDataset(dataset) {
  const solidDataset = {
    graphs: { default: {} },
    type: "Dataset"
  };
  return Array.from(dataset).reduce((datasetAcc, quad2) => addRdfJsQuadToDataset(datasetAcc, quad2), solidDataset);
}
function toRdfJsDataset(set3, options = {}) {
  var _a, _b;
  const datasetFactory = (_b = (_a = options.datasetFactory) === null || _a === void 0 ? void 0 : _a.dataset) !== null && _b !== void 0 ? _b : rdfJsDataset;
  return datasetFactory(toRdfJsQuads(set3, options));
}
var init_rdfjs = __esm({
  "node_modules/@inrupt/solid-client/dist/rdfjs.mjs"() {
    init_rdf_internal();
    init_rdfjs_internal();
  }
});

// node_modules/@inrupt/solid-client/dist/formats/solidDatasetAsTurtle.mjs
async function solidDatasetAsTurtle(dataset, options) {
  const { prefixes: prefixes$1 = prefixes, thing } = { ...options };
  const writer = new N3Writer({ format: "application/turtle", prefixes: prefixes$1 });
  const subject = thing ? new NamedNode(thing) : void 0;
  for (const quad2 of toRdfJsDataset(dataset).match(subject)) {
    writer.addQuad(quad2);
  }
  return new Promise((resolve, reject2) => {
    writer.end((error46, result) => {
      if (error46) {
        reject2(error46);
      } else {
        resolve(result);
      }
    });
  });
}
var init_solidDatasetAsTurtle = __esm({
  "node_modules/@inrupt/solid-client/dist/formats/solidDatasetAsTurtle.mjs"() {
    init_src();
    init_prefixes();
    init_rdfjs();
  }
});

// node_modules/@inrupt/solid-client/dist/formats/index.mjs
var formats_exports = {};
__export(formats_exports, {
  getJsonLdParser: () => getJsonLdParser,
  getTurtleParser: () => getTurtleParser,
  solidDatasetAsTurtle: () => solidDatasetAsTurtle
});
var init_formats = __esm({
  "node_modules/@inrupt/solid-client/dist/formats/index.mjs"() {
    init_jsonLd();
    init_turtle();
    init_solidDatasetAsTurtle();
  }
});

// node_modules/@inrupt/solid-client/dist/resource/file.mjs
function containsReserved(header) {
  return RESERVED_HEADERS.some((reserved) => header[reserved] !== void 0);
}
async function getFile(fileUrl, options) {
  var _a;
  const normalizedUrl = normalizeUrl(internal_toIriString(fileUrl), {
    trailingSlash: false
  });
  const response = await ((_a = options === null || options === void 0 ? void 0 : options.fetch) !== null && _a !== void 0 ? _a : fetch)(normalizedUrl, options === null || options === void 0 ? void 0 : options.init);
  if (internal_isUnsuccessfulResponse(response)) {
    const errorBody = await response.clone().text();
    throw new FetchError(`Fetching the File failed: [${response.status}] [${response.statusText}] ${errorBody}.`, response, errorBody);
  }
  const resourceInfo = internal_parseResourceInfo(response);
  const data = await response.blob();
  const fileWithResourceInfo = Object.assign(data, {
    internal_resourceInfo: resourceInfo
  });
  return fileWithResourceInfo;
}
async function deleteFile(file2, options) {
  var _a;
  const url2 = hasResourceInfo(file2) ? internal_toIriString(getSourceIri(file2)) : normalizeUrl(internal_toIriString(file2), { trailingSlash: false });
  const response = await ((_a = options === null || options === void 0 ? void 0 : options.fetch) !== null && _a !== void 0 ? _a : fetch)(url2, {
    ...options === null || options === void 0 ? void 0 : options.init,
    method: "DELETE"
  });
  if (internal_isUnsuccessfulResponse(response)) {
    const errorBody = await response.clone().text();
    throw new FetchError(`Deleting the file at [${url2}] failed: [${response.status}] [${response.statusText}] ${errorBody}.`, response, errorBody);
  }
}
async function overwriteFile(fileUrl, file2, options) {
  const fileUrlString = internal_toIriString(fileUrl);
  const response = await writeFile(fileUrlString, file2, "PUT", options);
  if (internal_isUnsuccessfulResponse(response)) {
    const errorBody = await response.clone().text();
    throw new FetchError(`Overwriting the file at [${fileUrlString}] failed: [${response.status}] [${response.statusText}] ${errorBody}.`, response, errorBody);
  }
  const blobClone = internal_cloneResource(file2);
  const resourceInfo = internal_parseResourceInfo(response);
  resourceInfo.sourceIri = fileUrlString;
  resourceInfo.isRawData = true;
  return Object.assign(blobClone, { internal_resourceInfo: resourceInfo });
}
function isHeadersArray(headers) {
  return Array.isArray(headers);
}
function hasHeadersObjectForEach(headers) {
  return typeof headers.forEach === "function";
}
function flattenHeaders(headersToFlatten) {
  if (typeof headersToFlatten === "undefined") {
    return {};
  }
  let flatHeaders = {};
  if (isHeadersArray(headersToFlatten)) {
    headersToFlatten.forEach(([key, value]) => {
      flatHeaders[key] = value;
    });
  } else if (hasHeadersObjectForEach(headersToFlatten)) {
    headersToFlatten.forEach((value, key) => {
      flatHeaders[key] = value;
    });
  } else {
    flatHeaders = headersToFlatten;
  }
  return flatHeaders;
}
async function writeFile(targetUrl, file2, method, options = {}) {
  var _a, _b, _c;
  const headers = flattenHeaders((_b = (_a = options.init) === null || _a === void 0 ? void 0 : _a.headers) !== null && _b !== void 0 ? _b : {});
  if (containsReserved(headers)) {
    throw new Error(`No reserved header (${RESERVED_HEADERS.join(", ")}) should be set in the optional RequestInit.`);
  }
  if (options.slug !== void 0) {
    headers.Slug = options.slug;
  } else if ("name" in file2 && file2.name !== void 0) {
    headers.Slug = file2.name;
  }
  headers["Content-Type"] = getContentType2(file2, options.contentType);
  return ((_c = options.fetch) !== null && _c !== void 0 ? _c : fetch)(targetUrl, {
    ...options.init,
    headers,
    method,
    body: file2
  });
}
function getContentType2(file2, contentTypeOverride) {
  if (typeof contentTypeOverride === "string") {
    return contentTypeOverride;
  }
  const fileType = typeof file2 === "object" && file2 !== null && "type" in file2 && typeof file2.type === "string" && file2.type.length > 0 ? file2.type : void 0;
  return fileType !== null && fileType !== void 0 ? fileType : "application/octet-stream";
}
var RESERVED_HEADERS;
var init_file = __esm({
  "node_modules/@inrupt/solid-client/dist/resource/file.mjs"() {
    init_interfaces();
    init_interfaces_internal();
    init_resource();
    init_resource_internal();
    RESERVED_HEADERS = ["Slug", "If-None-Match", "Content-Type"];
  }
});

// node_modules/uuid/dist/esm-browser/stringify.js
function unsafeStringify(arr, offset = 0) {
  return (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + "-" + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + "-" + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + "-" + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + "-" + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase();
}
var byteToHex;
var init_stringify = __esm({
  "node_modules/uuid/dist/esm-browser/stringify.js"() {
    byteToHex = [];
    for (let i = 0; i < 256; ++i) {
      byteToHex.push((i + 256).toString(16).slice(1));
    }
  }
});

// node_modules/uuid/dist/esm-browser/rng.js
function rng() {
  if (!getRandomValues) {
    if (typeof crypto === "undefined" || !crypto.getRandomValues) {
      throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
    }
    getRandomValues = crypto.getRandomValues.bind(crypto);
  }
  return getRandomValues(rnds8);
}
var getRandomValues, rnds8;
var init_rng = __esm({
  "node_modules/uuid/dist/esm-browser/rng.js"() {
    rnds8 = new Uint8Array(16);
  }
});

// node_modules/uuid/dist/esm-browser/native.js
var randomUUID, native_default;
var init_native = __esm({
  "node_modules/uuid/dist/esm-browser/native.js"() {
    randomUUID = typeof crypto !== "undefined" && crypto.randomUUID && crypto.randomUUID.bind(crypto);
    native_default = { randomUUID };
  }
});

// node_modules/uuid/dist/esm-browser/v4.js
function v4(options, buf, offset) {
  if (native_default.randomUUID && !buf && !options) {
    return native_default.randomUUID();
  }
  options = options || {};
  const rnds = options.random ?? options.rng?.() ?? rng();
  if (rnds.length < 16) {
    throw new Error("Random bytes length must be >= 16");
  }
  rnds[6] = rnds[6] & 15 | 64;
  rnds[8] = rnds[8] & 63 | 128;
  if (buf) {
    offset = offset || 0;
    if (offset < 0 || offset + 16 > buf.length) {
      throw new RangeError(`UUID byte range ${offset}:${offset + 15} is out of buffer bounds`);
    }
    for (let i = 0; i < 16; ++i) {
      buf[offset + i] = rnds[i];
    }
    return buf;
  }
  return unsafeStringify(rnds);
}
var v4_default;
var init_v4 = __esm({
  "node_modules/uuid/dist/esm-browser/v4.js"() {
    init_native();
    init_rng();
    init_stringify();
    v4_default = v4;
  }
});

// node_modules/uuid/dist/esm-browser/index.js
var init_esm_browser = __esm({
  "node_modules/uuid/dist/esm-browser/index.js"() {
    init_v4();
  }
});

// node_modules/@inrupt/solid-client/dist/thing/thing.internal.mjs
function internal_throwIfNotThing(thing) {
  if (!isThing(thing)) {
    throw new ThingExpectedError(thing);
  }
}
var init_thing_internal = __esm({
  "node_modules/@inrupt/solid-client/dist/thing/thing.internal.mjs"() {
    init_thing();
  }
});

// node_modules/@inrupt/solid-client/dist/thing/get.mjs
function getUrlAll(thing, property) {
  var _a, _b, _c;
  internal_throwIfNotThing(thing);
  if (!internal_isValidUrl(property)) {
    throw new ValidPropertyUrlExpectedError(property);
  }
  const predicateUrl = internal_toIriString(property);
  return (_c = (_b = (_a = thing.predicates[predicateUrl]) === null || _a === void 0 ? void 0 : _a.namedNodes) === null || _b === void 0 ? void 0 : _b.map((iri) => isLocalNodeIri(iri) ? `#${getLocalNodeName(iri)}` : iri)) !== null && _c !== void 0 ? _c : [];
}
var getIriAll;
var init_get = __esm({
  "node_modules/@inrupt/solid-client/dist/thing/get.mjs"() {
    init_datatypes();
    init_thing_internal();
    init_thing();
    init_interfaces_internal();
    init_rdf_internal();
    getIriAll = getUrlAll;
  }
});

// node_modules/@inrupt/solid-client/dist/thing/thing.mjs
function getThing(solidDataset, thingUrl, options = {}) {
  var _a;
  if (!internal_isValidUrl(thingUrl) && !thingUrl.match(/^_:/)) {
    throw new ValidThingUrlExpectedError(thingUrl);
  }
  const graph = typeof options.scope !== "undefined" ? internal_toIriString(options.scope) : "default";
  const thingsByIri = (_a = solidDataset.graphs[graph]) !== null && _a !== void 0 ? _a : {};
  const thingIri = internal_toIriString(thingUrl);
  const resolvedThingIri = isLocalNodeIri(thingIri) && hasServerResourceInfo(solidDataset) ? resolveLocalIri(getLocalNodeName(thingIri), getSourceUrl(solidDataset)) : thingIri;
  const thing = thingsByIri[resolvedThingIri];
  if (typeof thing === "undefined") {
    return null;
  }
  return thing;
}
function isThing(input) {
  return typeof input === "object" && input !== null && typeof input.type === "string" && input.type === "Subject";
}
var ThingExpectedError, ValidPropertyUrlExpectedError, ValidThingUrlExpectedError;
var init_thing = __esm({
  "node_modules/@inrupt/solid-client/dist/thing/thing.mjs"() {
    init_datatypes();
    init_interfaces();
    init_resource();
    init_rdf_internal();
    init_interfaces_internal();
    ThingExpectedError = class extends SolidClientError {
      constructor(receivedValue) {
        const message2 = `Expected a Thing, but received: [${receivedValue}].`;
        super(message2);
        this.receivedValue = receivedValue;
      }
    };
    ValidPropertyUrlExpectedError = class extends SolidClientError {
      constructor(receivedValue) {
        const value = isNamedNode(receivedValue) ? receivedValue.value : receivedValue;
        const message2 = `Expected a valid URL to identify a property, but received: [${value}].`;
        super(message2);
        this.receivedProperty = value;
      }
    };
    ValidThingUrlExpectedError = class extends SolidClientError {
      constructor(receivedValue) {
        const value = isNamedNode(receivedValue) ? receivedValue.value : receivedValue;
        const message2 = `Expected a valid URL to identify a Thing, but received: [${value}].`;
        super(message2);
        this.receivedValue = value;
      }
    };
  }
});

// node_modules/@inrupt/solid-client/dist/resource/solidDataset.mjs
function createSolidDataset() {
  return freeze({
    type: "Dataset",
    graphs: {
      default: {}
    }
  });
}
async function responseToSolidDataset(response, parseOptions = {}) {
  if (internal_isUnsuccessfulResponse(response)) {
    const errorBody = await response.clone().text();
    throw new FetchError(`Fetching the SolidDataset at [${response.url}] failed: [${response.status}] [${response.statusText}] ${errorBody}.`, response, errorBody);
  }
  const resourceInfo = responseToResourceInfo(response);
  const parsers = {
    "text/turtle": getTurtleParser(),
    ...parseOptions.parsers
  };
  const contentType = getContentType(resourceInfo);
  if (contentType === null) {
    throw new Error(`Could not determine the content type of the Resource at [${getSourceUrl(resourceInfo)}].`);
  }
  const mimeType = contentType.split(";")[0];
  const parser = parsers[mimeType];
  if (typeof parser === "undefined") {
    throw new Error(`The Resource at [${getSourceUrl(resourceInfo)}] has a MIME type of [${mimeType}], but the only parsers available are for the following MIME types: [${Object.keys(parsers).join(", ")}].`);
  }
  const data = await response.text();
  const rdfjsDataset = await new Promise((resolve, reject2) => {
    const store = new N3Store();
    parser.onError((error46) => {
      reject2(new Error(`Encountered an error parsing the Resource at [${getSourceUrl(resourceInfo)}] with content type [${contentType}]: ${error46}`));
    });
    parser.onQuad((quad2) => {
      store.add(quad2);
    });
    parser.onComplete(() => {
      resolve(store);
    });
    parser.parse(data, resourceInfo);
  });
  const solidDataset = freeze(fromRdfJsDataset(rdfjsDataset));
  return freeze({
    ...solidDataset,
    ...resourceInfo
  });
}
async function getSolidDataset(url2, options) {
  var _a, _b;
  const normalizedUrl = normalizeUrl(internal_toIriString(url2));
  const parserContentTypes = Object.keys((_a = options === null || options === void 0 ? void 0 : options.parsers) !== null && _a !== void 0 ? _a : {});
  const acceptedContentTypes = parserContentTypes.length > 0 ? parserContentTypes.join(", ") : "text/turtle";
  const response = await ((_b = options === null || options === void 0 ? void 0 : options.fetch) !== null && _b !== void 0 ? _b : fetch)(normalizedUrl, {
    headers: {
      Accept: acceptedContentTypes
    }
  });
  if (internal_isUnsuccessfulResponse(response)) {
    const errorBody = await response.clone().text();
    throw new FetchError(`Fetching the Resource at [${normalizedUrl}] failed: [${response.status}] [${response.statusText}] ${errorBody}.`, response, errorBody);
  }
  const solidDataset = await responseToSolidDataset(response, options);
  return solidDataset;
}
async function createContainerAt(url2, options = {}) {
  var _a, _b;
  const normalizedUrl = normalizeUrl(internal_toIriString(url2), {
    trailingSlash: true
  });
  const response = await ((_a = options.fetch) !== null && _a !== void 0 ? _a : fetch)(normalizedUrl, {
    method: "PUT",
    body: options.initialContent ? await triplesToTurtle(toRdfJsQuads(options.initialContent).map(getNamedNodesForLocalNodes)) : void 0,
    headers: {
      Accept: "text/turtle",
      "Content-Type": "text/turtle",
      "If-None-Match": "*",
      // This header should not be required to create a Container,
      // but ESS currently expects it:
      Link: `<${ldp.BasicContainer}>; rel="type"`
    }
  });
  if (internal_isUnsuccessfulResponse(response)) {
    const containerType = options.initialContent === void 0 ? "empty" : "non-empty";
    const errorBody = await response.clone().text();
    throw new FetchError(`Creating the ${containerType} Container at [${url2}] failed: [${response.status}] [${response.statusText}] ${errorBody}.`, response, errorBody);
  }
  const resourceInfo = internal_parseResourceInfo(response);
  const containerDataset = freeze({
    ...(_b = options.initialContent) !== null && _b !== void 0 ? _b : createSolidDataset(),
    internal_changeLog: { additions: [], deletions: [] },
    internal_resourceInfo: resourceInfo
  });
  return containerDataset;
}
function isChildResource(a, b) {
  const parent = new URL(b);
  const child = new URL(a);
  const isAncestor = child.href.startsWith(parent.href);
  const relativePath = child.pathname.substring(parent.pathname.length, child.pathname.length).replace(/(^\/)|(\/$)/g, "");
  return isAncestor && relativePath.length >= 1 && !relativePath.includes("/");
}
function getContainedResourceUrlAll(solidDataset) {
  const containerUrl = getSourceUrl(solidDataset);
  const container = getThing(solidDataset, containerUrl);
  if (container === null) {
    return [];
  }
  return getIriAll(container, ldp.contains).filter((childUrl) => isChildResource(childUrl, containerUrl));
}
function getNamedNodesForLocalNodes(quad2) {
  const subject = isNamedNode(quad2.subject) ? getNamedNodeFromLocalNode(quad2.subject) : (
    /* istanbul ignore next: We don't allow non-NamedNodes as the Subject, so this code path should never be hit: */
    quad2.subject
  );
  const object2 = isNamedNode(quad2.object) ? getNamedNodeFromLocalNode(quad2.object) : quad2.object;
  return N3DataFactory_default.quad(subject, quad2.predicate, object2, quad2.graph);
}
function getNamedNodeFromLocalNode(node) {
  if (isLocalNodeIri(node.value)) {
    return N3DataFactory_default.namedNode(`#${getLocalNodeName(node.value)}`);
  }
  return node;
}
var init_solidDataset = __esm({
  "node_modules/@inrupt/solid-client/dist/resource/solidDataset.mjs"() {
    init_src();
    init_rdfjs_internal();
    init_constants();
    init_turtle();
    init_datatypes();
    init_interfaces_internal();
    init_resource();
    init_resource_internal();
    init_thing();
    init_get();
    init_rdf_internal();
    init_rdfjs();
  }
});

// node_modules/@inrupt/solid-client/dist/index.mjs
var getJsonLdParser2, getTurtleParser2, solidDatasetAsTurtle2;
var init_dist2 = __esm({
  "node_modules/@inrupt/solid-client/dist/index.mjs"() {
    init_formats();
    init_file();
    init_solidDataset();
    ({ getJsonLdParser: getJsonLdParser2, getTurtleParser: getTurtleParser2, solidDatasetAsTurtle: solidDatasetAsTurtle2 } = formats_exports);
  }
});

// node_modules/jose/dist/browser/runtime/webcrypto.js
var webcrypto_default, isCryptoKey;
var init_webcrypto = __esm({
  "node_modules/jose/dist/browser/runtime/webcrypto.js"() {
    webcrypto_default = crypto;
    isCryptoKey = (key) => key instanceof CryptoKey;
  }
});

// node_modules/jose/dist/browser/lib/buffer_utils.js
function concat(...buffers) {
  const size = buffers.reduce((acc, { length }) => acc + length, 0);
  const buf = new Uint8Array(size);
  let i = 0;
  for (const buffer of buffers) {
    buf.set(buffer, i);
    i += buffer.length;
  }
  return buf;
}
var encoder, decoder, MAX_INT32;
var init_buffer_utils = __esm({
  "node_modules/jose/dist/browser/lib/buffer_utils.js"() {
    encoder = new TextEncoder();
    decoder = new TextDecoder();
    MAX_INT32 = 2 ** 32;
  }
});

// node_modules/jose/dist/browser/runtime/base64url.js
var encodeBase64, encode, decodeBase64, decode;
var init_base64url = __esm({
  "node_modules/jose/dist/browser/runtime/base64url.js"() {
    init_buffer_utils();
    encodeBase64 = (input) => {
      let unencoded = input;
      if (typeof unencoded === "string") {
        unencoded = encoder.encode(unencoded);
      }
      const CHUNK_SIZE = 32768;
      const arr = [];
      for (let i = 0; i < unencoded.length; i += CHUNK_SIZE) {
        arr.push(String.fromCharCode.apply(null, unencoded.subarray(i, i + CHUNK_SIZE)));
      }
      return btoa(arr.join(""));
    };
    encode = (input) => {
      return encodeBase64(input).replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
    };
    decodeBase64 = (encoded) => {
      const binary2 = atob(encoded);
      const bytes = new Uint8Array(binary2.length);
      for (let i = 0; i < binary2.length; i++) {
        bytes[i] = binary2.charCodeAt(i);
      }
      return bytes;
    };
    decode = (input) => {
      let encoded = input;
      if (encoded instanceof Uint8Array) {
        encoded = decoder.decode(encoded);
      }
      encoded = encoded.replace(/-/g, "+").replace(/_/g, "/").replace(/\s/g, "");
      try {
        return decodeBase64(encoded);
      } catch {
        throw new TypeError("The input to be decoded is not correctly encoded.");
      }
    };
  }
});

// node_modules/jose/dist/browser/util/errors.js
var JOSEError, JWTClaimValidationFailed, JWTExpired, JOSEAlgNotAllowed, JOSENotSupported, JWEDecryptionFailed, JWEInvalid, JWSInvalid, JWTInvalid, JWKInvalid, JWKSInvalid, JWKSNoMatchingKey, JWKSMultipleMatchingKeys, JWKSTimeout, JWSSignatureVerificationFailed;
var init_errors = __esm({
  "node_modules/jose/dist/browser/util/errors.js"() {
    JOSEError = class extends Error {
      constructor(message2, options) {
        super(message2, options);
        this.code = "ERR_JOSE_GENERIC";
        this.name = this.constructor.name;
        Error.captureStackTrace?.(this, this.constructor);
      }
    };
    JOSEError.code = "ERR_JOSE_GENERIC";
    JWTClaimValidationFailed = class extends JOSEError {
      constructor(message2, payload, claim = "unspecified", reason = "unspecified") {
        super(message2, { cause: { claim, reason, payload } });
        this.code = "ERR_JWT_CLAIM_VALIDATION_FAILED";
        this.claim = claim;
        this.reason = reason;
        this.payload = payload;
      }
    };
    JWTClaimValidationFailed.code = "ERR_JWT_CLAIM_VALIDATION_FAILED";
    JWTExpired = class extends JOSEError {
      constructor(message2, payload, claim = "unspecified", reason = "unspecified") {
        super(message2, { cause: { claim, reason, payload } });
        this.code = "ERR_JWT_EXPIRED";
        this.claim = claim;
        this.reason = reason;
        this.payload = payload;
      }
    };
    JWTExpired.code = "ERR_JWT_EXPIRED";
    JOSEAlgNotAllowed = class extends JOSEError {
      constructor() {
        super(...arguments);
        this.code = "ERR_JOSE_ALG_NOT_ALLOWED";
      }
    };
    JOSEAlgNotAllowed.code = "ERR_JOSE_ALG_NOT_ALLOWED";
    JOSENotSupported = class extends JOSEError {
      constructor() {
        super(...arguments);
        this.code = "ERR_JOSE_NOT_SUPPORTED";
      }
    };
    JOSENotSupported.code = "ERR_JOSE_NOT_SUPPORTED";
    JWEDecryptionFailed = class extends JOSEError {
      constructor(message2 = "decryption operation failed", options) {
        super(message2, options);
        this.code = "ERR_JWE_DECRYPTION_FAILED";
      }
    };
    JWEDecryptionFailed.code = "ERR_JWE_DECRYPTION_FAILED";
    JWEInvalid = class extends JOSEError {
      constructor() {
        super(...arguments);
        this.code = "ERR_JWE_INVALID";
      }
    };
    JWEInvalid.code = "ERR_JWE_INVALID";
    JWSInvalid = class extends JOSEError {
      constructor() {
        super(...arguments);
        this.code = "ERR_JWS_INVALID";
      }
    };
    JWSInvalid.code = "ERR_JWS_INVALID";
    JWTInvalid = class extends JOSEError {
      constructor() {
        super(...arguments);
        this.code = "ERR_JWT_INVALID";
      }
    };
    JWTInvalid.code = "ERR_JWT_INVALID";
    JWKInvalid = class extends JOSEError {
      constructor() {
        super(...arguments);
        this.code = "ERR_JWK_INVALID";
      }
    };
    JWKInvalid.code = "ERR_JWK_INVALID";
    JWKSInvalid = class extends JOSEError {
      constructor() {
        super(...arguments);
        this.code = "ERR_JWKS_INVALID";
      }
    };
    JWKSInvalid.code = "ERR_JWKS_INVALID";
    JWKSNoMatchingKey = class extends JOSEError {
      constructor(message2 = "no applicable key found in the JSON Web Key Set", options) {
        super(message2, options);
        this.code = "ERR_JWKS_NO_MATCHING_KEY";
      }
    };
    JWKSNoMatchingKey.code = "ERR_JWKS_NO_MATCHING_KEY";
    JWKSMultipleMatchingKeys = class extends JOSEError {
      constructor(message2 = "multiple matching keys found in the JSON Web Key Set", options) {
        super(message2, options);
        this.code = "ERR_JWKS_MULTIPLE_MATCHING_KEYS";
      }
    };
    JWKSMultipleMatchingKeys.code = "ERR_JWKS_MULTIPLE_MATCHING_KEYS";
    JWKSTimeout = class extends JOSEError {
      constructor(message2 = "request timed out", options) {
        super(message2, options);
        this.code = "ERR_JWKS_TIMEOUT";
      }
    };
    JWKSTimeout.code = "ERR_JWKS_TIMEOUT";
    JWSSignatureVerificationFailed = class extends JOSEError {
      constructor(message2 = "signature verification failed", options) {
        super(message2, options);
        this.code = "ERR_JWS_SIGNATURE_VERIFICATION_FAILED";
      }
    };
    JWSSignatureVerificationFailed.code = "ERR_JWS_SIGNATURE_VERIFICATION_FAILED";
  }
});

// node_modules/jose/dist/browser/lib/crypto_key.js
function unusable(name, prop = "algorithm.name") {
  return new TypeError(`CryptoKey does not support this operation, its ${prop} must be ${name}`);
}
function isAlgorithm(algorithm, name) {
  return algorithm.name === name;
}
function getHashLength(hash2) {
  return parseInt(hash2.name.slice(4), 10);
}
function getNamedCurve(alg) {
  switch (alg) {
    case "ES256":
      return "P-256";
    case "ES384":
      return "P-384";
    case "ES512":
      return "P-521";
    default:
      throw new Error("unreachable");
  }
}
function checkUsage(key, usages) {
  if (usages.length && !usages.some((expected) => key.usages.includes(expected))) {
    let msg = "CryptoKey does not support this operation, its usages must include ";
    if (usages.length > 2) {
      const last = usages.pop();
      msg += `one of ${usages.join(", ")}, or ${last}.`;
    } else if (usages.length === 2) {
      msg += `one of ${usages[0]} or ${usages[1]}.`;
    } else {
      msg += `${usages[0]}.`;
    }
    throw new TypeError(msg);
  }
}
function checkSigCryptoKey(key, alg, ...usages) {
  switch (alg) {
    case "HS256":
    case "HS384":
    case "HS512": {
      if (!isAlgorithm(key.algorithm, "HMAC"))
        throw unusable("HMAC");
      const expected = parseInt(alg.slice(2), 10);
      const actual = getHashLength(key.algorithm.hash);
      if (actual !== expected)
        throw unusable(`SHA-${expected}`, "algorithm.hash");
      break;
    }
    case "RS256":
    case "RS384":
    case "RS512": {
      if (!isAlgorithm(key.algorithm, "RSASSA-PKCS1-v1_5"))
        throw unusable("RSASSA-PKCS1-v1_5");
      const expected = parseInt(alg.slice(2), 10);
      const actual = getHashLength(key.algorithm.hash);
      if (actual !== expected)
        throw unusable(`SHA-${expected}`, "algorithm.hash");
      break;
    }
    case "PS256":
    case "PS384":
    case "PS512": {
      if (!isAlgorithm(key.algorithm, "RSA-PSS"))
        throw unusable("RSA-PSS");
      const expected = parseInt(alg.slice(2), 10);
      const actual = getHashLength(key.algorithm.hash);
      if (actual !== expected)
        throw unusable(`SHA-${expected}`, "algorithm.hash");
      break;
    }
    case "EdDSA": {
      if (key.algorithm.name !== "Ed25519" && key.algorithm.name !== "Ed448") {
        throw unusable("Ed25519 or Ed448");
      }
      break;
    }
    case "Ed25519": {
      if (!isAlgorithm(key.algorithm, "Ed25519"))
        throw unusable("Ed25519");
      break;
    }
    case "ES256":
    case "ES384":
    case "ES512": {
      if (!isAlgorithm(key.algorithm, "ECDSA"))
        throw unusable("ECDSA");
      const expected = getNamedCurve(alg);
      const actual = key.algorithm.namedCurve;
      if (actual !== expected)
        throw unusable(expected, "algorithm.namedCurve");
      break;
    }
    default:
      throw new TypeError("CryptoKey does not support this operation");
  }
  checkUsage(key, usages);
}
var init_crypto_key = __esm({
  "node_modules/jose/dist/browser/lib/crypto_key.js"() {
  }
});

// node_modules/jose/dist/browser/lib/invalid_key_input.js
function message(msg, actual, ...types3) {
  types3 = types3.filter(Boolean);
  if (types3.length > 2) {
    const last = types3.pop();
    msg += `one of type ${types3.join(", ")}, or ${last}.`;
  } else if (types3.length === 2) {
    msg += `one of type ${types3[0]} or ${types3[1]}.`;
  } else {
    msg += `of type ${types3[0]}.`;
  }
  if (actual == null) {
    msg += ` Received ${actual}`;
  } else if (typeof actual === "function" && actual.name) {
    msg += ` Received function ${actual.name}`;
  } else if (typeof actual === "object" && actual != null) {
    if (actual.constructor?.name) {
      msg += ` Received an instance of ${actual.constructor.name}`;
    }
  }
  return msg;
}
function withAlg(alg, actual, ...types3) {
  return message(`Key for the ${alg} algorithm must be `, actual, ...types3);
}
var invalid_key_input_default;
var init_invalid_key_input = __esm({
  "node_modules/jose/dist/browser/lib/invalid_key_input.js"() {
    invalid_key_input_default = (actual, ...types3) => {
      return message("Key must be ", actual, ...types3);
    };
  }
});

// node_modules/jose/dist/browser/runtime/is_key_like.js
var is_key_like_default, types;
var init_is_key_like = __esm({
  "node_modules/jose/dist/browser/runtime/is_key_like.js"() {
    init_webcrypto();
    is_key_like_default = (key) => {
      if (isCryptoKey(key)) {
        return true;
      }
      return key?.[Symbol.toStringTag] === "KeyObject";
    };
    types = ["CryptoKey"];
  }
});

// node_modules/jose/dist/browser/lib/is_disjoint.js
var isDisjoint, is_disjoint_default;
var init_is_disjoint = __esm({
  "node_modules/jose/dist/browser/lib/is_disjoint.js"() {
    isDisjoint = (...headers) => {
      const sources = headers.filter(Boolean);
      if (sources.length === 0 || sources.length === 1) {
        return true;
      }
      let acc;
      for (const header of sources) {
        const parameters = Object.keys(header);
        if (!acc || acc.size === 0) {
          acc = new Set(parameters);
          continue;
        }
        for (const parameter of parameters) {
          if (acc.has(parameter)) {
            return false;
          }
          acc.add(parameter);
        }
      }
      return true;
    };
    is_disjoint_default = isDisjoint;
  }
});

// node_modules/jose/dist/browser/lib/is_object.js
function isObjectLike(value) {
  return typeof value === "object" && value !== null;
}
function isObject(input) {
  if (!isObjectLike(input) || Object.prototype.toString.call(input) !== "[object Object]") {
    return false;
  }
  if (Object.getPrototypeOf(input) === null) {
    return true;
  }
  let proto = input;
  while (Object.getPrototypeOf(proto) !== null) {
    proto = Object.getPrototypeOf(proto);
  }
  return Object.getPrototypeOf(input) === proto;
}
var init_is_object = __esm({
  "node_modules/jose/dist/browser/lib/is_object.js"() {
  }
});

// node_modules/jose/dist/browser/runtime/check_key_length.js
var check_key_length_default;
var init_check_key_length = __esm({
  "node_modules/jose/dist/browser/runtime/check_key_length.js"() {
    check_key_length_default = (alg, key) => {
      if (alg.startsWith("RS") || alg.startsWith("PS")) {
        const { modulusLength } = key.algorithm;
        if (typeof modulusLength !== "number" || modulusLength < 2048) {
          throw new TypeError(`${alg} requires key modulusLength to be 2048 bits or larger`);
        }
      }
    };
  }
});

// node_modules/jose/dist/browser/lib/is_jwk.js
function isJWK(key) {
  return isObject(key) && typeof key.kty === "string";
}
function isPrivateJWK(key) {
  return key.kty !== "oct" && typeof key.d === "string";
}
function isPublicJWK(key) {
  return key.kty !== "oct" && typeof key.d === "undefined";
}
function isSecretJWK(key) {
  return isJWK(key) && key.kty === "oct" && typeof key.k === "string";
}
var init_is_jwk = __esm({
  "node_modules/jose/dist/browser/lib/is_jwk.js"() {
    init_is_object();
  }
});

// node_modules/jose/dist/browser/runtime/jwk_to_key.js
function subtleMapping(jwk) {
  let algorithm;
  let keyUsages;
  switch (jwk.kty) {
    case "RSA": {
      switch (jwk.alg) {
        case "PS256":
        case "PS384":
        case "PS512":
          algorithm = { name: "RSA-PSS", hash: `SHA-${jwk.alg.slice(-3)}` };
          keyUsages = jwk.d ? ["sign"] : ["verify"];
          break;
        case "RS256":
        case "RS384":
        case "RS512":
          algorithm = { name: "RSASSA-PKCS1-v1_5", hash: `SHA-${jwk.alg.slice(-3)}` };
          keyUsages = jwk.d ? ["sign"] : ["verify"];
          break;
        case "RSA-OAEP":
        case "RSA-OAEP-256":
        case "RSA-OAEP-384":
        case "RSA-OAEP-512":
          algorithm = {
            name: "RSA-OAEP",
            hash: `SHA-${parseInt(jwk.alg.slice(-3), 10) || 1}`
          };
          keyUsages = jwk.d ? ["decrypt", "unwrapKey"] : ["encrypt", "wrapKey"];
          break;
        default:
          throw new JOSENotSupported('Invalid or unsupported JWK "alg" (Algorithm) Parameter value');
      }
      break;
    }
    case "EC": {
      switch (jwk.alg) {
        case "ES256":
          algorithm = { name: "ECDSA", namedCurve: "P-256" };
          keyUsages = jwk.d ? ["sign"] : ["verify"];
          break;
        case "ES384":
          algorithm = { name: "ECDSA", namedCurve: "P-384" };
          keyUsages = jwk.d ? ["sign"] : ["verify"];
          break;
        case "ES512":
          algorithm = { name: "ECDSA", namedCurve: "P-521" };
          keyUsages = jwk.d ? ["sign"] : ["verify"];
          break;
        case "ECDH-ES":
        case "ECDH-ES+A128KW":
        case "ECDH-ES+A192KW":
        case "ECDH-ES+A256KW":
          algorithm = { name: "ECDH", namedCurve: jwk.crv };
          keyUsages = jwk.d ? ["deriveBits"] : [];
          break;
        default:
          throw new JOSENotSupported('Invalid or unsupported JWK "alg" (Algorithm) Parameter value');
      }
      break;
    }
    case "OKP": {
      switch (jwk.alg) {
        case "Ed25519":
          algorithm = { name: "Ed25519" };
          keyUsages = jwk.d ? ["sign"] : ["verify"];
          break;
        case "EdDSA":
          algorithm = { name: jwk.crv };
          keyUsages = jwk.d ? ["sign"] : ["verify"];
          break;
        case "ECDH-ES":
        case "ECDH-ES+A128KW":
        case "ECDH-ES+A192KW":
        case "ECDH-ES+A256KW":
          algorithm = { name: jwk.crv };
          keyUsages = jwk.d ? ["deriveBits"] : [];
          break;
        default:
          throw new JOSENotSupported('Invalid or unsupported JWK "alg" (Algorithm) Parameter value');
      }
      break;
    }
    default:
      throw new JOSENotSupported('Invalid or unsupported JWK "kty" (Key Type) Parameter value');
  }
  return { algorithm, keyUsages };
}
var parse, jwk_to_key_default;
var init_jwk_to_key = __esm({
  "node_modules/jose/dist/browser/runtime/jwk_to_key.js"() {
    init_webcrypto();
    init_errors();
    parse = async (jwk) => {
      if (!jwk.alg) {
        throw new TypeError('"alg" argument is required when "jwk.alg" is not present');
      }
      const { algorithm, keyUsages } = subtleMapping(jwk);
      const rest = [
        algorithm,
        jwk.ext ?? false,
        jwk.key_ops ?? keyUsages
      ];
      const keyData = { ...jwk };
      delete keyData.alg;
      delete keyData.use;
      return webcrypto_default.subtle.importKey("jwk", keyData, ...rest);
    };
    jwk_to_key_default = parse;
  }
});

// node_modules/jose/dist/browser/runtime/normalize_key.js
var exportKeyValue, privCache, pubCache, isKeyObject, importAndCache, normalizePublicKey, normalizePrivateKey, normalize_key_default;
var init_normalize_key = __esm({
  "node_modules/jose/dist/browser/runtime/normalize_key.js"() {
    init_is_jwk();
    init_base64url();
    init_jwk_to_key();
    exportKeyValue = (k) => decode(k);
    isKeyObject = (key) => {
      return key?.[Symbol.toStringTag] === "KeyObject";
    };
    importAndCache = async (cache, key, jwk, alg, freeze2 = false) => {
      let cached2 = cache.get(key);
      if (cached2?.[alg]) {
        return cached2[alg];
      }
      const cryptoKey = await jwk_to_key_default({ ...jwk, alg });
      if (freeze2)
        Object.freeze(key);
      if (!cached2) {
        cache.set(key, { [alg]: cryptoKey });
      } else {
        cached2[alg] = cryptoKey;
      }
      return cryptoKey;
    };
    normalizePublicKey = (key, alg) => {
      if (isKeyObject(key)) {
        let jwk = key.export({ format: "jwk" });
        delete jwk.d;
        delete jwk.dp;
        delete jwk.dq;
        delete jwk.p;
        delete jwk.q;
        delete jwk.qi;
        if (jwk.k) {
          return exportKeyValue(jwk.k);
        }
        pubCache || (pubCache = /* @__PURE__ */ new WeakMap());
        return importAndCache(pubCache, key, jwk, alg);
      }
      if (isJWK(key)) {
        if (key.k)
          return decode(key.k);
        pubCache || (pubCache = /* @__PURE__ */ new WeakMap());
        const cryptoKey = importAndCache(pubCache, key, key, alg, true);
        return cryptoKey;
      }
      return key;
    };
    normalizePrivateKey = (key, alg) => {
      if (isKeyObject(key)) {
        let jwk = key.export({ format: "jwk" });
        if (jwk.k) {
          return exportKeyValue(jwk.k);
        }
        privCache || (privCache = /* @__PURE__ */ new WeakMap());
        return importAndCache(privCache, key, jwk, alg);
      }
      if (isJWK(key)) {
        if (key.k)
          return decode(key.k);
        privCache || (privCache = /* @__PURE__ */ new WeakMap());
        const cryptoKey = importAndCache(privCache, key, key, alg, true);
        return cryptoKey;
      }
      return key;
    };
    normalize_key_default = { normalizePublicKey, normalizePrivateKey };
  }
});

// node_modules/jose/dist/browser/key/import.js
async function importJWK(jwk, alg) {
  if (!isObject(jwk)) {
    throw new TypeError("JWK must be an object");
  }
  alg || (alg = jwk.alg);
  switch (jwk.kty) {
    case "oct":
      if (typeof jwk.k !== "string" || !jwk.k) {
        throw new TypeError('missing "k" (Key Value) Parameter value');
      }
      return decode(jwk.k);
    case "RSA":
      if ("oth" in jwk && jwk.oth !== void 0) {
        throw new JOSENotSupported('RSA JWK "oth" (Other Primes Info) Parameter value is not supported');
      }
    case "EC":
    case "OKP":
      return jwk_to_key_default({ ...jwk, alg });
    default:
      throw new JOSENotSupported('Unsupported "kty" (Key Type) Parameter value');
  }
}
var init_import = __esm({
  "node_modules/jose/dist/browser/key/import.js"() {
    init_base64url();
    init_jwk_to_key();
    init_errors();
    init_is_object();
  }
});

// node_modules/jose/dist/browser/lib/check_key_type.js
function checkKeyType(allowJwk, alg, key, usage) {
  const symmetric = alg.startsWith("HS") || alg === "dir" || alg.startsWith("PBES2") || /^A\d{3}(?:GCM)?KW$/.test(alg);
  if (symmetric) {
    symmetricTypeCheck(alg, key, usage, allowJwk);
  } else {
    asymmetricTypeCheck(alg, key, usage, allowJwk);
  }
}
var tag, jwkMatchesOp, symmetricTypeCheck, asymmetricTypeCheck, check_key_type_default, checkKeyTypeWithJwk;
var init_check_key_type = __esm({
  "node_modules/jose/dist/browser/lib/check_key_type.js"() {
    init_invalid_key_input();
    init_is_key_like();
    init_is_jwk();
    tag = (key) => key?.[Symbol.toStringTag];
    jwkMatchesOp = (alg, key, usage) => {
      if (key.use !== void 0 && key.use !== "sig") {
        throw new TypeError("Invalid key for this operation, when present its use must be sig");
      }
      if (key.key_ops !== void 0 && key.key_ops.includes?.(usage) !== true) {
        throw new TypeError(`Invalid key for this operation, when present its key_ops must include ${usage}`);
      }
      if (key.alg !== void 0 && key.alg !== alg) {
        throw new TypeError(`Invalid key for this operation, when present its alg must be ${alg}`);
      }
      return true;
    };
    symmetricTypeCheck = (alg, key, usage, allowJwk) => {
      if (key instanceof Uint8Array)
        return;
      if (allowJwk && isJWK(key)) {
        if (isSecretJWK(key) && jwkMatchesOp(alg, key, usage))
          return;
        throw new TypeError(`JSON Web Key for symmetric algorithms must have JWK "kty" (Key Type) equal to "oct" and the JWK "k" (Key Value) present`);
      }
      if (!is_key_like_default(key)) {
        throw new TypeError(withAlg(alg, key, ...types, "Uint8Array", allowJwk ? "JSON Web Key" : null));
      }
      if (key.type !== "secret") {
        throw new TypeError(`${tag(key)} instances for symmetric algorithms must be of type "secret"`);
      }
    };
    asymmetricTypeCheck = (alg, key, usage, allowJwk) => {
      if (allowJwk && isJWK(key)) {
        switch (usage) {
          case "sign":
            if (isPrivateJWK(key) && jwkMatchesOp(alg, key, usage))
              return;
            throw new TypeError(`JSON Web Key for this operation be a private JWK`);
          case "verify":
            if (isPublicJWK(key) && jwkMatchesOp(alg, key, usage))
              return;
            throw new TypeError(`JSON Web Key for this operation be a public JWK`);
        }
      }
      if (!is_key_like_default(key)) {
        throw new TypeError(withAlg(alg, key, ...types, allowJwk ? "JSON Web Key" : null));
      }
      if (key.type === "secret") {
        throw new TypeError(`${tag(key)} instances for asymmetric algorithms must not be of type "secret"`);
      }
      if (usage === "sign" && key.type === "public") {
        throw new TypeError(`${tag(key)} instances for asymmetric algorithm signing must be of type "private"`);
      }
      if (usage === "decrypt" && key.type === "public") {
        throw new TypeError(`${tag(key)} instances for asymmetric algorithm decryption must be of type "private"`);
      }
      if (key.algorithm && usage === "verify" && key.type === "private") {
        throw new TypeError(`${tag(key)} instances for asymmetric algorithm verifying must be of type "public"`);
      }
      if (key.algorithm && usage === "encrypt" && key.type === "private") {
        throw new TypeError(`${tag(key)} instances for asymmetric algorithm encryption must be of type "public"`);
      }
    };
    check_key_type_default = checkKeyType.bind(void 0, false);
    checkKeyTypeWithJwk = checkKeyType.bind(void 0, true);
  }
});

// node_modules/jose/dist/browser/lib/validate_crit.js
function validateCrit(Err, recognizedDefault, recognizedOption, protectedHeader, joseHeader) {
  if (joseHeader.crit !== void 0 && protectedHeader?.crit === void 0) {
    throw new Err('"crit" (Critical) Header Parameter MUST be integrity protected');
  }
  if (!protectedHeader || protectedHeader.crit === void 0) {
    return /* @__PURE__ */ new Set();
  }
  if (!Array.isArray(protectedHeader.crit) || protectedHeader.crit.length === 0 || protectedHeader.crit.some((input) => typeof input !== "string" || input.length === 0)) {
    throw new Err('"crit" (Critical) Header Parameter MUST be an array of non-empty strings when present');
  }
  let recognized;
  if (recognizedOption !== void 0) {
    recognized = new Map([...Object.entries(recognizedOption), ...recognizedDefault.entries()]);
  } else {
    recognized = recognizedDefault;
  }
  for (const parameter of protectedHeader.crit) {
    if (!recognized.has(parameter)) {
      throw new JOSENotSupported(`Extension Header Parameter "${parameter}" is not recognized`);
    }
    if (joseHeader[parameter] === void 0) {
      throw new Err(`Extension Header Parameter "${parameter}" is missing`);
    }
    if (recognized.get(parameter) && protectedHeader[parameter] === void 0) {
      throw new Err(`Extension Header Parameter "${parameter}" MUST be integrity protected`);
    }
  }
  return new Set(protectedHeader.crit);
}
var validate_crit_default;
var init_validate_crit = __esm({
  "node_modules/jose/dist/browser/lib/validate_crit.js"() {
    init_errors();
    validate_crit_default = validateCrit;
  }
});

// node_modules/jose/dist/browser/lib/validate_algorithms.js
var validateAlgorithms, validate_algorithms_default;
var init_validate_algorithms = __esm({
  "node_modules/jose/dist/browser/lib/validate_algorithms.js"() {
    validateAlgorithms = (option, algorithms) => {
      if (algorithms !== void 0 && (!Array.isArray(algorithms) || algorithms.some((s) => typeof s !== "string"))) {
        throw new TypeError(`"${option}" option must be an array of strings`);
      }
      if (!algorithms) {
        return void 0;
      }
      return new Set(algorithms);
    };
    validate_algorithms_default = validateAlgorithms;
  }
});

// node_modules/jose/dist/browser/runtime/key_to_jwk.js
var keyToJWK, key_to_jwk_default;
var init_key_to_jwk = __esm({
  "node_modules/jose/dist/browser/runtime/key_to_jwk.js"() {
    init_webcrypto();
    init_invalid_key_input();
    init_base64url();
    init_is_key_like();
    keyToJWK = async (key) => {
      if (key instanceof Uint8Array) {
        return {
          kty: "oct",
          k: encode(key)
        };
      }
      if (!isCryptoKey(key)) {
        throw new TypeError(invalid_key_input_default(key, ...types, "Uint8Array"));
      }
      if (!key.extractable) {
        throw new TypeError("non-extractable CryptoKey cannot be exported as a JWK");
      }
      const { ext, key_ops, alg, use, ...jwk } = await webcrypto_default.subtle.exportKey("jwk", key);
      return jwk;
    };
    key_to_jwk_default = keyToJWK;
  }
});

// node_modules/jose/dist/browser/key/export.js
async function exportJWK(key) {
  return key_to_jwk_default(key);
}
var init_export = __esm({
  "node_modules/jose/dist/browser/key/export.js"() {
    init_key_to_jwk();
  }
});

// node_modules/jose/dist/browser/runtime/subtle_dsa.js
function subtleDsa(alg, algorithm) {
  const hash2 = `SHA-${alg.slice(-3)}`;
  switch (alg) {
    case "HS256":
    case "HS384":
    case "HS512":
      return { hash: hash2, name: "HMAC" };
    case "PS256":
    case "PS384":
    case "PS512":
      return { hash: hash2, name: "RSA-PSS", saltLength: alg.slice(-3) >> 3 };
    case "RS256":
    case "RS384":
    case "RS512":
      return { hash: hash2, name: "RSASSA-PKCS1-v1_5" };
    case "ES256":
    case "ES384":
    case "ES512":
      return { hash: hash2, name: "ECDSA", namedCurve: algorithm.namedCurve };
    case "Ed25519":
      return { name: "Ed25519" };
    case "EdDSA":
      return { name: algorithm.name };
    default:
      throw new JOSENotSupported(`alg ${alg} is not supported either by JOSE or your javascript runtime`);
  }
}
var init_subtle_dsa = __esm({
  "node_modules/jose/dist/browser/runtime/subtle_dsa.js"() {
    init_errors();
  }
});

// node_modules/jose/dist/browser/runtime/get_sign_verify_key.js
async function getCryptoKey(alg, key, usage) {
  if (usage === "sign") {
    key = await normalize_key_default.normalizePrivateKey(key, alg);
  }
  if (usage === "verify") {
    key = await normalize_key_default.normalizePublicKey(key, alg);
  }
  if (isCryptoKey(key)) {
    checkSigCryptoKey(key, alg, usage);
    return key;
  }
  if (key instanceof Uint8Array) {
    if (!alg.startsWith("HS")) {
      throw new TypeError(invalid_key_input_default(key, ...types));
    }
    return webcrypto_default.subtle.importKey("raw", key, { hash: `SHA-${alg.slice(-3)}`, name: "HMAC" }, false, [usage]);
  }
  throw new TypeError(invalid_key_input_default(key, ...types, "Uint8Array", "JSON Web Key"));
}
var init_get_sign_verify_key = __esm({
  "node_modules/jose/dist/browser/runtime/get_sign_verify_key.js"() {
    init_webcrypto();
    init_crypto_key();
    init_invalid_key_input();
    init_is_key_like();
    init_normalize_key();
  }
});

// node_modules/jose/dist/browser/runtime/verify.js
var verify, verify_default;
var init_verify = __esm({
  "node_modules/jose/dist/browser/runtime/verify.js"() {
    init_subtle_dsa();
    init_webcrypto();
    init_check_key_length();
    init_get_sign_verify_key();
    verify = async (alg, key, signature, data) => {
      const cryptoKey = await getCryptoKey(alg, key, "verify");
      check_key_length_default(alg, cryptoKey);
      const algorithm = subtleDsa(alg, cryptoKey.algorithm);
      try {
        return await webcrypto_default.subtle.verify(algorithm, cryptoKey, signature, data);
      } catch {
        return false;
      }
    };
    verify_default = verify;
  }
});

// node_modules/jose/dist/browser/jws/flattened/verify.js
async function flattenedVerify(jws, key, options) {
  if (!isObject(jws)) {
    throw new JWSInvalid("Flattened JWS must be an object");
  }
  if (jws.protected === void 0 && jws.header === void 0) {
    throw new JWSInvalid('Flattened JWS must have either of the "protected" or "header" members');
  }
  if (jws.protected !== void 0 && typeof jws.protected !== "string") {
    throw new JWSInvalid("JWS Protected Header incorrect type");
  }
  if (jws.payload === void 0) {
    throw new JWSInvalid("JWS Payload missing");
  }
  if (typeof jws.signature !== "string") {
    throw new JWSInvalid("JWS Signature missing or incorrect type");
  }
  if (jws.header !== void 0 && !isObject(jws.header)) {
    throw new JWSInvalid("JWS Unprotected Header incorrect type");
  }
  let parsedProt = {};
  if (jws.protected) {
    try {
      const protectedHeader = decode(jws.protected);
      parsedProt = JSON.parse(decoder.decode(protectedHeader));
    } catch {
      throw new JWSInvalid("JWS Protected Header is invalid");
    }
  }
  if (!is_disjoint_default(parsedProt, jws.header)) {
    throw new JWSInvalid("JWS Protected and JWS Unprotected Header Parameter names must be disjoint");
  }
  const joseHeader = {
    ...parsedProt,
    ...jws.header
  };
  const extensions = validate_crit_default(JWSInvalid, /* @__PURE__ */ new Map([["b64", true]]), options?.crit, parsedProt, joseHeader);
  let b64 = true;
  if (extensions.has("b64")) {
    b64 = parsedProt.b64;
    if (typeof b64 !== "boolean") {
      throw new JWSInvalid('The "b64" (base64url-encode payload) Header Parameter must be a boolean');
    }
  }
  const { alg } = joseHeader;
  if (typeof alg !== "string" || !alg) {
    throw new JWSInvalid('JWS "alg" (Algorithm) Header Parameter missing or invalid');
  }
  const algorithms = options && validate_algorithms_default("algorithms", options.algorithms);
  if (algorithms && !algorithms.has(alg)) {
    throw new JOSEAlgNotAllowed('"alg" (Algorithm) Header Parameter value not allowed');
  }
  if (b64) {
    if (typeof jws.payload !== "string") {
      throw new JWSInvalid("JWS Payload must be a string");
    }
  } else if (typeof jws.payload !== "string" && !(jws.payload instanceof Uint8Array)) {
    throw new JWSInvalid("JWS Payload must be a string or an Uint8Array instance");
  }
  let resolvedKey = false;
  if (typeof key === "function") {
    key = await key(parsedProt, jws);
    resolvedKey = true;
    checkKeyTypeWithJwk(alg, key, "verify");
    if (isJWK(key)) {
      key = await importJWK(key, alg);
    }
  } else {
    checkKeyTypeWithJwk(alg, key, "verify");
  }
  const data = concat(encoder.encode(jws.protected ?? ""), encoder.encode("."), typeof jws.payload === "string" ? encoder.encode(jws.payload) : jws.payload);
  let signature;
  try {
    signature = decode(jws.signature);
  } catch {
    throw new JWSInvalid("Failed to base64url decode the signature");
  }
  const verified = await verify_default(alg, key, signature, data);
  if (!verified) {
    throw new JWSSignatureVerificationFailed();
  }
  let payload;
  if (b64) {
    try {
      payload = decode(jws.payload);
    } catch {
      throw new JWSInvalid("Failed to base64url decode the payload");
    }
  } else if (typeof jws.payload === "string") {
    payload = encoder.encode(jws.payload);
  } else {
    payload = jws.payload;
  }
  const result = { payload };
  if (jws.protected !== void 0) {
    result.protectedHeader = parsedProt;
  }
  if (jws.header !== void 0) {
    result.unprotectedHeader = jws.header;
  }
  if (resolvedKey) {
    return { ...result, key };
  }
  return result;
}
var init_verify2 = __esm({
  "node_modules/jose/dist/browser/jws/flattened/verify.js"() {
    init_base64url();
    init_verify();
    init_errors();
    init_buffer_utils();
    init_is_disjoint();
    init_is_object();
    init_check_key_type();
    init_validate_crit();
    init_validate_algorithms();
    init_is_jwk();
    init_import();
  }
});

// node_modules/jose/dist/browser/jws/compact/verify.js
async function compactVerify(jws, key, options) {
  if (jws instanceof Uint8Array) {
    jws = decoder.decode(jws);
  }
  if (typeof jws !== "string") {
    throw new JWSInvalid("Compact JWS must be a string or Uint8Array");
  }
  const { 0: protectedHeader, 1: payload, 2: signature, length } = jws.split(".");
  if (length !== 3) {
    throw new JWSInvalid("Invalid Compact JWS");
  }
  const verified = await flattenedVerify({ payload, protected: protectedHeader, signature }, key, options);
  const result = { payload: verified.payload, protectedHeader: verified.protectedHeader };
  if (typeof key === "function") {
    return { ...result, key: verified.key };
  }
  return result;
}
var init_verify3 = __esm({
  "node_modules/jose/dist/browser/jws/compact/verify.js"() {
    init_verify2();
    init_errors();
    init_buffer_utils();
  }
});

// node_modules/jose/dist/browser/lib/epoch.js
var epoch_default;
var init_epoch = __esm({
  "node_modules/jose/dist/browser/lib/epoch.js"() {
    epoch_default = (date5) => Math.floor(date5.getTime() / 1e3);
  }
});

// node_modules/jose/dist/browser/lib/secs.js
var minute, hour, day, week, year, REGEX, secs_default;
var init_secs = __esm({
  "node_modules/jose/dist/browser/lib/secs.js"() {
    minute = 60;
    hour = minute * 60;
    day = hour * 24;
    week = day * 7;
    year = day * 365.25;
    REGEX = /^(\+|\-)? ?(\d+|\d+\.\d+) ?(seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)(?: (ago|from now))?$/i;
    secs_default = (str2) => {
      const matched = REGEX.exec(str2);
      if (!matched || matched[4] && matched[1]) {
        throw new TypeError("Invalid time period format");
      }
      const value = parseFloat(matched[2]);
      const unit = matched[3].toLowerCase();
      let numericDate;
      switch (unit) {
        case "sec":
        case "secs":
        case "second":
        case "seconds":
        case "s":
          numericDate = Math.round(value);
          break;
        case "minute":
        case "minutes":
        case "min":
        case "mins":
        case "m":
          numericDate = Math.round(value * minute);
          break;
        case "hour":
        case "hours":
        case "hr":
        case "hrs":
        case "h":
          numericDate = Math.round(value * hour);
          break;
        case "day":
        case "days":
        case "d":
          numericDate = Math.round(value * day);
          break;
        case "week":
        case "weeks":
        case "w":
          numericDate = Math.round(value * week);
          break;
        default:
          numericDate = Math.round(value * year);
          break;
      }
      if (matched[1] === "-" || matched[4] === "ago") {
        return -numericDate;
      }
      return numericDate;
    };
  }
});

// node_modules/jose/dist/browser/lib/jwt_claims_set.js
var normalizeTyp, checkAudiencePresence, jwt_claims_set_default;
var init_jwt_claims_set = __esm({
  "node_modules/jose/dist/browser/lib/jwt_claims_set.js"() {
    init_errors();
    init_buffer_utils();
    init_epoch();
    init_secs();
    init_is_object();
    normalizeTyp = (value) => value.toLowerCase().replace(/^application\//, "");
    checkAudiencePresence = (audPayload, audOption) => {
      if (typeof audPayload === "string") {
        return audOption.includes(audPayload);
      }
      if (Array.isArray(audPayload)) {
        return audOption.some(Set.prototype.has.bind(new Set(audPayload)));
      }
      return false;
    };
    jwt_claims_set_default = (protectedHeader, encodedPayload, options = {}) => {
      let payload;
      try {
        payload = JSON.parse(decoder.decode(encodedPayload));
      } catch {
      }
      if (!isObject(payload)) {
        throw new JWTInvalid("JWT Claims Set must be a top-level JSON object");
      }
      const { typ } = options;
      if (typ && (typeof protectedHeader.typ !== "string" || normalizeTyp(protectedHeader.typ) !== normalizeTyp(typ))) {
        throw new JWTClaimValidationFailed('unexpected "typ" JWT header value', payload, "typ", "check_failed");
      }
      const { requiredClaims = [], issuer, subject, audience, maxTokenAge } = options;
      const presenceCheck = [...requiredClaims];
      if (maxTokenAge !== void 0)
        presenceCheck.push("iat");
      if (audience !== void 0)
        presenceCheck.push("aud");
      if (subject !== void 0)
        presenceCheck.push("sub");
      if (issuer !== void 0)
        presenceCheck.push("iss");
      for (const claim of new Set(presenceCheck.reverse())) {
        if (!(claim in payload)) {
          throw new JWTClaimValidationFailed(`missing required "${claim}" claim`, payload, claim, "missing");
        }
      }
      if (issuer && !(Array.isArray(issuer) ? issuer : [issuer]).includes(payload.iss)) {
        throw new JWTClaimValidationFailed('unexpected "iss" claim value', payload, "iss", "check_failed");
      }
      if (subject && payload.sub !== subject) {
        throw new JWTClaimValidationFailed('unexpected "sub" claim value', payload, "sub", "check_failed");
      }
      if (audience && !checkAudiencePresence(payload.aud, typeof audience === "string" ? [audience] : audience)) {
        throw new JWTClaimValidationFailed('unexpected "aud" claim value', payload, "aud", "check_failed");
      }
      let tolerance;
      switch (typeof options.clockTolerance) {
        case "string":
          tolerance = secs_default(options.clockTolerance);
          break;
        case "number":
          tolerance = options.clockTolerance;
          break;
        case "undefined":
          tolerance = 0;
          break;
        default:
          throw new TypeError("Invalid clockTolerance option type");
      }
      const { currentDate } = options;
      const now = epoch_default(currentDate || /* @__PURE__ */ new Date());
      if ((payload.iat !== void 0 || maxTokenAge) && typeof payload.iat !== "number") {
        throw new JWTClaimValidationFailed('"iat" claim must be a number', payload, "iat", "invalid");
      }
      if (payload.nbf !== void 0) {
        if (typeof payload.nbf !== "number") {
          throw new JWTClaimValidationFailed('"nbf" claim must be a number', payload, "nbf", "invalid");
        }
        if (payload.nbf > now + tolerance) {
          throw new JWTClaimValidationFailed('"nbf" claim timestamp check failed', payload, "nbf", "check_failed");
        }
      }
      if (payload.exp !== void 0) {
        if (typeof payload.exp !== "number") {
          throw new JWTClaimValidationFailed('"exp" claim must be a number', payload, "exp", "invalid");
        }
        if (payload.exp <= now - tolerance) {
          throw new JWTExpired('"exp" claim timestamp check failed', payload, "exp", "check_failed");
        }
      }
      if (maxTokenAge) {
        const age = now - payload.iat;
        const max = typeof maxTokenAge === "number" ? maxTokenAge : secs_default(maxTokenAge);
        if (age - tolerance > max) {
          throw new JWTExpired('"iat" claim timestamp check failed (too far in the past)', payload, "iat", "check_failed");
        }
        if (age < 0 - tolerance) {
          throw new JWTClaimValidationFailed('"iat" claim timestamp check failed (it should be in the past)', payload, "iat", "check_failed");
        }
      }
      return payload;
    };
  }
});

// node_modules/jose/dist/browser/jwt/verify.js
async function jwtVerify(jwt2, key, options) {
  const verified = await compactVerify(jwt2, key, options);
  if (verified.protectedHeader.crit?.includes("b64") && verified.protectedHeader.b64 === false) {
    throw new JWTInvalid("JWTs MUST NOT use unencoded payload");
  }
  const payload = jwt_claims_set_default(verified.protectedHeader, verified.payload, options);
  const result = { payload, protectedHeader: verified.protectedHeader };
  if (typeof key === "function") {
    return { ...result, key: verified.key };
  }
  return result;
}
var init_verify4 = __esm({
  "node_modules/jose/dist/browser/jwt/verify.js"() {
    init_verify3();
    init_jwt_claims_set();
    init_errors();
  }
});

// node_modules/jose/dist/browser/runtime/sign.js
var sign, sign_default;
var init_sign = __esm({
  "node_modules/jose/dist/browser/runtime/sign.js"() {
    init_subtle_dsa();
    init_webcrypto();
    init_check_key_length();
    init_get_sign_verify_key();
    sign = async (alg, key, data) => {
      const cryptoKey = await getCryptoKey(alg, key, "sign");
      check_key_length_default(alg, cryptoKey);
      const signature = await webcrypto_default.subtle.sign(subtleDsa(alg, cryptoKey.algorithm), cryptoKey, data);
      return new Uint8Array(signature);
    };
    sign_default = sign;
  }
});

// node_modules/jose/dist/browser/jws/flattened/sign.js
var FlattenedSign;
var init_sign2 = __esm({
  "node_modules/jose/dist/browser/jws/flattened/sign.js"() {
    init_base64url();
    init_sign();
    init_is_disjoint();
    init_errors();
    init_buffer_utils();
    init_check_key_type();
    init_validate_crit();
    FlattenedSign = class {
      constructor(payload) {
        if (!(payload instanceof Uint8Array)) {
          throw new TypeError("payload must be an instance of Uint8Array");
        }
        this._payload = payload;
      }
      setProtectedHeader(protectedHeader) {
        if (this._protectedHeader) {
          throw new TypeError("setProtectedHeader can only be called once");
        }
        this._protectedHeader = protectedHeader;
        return this;
      }
      setUnprotectedHeader(unprotectedHeader) {
        if (this._unprotectedHeader) {
          throw new TypeError("setUnprotectedHeader can only be called once");
        }
        this._unprotectedHeader = unprotectedHeader;
        return this;
      }
      async sign(key, options) {
        if (!this._protectedHeader && !this._unprotectedHeader) {
          throw new JWSInvalid("either setProtectedHeader or setUnprotectedHeader must be called before #sign()");
        }
        if (!is_disjoint_default(this._protectedHeader, this._unprotectedHeader)) {
          throw new JWSInvalid("JWS Protected and JWS Unprotected Header Parameter names must be disjoint");
        }
        const joseHeader = {
          ...this._protectedHeader,
          ...this._unprotectedHeader
        };
        const extensions = validate_crit_default(JWSInvalid, /* @__PURE__ */ new Map([["b64", true]]), options?.crit, this._protectedHeader, joseHeader);
        let b64 = true;
        if (extensions.has("b64")) {
          b64 = this._protectedHeader.b64;
          if (typeof b64 !== "boolean") {
            throw new JWSInvalid('The "b64" (base64url-encode payload) Header Parameter must be a boolean');
          }
        }
        const { alg } = joseHeader;
        if (typeof alg !== "string" || !alg) {
          throw new JWSInvalid('JWS "alg" (Algorithm) Header Parameter missing or invalid');
        }
        checkKeyTypeWithJwk(alg, key, "sign");
        let payload = this._payload;
        if (b64) {
          payload = encoder.encode(encode(payload));
        }
        let protectedHeader;
        if (this._protectedHeader) {
          protectedHeader = encoder.encode(encode(JSON.stringify(this._protectedHeader)));
        } else {
          protectedHeader = encoder.encode("");
        }
        const data = concat(protectedHeader, encoder.encode("."), payload);
        const signature = await sign_default(alg, key, data);
        const jws = {
          signature: encode(signature),
          payload: ""
        };
        if (b64) {
          jws.payload = decoder.decode(payload);
        }
        if (this._unprotectedHeader) {
          jws.header = this._unprotectedHeader;
        }
        if (this._protectedHeader) {
          jws.protected = decoder.decode(protectedHeader);
        }
        return jws;
      }
    };
  }
});

// node_modules/jose/dist/browser/jws/compact/sign.js
var CompactSign;
var init_sign3 = __esm({
  "node_modules/jose/dist/browser/jws/compact/sign.js"() {
    init_sign2();
    CompactSign = class {
      constructor(payload) {
        this._flattened = new FlattenedSign(payload);
      }
      setProtectedHeader(protectedHeader) {
        this._flattened.setProtectedHeader(protectedHeader);
        return this;
      }
      async sign(key, options) {
        const jws = await this._flattened.sign(key, options);
        if (jws.payload === void 0) {
          throw new TypeError("use the flattened module for creating JWS with b64: false");
        }
        return `${jws.protected}.${jws.payload}.${jws.signature}`;
      }
    };
  }
});

// node_modules/jose/dist/browser/jwt/produce.js
function validateInput(label, input) {
  if (!Number.isFinite(input)) {
    throw new TypeError(`Invalid ${label} input`);
  }
  return input;
}
var ProduceJWT;
var init_produce = __esm({
  "node_modules/jose/dist/browser/jwt/produce.js"() {
    init_epoch();
    init_is_object();
    init_secs();
    ProduceJWT = class {
      constructor(payload = {}) {
        if (!isObject(payload)) {
          throw new TypeError("JWT Claims Set MUST be an object");
        }
        this._payload = payload;
      }
      setIssuer(issuer) {
        this._payload = { ...this._payload, iss: issuer };
        return this;
      }
      setSubject(subject) {
        this._payload = { ...this._payload, sub: subject };
        return this;
      }
      setAudience(audience) {
        this._payload = { ...this._payload, aud: audience };
        return this;
      }
      setJti(jwtId) {
        this._payload = { ...this._payload, jti: jwtId };
        return this;
      }
      setNotBefore(input) {
        if (typeof input === "number") {
          this._payload = { ...this._payload, nbf: validateInput("setNotBefore", input) };
        } else if (input instanceof Date) {
          this._payload = { ...this._payload, nbf: validateInput("setNotBefore", epoch_default(input)) };
        } else {
          this._payload = { ...this._payload, nbf: epoch_default(/* @__PURE__ */ new Date()) + secs_default(input) };
        }
        return this;
      }
      setExpirationTime(input) {
        if (typeof input === "number") {
          this._payload = { ...this._payload, exp: validateInput("setExpirationTime", input) };
        } else if (input instanceof Date) {
          this._payload = { ...this._payload, exp: validateInput("setExpirationTime", epoch_default(input)) };
        } else {
          this._payload = { ...this._payload, exp: epoch_default(/* @__PURE__ */ new Date()) + secs_default(input) };
        }
        return this;
      }
      setIssuedAt(input) {
        if (typeof input === "undefined") {
          this._payload = { ...this._payload, iat: epoch_default(/* @__PURE__ */ new Date()) };
        } else if (input instanceof Date) {
          this._payload = { ...this._payload, iat: validateInput("setIssuedAt", epoch_default(input)) };
        } else if (typeof input === "string") {
          this._payload = {
            ...this._payload,
            iat: validateInput("setIssuedAt", epoch_default(/* @__PURE__ */ new Date()) + secs_default(input))
          };
        } else {
          this._payload = { ...this._payload, iat: validateInput("setIssuedAt", input) };
        }
        return this;
      }
    };
  }
});

// node_modules/jose/dist/browser/jwt/sign.js
var SignJWT;
var init_sign4 = __esm({
  "node_modules/jose/dist/browser/jwt/sign.js"() {
    init_sign3();
    init_errors();
    init_buffer_utils();
    init_produce();
    SignJWT = class extends ProduceJWT {
      setProtectedHeader(protectedHeader) {
        this._protectedHeader = protectedHeader;
        return this;
      }
      async sign(key, options) {
        const sig = new CompactSign(encoder.encode(JSON.stringify(this._payload)));
        sig.setProtectedHeader(this._protectedHeader);
        if (Array.isArray(this._protectedHeader?.crit) && this._protectedHeader.crit.includes("b64") && this._protectedHeader.b64 === false) {
          throw new JWTInvalid("JWTs MUST NOT use unencoded payload");
        }
        return sig.sign(key, options);
      }
    };
  }
});

// node_modules/jose/dist/browser/jwks/local.js
function getKtyFromAlg(alg) {
  switch (typeof alg === "string" && alg.slice(0, 2)) {
    case "RS":
    case "PS":
      return "RSA";
    case "ES":
      return "EC";
    case "Ed":
      return "OKP";
    default:
      throw new JOSENotSupported('Unsupported "alg" value for a JSON Web Key Set');
  }
}
function isJWKSLike(jwks) {
  return jwks && typeof jwks === "object" && Array.isArray(jwks.keys) && jwks.keys.every(isJWKLike);
}
function isJWKLike(key) {
  return isObject(key);
}
function clone(obj) {
  if (typeof structuredClone === "function") {
    return structuredClone(obj);
  }
  return JSON.parse(JSON.stringify(obj));
}
async function importWithAlgCache(cache, jwk, alg) {
  const cached2 = cache.get(jwk) || cache.set(jwk, {}).get(jwk);
  if (cached2[alg] === void 0) {
    const key = await importJWK({ ...jwk, ext: true }, alg);
    if (key instanceof Uint8Array || key.type !== "public") {
      throw new JWKSInvalid("JSON Web Key Set members must be public keys");
    }
    cached2[alg] = key;
  }
  return cached2[alg];
}
function createLocalJWKSet(jwks) {
  const set3 = new LocalJWKSet(jwks);
  const localJWKSet = async (protectedHeader, token) => set3.getKey(protectedHeader, token);
  Object.defineProperties(localJWKSet, {
    jwks: {
      value: () => clone(set3._jwks),
      enumerable: true,
      configurable: false,
      writable: false
    }
  });
  return localJWKSet;
}
var LocalJWKSet;
var init_local = __esm({
  "node_modules/jose/dist/browser/jwks/local.js"() {
    init_import();
    init_errors();
    init_is_object();
    LocalJWKSet = class {
      constructor(jwks) {
        this._cached = /* @__PURE__ */ new WeakMap();
        if (!isJWKSLike(jwks)) {
          throw new JWKSInvalid("JSON Web Key Set malformed");
        }
        this._jwks = clone(jwks);
      }
      async getKey(protectedHeader, token) {
        const { alg, kid } = { ...protectedHeader, ...token?.header };
        const kty = getKtyFromAlg(alg);
        const candidates = this._jwks.keys.filter((jwk2) => {
          let candidate = kty === jwk2.kty;
          if (candidate && typeof kid === "string") {
            candidate = kid === jwk2.kid;
          }
          if (candidate && typeof jwk2.alg === "string") {
            candidate = alg === jwk2.alg;
          }
          if (candidate && typeof jwk2.use === "string") {
            candidate = jwk2.use === "sig";
          }
          if (candidate && Array.isArray(jwk2.key_ops)) {
            candidate = jwk2.key_ops.includes("verify");
          }
          if (candidate) {
            switch (alg) {
              case "ES256":
                candidate = jwk2.crv === "P-256";
                break;
              case "ES256K":
                candidate = jwk2.crv === "secp256k1";
                break;
              case "ES384":
                candidate = jwk2.crv === "P-384";
                break;
              case "ES512":
                candidate = jwk2.crv === "P-521";
                break;
              case "Ed25519":
                candidate = jwk2.crv === "Ed25519";
                break;
              case "EdDSA":
                candidate = jwk2.crv === "Ed25519" || jwk2.crv === "Ed448";
                break;
            }
          }
          return candidate;
        });
        const { 0: jwk, length } = candidates;
        if (length === 0) {
          throw new JWKSNoMatchingKey();
        }
        if (length !== 1) {
          const error46 = new JWKSMultipleMatchingKeys();
          const { _cached } = this;
          error46[Symbol.asyncIterator] = async function* () {
            for (const jwk2 of candidates) {
              try {
                yield await importWithAlgCache(_cached, jwk2, alg);
              } catch {
              }
            }
          };
          throw error46;
        }
        return importWithAlgCache(this._cached, jwk, alg);
      }
    };
  }
});

// node_modules/jose/dist/browser/runtime/fetch_jwks.js
var fetchJwks, fetch_jwks_default;
var init_fetch_jwks = __esm({
  "node_modules/jose/dist/browser/runtime/fetch_jwks.js"() {
    init_errors();
    fetchJwks = async (url2, timeout, options) => {
      let controller;
      let id;
      let timedOut = false;
      if (typeof AbortController === "function") {
        controller = new AbortController();
        id = setTimeout(() => {
          timedOut = true;
          controller.abort();
        }, timeout);
      }
      const response = await fetch(url2.href, {
        signal: controller ? controller.signal : void 0,
        redirect: "manual",
        headers: options.headers
      }).catch((err) => {
        if (timedOut)
          throw new JWKSTimeout();
        throw err;
      });
      if (id !== void 0)
        clearTimeout(id);
      if (response.status !== 200) {
        throw new JOSEError("Expected 200 OK from the JSON Web Key Set HTTP response");
      }
      try {
        return await response.json();
      } catch {
        throw new JOSEError("Failed to parse the JSON Web Key Set HTTP response as JSON");
      }
    };
    fetch_jwks_default = fetchJwks;
  }
});

// node_modules/jose/dist/browser/jwks/remote.js
function isCloudflareWorkers() {
  return typeof WebSocketPair !== "undefined" || typeof navigator !== "undefined" && navigator.userAgent === "Cloudflare-Workers" || typeof EdgeRuntime !== "undefined" && EdgeRuntime === "vercel";
}
function isFreshJwksCache(input, cacheMaxAge) {
  if (typeof input !== "object" || input === null) {
    return false;
  }
  if (!("uat" in input) || typeof input.uat !== "number" || Date.now() - input.uat >= cacheMaxAge) {
    return false;
  }
  if (!("jwks" in input) || !isObject(input.jwks) || !Array.isArray(input.jwks.keys) || !Array.prototype.every.call(input.jwks.keys, isObject)) {
    return false;
  }
  return true;
}
function createRemoteJWKSet(url2, options) {
  const set3 = new RemoteJWKSet(url2, options);
  const remoteJWKSet = async (protectedHeader, token) => set3.getKey(protectedHeader, token);
  Object.defineProperties(remoteJWKSet, {
    coolingDown: {
      get: () => set3.coolingDown(),
      enumerable: true,
      configurable: false
    },
    fresh: {
      get: () => set3.fresh(),
      enumerable: true,
      configurable: false
    },
    reload: {
      value: () => set3.reload(),
      enumerable: true,
      configurable: false,
      writable: false
    },
    reloading: {
      get: () => !!set3._pendingFetch,
      enumerable: true,
      configurable: false
    },
    jwks: {
      value: () => set3._local?.jwks(),
      enumerable: true,
      configurable: false,
      writable: false
    }
  });
  return remoteJWKSet;
}
var USER_AGENT, jwksCache, RemoteJWKSet;
var init_remote = __esm({
  "node_modules/jose/dist/browser/jwks/remote.js"() {
    init_fetch_jwks();
    init_errors();
    init_local();
    init_is_object();
    if (typeof navigator === "undefined" || !navigator.userAgent?.startsWith?.("Mozilla/5.0 ")) {
      const NAME = "jose";
      const VERSION = "v5.10.0";
      USER_AGENT = `${NAME}/${VERSION}`;
    }
    jwksCache = Symbol();
    RemoteJWKSet = class {
      constructor(url2, options) {
        if (!(url2 instanceof URL)) {
          throw new TypeError("url must be an instance of URL");
        }
        this._url = new URL(url2.href);
        this._options = { agent: options?.agent, headers: options?.headers };
        this._timeoutDuration = typeof options?.timeoutDuration === "number" ? options?.timeoutDuration : 5e3;
        this._cooldownDuration = typeof options?.cooldownDuration === "number" ? options?.cooldownDuration : 3e4;
        this._cacheMaxAge = typeof options?.cacheMaxAge === "number" ? options?.cacheMaxAge : 6e5;
        if (options?.[jwksCache] !== void 0) {
          this._cache = options?.[jwksCache];
          if (isFreshJwksCache(options?.[jwksCache], this._cacheMaxAge)) {
            this._jwksTimestamp = this._cache.uat;
            this._local = createLocalJWKSet(this._cache.jwks);
          }
        }
      }
      coolingDown() {
        return typeof this._jwksTimestamp === "number" ? Date.now() < this._jwksTimestamp + this._cooldownDuration : false;
      }
      fresh() {
        return typeof this._jwksTimestamp === "number" ? Date.now() < this._jwksTimestamp + this._cacheMaxAge : false;
      }
      async getKey(protectedHeader, token) {
        if (!this._local || !this.fresh()) {
          await this.reload();
        }
        try {
          return await this._local(protectedHeader, token);
        } catch (err) {
          if (err instanceof JWKSNoMatchingKey) {
            if (this.coolingDown() === false) {
              await this.reload();
              return this._local(protectedHeader, token);
            }
          }
          throw err;
        }
      }
      async reload() {
        if (this._pendingFetch && isCloudflareWorkers()) {
          this._pendingFetch = void 0;
        }
        const headers = new Headers(this._options.headers);
        if (USER_AGENT && !headers.has("User-Agent")) {
          headers.set("User-Agent", USER_AGENT);
          this._options.headers = Object.fromEntries(headers.entries());
        }
        this._pendingFetch || (this._pendingFetch = fetch_jwks_default(this._url, this._timeoutDuration, this._options).then((json3) => {
          this._local = createLocalJWKSet(json3);
          if (this._cache) {
            this._cache.uat = Date.now();
            this._cache.jwks = json3;
          }
          this._jwksTimestamp = Date.now();
          this._pendingFetch = void 0;
        }).catch((err) => {
          this._pendingFetch = void 0;
          throw err;
        }));
        await this._pendingFetch;
      }
    };
  }
});

// node_modules/jose/dist/browser/util/base64url.js
var init_base64url2 = __esm({
  "node_modules/jose/dist/browser/util/base64url.js"() {
  }
});

// node_modules/jose/dist/browser/runtime/generate.js
function getModulusLengthOption(options) {
  const modulusLength = options?.modulusLength ?? 2048;
  if (typeof modulusLength !== "number" || modulusLength < 2048) {
    throw new JOSENotSupported("Invalid or unsupported modulusLength option provided, 2048 bits or larger keys must be used");
  }
  return modulusLength;
}
async function generateKeyPair(alg, options) {
  let algorithm;
  let keyUsages;
  switch (alg) {
    case "PS256":
    case "PS384":
    case "PS512":
      algorithm = {
        name: "RSA-PSS",
        hash: `SHA-${alg.slice(-3)}`,
        publicExponent: new Uint8Array([1, 0, 1]),
        modulusLength: getModulusLengthOption(options)
      };
      keyUsages = ["sign", "verify"];
      break;
    case "RS256":
    case "RS384":
    case "RS512":
      algorithm = {
        name: "RSASSA-PKCS1-v1_5",
        hash: `SHA-${alg.slice(-3)}`,
        publicExponent: new Uint8Array([1, 0, 1]),
        modulusLength: getModulusLengthOption(options)
      };
      keyUsages = ["sign", "verify"];
      break;
    case "RSA-OAEP":
    case "RSA-OAEP-256":
    case "RSA-OAEP-384":
    case "RSA-OAEP-512":
      algorithm = {
        name: "RSA-OAEP",
        hash: `SHA-${parseInt(alg.slice(-3), 10) || 1}`,
        publicExponent: new Uint8Array([1, 0, 1]),
        modulusLength: getModulusLengthOption(options)
      };
      keyUsages = ["decrypt", "unwrapKey", "encrypt", "wrapKey"];
      break;
    case "ES256":
      algorithm = { name: "ECDSA", namedCurve: "P-256" };
      keyUsages = ["sign", "verify"];
      break;
    case "ES384":
      algorithm = { name: "ECDSA", namedCurve: "P-384" };
      keyUsages = ["sign", "verify"];
      break;
    case "ES512":
      algorithm = { name: "ECDSA", namedCurve: "P-521" };
      keyUsages = ["sign", "verify"];
      break;
    case "Ed25519":
      algorithm = { name: "Ed25519" };
      keyUsages = ["sign", "verify"];
      break;
    case "EdDSA": {
      keyUsages = ["sign", "verify"];
      const crv = options?.crv ?? "Ed25519";
      switch (crv) {
        case "Ed25519":
        case "Ed448":
          algorithm = { name: crv };
          break;
        default:
          throw new JOSENotSupported("Invalid or unsupported crv option provided");
      }
      break;
    }
    case "ECDH-ES":
    case "ECDH-ES+A128KW":
    case "ECDH-ES+A192KW":
    case "ECDH-ES+A256KW": {
      keyUsages = ["deriveKey", "deriveBits"];
      const crv = options?.crv ?? "P-256";
      switch (crv) {
        case "P-256":
        case "P-384":
        case "P-521": {
          algorithm = { name: "ECDH", namedCurve: crv };
          break;
        }
        case "X25519":
        case "X448":
          algorithm = { name: crv };
          break;
        default:
          throw new JOSENotSupported("Invalid or unsupported crv option provided, supported values are P-256, P-384, P-521, X25519, and X448");
      }
      break;
    }
    default:
      throw new JOSENotSupported('Invalid or unsupported JWK "alg" (Algorithm) Parameter value');
  }
  return webcrypto_default.subtle.generateKey(algorithm, options?.extractable ?? false, keyUsages);
}
var init_generate = __esm({
  "node_modules/jose/dist/browser/runtime/generate.js"() {
    init_webcrypto();
    init_errors();
  }
});

// node_modules/jose/dist/browser/key/generate_key_pair.js
async function generateKeyPair2(alg, options) {
  return generateKeyPair(alg, options);
}
var init_generate_key_pair = __esm({
  "node_modules/jose/dist/browser/key/generate_key_pair.js"() {
    init_generate();
  }
});

// node_modules/jose/dist/browser/index.js
var init_browser = __esm({
  "node_modules/jose/dist/browser/index.js"() {
    init_verify4();
    init_sign4();
    init_remote();
    init_export();
    init_errors();
    init_generate_key_pair();
    init_base64url2();
  }
});

// node_modules/@inrupt/solid-client-authn-core/dist/index.mjs
async function getWebidFromTokenPayload(idToken, jwksIri, issuerIri, clientId) {
  let payload;
  let clientIdInPayload;
  try {
    const { payload: verifiedPayload } = await jwtVerify(idToken, createRemoteJWKSet(new URL(jwksIri)), {
      issuer: issuerIri,
      audience: clientId
    });
    payload = verifiedPayload;
  } catch (e) {
    throw new Error(`Token verification failed: ${e.stack}`);
  }
  if (typeof payload.azp === "string") {
    clientIdInPayload = payload.azp;
  }
  if (typeof payload.webid === "string") {
    return {
      webId: payload.webid,
      clientId: clientIdInPayload
    };
  }
  if (typeof payload.sub !== "string") {
    throw new Error(`The token ${JSON.stringify(payload)} is invalid: it has no 'webid' claim and no 'sub' claim.`);
  }
  try {
    new URL(payload.sub);
    return {
      webId: payload.sub,
      clientId: clientIdInPayload
    };
  } catch (e) {
    throw new Error(`The token has no 'webid' claim, and its 'sub' claim of [${payload.sub}] is invalid as a URL - error [${e}].`);
  }
}
function normalizeScopes(scopes) {
  if (!Array.isArray(scopes)) {
    return DEFAULT_SCOPES;
  }
  return Array.from(
    // De-dupe potentia conflicts if any.
    /* @__PURE__ */ new Set([
      ...DEFAULT_SCOPES,
      ...scopes.filter(
        // Remove user-provided scopes that are not strings or include spaces.
        (scope) => typeof scope === "string" && !scope.includes(" ")
      )
    ])
  );
}
function isValidRedirectUrl(redirectUrl) {
  try {
    const urlObject = new URL(redirectUrl);
    const noReservedQuery = !urlObject.searchParams.has("code") && !urlObject.searchParams.has("state");
    const noHash = urlObject.hash === "";
    return noReservedQuery && noHash;
  } catch (e) {
    return false;
  }
}
function removeOpenIdParams(redirectUrl) {
  const cleanedUpUrl = new URL(redirectUrl);
  cleanedUpUrl.searchParams.delete("state");
  cleanedUpUrl.searchParams.delete("code");
  cleanedUpUrl.searchParams.delete("error");
  cleanedUpUrl.searchParams.delete("error_description");
  cleanedUpUrl.searchParams.delete("iss");
  return cleanedUpUrl;
}
function booleanWithFallback(value, fallback) {
  if (typeof value === "boolean") {
    return Boolean(value);
  }
  return Boolean(fallback);
}
function getUnauthenticatedSession() {
  return {
    isLoggedIn: false,
    sessionId: v4_default(),
    fetch: (...args) => fetch(...args)
  };
}
async function clear(sessionId, storage) {
  await Promise.all([
    storage.deleteAllUserData(sessionId, { secure: false }),
    storage.deleteAllUserData(sessionId, { secure: true })
  ]);
}
function getEndSessionUrl({ endSessionEndpoint, idTokenHint, postLogoutRedirectUri, state }) {
  const url2 = new URL(endSessionEndpoint);
  if (idTokenHint !== void 0)
    url2.searchParams.append("id_token_hint", idTokenHint);
  if (postLogoutRedirectUri !== void 0) {
    url2.searchParams.append("post_logout_redirect_uri", postLogoutRedirectUri);
    if (state !== void 0)
      url2.searchParams.append("state", state);
  }
  return url2.toString();
}
function maybeBuildRpInitiatedLogout({ endSessionEndpoint, idTokenHint }) {
  if (endSessionEndpoint === void 0)
    return void 0;
  return function logout({ state, postLogoutUrl }) {
    return getEndSessionUrl({
      endSessionEndpoint,
      idTokenHint,
      state,
      postLogoutRedirectUri: postLogoutUrl
    });
  };
}
function isSupportedTokenType(token) {
  return typeof token === "string" && ["DPoP", "Bearer"].includes(token);
}
function isValidUrl(url2) {
  try {
    new URL(url2);
    return true;
  } catch {
    return false;
  }
}
function determineSigningAlg(supported, preferred) {
  return preferred.find((signingAlg) => {
    return supported.includes(signingAlg);
  }) ?? null;
}
function isStaticClient(options) {
  return options.clientId !== void 0 && !isValidUrl(options.clientId);
}
function isSolidOidcClient(options, issuerConfig) {
  return issuerConfig.scopesSupported.includes("webid") && options.clientId !== void 0 && isValidUrl(options.clientId);
}
function isKnownClientType(clientType) {
  return typeof clientType === "string" && ["dynamic", "static", "solid-oidc"].includes(clientType);
}
async function handleRegistration(options, issuerConfig, storageUtility, clientRegistrar) {
  let clientInfo;
  if (isSolidOidcClient(options, issuerConfig)) {
    clientInfo = {
      clientId: options.clientId,
      clientName: options.clientName,
      clientType: "solid-oidc"
    };
  } else if (isStaticClient(options)) {
    clientInfo = {
      clientId: options.clientId,
      clientSecret: options.clientSecret,
      clientName: options.clientName,
      clientType: "static"
    };
  } else {
    return clientRegistrar.getClient({
      sessionId: options.sessionId,
      clientName: options.clientName,
      redirectUrl: options.redirectUrl
    }, issuerConfig);
  }
  const infoToSave = {
    clientId: clientInfo.clientId,
    clientType: clientInfo.clientType
  };
  if (clientInfo.clientType === "static") {
    infoToSave.clientSecret = clientInfo.clientSecret;
  }
  if (clientInfo.clientName) {
    infoToSave.clientName = clientInfo.clientName;
  }
  await storageUtility.setForUser(options.sessionId, infoToSave);
  return clientInfo;
}
async function loadOidcContextFromStorage(sessionId, storageUtility, configFetcher) {
  try {
    const [issuerIri, codeVerifier, storedRedirectIri, dpop, keepAlive] = await Promise.all([
      storageUtility.getForUser(sessionId, "issuer", {
        errorIfNull: true
      }),
      storageUtility.getForUser(sessionId, "codeVerifier"),
      storageUtility.getForUser(sessionId, "redirectUrl"),
      storageUtility.getForUser(sessionId, "dpop", { errorIfNull: true }),
      storageUtility.getForUser(sessionId, "keepAlive")
    ]);
    await storageUtility.deleteForUser(sessionId, "codeVerifier");
    const issuerConfig = await configFetcher.fetchConfig(issuerIri);
    return {
      codeVerifier,
      redirectUrl: storedRedirectIri,
      issuerConfig,
      dpop: dpop === "true",
      // Default keepAlive to true if not found in storage.
      keepAlive: typeof keepAlive === "string" ? keepAlive === "true" : true
    };
  } catch (e) {
    throw new Error(`Failed to retrieve OIDC context from storage associated with session [${sessionId}]: ${e}`);
  }
}
async function saveSessionInfoToStorage(storageUtility, sessionId, webId, clientId, isLoggedIn2, refreshToken, secure, dpopKey) {
  if (refreshToken !== void 0) {
    await storageUtility.setForUser(sessionId, { refreshToken }, { secure });
  }
  if (webId !== void 0) {
    await storageUtility.setForUser(sessionId, { webId }, { secure });
  }
  if (clientId !== void 0) {
    await storageUtility.setForUser(sessionId, { clientId }, { secure });
  }
  if (isLoggedIn2 !== void 0) {
    await storageUtility.setForUser(sessionId, { isLoggedIn: isLoggedIn2 }, { secure });
  }
  if (dpopKey !== void 0) {
    await storageUtility.setForUser(sessionId, {
      publicKey: JSON.stringify(dpopKey.publicKey),
      privateKey: JSON.stringify(await exportJWK(dpopKey.privateKey))
    }, { secure });
  }
}
function normalizeHTU(audience) {
  const audienceUrl = new URL(audience);
  return new URL(audienceUrl.pathname, audienceUrl.origin).toString();
}
async function createDpopHeader(audience, method, dpopKey) {
  return new SignJWT({
    htu: normalizeHTU(audience),
    htm: method.toUpperCase(),
    jti: v4_default()
  }).setProtectedHeader({
    alg: PREFERRED_SIGNING_ALG[0],
    jwk: dpopKey.publicKey,
    typ: "dpop+jwt"
  }).setIssuedAt().sign(dpopKey.privateKey, {});
}
async function generateDpopKeyPair() {
  const { privateKey, publicKey } = await generateKeyPair2(PREFERRED_SIGNING_ALG[0]);
  const dpopKeyPair = {
    privateKey,
    publicKey: await exportJWK(publicKey)
  };
  [dpopKeyPair.publicKey.alg] = PREFERRED_SIGNING_ALG;
  return dpopKeyPair;
}
function isExpectedAuthError(statusCode) {
  return [401, 403].includes(statusCode);
}
async function buildDpopFetchOptions(targetUrl, authToken, dpopKey, defaultOptions) {
  const headers = new Headers(defaultOptions?.headers);
  headers.set("Authorization", `DPoP ${authToken}`);
  headers.set("DPoP", await createDpopHeader(targetUrl, defaultOptions?.method ?? "get", dpopKey));
  return {
    ...defaultOptions,
    headers
  };
}
async function buildAuthenticatedHeaders(targetUrl, authToken, dpopKey, defaultOptions) {
  if (dpopKey !== void 0) {
    return buildDpopFetchOptions(targetUrl, authToken, dpopKey, defaultOptions);
  }
  const headers = new Headers(defaultOptions?.headers);
  headers.set("Authorization", `Bearer ${authToken}`);
  return {
    ...defaultOptions,
    headers
  };
}
async function makeAuthenticatedRequest(accessToken, url2, defaultRequestInit, dpopKey, unauthFetch = fetch) {
  return unauthFetch(url2, await buildAuthenticatedHeaders(url2.toString(), accessToken, dpopKey, defaultRequestInit));
}
async function refreshAccessToken(refreshOptions, dpopKey, eventEmitter) {
  const tokenSet = await refreshOptions.tokenRefresher.refresh(refreshOptions.sessionId, refreshOptions.refreshToken, dpopKey);
  eventEmitter?.emit(EVENTS.SESSION_EXTENDED, tokenSet.expiresIn ?? DEFAULT_EXPIRATION_TIME_SECONDS);
  return {
    accessToken: tokenSet.accessToken,
    refreshToken: tokenSet.refreshToken,
    expiresIn: tokenSet.expiresIn
  };
}
function buildAuthenticatedFetch(accessToken, options) {
  let currentAccessToken = accessToken;
  let latestTimeout;
  const currentRefreshOptions = options?.refreshOptions;
  if (currentRefreshOptions !== void 0) {
    const proactivelyRefreshToken = async () => {
      try {
        const { accessToken: refreshedAccessToken, refreshToken, expiresIn } = await refreshAccessToken(
          currentRefreshOptions,
          // If currentRefreshOptions is defined, options is necessarily defined too.
          // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
          options.dpopKey,
          // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
          options.eventEmitter
        );
        currentAccessToken = refreshedAccessToken;
        if (refreshToken !== void 0) {
          currentRefreshOptions.refreshToken = refreshToken;
        }
        clearTimeout(latestTimeout);
        latestTimeout = setTimeout(proactivelyRefreshToken, computeRefreshDelay(expiresIn) * 1e3);
        options.eventEmitter?.emit(EVENTS.TIMEOUT_SET, latestTimeout);
      } catch (e) {
        if (e instanceof OidcProviderError) {
          options?.eventEmitter?.emit(EVENTS.ERROR, e.error, e.errorDescription);
          options?.eventEmitter?.emit(EVENTS.SESSION_EXPIRED);
        }
        if (e instanceof InvalidResponseError && e.missingFields.includes("access_token")) {
          options?.eventEmitter?.emit(EVENTS.SESSION_EXPIRED);
        }
      }
    };
    latestTimeout = setTimeout(
      proactivelyRefreshToken,
      // If currentRefreshOptions is defined, options is necessarily defined too.
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      computeRefreshDelay(options.expiresIn) * 1e3
    );
    options.eventEmitter?.emit(EVENTS.TIMEOUT_SET, latestTimeout);
  } else if (options !== void 0 && options.eventEmitter !== void 0) {
    const expirationTimeout = setTimeout(() => {
      options.eventEmitter.emit(EVENTS.SESSION_EXPIRED);
    }, computeRefreshDelay(options.expiresIn) * 1e3);
    options.eventEmitter.emit(EVENTS.TIMEOUT_SET, expirationTimeout);
  }
  return async (url2, requestInit) => {
    let response = await makeAuthenticatedRequest(currentAccessToken, url2, requestInit, options?.dpopKey, options?.fetch);
    const failedButNotExpectedAuthError = !response.ok && !isExpectedAuthError(response.status);
    if (response.ok || failedButNotExpectedAuthError) {
      return response;
    }
    const hasBeenRedirected = response.url !== url2;
    if (hasBeenRedirected && options?.dpopKey !== void 0) {
      response = await makeAuthenticatedRequest(
        currentAccessToken,
        // Replace the original target IRI (`url`) by the redirection target
        response.url,
        requestInit,
        options.dpopKey,
        options.fetch
      );
    }
    return response;
  };
}
var SOLID_CLIENT_AUTHN_KEY_PREFIX, PREFERRED_SIGNING_ALG, EVENTS, REFRESH_BEFORE_EXPIRATION_SECONDS, SCOPE_OPENID, SCOPE_OFFLINE, SCOPE_WEBID, DEFAULT_SCOPES, AggregateHandler, AuthorizationCodeWithPkceOidcHandlerBase, GeneralLogoutHandler, IRpLogoutHandler, IWaterfallLogoutHandler, SessionInfoManagerBase, boundFetch, ClientAuthentication, StorageUtility, InMemoryStorage, ConfigurationError, InvalidResponseError, OidcProviderError, DEFAULT_EXPIRATION_TIME_SECONDS, computeRefreshDelay;
var init_dist3 = __esm({
  "node_modules/@inrupt/solid-client-authn-core/dist/index.mjs"() {
    init_browser();
    init_esm_browser();
    SOLID_CLIENT_AUTHN_KEY_PREFIX = "solidClientAuthn:";
    PREFERRED_SIGNING_ALG = ["ES256", "RS256"];
    EVENTS = {
      // Note that an `error` events MUST be listened to: https://nodejs.org/dist/latest-v16.x/docs/api/events.html#error-events.
      ERROR: "error",
      LOGIN: "login",
      LOGOUT: "logout",
      NEW_REFRESH_TOKEN: "newRefreshToken",
      NEW_TOKENS: "newTokens",
      AUTHORIZATION_REQUEST: "authorizationRequest",
      SESSION_EXPIRED: "sessionExpired",
      SESSION_EXTENDED: "sessionExtended",
      SESSION_RESTORED: "sessionRestore",
      TIMEOUT_SET: "timeoutSet"
    };
    REFRESH_BEFORE_EXPIRATION_SECONDS = 5;
    SCOPE_OPENID = "openid";
    SCOPE_OFFLINE = "offline_access";
    SCOPE_WEBID = "webid";
    DEFAULT_SCOPES = [SCOPE_OPENID, SCOPE_OFFLINE, SCOPE_WEBID];
    AggregateHandler = class {
      handleables;
      constructor(handleables) {
        this.handleables = handleables;
        this.handleables = handleables;
      }
      /**
       * Helper function that will asynchronously determine the proper handler to use. If multiple
       * handlers can handle, it will choose the first one in the list
       * @param params Paramerters to feed to the handler
       */
      async getProperHandler(params) {
        const canHandleList = await Promise.all(this.handleables.map((handleable) => handleable.canHandle(...params)));
        for (let i = 0; i < canHandleList.length; i += 1) {
          if (canHandleList[i]) {
            return this.handleables[i];
          }
        }
        return null;
      }
      async canHandle(...params) {
        return await this.getProperHandler(params) !== null;
      }
      async handle(...params) {
        const handler = await this.getProperHandler(params);
        if (handler) {
          return handler.handle(...params);
        }
        throw new Error(`[${this.constructor.name}] cannot find a suitable handler for: ${params.map((param) => {
          try {
            return JSON.stringify(param);
          } catch (err) {
            return param.toString();
          }
        }).join(", ")}`);
      }
    };
    AuthorizationCodeWithPkceOidcHandlerBase = class {
      storageUtility;
      redirector;
      constructor(storageUtility, redirector) {
        this.storageUtility = storageUtility;
        this.redirector = redirector;
        this.storageUtility = storageUtility;
        this.redirector = redirector;
      }
      parametersGuard = (oidcLoginOptions) => {
        return oidcLoginOptions.issuerConfiguration.grantTypesSupported !== void 0 && oidcLoginOptions.issuerConfiguration.grantTypesSupported.indexOf("authorization_code") > -1 && oidcLoginOptions.redirectUrl !== void 0;
      };
      async canHandle(oidcLoginOptions) {
        return this.parametersGuard(oidcLoginOptions);
      }
      async setupRedirectHandler({ oidcLoginOptions, state, codeVerifier, targetUrl }) {
        if (!this.parametersGuard(oidcLoginOptions)) {
          throw new Error("The authorization code grant requires a redirectUrl.");
        }
        await Promise.all([
          // We use the OAuth 'state' value (which should be crypto-random) as
          // the key in our storage to store our actual SessionID. We do this
          // 'cos we'll need to lookup our session information again when the
          // browser is redirected back to us (i.e. the OAuth client
          // application) from the Authorization Server.
          // We don't want to use our session ID as the OAuth 'state' value, as
          // that session ID can be any developer-specified value, and therefore
          // may not be appropriate (since the OAuth 'state' value should really
          // be an unguessable crypto-random value).
          this.storageUtility.setForUser(state, {
            sessionId: oidcLoginOptions.sessionId
          }),
          // Store our login-process state using the session ID as the key.
          // Strictly speaking, this indirection from our OAuth state value to
          // our session ID is unnecessary, but it provides a slightly cleaner
          // separation of concerns.
          this.storageUtility.setForUser(oidcLoginOptions.sessionId, {
            codeVerifier,
            issuer: oidcLoginOptions.issuer.toString(),
            // The redirect URL is read after redirect, so it must be stored now.
            redirectUrl: oidcLoginOptions.redirectUrl,
            dpop: Boolean(oidcLoginOptions.dpop).toString(),
            keepAlive: booleanWithFallback(oidcLoginOptions.keepAlive, true).toString()
          })
        ]);
        this.redirector.redirect(targetUrl, {
          handleRedirect: oidcLoginOptions.handleRedirect
        });
        return void 0;
      }
    };
    GeneralLogoutHandler = class {
      sessionInfoManager;
      constructor(sessionInfoManager) {
        this.sessionInfoManager = sessionInfoManager;
        this.sessionInfoManager = sessionInfoManager;
      }
      async canHandle() {
        return true;
      }
      async handle(userId) {
        await this.sessionInfoManager.clear(userId);
      }
    };
    IRpLogoutHandler = class {
      redirector;
      constructor(redirector) {
        this.redirector = redirector;
        this.redirector = redirector;
      }
      async canHandle(userId, options) {
        return options?.logoutType === "idp";
      }
      async handle(userId, options) {
        if (options?.logoutType !== "idp") {
          throw new Error("Attempting to call idp logout handler to perform app logout");
        }
        if (options.toLogoutUrl === void 0) {
          throw new Error("Cannot perform IDP logout. Did you log in using the OIDC authentication flow?");
        }
        this.redirector.redirect(options.toLogoutUrl(options), {
          handleRedirect: options.handleRedirect
        });
      }
    };
    IWaterfallLogoutHandler = class {
      handlers;
      constructor(sessionInfoManager, redirector) {
        this.handlers = [
          new GeneralLogoutHandler(sessionInfoManager),
          new IRpLogoutHandler(redirector)
        ];
      }
      async canHandle() {
        return true;
      }
      async handle(userId, options) {
        for (const handler of this.handlers) {
          if (await handler.canHandle(userId, options))
            await handler.handle(userId, options);
        }
      }
    };
    SessionInfoManagerBase = class {
      storageUtility;
      constructor(storageUtility) {
        this.storageUtility = storageUtility;
        this.storageUtility = storageUtility;
      }
      update(_sessionId, _options) {
        throw new Error("Not Implemented");
      }
      set(_sessionId, _sessionInfo) {
        throw new Error("Not Implemented");
      }
      get(_) {
        throw new Error("Not implemented");
      }
      // eslint-disable-next-line class-methods-use-this
      async getAll() {
        throw new Error("Not implemented");
      }
      /**
       * This function removes all session-related information from storage.
       * @param sessionId the session identifier
       * @hidden
       */
      async clear(sessionId) {
        return clear(sessionId, this.storageUtility);
      }
      /**
       * Registers a new session, so that its ID can be retrieved.
       */
      async register(_sessionId) {
        throw new Error("Not implemented");
      }
      /**
       * Returns all the registered session IDs. Differs from getAll, which also
       * returns additional session information.
       */
      async getRegisteredSessionIdAll() {
        throw new Error("Not implemented");
      }
      /**
       * Deletes all information about all sessions, including their registrations.
       */
      async clearAll() {
        throw new Error("Not implemented");
      }
      /**
       * Sets authorization request state in storage for a given session ID.
       */
      async setOidcContext(_sessionId, _authorizationRequestState) {
        throw new Error("Not implemented");
      }
    };
    boundFetch = (request, init) => fetch(request, init);
    ClientAuthentication = class {
      loginHandler;
      redirectHandler;
      logoutHandler;
      sessionInfoManager;
      issuerConfigFetcher;
      boundLogout;
      constructor(loginHandler, redirectHandler, logoutHandler, sessionInfoManager, issuerConfigFetcher) {
        this.loginHandler = loginHandler;
        this.redirectHandler = redirectHandler;
        this.logoutHandler = logoutHandler;
        this.sessionInfoManager = sessionInfoManager;
        this.issuerConfigFetcher = issuerConfigFetcher;
        this.loginHandler = loginHandler;
        this.redirectHandler = redirectHandler;
        this.logoutHandler = logoutHandler;
        this.sessionInfoManager = sessionInfoManager;
        this.issuerConfigFetcher = issuerConfigFetcher;
      }
      // By default, our fetch() resolves to the environment fetch() function.
      fetch = boundFetch;
      logout = async (sessionId, options) => {
        await this.logoutHandler.handle(sessionId, options?.logoutType === "idp" ? {
          ...options,
          toLogoutUrl: this.boundLogout
        } : options);
        this.fetch = boundFetch;
        delete this.boundLogout;
      };
      getSessionInfo = async (sessionId) => {
        return this.sessionInfoManager.get(sessionId);
      };
      getAllSessionInfo = async () => {
        return this.sessionInfoManager.getAll();
      };
    };
    StorageUtility = class {
      secureStorage;
      insecureStorage;
      constructor(secureStorage, insecureStorage) {
        this.secureStorage = secureStorage;
        this.insecureStorage = insecureStorage;
        this.secureStorage = secureStorage;
        this.insecureStorage = insecureStorage;
      }
      getKey(userId) {
        return `solidClientAuthenticationUser:${userId}`;
      }
      async getUserData(userId, secure) {
        const stored = await (secure ? this.secureStorage : this.insecureStorage).get(this.getKey(userId));
        if (stored === void 0) {
          return {};
        }
        try {
          return JSON.parse(stored);
        } catch (err) {
          throw new Error(`Data for user [${userId}] in [${secure ? "secure" : "unsecure"}] storage is corrupted - expected valid JSON, but got: ${stored}`);
        }
      }
      async setUserData(userId, data, secure) {
        await (secure ? this.secureStorage : this.insecureStorage).set(this.getKey(userId), JSON.stringify(data));
      }
      async get(key, options) {
        const value = await (options?.secure ? this.secureStorage : this.insecureStorage).get(key);
        if (value === void 0 && options?.errorIfNull) {
          throw new Error(`[${key}] is not stored`);
        }
        return value;
      }
      async set(key, value, options) {
        return (options?.secure ? this.secureStorage : this.insecureStorage).set(key, value);
      }
      async delete(key, options) {
        return (options?.secure ? this.secureStorage : this.insecureStorage).delete(key);
      }
      async getForUser(userId, key, options) {
        const userData = await this.getUserData(userId, options?.secure);
        let value;
        if (!userData || !userData[key]) {
          value = void 0;
        }
        value = userData[key];
        if (value === void 0 && options?.errorIfNull) {
          throw new Error(`Field [${key}] for user [${userId}] is not stored`);
        }
        return value || void 0;
      }
      async setForUser(userId, values, options) {
        let userData;
        try {
          userData = await this.getUserData(userId, options?.secure);
        } catch {
          userData = {};
        }
        await this.setUserData(userId, { ...userData, ...values }, options?.secure);
      }
      async deleteForUser(userId, key, options) {
        const userData = await this.getUserData(userId, options?.secure);
        delete userData[key];
        await this.setUserData(userId, userData, options?.secure);
      }
      async deleteAllUserData(userId, options) {
        await (options?.secure ? this.secureStorage : this.insecureStorage).delete(this.getKey(userId));
      }
    };
    InMemoryStorage = class {
      map = {};
      async get(key) {
        return this.map[key] || void 0;
      }
      async set(key, value) {
        this.map[key] = value;
      }
      async delete(key) {
        delete this.map[key];
      }
    };
    ConfigurationError = class extends Error {
      /* istanbul ignore next */
      constructor(message2) {
        super(message2);
      }
    };
    InvalidResponseError = class extends Error {
      missingFields;
      /* istanbul ignore next */
      constructor(missingFields) {
        super(`Invalid response from OIDC provider: missing fields ${missingFields}`);
        this.missingFields = missingFields;
      }
    };
    OidcProviderError = class extends Error {
      error;
      errorDescription;
      /* istanbul ignore next */
      constructor(message2, error46, errorDescription) {
        super(message2);
        this.error = error46;
        this.errorDescription = errorDescription;
      }
    };
    DEFAULT_EXPIRATION_TIME_SECONDS = 600;
    computeRefreshDelay = (expiresIn) => {
      if (expiresIn !== void 0) {
        return expiresIn - REFRESH_BEFORE_EXPIRATION_SECONDS > 0 ? (
          // We want to refresh the token 5 seconds before they actually expire.
          expiresIn - REFRESH_BEFORE_EXPIRATION_SECONDS
        ) : expiresIn;
      }
      return DEFAULT_EXPIRATION_TIME_SECONDS;
    };
  }
});

// node_modules/@inrupt/oidc-client/lib/oidc-client.min.js
var require_oidc_client_min = __commonJS({
  "node_modules/@inrupt/oidc-client/lib/oidc-client.min.js"(exports, module) {
    !(function t(e, r) {
      if ("object" == typeof exports && "object" == typeof module) module.exports = r();
      else if ("function" == typeof define && define.amd) define([], r);
      else {
        var n = r();
        for (var i in n) ("object" == typeof exports ? exports : e)[i] = n[i];
      }
    })(exports, (function() {
      return (function(t) {
        var e = {};
        function r(n) {
          if (e[n]) return e[n].exports;
          var i = e[n] = { i: n, l: false, exports: {} };
          return t[n].call(i.exports, i, i.exports, r), i.l = true, i.exports;
        }
        return r.m = t, r.c = e, r.d = function(t2, e2, n) {
          r.o(t2, e2) || Object.defineProperty(t2, e2, { enumerable: true, get: n });
        }, r.r = function(t2) {
          "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(t2, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(t2, "__esModule", { value: true });
        }, r.t = function(t2, e2) {
          if (1 & e2 && (t2 = r(t2)), 8 & e2) return t2;
          if (4 & e2 && "object" == typeof t2 && t2 && t2.__esModule) return t2;
          var n = /* @__PURE__ */ Object.create(null);
          if (r.r(n), Object.defineProperty(n, "default", { enumerable: true, value: t2 }), 2 & e2 && "string" != typeof t2) for (var i in t2) r.d(n, i, function(e3) {
            return t2[e3];
          }.bind(null, i));
          return n;
        }, r.n = function(t2) {
          var e2 = t2 && t2.__esModule ? function e3() {
            return t2.default;
          } : function e3() {
            return t2;
          };
          return r.d(e2, "a", e2), e2;
        }, r.o = function(t2, e2) {
          return Object.prototype.hasOwnProperty.call(t2, e2);
        }, r.p = "", r(r.s = 22);
      })([function(t, e, r) {
        "use strict";
        Object.defineProperty(e, "__esModule", { value: true });
        var n = /* @__PURE__ */ (function() {
          function t2(t3, e2) {
            for (var r2 = 0; r2 < e2.length; r2++) {
              var n2 = e2[r2];
              n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(t3, n2.key, n2);
            }
          }
          return function(e2, r2, n2) {
            return r2 && t2(e2.prototype, r2), n2 && t2(e2, n2), e2;
          };
        })();
        var i = { debug: function t2() {
        }, info: function t2() {
        }, warn: function t2() {
        }, error: function t2() {
        } }, o = void 0, s = void 0;
        (e.Log = (function() {
          function t2() {
            !(function e2(t3, r2) {
              if (!(t3 instanceof r2)) throw new TypeError("Cannot call a class as a function");
            })(this, t2);
          }
          return t2.reset = function t3() {
            s = 3, o = i;
          }, t2.debug = function t3() {
            if (s >= 4) {
              for (var e2 = arguments.length, r2 = Array(e2), n2 = 0; n2 < e2; n2++) r2[n2] = arguments[n2];
              o.debug.apply(o, Array.from(r2));
            }
          }, t2.info = function t3() {
            if (s >= 3) {
              for (var e2 = arguments.length, r2 = Array(e2), n2 = 0; n2 < e2; n2++) r2[n2] = arguments[n2];
              o.info.apply(o, Array.from(r2));
            }
          }, t2.warn = function t3() {
            if (s >= 2) {
              for (var e2 = arguments.length, r2 = Array(e2), n2 = 0; n2 < e2; n2++) r2[n2] = arguments[n2];
              o.warn.apply(o, Array.from(r2));
            }
          }, t2.error = function t3() {
            if (s >= 1) {
              for (var e2 = arguments.length, r2 = Array(e2), n2 = 0; n2 < e2; n2++) r2[n2] = arguments[n2];
              o.error.apply(o, Array.from(r2));
            }
          }, n(t2, null, [{ key: "NONE", get: function t3() {
            return 0;
          } }, { key: "ERROR", get: function t3() {
            return 1;
          } }, { key: "WARN", get: function t3() {
            return 2;
          } }, { key: "INFO", get: function t3() {
            return 3;
          } }, { key: "DEBUG", get: function t3() {
            return 4;
          } }, { key: "level", get: function t3() {
            return s;
          }, set: function t3(e2) {
            if (!(0 <= e2 && e2 <= 4)) throw new Error("Invalid log level");
            s = e2;
          } }, { key: "logger", get: function t3() {
            return o;
          }, set: function t3(e2) {
            if (!e2.debug && e2.info && (e2.debug = e2.info), !(e2.debug && e2.info && e2.warn && e2.error)) throw new Error("Invalid logger");
            o = e2;
          } }]), t2;
        })()).reset();
      }, function(t, e, r) {
        "use strict";
        Object.defineProperty(e, "__esModule", { value: true });
        var n = /* @__PURE__ */ (function() {
          function t2(t3, e2) {
            for (var r2 = 0; r2 < e2.length; r2++) {
              var n2 = e2[r2];
              n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(t3, n2.key, n2);
            }
          }
          return function(e2, r2, n2) {
            return r2 && t2(e2.prototype, r2), n2 && t2(e2, n2), e2;
          };
        })();
        var i = { setInterval: (function(t2) {
          function e2(e3, r2) {
            return t2.apply(this, arguments);
          }
          return e2.toString = function() {
            return t2.toString();
          }, e2;
        })((function(t2, e2) {
          return setInterval(t2, e2);
        })), clearInterval: (function(t2) {
          function e2(e3) {
            return t2.apply(this, arguments);
          }
          return e2.toString = function() {
            return t2.toString();
          }, e2;
        })((function(t2) {
          return clearInterval(t2);
        })) }, o = false, s = null;
        e.Global = (function() {
          function t2() {
            !(function e2(t3, r2) {
              if (!(t3 instanceof r2)) throw new TypeError("Cannot call a class as a function");
            })(this, t2);
          }
          return t2._testing = function t3() {
            o = true;
          }, t2.setXMLHttpRequest = function t3(e2) {
            s = e2;
          }, n(t2, null, [{ key: "location", get: function t3() {
            if (!o) return location;
          } }, { key: "localStorage", get: function t3() {
            if (!o && "undefined" != typeof window) return localStorage;
          } }, { key: "sessionStorage", get: function t3() {
            if (!o && "undefined" != typeof window) return sessionStorage;
          } }, { key: "XMLHttpRequest", get: function t3() {
            if (!o && "undefined" != typeof window) return s || XMLHttpRequest;
          } }, { key: "timer", get: function t3() {
            if (!o) return i;
          } }]), t2;
        })();
      }, function(t, e, r) {
        "use strict";
        Object.defineProperty(e, "__esModule", { value: true }), e.MetadataService = void 0;
        var n = /* @__PURE__ */ (function() {
          function t2(t3, e2) {
            for (var r2 = 0; r2 < e2.length; r2++) {
              var n2 = e2[r2];
              n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(t3, n2.key, n2);
            }
          }
          return function(e2, r2, n2) {
            return r2 && t2(e2.prototype, r2), n2 && t2(e2, n2), e2;
          };
        })(), i = r(0), o = r(7);
        function s(t2, e2) {
          if (!(t2 instanceof e2)) throw new TypeError("Cannot call a class as a function");
        }
        var a = ".well-known/openid-configuration";
        e.MetadataService = (function() {
          function t2(e2) {
            var r2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : o.JsonService;
            if (s(this, t2), !e2) throw i.Log.error("MetadataService: No settings passed to MetadataService"), new Error("settings");
            this._settings = e2, this._jsonService = new r2(["application/jwk-set+json"]);
          }
          return t2.prototype.resetSigningKeys = function t3() {
            this._settings = this._settings || {}, this._settings.signingKeys = void 0;
          }, t2.prototype.getMetadata = function t3() {
            var e2 = this;
            return this._settings.metadata ? (i.Log.debug("MetadataService.getMetadata: Returning metadata from settings"), Promise.resolve(this._settings.metadata)) : this.metadataUrl ? (i.Log.debug("MetadataService.getMetadata: getting metadata from", this.metadataUrl), this._jsonService.getJson(this.metadataUrl).then((function(t4) {
              i.Log.debug("MetadataService.getMetadata: json received");
              var r2 = e2._settings.metadataSeed || {};
              return e2._settings.metadata = Object.assign({}, r2, t4), e2._settings.metadata;
            }))) : (i.Log.error("MetadataService.getMetadata: No authority or metadataUrl configured on settings"), Promise.reject(new Error("No authority or metadataUrl configured on settings")));
          }, t2.prototype.getIssuer = function t3() {
            return this._getMetadataProperty("issuer");
          }, t2.prototype.getAuthorizationEndpoint = function t3() {
            return this._getMetadataProperty("authorization_endpoint");
          }, t2.prototype.getUserInfoEndpoint = function t3() {
            return this._getMetadataProperty("userinfo_endpoint");
          }, t2.prototype.getTokenEndpoint = function t3() {
            var e2 = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0];
            return this._getMetadataProperty("token_endpoint", e2);
          }, t2.prototype.getCheckSessionIframe = function t3() {
            return this._getMetadataProperty("check_session_iframe", true);
          }, t2.prototype.getEndSessionEndpoint = function t3() {
            return this._getMetadataProperty("end_session_endpoint", true);
          }, t2.prototype.getRevocationEndpoint = function t3() {
            return this._getMetadataProperty("revocation_endpoint", true);
          }, t2.prototype.getKeysEndpoint = function t3() {
            return this._getMetadataProperty("jwks_uri", true);
          }, t2.prototype._getMetadataProperty = function t3(e2) {
            var r2 = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
            return i.Log.debug("MetadataService.getMetadataProperty for: " + e2), this.getMetadata().then((function(t4) {
              if (i.Log.debug("MetadataService.getMetadataProperty: metadata recieved"), void 0 === t4[e2]) {
                if (true === r2) return void i.Log.warn("MetadataService.getMetadataProperty: Metadata does not contain optional property " + e2);
                throw i.Log.error("MetadataService.getMetadataProperty: Metadata does not contain property " + e2), new Error("Metadata does not contain property " + e2);
              }
              return t4[e2];
            }));
          }, t2.prototype.getSigningKeys = function t3() {
            var e2 = this;
            return this._settings.signingKeys ? (i.Log.debug("MetadataService.getSigningKeys: Returning signingKeys from settings"), Promise.resolve(this._settings.signingKeys)) : this._getMetadataProperty("jwks_uri").then((function(t4) {
              return i.Log.debug("MetadataService.getSigningKeys: jwks_uri received", t4), e2._jsonService.getJson(t4).then((function(t5) {
                if (i.Log.debug("MetadataService.getSigningKeys: key set received", t5), !t5.keys) throw i.Log.error("MetadataService.getSigningKeys: Missing keys on keyset"), new Error("Missing keys on keyset");
                return e2._settings.signingKeys = t5.keys, e2._settings.signingKeys;
              }));
            }));
          }, n(t2, [{ key: "metadataUrl", get: function t3() {
            return this._metadataUrl || (this._settings.metadataUrl ? this._metadataUrl = this._settings.metadataUrl : (this._metadataUrl = this._settings.authority, this._metadataUrl && this._metadataUrl.indexOf(a) < 0 && ("/" !== this._metadataUrl[this._metadataUrl.length - 1] && (this._metadataUrl += "/"), this._metadataUrl += a))), this._metadataUrl;
          } }]), t2;
        })();
      }, function(t, e, r) {
        "use strict";
        Object.defineProperty(e, "__esModule", { value: true }), e.UrlUtility = void 0;
        var n = r(0), i = r(1);
        e.UrlUtility = (function() {
          function t2() {
            !(function e2(t3, r2) {
              if (!(t3 instanceof r2)) throw new TypeError("Cannot call a class as a function");
            })(this, t2);
          }
          return t2.addQueryParam = function t3(e2, r2, n2) {
            return e2.indexOf("?") < 0 && (e2 += "?"), "?" !== e2[e2.length - 1] && (e2 += "&"), e2 += encodeURIComponent(r2), e2 += "=", e2 += encodeURIComponent(n2);
          }, t2.parseUrlFragment = function t3(e2) {
            var r2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "#", o = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : i.Global;
            "string" != typeof e2 && (e2 = o.location.href);
            var s = e2.lastIndexOf(r2);
            s >= 0 && (e2 = e2.substr(s + 1)), "?" === r2 && (s = e2.indexOf("#")) >= 0 && (e2 = e2.substr(0, s));
            for (var a, u = {}, c = /([^&=]+)=([^&]*)/g, h = 0; a = c.exec(e2); ) if (u[decodeURIComponent(a[1])] = decodeURIComponent(a[2].replace(/\+/g, " ")), h++ > 50) return n.Log.error("UrlUtility.parseUrlFragment: response exceeded expected number of parameters", e2), { error: "Response exceeded expected number of parameters" };
            for (var l in u) return u;
            return {};
          }, t2;
        })();
      }, function(t, e, r) {
        "use strict";
        Object.defineProperty(e, "__esModule", { value: true }), e.JoseUtil = void 0;
        var n = r(26), i = (function o(t2) {
          return t2 && t2.__esModule ? t2 : { default: t2 };
        })(r(33));
        e.JoseUtil = (0, i.default)({ jws: n.jws, KeyUtil: n.KeyUtil, X509: n.X509, crypto: n.crypto, hextob64u: n.hextob64u, b64tohex: n.b64tohex, AllowedSigningAlgs: n.AllowedSigningAlgs });
      }, function(t, e, r) {
        "use strict";
        Object.defineProperty(e, "__esModule", { value: true }), e.OidcClientSettings = void 0;
        var n = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t2) {
          return typeof t2;
        } : function(t2) {
          return t2 && "function" == typeof Symbol && t2.constructor === Symbol && t2 !== Symbol.prototype ? "symbol" : typeof t2;
        }, i = /* @__PURE__ */ (function() {
          function t2(t3, e2) {
            for (var r2 = 0; r2 < e2.length; r2++) {
              var n2 = e2[r2];
              n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(t3, n2.key, n2);
            }
          }
          return function(e2, r2, n2) {
            return r2 && t2(e2.prototype, r2), n2 && t2(e2, n2), e2;
          };
        })(), o = r(0), s = r(23), a = r(6), u = r(24), c = r(2);
        function h(t2, e2) {
          if (!(t2 instanceof e2)) throw new TypeError("Cannot call a class as a function");
        }
        var l = ".well-known/openid-configuration", f = "id_token", g = "openid", d = "client_secret_post";
        e.OidcClientSettings = (function() {
          function t2() {
            var e2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, r2 = e2.authority, i2 = e2.metadataUrl, o2 = e2.metadata, l2 = e2.signingKeys, p = e2.metadataSeed, v = e2.client_id, y = e2.client_secret, m = e2.response_type, _ = void 0 === m ? f : m, S = e2.scope, b = void 0 === S ? g : S, w = e2.redirect_uri, F = e2.post_logout_redirect_uri, E = e2.client_authentication, x = void 0 === E ? d : E, A = e2.prompt, k = e2.display, P = e2.max_age, C = e2.ui_locales, T = e2.acr_values, R = e2.resource, I = e2.response_mode, D = e2.filterProtocolClaims, L = void 0 === D || D, N = e2.loadUserInfo, U = void 0 === N || N, B = e2.staleStateAge, O = void 0 === B ? 900 : B, j = e2.clockSkew, M = void 0 === j ? 300 : j, H = e2.clockService, V = void 0 === H ? new s.ClockService() : H, K = e2.userInfoJwtIssuer, q = void 0 === K ? "OP" : K, J = e2.mergeClaims, W = void 0 !== J && J, z = e2.stateStore, Y = void 0 === z ? new a.WebStorageStateStore() : z, G = e2.ResponseValidatorCtor, X = void 0 === G ? u.ResponseValidator : G, $ = e2.MetadataServiceCtor, Q = void 0 === $ ? c.MetadataService : $, Z = e2.extraQueryParams, tt = void 0 === Z ? {} : Z, et = e2.extraTokenParams, rt = void 0 === et ? {} : et;
            h(this, t2), this._authority = r2, this._metadataUrl = i2, this._metadata = o2, this._metadataSeed = p, this._signingKeys = l2, this._client_id = v, this._client_secret = y, this._response_type = _, this._scope = b, this._redirect_uri = w, this._post_logout_redirect_uri = F, this._client_authentication = x, this._prompt = A, this._display = k, this._max_age = P, this._ui_locales = C, this._acr_values = T, this._resource = R, this._response_mode = I, this._filterProtocolClaims = !!L, this._loadUserInfo = !!U, this._staleStateAge = O, this._clockSkew = M, this._clockService = V, this._userInfoJwtIssuer = q, this._mergeClaims = !!W, this._stateStore = Y, this._validator = new X(this), this._metadataService = new Q(this), this._extraQueryParams = "object" === (void 0 === tt ? "undefined" : n(tt)) ? tt : {}, this._extraTokenParams = "object" === (void 0 === rt ? "undefined" : n(rt)) ? rt : {};
          }
          return t2.prototype.getEpochTime = function t3() {
            return this._clockService.getEpochTime();
          }, i(t2, [{ key: "client_id", get: function t3() {
            return this._client_id;
          }, set: function t3(e2) {
            if (this._client_id) throw o.Log.error("OidcClientSettings.set_client_id: client_id has already been assigned."), new Error("client_id has already been assigned.");
            this._client_id = e2;
          } }, { key: "client_secret", get: function t3() {
            return this._client_secret;
          } }, { key: "response_type", get: function t3() {
            return this._response_type;
          } }, { key: "scope", get: function t3() {
            return this._scope;
          } }, { key: "redirect_uri", get: function t3() {
            return this._redirect_uri;
          } }, { key: "post_logout_redirect_uri", get: function t3() {
            return this._post_logout_redirect_uri;
          } }, { key: "client_authentication", get: function t3() {
            return this._client_authentication;
          } }, { key: "prompt", get: function t3() {
            return this._prompt;
          } }, { key: "display", get: function t3() {
            return this._display;
          } }, { key: "max_age", get: function t3() {
            return this._max_age;
          } }, { key: "ui_locales", get: function t3() {
            return this._ui_locales;
          } }, { key: "acr_values", get: function t3() {
            return this._acr_values;
          } }, { key: "resource", get: function t3() {
            return this._resource;
          } }, { key: "response_mode", get: function t3() {
            return this._response_mode;
          } }, { key: "authority", get: function t3() {
            return this._authority;
          }, set: function t3(e2) {
            if (this._authority) throw o.Log.error("OidcClientSettings.set_authority: authority has already been assigned."), new Error("authority has already been assigned.");
            this._authority = e2;
          } }, { key: "metadataUrl", get: function t3() {
            return this._metadataUrl || (this._metadataUrl = this.authority, this._metadataUrl && this._metadataUrl.indexOf(l) < 0 && ("/" !== this._metadataUrl[this._metadataUrl.length - 1] && (this._metadataUrl += "/"), this._metadataUrl += l)), this._metadataUrl;
          } }, { key: "metadata", get: function t3() {
            return this._metadata;
          }, set: function t3(e2) {
            this._metadata = e2;
          } }, { key: "metadataSeed", get: function t3() {
            return this._metadataSeed;
          }, set: function t3(e2) {
            this._metadataSeed = e2;
          } }, { key: "signingKeys", get: function t3() {
            return this._signingKeys;
          }, set: function t3(e2) {
            this._signingKeys = e2;
          } }, { key: "filterProtocolClaims", get: function t3() {
            return this._filterProtocolClaims;
          } }, { key: "loadUserInfo", get: function t3() {
            return this._loadUserInfo;
          } }, { key: "staleStateAge", get: function t3() {
            return this._staleStateAge;
          } }, { key: "clockSkew", get: function t3() {
            return this._clockSkew;
          } }, { key: "userInfoJwtIssuer", get: function t3() {
            return this._userInfoJwtIssuer;
          } }, { key: "mergeClaims", get: function t3() {
            return this._mergeClaims;
          } }, { key: "stateStore", get: function t3() {
            return this._stateStore;
          } }, { key: "validator", get: function t3() {
            return this._validator;
          } }, { key: "metadataService", get: function t3() {
            return this._metadataService;
          } }, { key: "extraQueryParams", get: function t3() {
            return this._extraQueryParams;
          }, set: function t3(e2) {
            "object" === (void 0 === e2 ? "undefined" : n(e2)) ? this._extraQueryParams = e2 : this._extraQueryParams = {};
          } }, { key: "extraTokenParams", get: function t3() {
            return this._extraTokenParams;
          }, set: function t3(e2) {
            "object" === (void 0 === e2 ? "undefined" : n(e2)) ? this._extraTokenParams = e2 : this._extraTokenParams = {};
          } }]), t2;
        })();
      }, function(t, e, r) {
        "use strict";
        Object.defineProperty(e, "__esModule", { value: true }), e.WebStorageStateStore = void 0;
        var n = r(0), i = r(1);
        function o(t2, e2) {
          if (!(t2 instanceof e2)) throw new TypeError("Cannot call a class as a function");
        }
        e.WebStorageStateStore = (function() {
          function t2() {
            var e2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, r2 = e2.prefix, n2 = void 0 === r2 ? "oidc." : r2, s = e2.store, a = void 0 === s ? i.Global.localStorage : s;
            o(this, t2), this._store = a, this._prefix = n2;
          }
          return t2.prototype.set = function t3(e2, r2) {
            return n.Log.debug("WebStorageStateStore.set", e2), e2 = this._prefix + e2, this._store.setItem(e2, r2), Promise.resolve();
          }, t2.prototype.get = function t3(e2) {
            n.Log.debug("WebStorageStateStore.get", e2), e2 = this._prefix + e2;
            var r2 = this._store.getItem(e2);
            return Promise.resolve(r2);
          }, t2.prototype.remove = function t3(e2) {
            n.Log.debug("WebStorageStateStore.remove", e2), e2 = this._prefix + e2;
            var r2 = this._store.getItem(e2);
            return this._store.removeItem(e2), Promise.resolve(r2);
          }, t2.prototype.getAllKeys = function t3() {
            n.Log.debug("WebStorageStateStore.getAllKeys");
            for (var e2 = [], r2 = 0; r2 < this._store.length; r2++) {
              var i2 = this._store.key(r2);
              0 === i2.indexOf(this._prefix) && e2.push(i2.substr(this._prefix.length));
            }
            return Promise.resolve(e2);
          }, t2;
        })();
      }, function(t, e, r) {
        "use strict";
        Object.defineProperty(e, "__esModule", { value: true }), e.JsonService = void 0;
        var n = r(0), i = r(1);
        function o(t2, e2) {
          if (!(t2 instanceof e2)) throw new TypeError("Cannot call a class as a function");
        }
        e.JsonService = (function() {
          function t2() {
            var e2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null, r2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : i.Global.XMLHttpRequest, n2 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null;
            o(this, t2), e2 && Array.isArray(e2) ? this._contentTypes = e2.slice() : this._contentTypes = [], this._contentTypes.push("application/json"), n2 && this._contentTypes.push("application/jwt"), this._XMLHttpRequest = r2, this._jwtHandler = n2;
          }
          return t2.prototype.getJson = function t3(e2, r2) {
            var i2 = this;
            if (!e2) throw n.Log.error("JsonService.getJson: No url passed"), new Error("url");
            return n.Log.debug("JsonService.getJson, url: ", e2), new Promise((function(t4, o2) {
              var s = new i2._XMLHttpRequest();
              s.open("GET", e2);
              var a = i2._contentTypes, u = i2._jwtHandler;
              s.onload = function() {
                if (n.Log.debug("JsonService.getJson: HTTP response received, status", s.status), 200 === s.status) {
                  var r3 = s.getResponseHeader("Content-Type");
                  if (r3) {
                    var i3 = a.find((function(t5) {
                      if (r3.startsWith(t5)) return true;
                    }));
                    if ("application/jwt" == i3) return void u(s).then(t4, o2);
                    if (i3) try {
                      return void t4(JSON.parse(s.responseText));
                    } catch (t5) {
                      return n.Log.error("JsonService.getJson: Error parsing JSON response", t5.message), void o2(t5);
                    }
                  }
                  o2(Error("Invalid response Content-Type: " + r3 + ", from URL: " + e2));
                } else o2(Error(s.statusText + " (" + s.status + ")"));
              }, s.onerror = function() {
                n.Log.error("JsonService.getJson: network error"), o2(Error("Network Error"));
              }, r2 && (n.Log.debug("JsonService.getJson: token passed, setting Authorization header"), s.setRequestHeader("Authorization", "Bearer " + r2)), s.send();
            }));
          }, t2.prototype.postForm = function t3(e2, r2, i2) {
            var o2 = this;
            if (!e2) throw n.Log.error("JsonService.postForm: No url passed"), new Error("url");
            return n.Log.debug("JsonService.postForm, url: ", e2), new Promise((function(t4, s) {
              var a = new o2._XMLHttpRequest();
              a.open("POST", e2);
              var u = o2._contentTypes;
              a.onload = function() {
                if (n.Log.debug("JsonService.postForm: HTTP response received, status", a.status), 200 !== a.status) {
                  if (400 === a.status) {
                    if (i3 = a.getResponseHeader("Content-Type")) {
                      if (u.find((function(t5) {
                        if (i3.startsWith(t5)) return true;
                      }))) try {
                        var r3 = JSON.parse(a.responseText);
                        if (r3 && r3.error) return n.Log.error("JsonService.postForm: Error from server: ", r3.error), void s(new Error(r3.error));
                      } catch (t5) {
                        return n.Log.error("JsonService.postForm: Error parsing JSON response", t5.message), void s(t5);
                      }
                    }
                  }
                  s(Error(a.statusText + " (" + a.status + ")"));
                } else {
                  var i3;
                  if ((i3 = a.getResponseHeader("Content-Type")) && u.find((function(t5) {
                    if (i3.startsWith(t5)) return true;
                  }))) try {
                    return void t4(JSON.parse(a.responseText));
                  } catch (t5) {
                    return n.Log.error("JsonService.postForm: Error parsing JSON response", t5.message), void s(t5);
                  }
                  s(Error("Invalid response Content-Type: " + i3 + ", from URL: " + e2));
                }
              }, a.onerror = function() {
                n.Log.error("JsonService.postForm: network error"), s(Error("Network Error"));
              };
              var c = "";
              for (var h in r2) {
                var l = r2[h];
                l && (c.length > 0 && (c += "&"), c += encodeURIComponent(h), c += "=", c += encodeURIComponent(l));
              }
              a.setRequestHeader("Content-Type", "application/x-www-form-urlencoded"), void 0 !== i2 && a.setRequestHeader("Authorization", "Basic " + btoa(i2)), a.send(c);
            }));
          }, t2;
        })();
      }, function(t, e, r) {
        "use strict";
        Object.defineProperty(e, "__esModule", { value: true }), e.SigninRequest = void 0;
        var n = r(0), i = r(3), o = r(13);
        e.SigninRequest = (function() {
          function t2(e2) {
            var r2 = e2.url, s = e2.client_id, a = e2.redirect_uri, u = e2.response_type, c = e2.scope, h = e2.authority, l = e2.data, f = e2.prompt, g = e2.display, d = e2.max_age, p = e2.ui_locales, v = e2.id_token_hint, y = e2.login_hint, m = e2.acr_values, _ = e2.resource, S = e2.response_mode, b = e2.request, w = e2.request_uri, F = e2.extraQueryParams, E = e2.request_type, x = e2.client_secret, A = e2.extraTokenParams, k = e2.skipUserInfo;
            if ((function P(t3, e3) {
              if (!(t3 instanceof e3)) throw new TypeError("Cannot call a class as a function");
            })(this, t2), !r2) throw n.Log.error("SigninRequest.ctor: No url passed"), new Error("url");
            if (!s) throw n.Log.error("SigninRequest.ctor: No client_id passed"), new Error("client_id");
            if (!a) throw n.Log.error("SigninRequest.ctor: No redirect_uri passed"), new Error("redirect_uri");
            if (!u) throw n.Log.error("SigninRequest.ctor: No response_type passed"), new Error("response_type");
            if (!c) throw n.Log.error("SigninRequest.ctor: No scope passed"), new Error("scope");
            if (!h) throw n.Log.error("SigninRequest.ctor: No authority passed"), new Error("authority");
            var C = t2.isOidc(u), T = t2.isCode(u);
            S || (S = t2.isCode(u) ? "query" : null), this.state = new o.SigninState({ nonce: C, data: l, client_id: s, authority: h, redirect_uri: a, code_verifier: T, request_type: E, response_mode: S, client_secret: x, scope: c, extraTokenParams: A, skipUserInfo: k }), r2 = i.UrlUtility.addQueryParam(r2, "client_id", s), r2 = i.UrlUtility.addQueryParam(r2, "redirect_uri", a), r2 = i.UrlUtility.addQueryParam(r2, "response_type", u), r2 = i.UrlUtility.addQueryParam(r2, "scope", c), r2 = i.UrlUtility.addQueryParam(r2, "state", this.state.id), C && (r2 = i.UrlUtility.addQueryParam(r2, "nonce", this.state.nonce)), T && (r2 = i.UrlUtility.addQueryParam(r2, "code_challenge", this.state.code_challenge), r2 = i.UrlUtility.addQueryParam(r2, "code_challenge_method", "S256"));
            var R = { prompt: f, display: g, max_age: d, ui_locales: p, id_token_hint: v, login_hint: y, acr_values: m, resource: _, request: b, request_uri: w, response_mode: S };
            for (var I in R) R[I] && (r2 = i.UrlUtility.addQueryParam(r2, I, R[I]));
            for (var D in F) r2 = i.UrlUtility.addQueryParam(r2, D, F[D]);
            this.url = r2;
          }
          return t2.isOidc = function t3(e2) {
            return !!e2.split(/\s+/g).filter((function(t4) {
              return "id_token" === t4;
            }))[0];
          }, t2.isOAuth = function t3(e2) {
            return !!e2.split(/\s+/g).filter((function(t4) {
              return "token" === t4;
            }))[0];
          }, t2.isCode = function t3(e2) {
            return !!e2.split(/\s+/g).filter((function(t4) {
              return "code" === t4;
            }))[0];
          }, t2;
        })();
      }, function(t, e, r) {
        "use strict";
        Object.defineProperty(e, "__esModule", { value: true }), e.State = void 0;
        var n = /* @__PURE__ */ (function() {
          function t2(t3, e2) {
            for (var r2 = 0; r2 < e2.length; r2++) {
              var n2 = e2[r2];
              n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(t3, n2.key, n2);
            }
          }
          return function(e2, r2, n2) {
            return r2 && t2(e2.prototype, r2), n2 && t2(e2, n2), e2;
          };
        })(), i = r(0), o = (function s(t2) {
          return t2 && t2.__esModule ? t2 : { default: t2 };
        })(r(14));
        function a(t2, e2) {
          if (!(t2 instanceof e2)) throw new TypeError("Cannot call a class as a function");
        }
        e.State = (function() {
          function t2() {
            var e2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, r2 = e2.id, n2 = e2.data, i2 = e2.created, s = e2.request_type;
            a(this, t2), this._id = r2 || (0, o.default)(), this._data = n2, this._created = "number" == typeof i2 && i2 > 0 ? i2 : parseInt(Date.now() / 1e3), this._request_type = s;
          }
          return t2.prototype.toStorageString = function t3() {
            return i.Log.debug("State.toStorageString"), JSON.stringify({ id: this.id, data: this.data, created: this.created, request_type: this.request_type });
          }, t2.fromStorageString = function e2(r2) {
            return i.Log.debug("State.fromStorageString"), new t2(JSON.parse(r2));
          }, t2.clearStaleState = function e2(r2, n2) {
            var o2 = Date.now() / 1e3 - n2;
            return r2.getAllKeys().then((function(e3) {
              i.Log.debug("State.clearStaleState: got keys", e3);
              for (var n3 = [], s = function s2(a3) {
                var c = e3[a3];
                u = r2.get(c).then((function(e4) {
                  var n4 = false;
                  if (e4) try {
                    var s3 = t2.fromStorageString(e4);
                    i.Log.debug("State.clearStaleState: got item from key: ", c, s3.created), s3.created <= o2 && (n4 = true);
                  } catch (t3) {
                    i.Log.error("State.clearStaleState: Error parsing state for key", c, t3.message), n4 = true;
                  }
                  else i.Log.debug("State.clearStaleState: no item in storage for key: ", c), n4 = true;
                  if (n4) return i.Log.debug("State.clearStaleState: removed item for key: ", c), r2.remove(c);
                })), n3.push(u);
              }, a2 = 0; a2 < e3.length; a2++) {
                var u;
                s(a2);
              }
              return i.Log.debug("State.clearStaleState: waiting on promise count:", n3.length), Promise.all(n3);
            }));
          }, n(t2, [{ key: "id", get: function t3() {
            return this._id;
          } }, { key: "data", get: function t3() {
            return this._data;
          } }, { key: "created", get: function t3() {
            return this._created;
          } }, { key: "request_type", get: function t3() {
            return this._request_type;
          } }]), t2;
        })();
      }, function(t, e, r) {
        "use strict";
        Object.defineProperty(e, "__esModule", { value: true }), e.OidcClient = void 0;
        var n = /* @__PURE__ */ (function() {
          function t2(t3, e2) {
            for (var r2 = 0; r2 < e2.length; r2++) {
              var n2 = e2[r2];
              n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(t3, n2.key, n2);
            }
          }
          return function(e2, r2, n2) {
            return r2 && t2(e2.prototype, r2), n2 && t2(e2, n2), e2;
          };
        })(), i = r(0), o = r(5), s = r(12), a = r(8), u = r(34), c = r(35), h = r(36), l = r(13), f = r(9);
        function g(t2, e2) {
          if (!(t2 instanceof e2)) throw new TypeError("Cannot call a class as a function");
        }
        e.OidcClient = (function() {
          function t2() {
            var e2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
            g(this, t2), e2 instanceof o.OidcClientSettings ? this._settings = e2 : this._settings = new o.OidcClientSettings(e2);
          }
          return t2.prototype.createSigninRequest = function t3() {
            var e2 = this, r2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, n2 = r2.response_type, o2 = r2.scope, s2 = r2.redirect_uri, u2 = r2.data, c2 = r2.state, h2 = r2.prompt, l2 = r2.display, f2 = r2.max_age, g2 = r2.ui_locales, d = r2.id_token_hint, p = r2.login_hint, v = r2.acr_values, y = r2.resource, m = r2.request, _ = r2.request_uri, S = r2.response_mode, b = r2.extraQueryParams, w = r2.extraTokenParams, F = r2.request_type, E = r2.skipUserInfo, x = arguments[1];
            i.Log.debug("OidcClient.createSigninRequest");
            var A = this._settings.client_id;
            n2 = n2 || this._settings.response_type, o2 = o2 || this._settings.scope, s2 = s2 || this._settings.redirect_uri, h2 = h2 || this._settings.prompt, l2 = l2 || this._settings.display, f2 = f2 || this._settings.max_age, g2 = g2 || this._settings.ui_locales, v = v || this._settings.acr_values, y = y || this._settings.resource, S = S || this._settings.response_mode, b = b || this._settings.extraQueryParams, w = w || this._settings.extraTokenParams;
            var k = this._settings.authority;
            return a.SigninRequest.isCode(n2) && "code" !== n2 ? Promise.reject(new Error("OpenID Connect hybrid flow is not supported")) : this._metadataService.getAuthorizationEndpoint().then((function(t4) {
              i.Log.debug("OidcClient.createSigninRequest: Received authorization endpoint", t4);
              var r3 = new a.SigninRequest({ url: t4, client_id: A, redirect_uri: s2, response_type: n2, scope: o2, data: u2 || c2, authority: k, prompt: h2, display: l2, max_age: f2, ui_locales: g2, id_token_hint: d, login_hint: p, acr_values: v, resource: y, request: m, request_uri: _, extraQueryParams: b, extraTokenParams: w, request_type: F, response_mode: S, client_secret: e2._settings.client_secret, skipUserInfo: E }), P = r3.state;
              return (x = x || e2._stateStore).set(P.id, P.toStorageString()).then((function() {
                return r3;
              }));
            }));
          }, t2.prototype.readSigninResponseState = function t3(e2, r2) {
            var n2 = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
            i.Log.debug("OidcClient.readSigninResponseState");
            var o2 = "query" === this._settings.response_mode || !this._settings.response_mode && a.SigninRequest.isCode(this._settings.response_type), s2 = o2 ? "?" : "#", c2 = new u.SigninResponse(e2, s2);
            if (!c2.state) return i.Log.error("OidcClient.readSigninResponseState: No state in response"), Promise.reject(new Error("No state in response"));
            r2 = r2 || this._stateStore;
            var h2 = n2 ? r2.remove.bind(r2) : r2.get.bind(r2);
            return h2(c2.state).then((function(t4) {
              if (!t4) throw i.Log.error("OidcClient.readSigninResponseState: No matching state found in storage"), new Error("No matching state found in storage");
              return { state: l.SigninState.fromStorageString(t4), response: c2 };
            }));
          }, t2.prototype.processSigninResponse = function t3(e2, r2) {
            var n2 = this;
            return i.Log.debug("OidcClient.processSigninResponse"), this.readSigninResponseState(e2, r2, true).then((function(t4) {
              var e3 = t4.state, r3 = t4.response;
              return i.Log.debug("OidcClient.processSigninResponse: Received state from storage; validating response"), n2._validator.validateSigninResponse(e3, r3);
            }));
          }, t2.prototype.createSignoutRequest = function t3() {
            var e2 = this, r2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, n2 = r2.id_token_hint, o2 = r2.data, s2 = r2.state, a2 = r2.post_logout_redirect_uri, u2 = r2.extraQueryParams, h2 = r2.request_type, l2 = arguments[1];
            return i.Log.debug("OidcClient.createSignoutRequest"), a2 = a2 || this._settings.post_logout_redirect_uri, u2 = u2 || this._settings.extraQueryParams, this._metadataService.getEndSessionEndpoint().then((function(t4) {
              if (!t4) throw i.Log.error("OidcClient.createSignoutRequest: No end session endpoint url returned"), new Error("no end session endpoint");
              i.Log.debug("OidcClient.createSignoutRequest: Received end session endpoint", t4);
              var r3 = new c.SignoutRequest({ url: t4, id_token_hint: n2, post_logout_redirect_uri: a2, data: o2 || s2, extraQueryParams: u2, request_type: h2 }), f2 = r3.state;
              return f2 && (i.Log.debug("OidcClient.createSignoutRequest: Signout request has state to persist"), (l2 = l2 || e2._stateStore).set(f2.id, f2.toStorageString())), r3;
            }));
          }, t2.prototype.readSignoutResponseState = function t3(e2, r2) {
            var n2 = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
            i.Log.debug("OidcClient.readSignoutResponseState");
            var o2 = new h.SignoutResponse(e2);
            if (!o2.state) return i.Log.debug("OidcClient.readSignoutResponseState: No state in response"), o2.error ? (i.Log.warn("OidcClient.readSignoutResponseState: Response was error: ", o2.error), Promise.reject(new s.ErrorResponse(o2))) : Promise.resolve({ state: void 0, response: o2 });
            var a2 = o2.state;
            r2 = r2 || this._stateStore;
            var u2 = n2 ? r2.remove.bind(r2) : r2.get.bind(r2);
            return u2(a2).then((function(t4) {
              if (!t4) throw i.Log.error("OidcClient.readSignoutResponseState: No matching state found in storage"), new Error("No matching state found in storage");
              return { state: f.State.fromStorageString(t4), response: o2 };
            }));
          }, t2.prototype.processSignoutResponse = function t3(e2, r2) {
            var n2 = this;
            return i.Log.debug("OidcClient.processSignoutResponse"), this.readSignoutResponseState(e2, r2, true).then((function(t4) {
              var e3 = t4.state, r3 = t4.response;
              return e3 ? (i.Log.debug("OidcClient.processSignoutResponse: Received state from storage; validating response"), n2._validator.validateSignoutResponse(e3, r3)) : (i.Log.debug("OidcClient.processSignoutResponse: No state from storage; skipping validating response"), r3);
            }));
          }, t2.prototype.clearStaleState = function t3(e2) {
            return i.Log.debug("OidcClient.clearStaleState"), e2 = e2 || this._stateStore, f.State.clearStaleState(e2, this.settings.staleStateAge);
          }, n(t2, [{ key: "_stateStore", get: function t3() {
            return this.settings.stateStore;
          } }, { key: "_validator", get: function t3() {
            return this.settings.validator;
          } }, { key: "_metadataService", get: function t3() {
            return this.settings.metadataService;
          } }, { key: "settings", get: function t3() {
            return this._settings;
          } }, { key: "metadataService", get: function t3() {
            return this._metadataService;
          } }]), t2;
        })();
      }, function(t, e, r) {
        "use strict";
        Object.defineProperty(e, "__esModule", { value: true }), e.TokenClient = void 0;
        var n = r(7), i = r(2), o = r(0);
        function s(t2, e2) {
          if (!(t2 instanceof e2)) throw new TypeError("Cannot call a class as a function");
        }
        e.TokenClient = (function() {
          function t2(e2) {
            var r2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : n.JsonService, a = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : i.MetadataService;
            if (s(this, t2), !e2) throw o.Log.error("TokenClient.ctor: No settings passed"), new Error("settings");
            this._settings = e2, this._jsonService = new r2(), this._metadataService = new a(this._settings);
          }
          return t2.prototype.exchangeCode = function t3() {
            var e2 = this, r2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
            (r2 = Object.assign({}, r2)).grant_type = r2.grant_type || "authorization_code", r2.client_id = r2.client_id || this._settings.client_id, r2.client_secret = r2.client_secret || this._settings.client_secret, r2.redirect_uri = r2.redirect_uri || this._settings.redirect_uri;
            var n2 = void 0, i2 = r2._client_authentication || this._settings._client_authentication;
            return delete r2._client_authentication, r2.code ? r2.redirect_uri ? r2.code_verifier ? r2.client_id ? r2.client_secret || "client_secret_basic" != i2 ? ("client_secret_basic" == i2 && (n2 = r2.client_id + ":" + r2.client_secret, delete r2.client_id, delete r2.client_secret), this._metadataService.getTokenEndpoint(false).then((function(t4) {
              return o.Log.debug("TokenClient.exchangeCode: Received token endpoint"), e2._jsonService.postForm(t4, r2, n2).then((function(t5) {
                return o.Log.debug("TokenClient.exchangeCode: response received"), t5;
              }));
            }))) : (o.Log.error("TokenClient.exchangeCode: No client_secret passed"), Promise.reject(new Error("A client_secret is required"))) : (o.Log.error("TokenClient.exchangeCode: No client_id passed"), Promise.reject(new Error("A client_id is required"))) : (o.Log.error("TokenClient.exchangeCode: No code_verifier passed"), Promise.reject(new Error("A code_verifier is required"))) : (o.Log.error("TokenClient.exchangeCode: No redirect_uri passed"), Promise.reject(new Error("A redirect_uri is required"))) : (o.Log.error("TokenClient.exchangeCode: No code passed"), Promise.reject(new Error("A code is required")));
          }, t2.prototype.exchangeRefreshToken = function t3() {
            var e2 = this, r2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
            (r2 = Object.assign({}, r2)).grant_type = r2.grant_type || "refresh_token", r2.client_id = r2.client_id || this._settings.client_id, r2.client_secret = r2.client_secret || this._settings.client_secret;
            var n2 = void 0, i2 = r2._client_authentication || this._settings._client_authentication;
            return delete r2._client_authentication, r2.refresh_token ? r2.client_id ? ("client_secret_basic" == i2 && (n2 = r2.client_id + ":" + r2.client_secret, delete r2.client_id, delete r2.client_secret), this._metadataService.getTokenEndpoint(false).then((function(t4) {
              return o.Log.debug("TokenClient.exchangeRefreshToken: Received token endpoint"), e2._jsonService.postForm(t4, r2, n2).then((function(t5) {
                return o.Log.debug("TokenClient.exchangeRefreshToken: response received"), t5;
              }));
            }))) : (o.Log.error("TokenClient.exchangeRefreshToken: No client_id passed"), Promise.reject(new Error("A client_id is required"))) : (o.Log.error("TokenClient.exchangeRefreshToken: No refresh_token passed"), Promise.reject(new Error("A refresh_token is required")));
          }, t2;
        })();
      }, function(t, e, r) {
        "use strict";
        Object.defineProperty(e, "__esModule", { value: true }), e.ErrorResponse = void 0;
        var n = r(0);
        function i(t2, e2) {
          if (!(t2 instanceof e2)) throw new TypeError("Cannot call a class as a function");
        }
        function o(t2, e2) {
          if (!t2) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
          return !e2 || "object" != typeof e2 && "function" != typeof e2 ? t2 : e2;
        }
        e.ErrorResponse = (function(t2) {
          function e2() {
            var r2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, s = r2.error, a = r2.error_description, u = r2.error_uri, c = r2.state, h = r2.session_state;
            if (i(this, e2), !s) throw n.Log.error("No error passed to ErrorResponse"), new Error("error");
            var l = o(this, t2.call(this, a || s));
            return l.name = "ErrorResponse", l.error = s, l.error_description = a, l.error_uri = u, l.state = c, l.session_state = h, l;
          }
          return (function r2(t3, e3) {
            if ("function" != typeof e3 && null !== e3) throw new TypeError("Super expression must either be null or a function, not " + typeof e3);
            t3.prototype = Object.create(e3 && e3.prototype, { constructor: { value: t3, enumerable: false, writable: true, configurable: true } }), e3 && (Object.setPrototypeOf ? Object.setPrototypeOf(t3, e3) : t3.__proto__ = e3);
          })(e2, t2), e2;
        })(Error);
      }, function(t, e, r) {
        "use strict";
        Object.defineProperty(e, "__esModule", { value: true }), e.SigninState = void 0;
        var n = /* @__PURE__ */ (function() {
          function t2(t3, e2) {
            for (var r2 = 0; r2 < e2.length; r2++) {
              var n2 = e2[r2];
              n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(t3, n2.key, n2);
            }
          }
          return function(e2, r2, n2) {
            return r2 && t2(e2.prototype, r2), n2 && t2(e2, n2), e2;
          };
        })(), i = r(0), o = r(9), s = r(4), a = (function u(t2) {
          return t2 && t2.__esModule ? t2 : { default: t2 };
        })(r(14));
        function c(t2, e2) {
          if (!(t2 instanceof e2)) throw new TypeError("Cannot call a class as a function");
        }
        function h(t2, e2) {
          if (!t2) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
          return !e2 || "object" != typeof e2 && "function" != typeof e2 ? t2 : e2;
        }
        e.SigninState = (function(t2) {
          function e2() {
            var r2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, n2 = r2.nonce, i2 = r2.authority, o2 = r2.client_id, u = r2.redirect_uri, l = r2.code_verifier, f = r2.response_mode, g = r2.client_secret, d = r2.scope, p = r2.extraTokenParams, v = r2.skipUserInfo;
            c(this, e2);
            var y = h(this, t2.call(this, arguments[0]));
            if (true === n2 ? y._nonce = (0, a.default)() : n2 && (y._nonce = n2), true === l ? y._code_verifier = (0, a.default)() + (0, a.default)() + (0, a.default)() : l && (y._code_verifier = l), y.code_verifier) {
              var m = s.JoseUtil.hashString(y.code_verifier, "SHA256");
              y._code_challenge = s.JoseUtil.hexToBase64Url(m);
            }
            return y._redirect_uri = u, y._authority = i2, y._client_id = o2, y._response_mode = f, y._client_secret = g, y._scope = d, y._extraTokenParams = p, y._skipUserInfo = v, y;
          }
          return (function r2(t3, e3) {
            if ("function" != typeof e3 && null !== e3) throw new TypeError("Super expression must either be null or a function, not " + typeof e3);
            t3.prototype = Object.create(e3 && e3.prototype, { constructor: { value: t3, enumerable: false, writable: true, configurable: true } }), e3 && (Object.setPrototypeOf ? Object.setPrototypeOf(t3, e3) : t3.__proto__ = e3);
          })(e2, t2), e2.prototype.toStorageString = function t3() {
            return i.Log.debug("SigninState.toStorageString"), JSON.stringify({ id: this.id, data: this.data, created: this.created, request_type: this.request_type, nonce: this.nonce, code_verifier: this.code_verifier, redirect_uri: this.redirect_uri, authority: this.authority, client_id: this.client_id, response_mode: this.response_mode, client_secret: this.client_secret, scope: this.scope, extraTokenParams: this.extraTokenParams, skipUserInfo: this.skipUserInfo });
          }, e2.fromStorageString = function t3(r2) {
            return i.Log.debug("SigninState.fromStorageString"), new e2(JSON.parse(r2));
          }, n(e2, [{ key: "nonce", get: function t3() {
            return this._nonce;
          } }, { key: "authority", get: function t3() {
            return this._authority;
          } }, { key: "client_id", get: function t3() {
            return this._client_id;
          } }, { key: "redirect_uri", get: function t3() {
            return this._redirect_uri;
          } }, { key: "code_verifier", get: function t3() {
            return this._code_verifier;
          } }, { key: "code_challenge", get: function t3() {
            return this._code_challenge;
          } }, { key: "response_mode", get: function t3() {
            return this._response_mode;
          } }, { key: "client_secret", get: function t3() {
            return this._client_secret;
          } }, { key: "scope", get: function t3() {
            return this._scope;
          } }, { key: "extraTokenParams", get: function t3() {
            return this._extraTokenParams;
          } }, { key: "skipUserInfo", get: function t3() {
            return this._skipUserInfo;
          } }]), e2;
        })(o.State);
      }, function(t, e, r) {
        "use strict";
        Object.defineProperty(e, "__esModule", { value: true }), e.default = function n() {
          return ("undefined" != i && null !== i && void 0 !== i.getRandomValues ? o : s)().replace(/-/g, "");
        };
        var i = "undefined" != typeof window ? window.crypto || window.msCrypto : null;
        function o() {
          return ("10000000-1000-4000-8000" + -1e11).replace(/[018]/g, (function(t2) {
            return (t2 ^ i.getRandomValues(new Uint8Array(1))[0] & 15 >> t2 / 4).toString(16);
          }));
        }
        function s() {
          return ("10000000-1000-4000-8000" + -1e11).replace(/[018]/g, (function(t2) {
            return (t2 ^ 16 * Math.random() >> t2 / 4).toString(16);
          }));
        }
        t.exports = e.default;
      }, function(t, e, r) {
        "use strict";
        Object.defineProperty(e, "__esModule", { value: true }), e.User = void 0;
        var n = /* @__PURE__ */ (function() {
          function t2(t3, e2) {
            for (var r2 = 0; r2 < e2.length; r2++) {
              var n2 = e2[r2];
              n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(t3, n2.key, n2);
            }
          }
          return function(e2, r2, n2) {
            return r2 && t2(e2.prototype, r2), n2 && t2(e2, n2), e2;
          };
        })(), i = r(0);
        e.User = (function() {
          function t2(e2) {
            var r2 = e2.id_token, n2 = e2.session_state, i2 = e2.access_token, o = e2.refresh_token, s = e2.token_type, a = e2.scope, u = e2.profile, c = e2.expires_at, h = e2.state;
            !(function l(t3, e3) {
              if (!(t3 instanceof e3)) throw new TypeError("Cannot call a class as a function");
            })(this, t2), this.id_token = r2, this.session_state = n2, this.access_token = i2, this.refresh_token = o, this.token_type = s, this.scope = a, this.profile = u, this.expires_at = c, this.state = h;
          }
          return t2.prototype.toStorageString = function t3() {
            return i.Log.debug("User.toStorageString"), JSON.stringify({ id_token: this.id_token, session_state: this.session_state, access_token: this.access_token, refresh_token: this.refresh_token, token_type: this.token_type, scope: this.scope, profile: this.profile, expires_at: this.expires_at });
          }, t2.fromStorageString = function e2(r2) {
            return i.Log.debug("User.fromStorageString"), new t2(JSON.parse(r2));
          }, n(t2, [{ key: "expires_in", get: function t3() {
            if (this.expires_at) {
              var e2 = parseInt(Date.now() / 1e3);
              return this.expires_at - e2;
            }
          }, set: function t3(e2) {
            var r2 = parseInt(e2);
            if ("number" == typeof r2 && r2 > 0) {
              var n2 = parseInt(Date.now() / 1e3);
              this.expires_at = n2 + r2;
            }
          } }, { key: "expired", get: function t3() {
            var e2 = this.expires_in;
            if (void 0 !== e2) return e2 <= 0;
          } }, { key: "scopes", get: function t3() {
            return (this.scope || "").split(" ");
          } }]), t2;
        })();
      }, function(t, e, r) {
        "use strict";
        Object.defineProperty(e, "__esModule", { value: true }), e.AccessTokenEvents = void 0;
        var n = r(0), i = r(46);
        function o(t2, e2) {
          if (!(t2 instanceof e2)) throw new TypeError("Cannot call a class as a function");
        }
        e.AccessTokenEvents = (function() {
          function t2() {
            var e2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, r2 = e2.accessTokenExpiringNotificationTime, n2 = void 0 === r2 ? 60 : r2, s = e2.accessTokenExpiringTimer, a = void 0 === s ? new i.Timer("Access token expiring") : s, u = e2.accessTokenExpiredTimer, c = void 0 === u ? new i.Timer("Access token expired") : u;
            o(this, t2), this._accessTokenExpiringNotificationTime = n2, this._accessTokenExpiring = a, this._accessTokenExpired = c;
          }
          return t2.prototype.load = function t3(e2) {
            if (e2.access_token && void 0 !== e2.expires_in) {
              var r2 = e2.expires_in;
              if (n.Log.debug("AccessTokenEvents.load: access token present, remaining duration:", r2), r2 > 0) {
                var i2 = r2 - this._accessTokenExpiringNotificationTime;
                i2 <= 0 && (i2 = 1), n.Log.debug("AccessTokenEvents.load: registering expiring timer in:", i2), this._accessTokenExpiring.init(i2);
              } else n.Log.debug("AccessTokenEvents.load: canceling existing expiring timer becase we're past expiration."), this._accessTokenExpiring.cancel();
              var o2 = r2 + 1;
              n.Log.debug("AccessTokenEvents.load: registering expired timer in:", o2), this._accessTokenExpired.init(o2);
            } else this._accessTokenExpiring.cancel(), this._accessTokenExpired.cancel();
          }, t2.prototype.unload = function t3() {
            n.Log.debug("AccessTokenEvents.unload: canceling existing access token timers"), this._accessTokenExpiring.cancel(), this._accessTokenExpired.cancel();
          }, t2.prototype.addAccessTokenExpiring = function t3(e2) {
            this._accessTokenExpiring.addHandler(e2);
          }, t2.prototype.removeAccessTokenExpiring = function t3(e2) {
            this._accessTokenExpiring.removeHandler(e2);
          }, t2.prototype.addAccessTokenExpired = function t3(e2) {
            this._accessTokenExpired.addHandler(e2);
          }, t2.prototype.removeAccessTokenExpired = function t3(e2) {
            this._accessTokenExpired.removeHandler(e2);
          }, t2;
        })();
      }, function(t, e, r) {
        "use strict";
        Object.defineProperty(e, "__esModule", { value: true }), e.Event = void 0;
        var n = r(0);
        e.Event = (function() {
          function t2(e2) {
            !(function r2(t3, e3) {
              if (!(t3 instanceof e3)) throw new TypeError("Cannot call a class as a function");
            })(this, t2), this._name = e2, this._callbacks = [];
          }
          return t2.prototype.addHandler = function t3(e2) {
            this._callbacks.push(e2);
          }, t2.prototype.removeHandler = function t3(e2) {
            var r2 = this._callbacks.findIndex((function(t4) {
              return t4 === e2;
            }));
            r2 >= 0 && this._callbacks.splice(r2, 1);
          }, t2.prototype.raise = function t3() {
            n.Log.debug("Event: Raising event: " + this._name);
            for (var e2 = 0; e2 < this._callbacks.length; e2++) {
              var r2;
              (r2 = this._callbacks)[e2].apply(r2, arguments);
            }
          }, t2;
        })();
      }, function(t, e, r) {
        "use strict";
        Object.defineProperty(e, "__esModule", { value: true }), e.SessionMonitor = void 0;
        var n = /* @__PURE__ */ (function() {
          function t2(t3, e2) {
            for (var r2 = 0; r2 < e2.length; r2++) {
              var n2 = e2[r2];
              n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(t3, n2.key, n2);
            }
          }
          return function(e2, r2, n2) {
            return r2 && t2(e2.prototype, r2), n2 && t2(e2, n2), e2;
          };
        })(), i = r(0), o = r(19), s = r(1);
        function a(t2, e2) {
          if (!(t2 instanceof e2)) throw new TypeError("Cannot call a class as a function");
        }
        e.SessionMonitor = (function() {
          function t2(e2) {
            var r2 = this, n2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : o.CheckSessionIFrame, u = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : s.Global.timer;
            if (a(this, t2), !e2) throw i.Log.error("SessionMonitor.ctor: No user manager passed to SessionMonitor"), new Error("userManager");
            this._userManager = e2, this._CheckSessionIFrameCtor = n2, this._timer = u, this._userManager.events.addUserLoaded(this._start.bind(this)), this._userManager.events.addUserUnloaded(this._stop.bind(this)), Promise.resolve(this._userManager.getUser().then((function(t3) {
              t3 ? r2._start(t3) : r2._settings.monitorAnonymousSession && r2._userManager.querySessionStatus().then((function(t4) {
                var e3 = { session_state: t4.session_state };
                t4.sub && t4.sid && (e3.profile = { sub: t4.sub, sid: t4.sid }), r2._start(e3);
              })).catch((function(t4) {
                i.Log.error("SessionMonitor ctor: error from querySessionStatus:", t4.message);
              }));
            })).catch((function(t3) {
              i.Log.error("SessionMonitor ctor: error from getUser:", t3.message);
            })));
          }
          return t2.prototype._start = function t3(e2) {
            var r2 = this, n2 = e2.session_state;
            n2 && (e2.profile ? (this._sub = e2.profile.sub, this._sid = e2.profile.sid, i.Log.debug("SessionMonitor._start: session_state:", n2, ", sub:", this._sub)) : (this._sub = void 0, this._sid = void 0, i.Log.debug("SessionMonitor._start: session_state:", n2, ", anonymous user")), this._checkSessionIFrame ? this._checkSessionIFrame.start(n2) : this._metadataService.getCheckSessionIframe().then((function(t4) {
              if (t4) {
                i.Log.debug("SessionMonitor._start: Initializing check session iframe");
                var e3 = r2._client_id, o2 = r2._checkSessionInterval, s2 = r2._stopCheckSessionOnError;
                r2._checkSessionIFrame = new r2._CheckSessionIFrameCtor(r2._callback.bind(r2), e3, t4, o2, s2), r2._checkSessionIFrame.load().then((function() {
                  r2._checkSessionIFrame.start(n2);
                }));
              } else i.Log.warn("SessionMonitor._start: No check session iframe found in the metadata");
            })).catch((function(t4) {
              i.Log.error("SessionMonitor._start: Error from getCheckSessionIframe:", t4.message);
            })));
          }, t2.prototype._stop = function t3() {
            var e2 = this;
            if (this._sub = void 0, this._sid = void 0, this._checkSessionIFrame && (i.Log.debug("SessionMonitor._stop"), this._checkSessionIFrame.stop()), this._settings.monitorAnonymousSession) var r2 = this._timer.setInterval((function() {
              e2._timer.clearInterval(r2), e2._userManager.querySessionStatus().then((function(t4) {
                var r3 = { session_state: t4.session_state };
                t4.sub && t4.sid && (r3.profile = { sub: t4.sub, sid: t4.sid }), e2._start(r3);
              })).catch((function(t4) {
                i.Log.error("SessionMonitor: error from querySessionStatus:", t4.message);
              }));
            }), 1e3);
          }, t2.prototype._callback = function t3() {
            var e2 = this;
            this._userManager.querySessionStatus().then((function(t4) {
              var r2 = true;
              t4 ? t4.sub === e2._sub ? (r2 = false, e2._checkSessionIFrame.start(t4.session_state), t4.sid === e2._sid ? i.Log.debug("SessionMonitor._callback: Same sub still logged in at OP, restarting check session iframe; session_state:", t4.session_state) : (i.Log.debug("SessionMonitor._callback: Same sub still logged in at OP, session state has changed, restarting check session iframe; session_state:", t4.session_state), e2._userManager.events._raiseUserSessionChanged())) : i.Log.debug("SessionMonitor._callback: Different subject signed into OP:", t4.sub) : i.Log.debug("SessionMonitor._callback: Subject no longer signed into OP"), r2 && (e2._sub ? (i.Log.debug("SessionMonitor._callback: SessionMonitor._callback; raising signed out event"), e2._userManager.events._raiseUserSignedOut()) : (i.Log.debug("SessionMonitor._callback: SessionMonitor._callback; raising signed in event"), e2._userManager.events._raiseUserSignedIn()));
            })).catch((function(t4) {
              e2._sub && (i.Log.debug("SessionMonitor._callback: Error calling queryCurrentSigninSession; raising signed out event", t4.message), e2._userManager.events._raiseUserSignedOut());
            }));
          }, n(t2, [{ key: "_settings", get: function t3() {
            return this._userManager.settings;
          } }, { key: "_metadataService", get: function t3() {
            return this._userManager.metadataService;
          } }, { key: "_client_id", get: function t3() {
            return this._settings.client_id;
          } }, { key: "_checkSessionInterval", get: function t3() {
            return this._settings.checkSessionInterval;
          } }, { key: "_stopCheckSessionOnError", get: function t3() {
            return this._settings.stopCheckSessionOnError;
          } }]), t2;
        })();
      }, function(t, e, r) {
        "use strict";
        Object.defineProperty(e, "__esModule", { value: true }), e.CheckSessionIFrame = void 0;
        var n = r(0);
        function i(t2, e2) {
          if (!(t2 instanceof e2)) throw new TypeError("Cannot call a class as a function");
        }
        e.CheckSessionIFrame = (function() {
          function t2(e2, r2, n2, o) {
            var s = !(arguments.length > 4 && void 0 !== arguments[4]) || arguments[4];
            i(this, t2), this._callback = e2, this._client_id = r2, this._url = n2, this._interval = o || 2e3, this._stopOnError = s;
            var a = n2.indexOf("/", n2.indexOf("//") + 2);
            this._frame_origin = n2.substr(0, a), this._frame = window.document.createElement("iframe"), this._frame.style.visibility = "hidden", this._frame.style.position = "absolute", this._frame.style.display = "none", this._frame.width = 0, this._frame.height = 0, this._frame.src = n2;
          }
          return t2.prototype.load = function t3() {
            var e2 = this;
            return new Promise((function(t4) {
              e2._frame.onload = function() {
                t4();
              }, window.document.body.appendChild(e2._frame), e2._boundMessageEvent = e2._message.bind(e2), window.addEventListener("message", e2._boundMessageEvent, false);
            }));
          }, t2.prototype._message = function t3(e2) {
            e2.origin === this._frame_origin && e2.source === this._frame.contentWindow && ("error" === e2.data ? (n.Log.error("CheckSessionIFrame: error message from check session op iframe"), this._stopOnError && this.stop()) : "changed" === e2.data ? (n.Log.debug("CheckSessionIFrame: changed message from check session op iframe"), this.stop(), this._callback()) : n.Log.debug("CheckSessionIFrame: " + e2.data + " message from check session op iframe"));
          }, t2.prototype.start = function t3(e2) {
            var r2 = this;
            if (this._session_state !== e2) {
              n.Log.debug("CheckSessionIFrame.start"), this.stop(), this._session_state = e2;
              var i2 = function t4() {
                r2._frame.contentWindow.postMessage(r2._client_id + " " + r2._session_state, r2._frame_origin);
              };
              i2(), this._timer = window.setInterval(i2, this._interval);
            }
          }, t2.prototype.stop = function t3() {
            this._session_state = null, this._timer && (n.Log.debug("CheckSessionIFrame.stop"), window.clearInterval(this._timer), this._timer = null);
          }, t2;
        })();
      }, function(t, e, r) {
        "use strict";
        Object.defineProperty(e, "__esModule", { value: true }), e.TokenRevocationClient = void 0;
        var n = r(0), i = r(2), o = r(1);
        function s(t2, e2) {
          if (!(t2 instanceof e2)) throw new TypeError("Cannot call a class as a function");
        }
        var a = "access_token", u = "refresh_token";
        e.TokenRevocationClient = (function() {
          function t2(e2) {
            var r2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : o.Global.XMLHttpRequest, a2 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : i.MetadataService;
            if (s(this, t2), !e2) throw n.Log.error("TokenRevocationClient.ctor: No settings provided"), new Error("No settings provided.");
            this._settings = e2, this._XMLHttpRequestCtor = r2, this._metadataService = new a2(this._settings);
          }
          return t2.prototype.revoke = function t3(e2, r2) {
            var i2 = this, o2 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : "access_token";
            if (!e2) throw n.Log.error("TokenRevocationClient.revoke: No token provided"), new Error("No token provided.");
            if (o2 !== a && o2 != u) throw n.Log.error("TokenRevocationClient.revoke: Invalid token type"), new Error("Invalid token type.");
            return this._metadataService.getRevocationEndpoint().then((function(t4) {
              if (t4) {
                n.Log.debug("TokenRevocationClient.revoke: Revoking " + o2);
                var s2 = i2._settings.client_id, a2 = i2._settings.client_secret;
                return i2._revoke(t4, s2, a2, e2, o2);
              }
              if (r2) throw n.Log.error("TokenRevocationClient.revoke: Revocation not supported"), new Error("Revocation not supported");
            }));
          }, t2.prototype._revoke = function t3(e2, r2, i2, o2, s2) {
            var a2 = this;
            return new Promise((function(t4, u2) {
              var c = new a2._XMLHttpRequestCtor();
              c.open("POST", e2), c.onload = function() {
                n.Log.debug("TokenRevocationClient.revoke: HTTP response received, status", c.status), 200 === c.status ? t4() : u2(Error(c.statusText + " (" + c.status + ")"));
              }, c.onerror = function() {
                n.Log.debug("TokenRevocationClient.revoke: Network Error."), u2("Network Error");
              };
              var h = "client_id=" + encodeURIComponent(r2);
              i2 && (h += "&client_secret=" + encodeURIComponent(i2)), h += "&token_type_hint=" + encodeURIComponent(s2), h += "&token=" + encodeURIComponent(o2), c.setRequestHeader("Content-Type", "application/x-www-form-urlencoded"), c.send(h);
            }));
          }, t2;
        })();
      }, function(t, e, r) {
        "use strict";
        Object.defineProperty(e, "__esModule", { value: true }), e.CordovaPopupWindow = void 0;
        var n = /* @__PURE__ */ (function() {
          function t2(t3, e2) {
            for (var r2 = 0; r2 < e2.length; r2++) {
              var n2 = e2[r2];
              n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(t3, n2.key, n2);
            }
          }
          return function(e2, r2, n2) {
            return r2 && t2(e2.prototype, r2), n2 && t2(e2, n2), e2;
          };
        })(), i = r(0);
        e.CordovaPopupWindow = (function() {
          function t2(e2) {
            var r2 = this;
            !(function n2(t3, e3) {
              if (!(t3 instanceof e3)) throw new TypeError("Cannot call a class as a function");
            })(this, t2), this._promise = new Promise((function(t3, e3) {
              r2._resolve = t3, r2._reject = e3;
            })), this.features = e2.popupWindowFeatures || "location=no,toolbar=no,zoom=no", this.target = e2.popupWindowTarget || "_blank", this.redirect_uri = e2.startUrl, i.Log.debug("CordovaPopupWindow.ctor: redirect_uri: " + this.redirect_uri);
          }
          return t2.prototype._isInAppBrowserInstalled = function t3(e2) {
            return ["cordova-plugin-inappbrowser", "cordova-plugin-inappbrowser.inappbrowser", "org.apache.cordova.inappbrowser"].some((function(t4) {
              return e2.hasOwnProperty(t4);
            }));
          }, t2.prototype.navigate = function t3(e2) {
            if (e2 && e2.url) {
              if (!window.cordova) return this._error("cordova is undefined");
              var r2 = window.cordova.require("cordova/plugin_list").metadata;
              if (false === this._isInAppBrowserInstalled(r2)) return this._error("InAppBrowser plugin not found");
              this._popup = cordova.InAppBrowser.open(e2.url, this.target, this.features), this._popup ? (i.Log.debug("CordovaPopupWindow.navigate: popup successfully created"), this._exitCallbackEvent = this._exitCallback.bind(this), this._loadStartCallbackEvent = this._loadStartCallback.bind(this), this._popup.addEventListener("exit", this._exitCallbackEvent, false), this._popup.addEventListener("loadstart", this._loadStartCallbackEvent, false)) : this._error("Error opening popup window");
            } else this._error("No url provided");
            return this.promise;
          }, t2.prototype._loadStartCallback = function t3(e2) {
            0 === e2.url.indexOf(this.redirect_uri) && this._success({ url: e2.url });
          }, t2.prototype._exitCallback = function t3(e2) {
            this._error(e2);
          }, t2.prototype._success = function t3(e2) {
            this._cleanup(), i.Log.debug("CordovaPopupWindow: Successful response from cordova popup window"), this._resolve(e2);
          }, t2.prototype._error = function t3(e2) {
            this._cleanup(), i.Log.error(e2), this._reject(new Error(e2));
          }, t2.prototype.close = function t3() {
            this._cleanup();
          }, t2.prototype._cleanup = function t3() {
            this._popup && (i.Log.debug("CordovaPopupWindow: cleaning up popup"), this._popup.removeEventListener("exit", this._exitCallbackEvent, false), this._popup.removeEventListener("loadstart", this._loadStartCallbackEvent, false), this._popup.close()), this._popup = null;
          }, n(t2, [{ key: "promise", get: function t3() {
            return this._promise;
          } }]), t2;
        })();
      }, function(t, e, r) {
        "use strict";
        Object.defineProperty(e, "__esModule", { value: true });
        var n = r(0), i = r(10), o = r(5), s = r(6), a = r(37), u = r(38), c = r(16), h = r(2), l = r(48), f = r(49), g = r(19), d = r(20), p = r(18), v = r(1), y = r(15), m = r(50);
        e.default = { Version: m.Version, Log: n.Log, OidcClient: i.OidcClient, OidcClientSettings: o.OidcClientSettings, WebStorageStateStore: s.WebStorageStateStore, InMemoryWebStorage: a.InMemoryWebStorage, UserManager: u.UserManager, AccessTokenEvents: c.AccessTokenEvents, MetadataService: h.MetadataService, CordovaPopupNavigator: l.CordovaPopupNavigator, CordovaIFrameNavigator: f.CordovaIFrameNavigator, CheckSessionIFrame: g.CheckSessionIFrame, TokenRevocationClient: d.TokenRevocationClient, SessionMonitor: p.SessionMonitor, Global: v.Global, User: y.User }, t.exports = e.default;
      }, function(t, e, r) {
        "use strict";
        Object.defineProperty(e, "__esModule", { value: true });
        e.ClockService = (function() {
          function t2() {
            !(function e2(t3, r2) {
              if (!(t3 instanceof r2)) throw new TypeError("Cannot call a class as a function");
            })(this, t2);
          }
          return t2.prototype.getEpochTime = function t3() {
            return Promise.resolve(Date.now() / 1e3 | 0);
          }, t2;
        })();
      }, function(t, e, r) {
        "use strict";
        Object.defineProperty(e, "__esModule", { value: true }), e.ResponseValidator = void 0;
        var n = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t2) {
          return typeof t2;
        } : function(t2) {
          return t2 && "function" == typeof Symbol && t2.constructor === Symbol && t2 !== Symbol.prototype ? "symbol" : typeof t2;
        }, i = r(0), o = r(2), s = r(25), a = r(11), u = r(12), c = r(4);
        function h(t2, e2) {
          if (!(t2 instanceof e2)) throw new TypeError("Cannot call a class as a function");
        }
        var l = ["nonce", "at_hash", "iat", "nbf", "exp", "aud", "iss", "c_hash"];
        e.ResponseValidator = (function() {
          function t2(e2) {
            var r2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : o.MetadataService, n2 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : s.UserInfoService, u2 = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : c.JoseUtil, l2 = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : a.TokenClient;
            if (h(this, t2), !e2) throw i.Log.error("ResponseValidator.ctor: No settings passed to ResponseValidator"), new Error("settings");
            this._settings = e2, this._metadataService = new r2(this._settings), this._userInfoService = new n2(this._settings), this._joseUtil = u2, this._tokenClient = new l2(this._settings);
          }
          return t2.prototype.validateSigninResponse = function t3(e2, r2) {
            var n2 = this;
            return i.Log.debug("ResponseValidator.validateSigninResponse"), this._processSigninParams(e2, r2).then((function(t4) {
              return i.Log.debug("ResponseValidator.validateSigninResponse: state processed"), n2._validateTokens(e2, t4).then((function(t5) {
                return i.Log.debug("ResponseValidator.validateSigninResponse: tokens validated"), n2._processClaims(e2, t5).then((function(t6) {
                  return i.Log.debug("ResponseValidator.validateSigninResponse: claims processed"), t6;
                }));
              }));
            }));
          }, t2.prototype.validateSignoutResponse = function t3(e2, r2) {
            return e2.id !== r2.state ? (i.Log.error("ResponseValidator.validateSignoutResponse: State does not match"), Promise.reject(new Error("State does not match"))) : (i.Log.debug("ResponseValidator.validateSignoutResponse: state validated"), r2.state = e2.data, r2.error ? (i.Log.warn("ResponseValidator.validateSignoutResponse: Response was error", r2.error), Promise.reject(new u.ErrorResponse(r2))) : Promise.resolve(r2));
          }, t2.prototype._processSigninParams = function t3(e2, r2) {
            if (e2.id !== r2.state) return i.Log.error("ResponseValidator._processSigninParams: State does not match"), Promise.reject(new Error("State does not match"));
            if (!e2.client_id) return i.Log.error("ResponseValidator._processSigninParams: No client_id on state"), Promise.reject(new Error("No client_id on state"));
            if (!e2.authority) return i.Log.error("ResponseValidator._processSigninParams: No authority on state"), Promise.reject(new Error("No authority on state"));
            if (this._settings.authority) {
              if (this._settings.authority && this._settings.authority !== e2.authority) return i.Log.error("ResponseValidator._processSigninParams: authority mismatch on settings vs. signin state"), Promise.reject(new Error("authority mismatch on settings vs. signin state"));
            } else this._settings.authority = e2.authority;
            if (this._settings.client_id) {
              if (this._settings.client_id && this._settings.client_id !== e2.client_id) return i.Log.error("ResponseValidator._processSigninParams: client_id mismatch on settings vs. signin state"), Promise.reject(new Error("client_id mismatch on settings vs. signin state"));
            } else this._settings.client_id = e2.client_id;
            return i.Log.debug("ResponseValidator._processSigninParams: state validated"), r2.state = e2.data, r2.error ? (i.Log.warn("ResponseValidator._processSigninParams: Response was error", r2.error), Promise.reject(new u.ErrorResponse(r2))) : e2.nonce && !r2.id_token ? (i.Log.error("ResponseValidator._processSigninParams: Expecting id_token in response"), Promise.reject(new Error("No id_token in response"))) : !e2.nonce && r2.id_token ? (i.Log.error("ResponseValidator._processSigninParams: Not expecting id_token in response"), Promise.reject(new Error("Unexpected id_token in response"))) : e2.code_verifier && !r2.code ? (i.Log.error("ResponseValidator._processSigninParams: Expecting code in response"), Promise.reject(new Error("No code in response"))) : !e2.code_verifier && r2.code ? (i.Log.error("ResponseValidator._processSigninParams: Not expecting code in response"), Promise.reject(new Error("Unexpected code in response"))) : (r2.scope || (r2.scope = e2.scope), Promise.resolve(r2));
          }, t2.prototype._processClaims = function t3(e2, r2) {
            var n2 = this;
            if (r2.isOpenIdConnect) {
              if (i.Log.debug("ResponseValidator._processClaims: response is OIDC, processing claims"), r2.profile = this._filterProtocolClaims(r2.profile), true !== e2.skipUserInfo && this._settings.loadUserInfo && r2.access_token) return i.Log.debug("ResponseValidator._processClaims: loading user info"), this._userInfoService.getClaims(r2.access_token).then((function(t4) {
                return i.Log.debug("ResponseValidator._processClaims: user info claims received from user info endpoint"), t4.sub !== r2.profile.sub ? (i.Log.error("ResponseValidator._processClaims: sub from user info endpoint does not match sub in id_token"), Promise.reject(new Error("sub from user info endpoint does not match sub in id_token"))) : (r2.profile = n2._mergeClaims(r2.profile, t4), i.Log.debug("ResponseValidator._processClaims: user info claims received, updated profile:", r2.profile), r2);
              }));
              i.Log.debug("ResponseValidator._processClaims: not loading user info");
            } else i.Log.debug("ResponseValidator._processClaims: response is not OIDC, not processing claims");
            return Promise.resolve(r2);
          }, t2.prototype._mergeClaims = function t3(e2, r2) {
            var i2 = Object.assign({}, e2);
            for (var o2 in r2) {
              var s2 = r2[o2];
              Array.isArray(s2) || (s2 = [s2]);
              for (var a2 = 0; a2 < s2.length; a2++) {
                var u2 = s2[a2];
                i2[o2] ? Array.isArray(i2[o2]) ? i2[o2].indexOf(u2) < 0 && i2[o2].push(u2) : i2[o2] !== u2 && ("object" === (void 0 === u2 ? "undefined" : n(u2)) && this._settings.mergeClaims ? i2[o2] = this._mergeClaims(i2[o2], u2) : i2[o2] = [i2[o2], u2]) : i2[o2] = u2;
              }
            }
            return i2;
          }, t2.prototype._filterProtocolClaims = function t3(e2) {
            i.Log.debug("ResponseValidator._filterProtocolClaims, incoming claims:", e2);
            var r2 = Object.assign({}, e2);
            return this._settings._filterProtocolClaims ? (l.forEach((function(t4) {
              delete r2[t4];
            })), i.Log.debug("ResponseValidator._filterProtocolClaims: protocol claims filtered", r2)) : i.Log.debug("ResponseValidator._filterProtocolClaims: protocol claims not filtered"), r2;
          }, t2.prototype._validateTokens = function t3(e2, r2) {
            return r2.code ? (i.Log.debug("ResponseValidator._validateTokens: Validating code"), this._processCode(e2, r2)) : r2.id_token ? r2.access_token ? (i.Log.debug("ResponseValidator._validateTokens: Validating id_token and access_token"), this._validateIdTokenAndAccessToken(e2, r2)) : (i.Log.debug("ResponseValidator._validateTokens: Validating id_token"), this._validateIdToken(e2, r2)) : (i.Log.debug("ResponseValidator._validateTokens: No code to process or id_token to validate"), Promise.resolve(r2));
          }, t2.prototype._processCode = function t3(e2, r2) {
            var o2 = this, s2 = { client_id: e2.client_id, client_secret: e2.client_secret, code: r2.code, redirect_uri: e2.redirect_uri, code_verifier: e2.code_verifier };
            return e2.extraTokenParams && "object" === n(e2.extraTokenParams) && Object.assign(s2, e2.extraTokenParams), this._tokenClient.exchangeCode(s2).then((function(t4) {
              for (var n2 in t4) r2[n2] = t4[n2];
              return r2.id_token ? (i.Log.debug("ResponseValidator._processCode: token response successful, processing id_token"), o2._validateIdTokenAttributes(e2, r2)) : (i.Log.debug("ResponseValidator._processCode: token response successful, returning response"), r2);
            }));
          }, t2.prototype._validateIdTokenAttributes = function t3(e2, r2) {
            var n2 = this;
            return this._metadataService.getIssuer().then((function(t4) {
              var o2 = e2.client_id, s2 = n2._settings.clockSkew;
              return i.Log.debug("ResponseValidator._validateIdTokenAttributes: Validaing JWT attributes; using clock skew (in seconds) of: ", s2), n2._settings.getEpochTime().then((function(a2) {
                return n2._joseUtil.validateJwtAttributes(r2.id_token, t4, o2, s2, a2).then((function(t5) {
                  return e2.nonce && e2.nonce !== t5.nonce ? (i.Log.error("ResponseValidator._validateIdTokenAttributes: Invalid nonce in id_token"), Promise.reject(new Error("Invalid nonce in id_token"))) : t5.sub ? (r2.profile = t5, r2) : (i.Log.error("ResponseValidator._validateIdTokenAttributes: No sub present in id_token"), Promise.reject(new Error("No sub present in id_token")));
                }));
              }));
            }));
          }, t2.prototype._validateIdTokenAndAccessToken = function t3(e2, r2) {
            var n2 = this;
            return this._validateIdToken(e2, r2).then((function(t4) {
              return n2._validateAccessToken(t4);
            }));
          }, t2.prototype._getSigningKeyForJwt = function t3(e2) {
            var r2 = this;
            return this._metadataService.getSigningKeys().then((function(t4) {
              var n2 = e2.header.kid;
              if (!t4) return i.Log.error("ResponseValidator._validateIdToken: No signing keys from metadata"), Promise.reject(new Error("No signing keys from metadata"));
              i.Log.debug("ResponseValidator._validateIdToken: Received signing keys");
              var o2 = void 0;
              if (n2) o2 = t4.filter((function(t5) {
                return t5.kid === n2;
              }))[0];
              else {
                if ((t4 = r2._filterByAlg(t4, e2.header.alg)).length > 1) return i.Log.error("ResponseValidator._validateIdToken: No kid found in id_token and more than one key found in metadata"), Promise.reject(new Error("No kid found in id_token and more than one key found in metadata"));
                o2 = t4[0];
              }
              return Promise.resolve(o2);
            }));
          }, t2.prototype._getSigningKeyForJwtWithSingleRetry = function t3(e2) {
            var r2 = this;
            return this._getSigningKeyForJwt(e2).then((function(t4) {
              return t4 ? Promise.resolve(t4) : (r2._metadataService.resetSigningKeys(), r2._getSigningKeyForJwt(e2));
            }));
          }, t2.prototype._validateIdToken = function t3(e2, r2) {
            var n2 = this;
            if (!e2.nonce) return i.Log.error("ResponseValidator._validateIdToken: No nonce on state"), Promise.reject(new Error("No nonce on state"));
            var o2 = this._joseUtil.parseJwt(r2.id_token);
            return o2 && o2.header && o2.payload ? e2.nonce !== o2.payload.nonce ? (i.Log.error("ResponseValidator._validateIdToken: Invalid nonce in id_token"), Promise.reject(new Error("Invalid nonce in id_token"))) : this._metadataService.getIssuer().then((function(t4) {
              return i.Log.debug("ResponseValidator._validateIdToken: Received issuer"), n2._getSigningKeyForJwtWithSingleRetry(o2).then((function(s2) {
                if (!s2) return i.Log.error("ResponseValidator._validateIdToken: No key matching kid or alg found in signing keys"), Promise.reject(new Error("No key matching kid or alg found in signing keys"));
                var a2 = e2.client_id, u2 = n2._settings.clockSkew;
                return i.Log.debug("ResponseValidator._validateIdToken: Validaing JWT; using clock skew (in seconds) of: ", u2), n2._joseUtil.validateJwt(r2.id_token, s2, t4, a2, u2).then((function() {
                  return i.Log.debug("ResponseValidator._validateIdToken: JWT validation successful"), o2.payload.sub ? (r2.profile = o2.payload, r2) : (i.Log.error("ResponseValidator._validateIdToken: No sub present in id_token"), Promise.reject(new Error("No sub present in id_token")));
                }));
              }));
            })) : (i.Log.error("ResponseValidator._validateIdToken: Failed to parse id_token", o2), Promise.reject(new Error("Failed to parse id_token")));
          }, t2.prototype._filterByAlg = function t3(e2, r2) {
            var n2 = null;
            if (r2.startsWith("RS")) n2 = "RSA";
            else if (r2.startsWith("PS")) n2 = "PS";
            else {
              if (!r2.startsWith("ES")) return i.Log.debug("ResponseValidator._filterByAlg: alg not supported: ", r2), [];
              n2 = "EC";
            }
            return i.Log.debug("ResponseValidator._filterByAlg: Looking for keys that match kty: ", n2), e2 = e2.filter((function(t4) {
              return t4.kty === n2;
            })), i.Log.debug("ResponseValidator._filterByAlg: Number of keys that match kty: ", n2, e2.length), e2;
          }, t2.prototype._validateAccessToken = function t3(e2) {
            if (!e2.profile) return i.Log.error("ResponseValidator._validateAccessToken: No profile loaded from id_token"), Promise.reject(new Error("No profile loaded from id_token"));
            if (!e2.profile.at_hash) return i.Log.error("ResponseValidator._validateAccessToken: No at_hash in id_token"), Promise.reject(new Error("No at_hash in id_token"));
            if (!e2.id_token) return i.Log.error("ResponseValidator._validateAccessToken: No id_token"), Promise.reject(new Error("No id_token"));
            var r2 = this._joseUtil.parseJwt(e2.id_token);
            if (!r2 || !r2.header) return i.Log.error("ResponseValidator._validateAccessToken: Failed to parse id_token", r2), Promise.reject(new Error("Failed to parse id_token"));
            var n2 = r2.header.alg;
            if (!n2 || 5 !== n2.length) return i.Log.error("ResponseValidator._validateAccessToken: Unsupported alg:", n2), Promise.reject(new Error("Unsupported alg: " + n2));
            var o2 = n2.substr(2, 3);
            if (!o2) return i.Log.error("ResponseValidator._validateAccessToken: Unsupported alg:", n2, o2), Promise.reject(new Error("Unsupported alg: " + n2));
            if (256 !== (o2 = parseInt(o2)) && 384 !== o2 && 512 !== o2) return i.Log.error("ResponseValidator._validateAccessToken: Unsupported alg:", n2, o2), Promise.reject(new Error("Unsupported alg: " + n2));
            var s2 = "sha" + o2, a2 = this._joseUtil.hashString(e2.access_token, s2);
            if (!a2) return i.Log.error("ResponseValidator._validateAccessToken: access_token hash failed:", s2), Promise.reject(new Error("Failed to validate at_hash"));
            var u2 = a2.substr(0, a2.length / 2), c2 = this._joseUtil.hexToBase64Url(u2);
            return c2 !== e2.profile.at_hash ? (i.Log.error("ResponseValidator._validateAccessToken: Failed to validate at_hash", c2, e2.profile.at_hash), Promise.reject(new Error("Failed to validate at_hash"))) : (i.Log.debug("ResponseValidator._validateAccessToken: success"), Promise.resolve(e2));
          }, t2;
        })();
      }, function(t, e, r) {
        "use strict";
        Object.defineProperty(e, "__esModule", { value: true }), e.UserInfoService = void 0;
        var n = r(7), i = r(2), o = r(0), s = r(4);
        function a(t2, e2) {
          if (!(t2 instanceof e2)) throw new TypeError("Cannot call a class as a function");
        }
        e.UserInfoService = (function() {
          function t2(e2) {
            var r2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : n.JsonService, u = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : i.MetadataService, c = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : s.JoseUtil;
            if (a(this, t2), !e2) throw o.Log.error("UserInfoService.ctor: No settings passed"), new Error("settings");
            this._settings = e2, this._jsonService = new r2(void 0, void 0, this._getClaimsFromJwt.bind(this)), this._metadataService = new u(this._settings), this._joseUtil = c;
          }
          return t2.prototype.getClaims = function t3(e2) {
            var r2 = this;
            return e2 ? this._metadataService.getUserInfoEndpoint().then((function(t4) {
              return o.Log.debug("UserInfoService.getClaims: received userinfo url", t4), r2._jsonService.getJson(t4, e2).then((function(t5) {
                return o.Log.debug("UserInfoService.getClaims: claims received", t5), t5;
              }));
            })) : (o.Log.error("UserInfoService.getClaims: No token passed"), Promise.reject(new Error("A token is required")));
          }, t2.prototype._getClaimsFromJwt = function t3(e2) {
            var r2 = this;
            try {
              var n2 = this._joseUtil.parseJwt(e2.responseText);
              if (!n2 || !n2.header || !n2.payload) return o.Log.error("UserInfoService._getClaimsFromJwt: Failed to parse JWT", n2), Promise.reject(new Error("Failed to parse id_token"));
              var i2 = n2.header.kid, s2 = void 0;
              switch (this._settings.userInfoJwtIssuer) {
                case "OP":
                  s2 = this._metadataService.getIssuer();
                  break;
                case "ANY":
                  s2 = Promise.resolve(n2.payload.iss);
                  break;
                default:
                  s2 = Promise.resolve(this._settings.userInfoJwtIssuer);
              }
              return s2.then((function(t4) {
                return o.Log.debug("UserInfoService._getClaimsFromJwt: Received issuer:" + t4), r2._metadataService.getSigningKeys().then((function(s3) {
                  if (!s3) return o.Log.error("UserInfoService._getClaimsFromJwt: No signing keys from metadata"), Promise.reject(new Error("No signing keys from metadata"));
                  o.Log.debug("UserInfoService._getClaimsFromJwt: Received signing keys");
                  var a2 = void 0;
                  if (i2) a2 = s3.filter((function(t5) {
                    return t5.kid === i2;
                  }))[0];
                  else {
                    if ((s3 = r2._filterByAlg(s3, n2.header.alg)).length > 1) return o.Log.error("UserInfoService._getClaimsFromJwt: No kid found in id_token and more than one key found in metadata"), Promise.reject(new Error("No kid found in id_token and more than one key found in metadata"));
                    a2 = s3[0];
                  }
                  if (!a2) return o.Log.error("UserInfoService._getClaimsFromJwt: No key matching kid or alg found in signing keys"), Promise.reject(new Error("No key matching kid or alg found in signing keys"));
                  var u = r2._settings.client_id, c = r2._settings.clockSkew;
                  return o.Log.debug("UserInfoService._getClaimsFromJwt: Validaing JWT; using clock skew (in seconds) of: ", c), r2._joseUtil.validateJwt(e2.responseText, a2, t4, u, c, void 0, true).then((function() {
                    return o.Log.debug("UserInfoService._getClaimsFromJwt: JWT validation successful"), n2.payload;
                  }));
                }));
              }));
            } catch (t4) {
              return o.Log.error("UserInfoService._getClaimsFromJwt: Error parsing JWT response", t4.message), void reject(t4);
            }
          }, t2.prototype._filterByAlg = function t3(e2, r2) {
            var n2 = null;
            if (r2.startsWith("RS")) n2 = "RSA";
            else if (r2.startsWith("PS")) n2 = "PS";
            else {
              if (!r2.startsWith("ES")) return o.Log.debug("UserInfoService._filterByAlg: alg not supported: ", r2), [];
              n2 = "EC";
            }
            return o.Log.debug("UserInfoService._filterByAlg: Looking for keys that match kty: ", n2), e2 = e2.filter((function(t4) {
              return t4.kty === n2;
            })), o.Log.debug("UserInfoService._filterByAlg: Number of keys that match kty: ", n2, e2.length), e2;
          }, t2;
        })();
      }, function(t, e, r) {
        "use strict";
        Object.defineProperty(e, "__esModule", { value: true }), e.AllowedSigningAlgs = e.b64tohex = e.hextob64u = e.crypto = e.X509 = e.KeyUtil = e.jws = void 0;
        var n = r(27);
        e.jws = n.jws, e.KeyUtil = n.KEYUTIL, e.X509 = n.X509, e.crypto = n.crypto, e.hextob64u = n.hextob64u, e.b64tohex = n.b64tohex, e.AllowedSigningAlgs = ["RS256", "RS384", "RS512", "PS256", "PS384", "PS512", "ES256", "ES384", "ES512"];
      }, function(t, e, r) {
        "use strict";
        (function(t2) {
          Object.defineProperty(e, "__esModule", { value: true });
          var r2, n, i, o, s, a, u, c, h, l, f, g = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t3) {
            return typeof t3;
          } : function(t3) {
            return t3 && "function" == typeof Symbol && t3.constructor === Symbol && t3 !== Symbol.prototype ? "symbol" : typeof t3;
          }, d = { userAgent: false }, p = {}, v = v || (r2 = Math, i = (n = {}).lib = {}, o = i.Base = /* @__PURE__ */ (function() {
            function t3() {
            }
            return { extend: function e2(r3) {
              t3.prototype = this;
              var n2 = new t3();
              return r3 && n2.mixIn(r3), n2.hasOwnProperty("init") || (n2.init = function() {
                n2.$super.init.apply(this, arguments);
              }), n2.init.prototype = n2, n2.$super = this, n2;
            }, create: function t4() {
              var e2 = this.extend();
              return e2.init.apply(e2, arguments), e2;
            }, init: function t4() {
            }, mixIn: function t4(e2) {
              for (var r3 in e2) e2.hasOwnProperty(r3) && (this[r3] = e2[r3]);
              e2.hasOwnProperty("toString") && (this.toString = e2.toString);
            }, clone: function t4() {
              return this.init.prototype.extend(this);
            } };
          })(), s = i.WordArray = o.extend({ init: function t3(e2, r3) {
            e2 = this.words = e2 || [], this.sigBytes = null != r3 ? r3 : 4 * e2.length;
          }, toString: function t3(e2) {
            return (e2 || u).stringify(this);
          }, concat: function t3(e2) {
            var r3 = this.words, n2 = e2.words, i2 = this.sigBytes, o2 = e2.sigBytes;
            if (this.clamp(), i2 % 4) for (var s2 = 0; s2 < o2; s2++) {
              var a2 = n2[s2 >>> 2] >>> 24 - s2 % 4 * 8 & 255;
              r3[i2 + s2 >>> 2] |= a2 << 24 - (i2 + s2) % 4 * 8;
            }
            else for (s2 = 0; s2 < o2; s2 += 4) r3[i2 + s2 >>> 2] = n2[s2 >>> 2];
            return this.sigBytes += o2, this;
          }, clamp: function t3() {
            var e2 = this.words, n2 = this.sigBytes;
            e2[n2 >>> 2] &= 4294967295 << 32 - n2 % 4 * 8, e2.length = r2.ceil(n2 / 4);
          }, clone: function t3() {
            var e2 = o.clone.call(this);
            return e2.words = this.words.slice(0), e2;
          }, random: function t3(e2) {
            for (var n2 = [], i2 = 0; i2 < e2; i2 += 4) n2.push(4294967296 * r2.random() | 0);
            return new s.init(n2, e2);
          } }), a = n.enc = {}, u = a.Hex = { stringify: function t3(e2) {
            for (var r3 = e2.words, n2 = e2.sigBytes, i2 = [], o2 = 0; o2 < n2; o2++) {
              var s2 = r3[o2 >>> 2] >>> 24 - o2 % 4 * 8 & 255;
              i2.push((s2 >>> 4).toString(16)), i2.push((15 & s2).toString(16));
            }
            return i2.join("");
          }, parse: function t3(e2) {
            for (var r3 = e2.length, n2 = [], i2 = 0; i2 < r3; i2 += 2) n2[i2 >>> 3] |= parseInt(e2.substr(i2, 2), 16) << 24 - i2 % 8 * 4;
            return new s.init(n2, r3 / 2);
          } }, c = a.Latin1 = { stringify: function t3(e2) {
            for (var r3 = e2.words, n2 = e2.sigBytes, i2 = [], o2 = 0; o2 < n2; o2++) {
              var s2 = r3[o2 >>> 2] >>> 24 - o2 % 4 * 8 & 255;
              i2.push(String.fromCharCode(s2));
            }
            return i2.join("");
          }, parse: function t3(e2) {
            for (var r3 = e2.length, n2 = [], i2 = 0; i2 < r3; i2++) n2[i2 >>> 2] |= (255 & e2.charCodeAt(i2)) << 24 - i2 % 4 * 8;
            return new s.init(n2, r3);
          } }, h = a.Utf8 = { stringify: function t3(e2) {
            try {
              return decodeURIComponent(escape(c.stringify(e2)));
            } catch (t4) {
              throw new Error("Malformed UTF-8 data");
            }
          }, parse: function t3(e2) {
            return c.parse(unescape(encodeURIComponent(e2)));
          } }, l = i.BufferedBlockAlgorithm = o.extend({ reset: function t3() {
            this._data = new s.init(), this._nDataBytes = 0;
          }, _append: function t3(e2) {
            "string" == typeof e2 && (e2 = h.parse(e2)), this._data.concat(e2), this._nDataBytes += e2.sigBytes;
          }, _process: function t3(e2) {
            var n2 = this._data, i2 = n2.words, o2 = n2.sigBytes, a2 = this.blockSize, u2 = o2 / (4 * a2), c2 = (u2 = e2 ? r2.ceil(u2) : r2.max((0 | u2) - this._minBufferSize, 0)) * a2, h2 = r2.min(4 * c2, o2);
            if (c2) {
              for (var l2 = 0; l2 < c2; l2 += a2) this._doProcessBlock(i2, l2);
              var f2 = i2.splice(0, c2);
              n2.sigBytes -= h2;
            }
            return new s.init(f2, h2);
          }, clone: function t3() {
            var e2 = o.clone.call(this);
            return e2._data = this._data.clone(), e2;
          }, _minBufferSize: 0 }), i.Hasher = l.extend({ cfg: o.extend(), init: function t3(e2) {
            this.cfg = this.cfg.extend(e2), this.reset();
          }, reset: function t3() {
            l.reset.call(this), this._doReset();
          }, update: function t3(e2) {
            return this._append(e2), this._process(), this;
          }, finalize: function t3(e2) {
            return e2 && this._append(e2), this._doFinalize();
          }, blockSize: 16, _createHelper: function t3(e2) {
            return function(t4, r3) {
              return new e2.init(r3).finalize(t4);
            };
          }, _createHmacHelper: function t3(e2) {
            return function(t4, r3) {
              return new f.HMAC.init(e2, r3).finalize(t4);
            };
          } }), f = n.algo = {}, n);
          !(function(t3) {
            var e2, r3 = (e2 = v).lib, n2 = r3.Base, i2 = r3.WordArray;
            (e2 = e2.x64 = {}).Word = n2.extend({ init: function t4(e3, r4) {
              this.high = e3, this.low = r4;
            } }), e2.WordArray = n2.extend({ init: function t4(e3, r4) {
              e3 = this.words = e3 || [], this.sigBytes = null != r4 ? r4 : 8 * e3.length;
            }, toX32: function t4() {
              for (var e3 = this.words, r4 = e3.length, n3 = [], o2 = 0; o2 < r4; o2++) {
                var s2 = e3[o2];
                n3.push(s2.high), n3.push(s2.low);
              }
              return i2.create(n3, this.sigBytes);
            }, clone: function t4() {
              for (var e3 = n2.clone.call(this), r4 = e3.words = this.words.slice(0), i3 = r4.length, o2 = 0; o2 < i3; o2++) r4[o2] = r4[o2].clone();
              return e3;
            } });
          })(), (function() {
            var t3 = v, e2 = t3.lib.WordArray;
            t3.enc.Base64 = { stringify: function t4(e3) {
              var r3 = e3.words, n2 = e3.sigBytes, i2 = this._map;
              e3.clamp(), e3 = [];
              for (var o2 = 0; o2 < n2; o2 += 3) for (var s2 = (r3[o2 >>> 2] >>> 24 - o2 % 4 * 8 & 255) << 16 | (r3[o2 + 1 >>> 2] >>> 24 - (o2 + 1) % 4 * 8 & 255) << 8 | r3[o2 + 2 >>> 2] >>> 24 - (o2 + 2) % 4 * 8 & 255, a2 = 0; 4 > a2 && o2 + 0.75 * a2 < n2; a2++) e3.push(i2.charAt(s2 >>> 6 * (3 - a2) & 63));
              if (r3 = i2.charAt(64)) for (; e3.length % 4; ) e3.push(r3);
              return e3.join("");
            }, parse: function t4(r3) {
              var n2 = r3.length, i2 = this._map;
              (o2 = i2.charAt(64)) && (-1 != (o2 = r3.indexOf(o2)) && (n2 = o2));
              for (var o2 = [], s2 = 0, a2 = 0; a2 < n2; a2++) if (a2 % 4) {
                var u2 = i2.indexOf(r3.charAt(a2 - 1)) << a2 % 4 * 2, c2 = i2.indexOf(r3.charAt(a2)) >>> 6 - a2 % 4 * 2;
                o2[s2 >>> 2] |= (u2 | c2) << 24 - s2 % 4 * 8, s2++;
              }
              return e2.create(o2, s2);
            }, _map: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=" };
          })(), (function(t3) {
            for (var e2 = v, r3 = (i2 = e2.lib).WordArray, n2 = i2.Hasher, i2 = e2.algo, o2 = [], s2 = [], a2 = function t4(e3) {
              return 4294967296 * (e3 - (0 | e3)) | 0;
            }, u2 = 2, c2 = 0; 64 > c2; ) {
              var h2;
              t: {
                h2 = u2;
                for (var l2 = t3.sqrt(h2), f2 = 2; f2 <= l2; f2++) if (!(h2 % f2)) {
                  h2 = false;
                  break t;
                }
                h2 = true;
              }
              h2 && (8 > c2 && (o2[c2] = a2(t3.pow(u2, 0.5))), s2[c2] = a2(t3.pow(u2, 1 / 3)), c2++), u2++;
            }
            var g2 = [];
            i2 = i2.SHA256 = n2.extend({ _doReset: function t4() {
              this._hash = new r3.init(o2.slice(0));
            }, _doProcessBlock: function t4(e3, r4) {
              for (var n3 = this._hash.words, i3 = n3[0], o3 = n3[1], a3 = n3[2], u3 = n3[3], c3 = n3[4], h3 = n3[5], l3 = n3[6], f3 = n3[7], d2 = 0; 64 > d2; d2++) {
                if (16 > d2) g2[d2] = 0 | e3[r4 + d2];
                else {
                  var p2 = g2[d2 - 15], v2 = g2[d2 - 2];
                  g2[d2] = ((p2 << 25 | p2 >>> 7) ^ (p2 << 14 | p2 >>> 18) ^ p2 >>> 3) + g2[d2 - 7] + ((v2 << 15 | v2 >>> 17) ^ (v2 << 13 | v2 >>> 19) ^ v2 >>> 10) + g2[d2 - 16];
                }
                p2 = f3 + ((c3 << 26 | c3 >>> 6) ^ (c3 << 21 | c3 >>> 11) ^ (c3 << 7 | c3 >>> 25)) + (c3 & h3 ^ ~c3 & l3) + s2[d2] + g2[d2], v2 = ((i3 << 30 | i3 >>> 2) ^ (i3 << 19 | i3 >>> 13) ^ (i3 << 10 | i3 >>> 22)) + (i3 & o3 ^ i3 & a3 ^ o3 & a3), f3 = l3, l3 = h3, h3 = c3, c3 = u3 + p2 | 0, u3 = a3, a3 = o3, o3 = i3, i3 = p2 + v2 | 0;
              }
              n3[0] = n3[0] + i3 | 0, n3[1] = n3[1] + o3 | 0, n3[2] = n3[2] + a3 | 0, n3[3] = n3[3] + u3 | 0, n3[4] = n3[4] + c3 | 0, n3[5] = n3[5] + h3 | 0, n3[6] = n3[6] + l3 | 0, n3[7] = n3[7] + f3 | 0;
            }, _doFinalize: function e3() {
              var r4 = this._data, n3 = r4.words, i3 = 8 * this._nDataBytes, o3 = 8 * r4.sigBytes;
              return n3[o3 >>> 5] |= 128 << 24 - o3 % 32, n3[14 + (o3 + 64 >>> 9 << 4)] = t3.floor(i3 / 4294967296), n3[15 + (o3 + 64 >>> 9 << 4)] = i3, r4.sigBytes = 4 * n3.length, this._process(), this._hash;
            }, clone: function t4() {
              var e3 = n2.clone.call(this);
              return e3._hash = this._hash.clone(), e3;
            } });
            e2.SHA256 = n2._createHelper(i2), e2.HmacSHA256 = n2._createHmacHelper(i2);
          })(Math), (function() {
            function t3() {
              return n2.create.apply(n2, arguments);
            }
            for (var e2 = v, r3 = e2.lib.Hasher, n2 = (o2 = e2.x64).Word, i2 = o2.WordArray, o2 = e2.algo, s2 = [t3(1116352408, 3609767458), t3(1899447441, 602891725), t3(3049323471, 3964484399), t3(3921009573, 2173295548), t3(961987163, 4081628472), t3(1508970993, 3053834265), t3(2453635748, 2937671579), t3(2870763221, 3664609560), t3(3624381080, 2734883394), t3(310598401, 1164996542), t3(607225278, 1323610764), t3(1426881987, 3590304994), t3(1925078388, 4068182383), t3(2162078206, 991336113), t3(2614888103, 633803317), t3(3248222580, 3479774868), t3(3835390401, 2666613458), t3(4022224774, 944711139), t3(264347078, 2341262773), t3(604807628, 2007800933), t3(770255983, 1495990901), t3(1249150122, 1856431235), t3(1555081692, 3175218132), t3(1996064986, 2198950837), t3(2554220882, 3999719339), t3(2821834349, 766784016), t3(2952996808, 2566594879), t3(3210313671, 3203337956), t3(3336571891, 1034457026), t3(3584528711, 2466948901), t3(113926993, 3758326383), t3(338241895, 168717936), t3(666307205, 1188179964), t3(773529912, 1546045734), t3(1294757372, 1522805485), t3(1396182291, 2643833823), t3(1695183700, 2343527390), t3(1986661051, 1014477480), t3(2177026350, 1206759142), t3(2456956037, 344077627), t3(2730485921, 1290863460), t3(2820302411, 3158454273), t3(3259730800, 3505952657), t3(3345764771, 106217008), t3(3516065817, 3606008344), t3(3600352804, 1432725776), t3(4094571909, 1467031594), t3(275423344, 851169720), t3(430227734, 3100823752), t3(506948616, 1363258195), t3(659060556, 3750685593), t3(883997877, 3785050280), t3(958139571, 3318307427), t3(1322822218, 3812723403), t3(1537002063, 2003034995), t3(1747873779, 3602036899), t3(1955562222, 1575990012), t3(2024104815, 1125592928), t3(2227730452, 2716904306), t3(2361852424, 442776044), t3(2428436474, 593698344), t3(2756734187, 3733110249), t3(3204031479, 2999351573), t3(3329325298, 3815920427), t3(3391569614, 3928383900), t3(3515267271, 566280711), t3(3940187606, 3454069534), t3(4118630271, 4000239992), t3(116418474, 1914138554), t3(174292421, 2731055270), t3(289380356, 3203993006), t3(460393269, 320620315), t3(685471733, 587496836), t3(852142971, 1086792851), t3(1017036298, 365543100), t3(1126000580, 2618297676), t3(1288033470, 3409855158), t3(1501505948, 4234509866), t3(1607167915, 987167468), t3(1816402316, 1246189591)], a2 = [], u2 = 0; 80 > u2; u2++) a2[u2] = t3();
            o2 = o2.SHA512 = r3.extend({ _doReset: function t4() {
              this._hash = new i2.init([new n2.init(1779033703, 4089235720), new n2.init(3144134277, 2227873595), new n2.init(1013904242, 4271175723), new n2.init(2773480762, 1595750129), new n2.init(1359893119, 2917565137), new n2.init(2600822924, 725511199), new n2.init(528734635, 4215389547), new n2.init(1541459225, 327033209)]);
            }, _doProcessBlock: function t4(e3, r4) {
              for (var n3 = (f2 = this._hash.words)[0], i3 = f2[1], o3 = f2[2], u3 = f2[3], c2 = f2[4], h2 = f2[5], l2 = f2[6], f2 = f2[7], g2 = n3.high, d2 = n3.low, p2 = i3.high, v2 = i3.low, y2 = o3.high, m2 = o3.low, _2 = u3.high, S2 = u3.low, b2 = c2.high, w2 = c2.low, F2 = h2.high, E = h2.low, x = l2.high, A = l2.low, k2 = f2.high, P2 = f2.low, C2 = g2, T2 = d2, R2 = p2, I2 = v2, D2 = y2, L2 = m2, N2 = _2, U2 = S2, B2 = b2, O2 = w2, j2 = F2, M2 = E, H2 = x, V2 = A, K2 = k2, q2 = P2, J = 0; 80 > J; J++) {
                var W = a2[J];
                if (16 > J) var z = W.high = 0 | e3[r4 + 2 * J], Y = W.low = 0 | e3[r4 + 2 * J + 1];
                else {
                  z = ((Y = (z = a2[J - 15]).high) >>> 1 | (G = z.low) << 31) ^ (Y >>> 8 | G << 24) ^ Y >>> 7;
                  var G = (G >>> 1 | Y << 31) ^ (G >>> 8 | Y << 24) ^ (G >>> 7 | Y << 25), X = ((Y = (X = a2[J - 2]).high) >>> 19 | ($ = X.low) << 13) ^ (Y << 3 | $ >>> 29) ^ Y >>> 6, $ = ($ >>> 19 | Y << 13) ^ ($ << 3 | Y >>> 29) ^ ($ >>> 6 | Y << 26), Q = (Y = a2[J - 7]).high, Z = (tt = a2[J - 16]).high, tt = tt.low;
                  z = (z = (z = z + Q + ((Y = G + Y.low) >>> 0 < G >>> 0 ? 1 : 0)) + X + ((Y = Y + $) >>> 0 < $ >>> 0 ? 1 : 0)) + Z + ((Y = Y + tt) >>> 0 < tt >>> 0 ? 1 : 0);
                  W.high = z, W.low = Y;
                }
                Q = B2 & j2 ^ ~B2 & H2, tt = O2 & M2 ^ ~O2 & V2, W = C2 & R2 ^ C2 & D2 ^ R2 & D2;
                var et = T2 & I2 ^ T2 & L2 ^ I2 & L2, rt = (G = (C2 >>> 28 | T2 << 4) ^ (C2 << 30 | T2 >>> 2) ^ (C2 << 25 | T2 >>> 7), X = (T2 >>> 28 | C2 << 4) ^ (T2 << 30 | C2 >>> 2) ^ (T2 << 25 | C2 >>> 7), ($ = s2[J]).high), nt = $.low;
                Z = K2 + ((B2 >>> 14 | O2 << 18) ^ (B2 >>> 18 | O2 << 14) ^ (B2 << 23 | O2 >>> 9)) + (($ = q2 + ((O2 >>> 14 | B2 << 18) ^ (O2 >>> 18 | B2 << 14) ^ (O2 << 23 | B2 >>> 9))) >>> 0 < q2 >>> 0 ? 1 : 0), K2 = H2, q2 = V2, H2 = j2, V2 = M2, j2 = B2, M2 = O2, B2 = N2 + (Z = (Z = (Z = Z + Q + (($ = $ + tt) >>> 0 < tt >>> 0 ? 1 : 0)) + rt + (($ = $ + nt) >>> 0 < nt >>> 0 ? 1 : 0)) + z + (($ = $ + Y) >>> 0 < Y >>> 0 ? 1 : 0)) + ((O2 = U2 + $ | 0) >>> 0 < U2 >>> 0 ? 1 : 0) | 0, N2 = D2, U2 = L2, D2 = R2, L2 = I2, R2 = C2, I2 = T2, C2 = Z + (W = G + W + ((Y = X + et) >>> 0 < X >>> 0 ? 1 : 0)) + ((T2 = $ + Y | 0) >>> 0 < $ >>> 0 ? 1 : 0) | 0;
              }
              d2 = n3.low = d2 + T2, n3.high = g2 + C2 + (d2 >>> 0 < T2 >>> 0 ? 1 : 0), v2 = i3.low = v2 + I2, i3.high = p2 + R2 + (v2 >>> 0 < I2 >>> 0 ? 1 : 0), m2 = o3.low = m2 + L2, o3.high = y2 + D2 + (m2 >>> 0 < L2 >>> 0 ? 1 : 0), S2 = u3.low = S2 + U2, u3.high = _2 + N2 + (S2 >>> 0 < U2 >>> 0 ? 1 : 0), w2 = c2.low = w2 + O2, c2.high = b2 + B2 + (w2 >>> 0 < O2 >>> 0 ? 1 : 0), E = h2.low = E + M2, h2.high = F2 + j2 + (E >>> 0 < M2 >>> 0 ? 1 : 0), A = l2.low = A + V2, l2.high = x + H2 + (A >>> 0 < V2 >>> 0 ? 1 : 0), P2 = f2.low = P2 + q2, f2.high = k2 + K2 + (P2 >>> 0 < q2 >>> 0 ? 1 : 0);
            }, _doFinalize: function t4() {
              var e3 = this._data, r4 = e3.words, n3 = 8 * this._nDataBytes, i3 = 8 * e3.sigBytes;
              return r4[i3 >>> 5] |= 128 << 24 - i3 % 32, r4[30 + (i3 + 128 >>> 10 << 5)] = Math.floor(n3 / 4294967296), r4[31 + (i3 + 128 >>> 10 << 5)] = n3, e3.sigBytes = 4 * r4.length, this._process(), this._hash.toX32();
            }, clone: function t4() {
              var e3 = r3.clone.call(this);
              return e3._hash = this._hash.clone(), e3;
            }, blockSize: 32 }), e2.SHA512 = r3._createHelper(o2), e2.HmacSHA512 = r3._createHmacHelper(o2);
          })(), (function() {
            var t3 = v, e2 = (i2 = t3.x64).Word, r3 = i2.WordArray, n2 = (i2 = t3.algo).SHA512, i2 = i2.SHA384 = n2.extend({ _doReset: function t4() {
              this._hash = new r3.init([new e2.init(3418070365, 3238371032), new e2.init(1654270250, 914150663), new e2.init(2438529370, 812702999), new e2.init(355462360, 4144912697), new e2.init(1731405415, 4290775857), new e2.init(2394180231, 1750603025), new e2.init(3675008525, 1694076839), new e2.init(1203062813, 3204075428)]);
            }, _doFinalize: function t4() {
              var e3 = n2._doFinalize.call(this);
              return e3.sigBytes -= 16, e3;
            } });
            t3.SHA384 = n2._createHelper(i2), t3.HmacSHA384 = n2._createHmacHelper(i2);
          })();
          var y, m = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
          function _(t3) {
            var e2, r3, n2 = "";
            for (e2 = 0; e2 + 3 <= t3.length; e2 += 3) r3 = parseInt(t3.substring(e2, e2 + 3), 16), n2 += m.charAt(r3 >> 6) + m.charAt(63 & r3);
            for (e2 + 1 == t3.length ? (r3 = parseInt(t3.substring(e2, e2 + 1), 16), n2 += m.charAt(r3 << 2)) : e2 + 2 == t3.length && (r3 = parseInt(t3.substring(e2, e2 + 2), 16), n2 += m.charAt(r3 >> 2) + m.charAt((3 & r3) << 4)), "="; (3 & n2.length) > 0; ) n2 += "=";
            return n2;
          }
          function S(t3) {
            var e2, r3, n2, i2 = "", o2 = 0;
            for (e2 = 0; e2 < t3.length && "=" != t3.charAt(e2); ++e2) (n2 = m.indexOf(t3.charAt(e2))) < 0 || (0 == o2 ? (i2 += T(n2 >> 2), r3 = 3 & n2, o2 = 1) : 1 == o2 ? (i2 += T(r3 << 2 | n2 >> 4), r3 = 15 & n2, o2 = 2) : 2 == o2 ? (i2 += T(r3), i2 += T(n2 >> 2), r3 = 3 & n2, o2 = 3) : (i2 += T(r3 << 2 | n2 >> 4), i2 += T(15 & n2), o2 = 0));
            return 1 == o2 && (i2 += T(r3 << 2)), i2;
          }
          function b(t3) {
            var e2, r3 = S(t3), n2 = new Array();
            for (e2 = 0; 2 * e2 < r3.length; ++e2) n2[e2] = parseInt(r3.substring(2 * e2, 2 * e2 + 2), 16);
            return n2;
          }
          function w(t3, e2, r3) {
            null != t3 && ("number" == typeof t3 ? this.fromNumber(t3, e2, r3) : null == e2 && "string" != typeof t3 ? this.fromString(t3, 256) : this.fromString(t3, e2));
          }
          function F() {
            return new w(null);
          }
          "Microsoft Internet Explorer" == d.appName ? (w.prototype.am = function E(t3, e2, r3, n2, i2, o2) {
            for (var s2 = 32767 & e2, a2 = e2 >> 15; --o2 >= 0; ) {
              var u2 = 32767 & this[t3], c2 = this[t3++] >> 15, h2 = a2 * u2 + c2 * s2;
              i2 = ((u2 = s2 * u2 + ((32767 & h2) << 15) + r3[n2] + (1073741823 & i2)) >>> 30) + (h2 >>> 15) + a2 * c2 + (i2 >>> 30), r3[n2++] = 1073741823 & u2;
            }
            return i2;
          }, y = 30) : "Netscape" != d.appName ? (w.prototype.am = function x(t3, e2, r3, n2, i2, o2) {
            for (; --o2 >= 0; ) {
              var s2 = e2 * this[t3++] + r3[n2] + i2;
              i2 = Math.floor(s2 / 67108864), r3[n2++] = 67108863 & s2;
            }
            return i2;
          }, y = 26) : (w.prototype.am = function A(t3, e2, r3, n2, i2, o2) {
            for (var s2 = 16383 & e2, a2 = e2 >> 14; --o2 >= 0; ) {
              var u2 = 16383 & this[t3], c2 = this[t3++] >> 14, h2 = a2 * u2 + c2 * s2;
              i2 = ((u2 = s2 * u2 + ((16383 & h2) << 14) + r3[n2] + i2) >> 28) + (h2 >> 14) + a2 * c2, r3[n2++] = 268435455 & u2;
            }
            return i2;
          }, y = 28), w.prototype.DB = y, w.prototype.DM = (1 << y) - 1, w.prototype.DV = 1 << y;
          w.prototype.FV = Math.pow(2, 52), w.prototype.F1 = 52 - y, w.prototype.F2 = 2 * y - 52;
          var k, P, C = new Array();
          for (k = "0".charCodeAt(0), P = 0; P <= 9; ++P) C[k++] = P;
          for (k = "a".charCodeAt(0), P = 10; P < 36; ++P) C[k++] = P;
          for (k = "A".charCodeAt(0), P = 10; P < 36; ++P) C[k++] = P;
          function T(t3) {
            return "0123456789abcdefghijklmnopqrstuvwxyz".charAt(t3);
          }
          function R(t3, e2) {
            var r3 = C[t3.charCodeAt(e2)];
            return null == r3 ? -1 : r3;
          }
          function I(t3) {
            var e2 = F();
            return e2.fromInt(t3), e2;
          }
          function D(t3) {
            var e2, r3 = 1;
            return 0 != (e2 = t3 >>> 16) && (t3 = e2, r3 += 16), 0 != (e2 = t3 >> 8) && (t3 = e2, r3 += 8), 0 != (e2 = t3 >> 4) && (t3 = e2, r3 += 4), 0 != (e2 = t3 >> 2) && (t3 = e2, r3 += 2), 0 != (e2 = t3 >> 1) && (t3 = e2, r3 += 1), r3;
          }
          function L(t3) {
            this.m = t3;
          }
          function N(t3) {
            this.m = t3, this.mp = t3.invDigit(), this.mpl = 32767 & this.mp, this.mph = this.mp >> 15, this.um = (1 << t3.DB - 15) - 1, this.mt2 = 2 * t3.t;
          }
          function U(t3, e2) {
            return t3 & e2;
          }
          function B(t3, e2) {
            return t3 | e2;
          }
          function O(t3, e2) {
            return t3 ^ e2;
          }
          function j(t3, e2) {
            return t3 & ~e2;
          }
          function M(t3) {
            if (0 == t3) return -1;
            var e2 = 0;
            return 0 == (65535 & t3) && (t3 >>= 16, e2 += 16), 0 == (255 & t3) && (t3 >>= 8, e2 += 8), 0 == (15 & t3) && (t3 >>= 4, e2 += 4), 0 == (3 & t3) && (t3 >>= 2, e2 += 2), 0 == (1 & t3) && ++e2, e2;
          }
          function H(t3) {
            for (var e2 = 0; 0 != t3; ) t3 &= t3 - 1, ++e2;
            return e2;
          }
          function V() {
          }
          function K(t3) {
            return t3;
          }
          function q(t3) {
            this.r2 = F(), this.q3 = F(), w.ONE.dlShiftTo(2 * t3.t, this.r2), this.mu = this.r2.divide(t3), this.m = t3;
          }
          L.prototype.convert = function J(t3) {
            return t3.s < 0 || t3.compareTo(this.m) >= 0 ? t3.mod(this.m) : t3;
          }, L.prototype.revert = function W(t3) {
            return t3;
          }, L.prototype.reduce = function z(t3) {
            t3.divRemTo(this.m, null, t3);
          }, L.prototype.mulTo = function Y(t3, e2, r3) {
            t3.multiplyTo(e2, r3), this.reduce(r3);
          }, L.prototype.sqrTo = function G(t3, e2) {
            t3.squareTo(e2), this.reduce(e2);
          }, N.prototype.convert = function X(t3) {
            var e2 = F();
            return t3.abs().dlShiftTo(this.m.t, e2), e2.divRemTo(this.m, null, e2), t3.s < 0 && e2.compareTo(w.ZERO) > 0 && this.m.subTo(e2, e2), e2;
          }, N.prototype.revert = function $(t3) {
            var e2 = F();
            return t3.copyTo(e2), this.reduce(e2), e2;
          }, N.prototype.reduce = function Q(t3) {
            for (; t3.t <= this.mt2; ) t3[t3.t++] = 0;
            for (var e2 = 0; e2 < this.m.t; ++e2) {
              var r3 = 32767 & t3[e2], n2 = r3 * this.mpl + ((r3 * this.mph + (t3[e2] >> 15) * this.mpl & this.um) << 15) & t3.DM;
              for (t3[r3 = e2 + this.m.t] += this.m.am(0, n2, t3, e2, 0, this.m.t); t3[r3] >= t3.DV; ) t3[r3] -= t3.DV, t3[++r3]++;
            }
            t3.clamp(), t3.drShiftTo(this.m.t, t3), t3.compareTo(this.m) >= 0 && t3.subTo(this.m, t3);
          }, N.prototype.mulTo = function Z(t3, e2, r3) {
            t3.multiplyTo(e2, r3), this.reduce(r3);
          }, N.prototype.sqrTo = function tt(t3, e2) {
            t3.squareTo(e2), this.reduce(e2);
          }, w.prototype.copyTo = function et(t3) {
            for (var e2 = this.t - 1; e2 >= 0; --e2) t3[e2] = this[e2];
            t3.t = this.t, t3.s = this.s;
          }, w.prototype.fromInt = function rt(t3) {
            this.t = 1, this.s = t3 < 0 ? -1 : 0, t3 > 0 ? this[0] = t3 : t3 < -1 ? this[0] = t3 + this.DV : this.t = 0;
          }, w.prototype.fromString = function nt(t3, e2) {
            var r3;
            if (16 == e2) r3 = 4;
            else if (8 == e2) r3 = 3;
            else if (256 == e2) r3 = 8;
            else if (2 == e2) r3 = 1;
            else if (32 == e2) r3 = 5;
            else {
              if (4 != e2) return void this.fromRadix(t3, e2);
              r3 = 2;
            }
            this.t = 0, this.s = 0;
            for (var n2 = t3.length, i2 = false, o2 = 0; --n2 >= 0; ) {
              var s2 = 8 == r3 ? 255 & t3[n2] : R(t3, n2);
              s2 < 0 ? "-" == t3.charAt(n2) && (i2 = true) : (i2 = false, 0 == o2 ? this[this.t++] = s2 : o2 + r3 > this.DB ? (this[this.t - 1] |= (s2 & (1 << this.DB - o2) - 1) << o2, this[this.t++] = s2 >> this.DB - o2) : this[this.t - 1] |= s2 << o2, (o2 += r3) >= this.DB && (o2 -= this.DB));
            }
            8 == r3 && 0 != (128 & t3[0]) && (this.s = -1, o2 > 0 && (this[this.t - 1] |= (1 << this.DB - o2) - 1 << o2)), this.clamp(), i2 && w.ZERO.subTo(this, this);
          }, w.prototype.clamp = function it() {
            for (var t3 = this.s & this.DM; this.t > 0 && this[this.t - 1] == t3; ) --this.t;
          }, w.prototype.dlShiftTo = function ot(t3, e2) {
            var r3;
            for (r3 = this.t - 1; r3 >= 0; --r3) e2[r3 + t3] = this[r3];
            for (r3 = t3 - 1; r3 >= 0; --r3) e2[r3] = 0;
            e2.t = this.t + t3, e2.s = this.s;
          }, w.prototype.drShiftTo = function st(t3, e2) {
            for (var r3 = t3; r3 < this.t; ++r3) e2[r3 - t3] = this[r3];
            e2.t = Math.max(this.t - t3, 0), e2.s = this.s;
          }, w.prototype.lShiftTo = function at(t3, e2) {
            var r3, n2 = t3 % this.DB, i2 = this.DB - n2, o2 = (1 << i2) - 1, s2 = Math.floor(t3 / this.DB), a2 = this.s << n2 & this.DM;
            for (r3 = this.t - 1; r3 >= 0; --r3) e2[r3 + s2 + 1] = this[r3] >> i2 | a2, a2 = (this[r3] & o2) << n2;
            for (r3 = s2 - 1; r3 >= 0; --r3) e2[r3] = 0;
            e2[s2] = a2, e2.t = this.t + s2 + 1, e2.s = this.s, e2.clamp();
          }, w.prototype.rShiftTo = function ut(t3, e2) {
            e2.s = this.s;
            var r3 = Math.floor(t3 / this.DB);
            if (r3 >= this.t) e2.t = 0;
            else {
              var n2 = t3 % this.DB, i2 = this.DB - n2, o2 = (1 << n2) - 1;
              e2[0] = this[r3] >> n2;
              for (var s2 = r3 + 1; s2 < this.t; ++s2) e2[s2 - r3 - 1] |= (this[s2] & o2) << i2, e2[s2 - r3] = this[s2] >> n2;
              n2 > 0 && (e2[this.t - r3 - 1] |= (this.s & o2) << i2), e2.t = this.t - r3, e2.clamp();
            }
          }, w.prototype.subTo = function ct(t3, e2) {
            for (var r3 = 0, n2 = 0, i2 = Math.min(t3.t, this.t); r3 < i2; ) n2 += this[r3] - t3[r3], e2[r3++] = n2 & this.DM, n2 >>= this.DB;
            if (t3.t < this.t) {
              for (n2 -= t3.s; r3 < this.t; ) n2 += this[r3], e2[r3++] = n2 & this.DM, n2 >>= this.DB;
              n2 += this.s;
            } else {
              for (n2 += this.s; r3 < t3.t; ) n2 -= t3[r3], e2[r3++] = n2 & this.DM, n2 >>= this.DB;
              n2 -= t3.s;
            }
            e2.s = n2 < 0 ? -1 : 0, n2 < -1 ? e2[r3++] = this.DV + n2 : n2 > 0 && (e2[r3++] = n2), e2.t = r3, e2.clamp();
          }, w.prototype.multiplyTo = function ht(t3, e2) {
            var r3 = this.abs(), n2 = t3.abs(), i2 = r3.t;
            for (e2.t = i2 + n2.t; --i2 >= 0; ) e2[i2] = 0;
            for (i2 = 0; i2 < n2.t; ++i2) e2[i2 + r3.t] = r3.am(0, n2[i2], e2, i2, 0, r3.t);
            e2.s = 0, e2.clamp(), this.s != t3.s && w.ZERO.subTo(e2, e2);
          }, w.prototype.squareTo = function lt(t3) {
            for (var e2 = this.abs(), r3 = t3.t = 2 * e2.t; --r3 >= 0; ) t3[r3] = 0;
            for (r3 = 0; r3 < e2.t - 1; ++r3) {
              var n2 = e2.am(r3, e2[r3], t3, 2 * r3, 0, 1);
              (t3[r3 + e2.t] += e2.am(r3 + 1, 2 * e2[r3], t3, 2 * r3 + 1, n2, e2.t - r3 - 1)) >= e2.DV && (t3[r3 + e2.t] -= e2.DV, t3[r3 + e2.t + 1] = 1);
            }
            t3.t > 0 && (t3[t3.t - 1] += e2.am(r3, e2[r3], t3, 2 * r3, 0, 1)), t3.s = 0, t3.clamp();
          }, w.prototype.divRemTo = function ft(t3, e2, r3) {
            var n2 = t3.abs();
            if (!(n2.t <= 0)) {
              var i2 = this.abs();
              if (i2.t < n2.t) return null != e2 && e2.fromInt(0), void (null != r3 && this.copyTo(r3));
              null == r3 && (r3 = F());
              var o2 = F(), s2 = this.s, a2 = t3.s, u2 = this.DB - D(n2[n2.t - 1]);
              u2 > 0 ? (n2.lShiftTo(u2, o2), i2.lShiftTo(u2, r3)) : (n2.copyTo(o2), i2.copyTo(r3));
              var c2 = o2.t, h2 = o2[c2 - 1];
              if (0 != h2) {
                var l2 = h2 * (1 << this.F1) + (c2 > 1 ? o2[c2 - 2] >> this.F2 : 0), f2 = this.FV / l2, g2 = (1 << this.F1) / l2, d2 = 1 << this.F2, p2 = r3.t, v2 = p2 - c2, y2 = null == e2 ? F() : e2;
                for (o2.dlShiftTo(v2, y2), r3.compareTo(y2) >= 0 && (r3[r3.t++] = 1, r3.subTo(y2, r3)), w.ONE.dlShiftTo(c2, y2), y2.subTo(o2, o2); o2.t < c2; ) o2[o2.t++] = 0;
                for (; --v2 >= 0; ) {
                  var m2 = r3[--p2] == h2 ? this.DM : Math.floor(r3[p2] * f2 + (r3[p2 - 1] + d2) * g2);
                  if ((r3[p2] += o2.am(0, m2, r3, v2, 0, c2)) < m2) for (o2.dlShiftTo(v2, y2), r3.subTo(y2, r3); r3[p2] < --m2; ) r3.subTo(y2, r3);
                }
                null != e2 && (r3.drShiftTo(c2, e2), s2 != a2 && w.ZERO.subTo(e2, e2)), r3.t = c2, r3.clamp(), u2 > 0 && r3.rShiftTo(u2, r3), s2 < 0 && w.ZERO.subTo(r3, r3);
              }
            }
          }, w.prototype.invDigit = function gt() {
            if (this.t < 1) return 0;
            var t3 = this[0];
            if (0 == (1 & t3)) return 0;
            var e2 = 3 & t3;
            return (e2 = (e2 = (e2 = (e2 = e2 * (2 - (15 & t3) * e2) & 15) * (2 - (255 & t3) * e2) & 255) * (2 - ((65535 & t3) * e2 & 65535)) & 65535) * (2 - t3 * e2 % this.DV) % this.DV) > 0 ? this.DV - e2 : -e2;
          }, w.prototype.isEven = function dt() {
            return 0 == (this.t > 0 ? 1 & this[0] : this.s);
          }, w.prototype.exp = function pt(t3, e2) {
            if (t3 > 4294967295 || t3 < 1) return w.ONE;
            var r3 = F(), n2 = F(), i2 = e2.convert(this), o2 = D(t3) - 1;
            for (i2.copyTo(r3); --o2 >= 0; ) if (e2.sqrTo(r3, n2), (t3 & 1 << o2) > 0) e2.mulTo(n2, i2, r3);
            else {
              var s2 = r3;
              r3 = n2, n2 = s2;
            }
            return e2.revert(r3);
          }, w.prototype.toString = function vt(t3) {
            if (this.s < 0) return "-" + this.negate().toString(t3);
            var e2;
            if (16 == t3) e2 = 4;
            else if (8 == t3) e2 = 3;
            else if (2 == t3) e2 = 1;
            else if (32 == t3) e2 = 5;
            else {
              if (4 != t3) return this.toRadix(t3);
              e2 = 2;
            }
            var r3, n2 = (1 << e2) - 1, i2 = false, o2 = "", s2 = this.t, a2 = this.DB - s2 * this.DB % e2;
            if (s2-- > 0) for (a2 < this.DB && (r3 = this[s2] >> a2) > 0 && (i2 = true, o2 = T(r3)); s2 >= 0; ) a2 < e2 ? (r3 = (this[s2] & (1 << a2) - 1) << e2 - a2, r3 |= this[--s2] >> (a2 += this.DB - e2)) : (r3 = this[s2] >> (a2 -= e2) & n2, a2 <= 0 && (a2 += this.DB, --s2)), r3 > 0 && (i2 = true), i2 && (o2 += T(r3));
            return i2 ? o2 : "0";
          }, w.prototype.negate = function yt() {
            var t3 = F();
            return w.ZERO.subTo(this, t3), t3;
          }, w.prototype.abs = function mt() {
            return this.s < 0 ? this.negate() : this;
          }, w.prototype.compareTo = function _t(t3) {
            var e2 = this.s - t3.s;
            if (0 != e2) return e2;
            var r3 = this.t;
            if (0 != (e2 = r3 - t3.t)) return this.s < 0 ? -e2 : e2;
            for (; --r3 >= 0; ) if (0 != (e2 = this[r3] - t3[r3])) return e2;
            return 0;
          }, w.prototype.bitLength = function St() {
            return this.t <= 0 ? 0 : this.DB * (this.t - 1) + D(this[this.t - 1] ^ this.s & this.DM);
          }, w.prototype.mod = function bt(t3) {
            var e2 = F();
            return this.abs().divRemTo(t3, null, e2), this.s < 0 && e2.compareTo(w.ZERO) > 0 && t3.subTo(e2, e2), e2;
          }, w.prototype.modPowInt = function wt(t3, e2) {
            var r3;
            return r3 = t3 < 256 || e2.isEven() ? new L(e2) : new N(e2), this.exp(t3, r3);
          }, w.ZERO = I(0), w.ONE = I(1), V.prototype.convert = K, V.prototype.revert = K, V.prototype.mulTo = function Ft(t3, e2, r3) {
            t3.multiplyTo(e2, r3);
          }, V.prototype.sqrTo = function Et(t3, e2) {
            t3.squareTo(e2);
          }, q.prototype.convert = function xt(t3) {
            if (t3.s < 0 || t3.t > 2 * this.m.t) return t3.mod(this.m);
            if (t3.compareTo(this.m) < 0) return t3;
            var e2 = F();
            return t3.copyTo(e2), this.reduce(e2), e2;
          }, q.prototype.revert = function At(t3) {
            return t3;
          }, q.prototype.reduce = function kt(t3) {
            for (t3.drShiftTo(this.m.t - 1, this.r2), t3.t > this.m.t + 1 && (t3.t = this.m.t + 1, t3.clamp()), this.mu.multiplyUpperTo(this.r2, this.m.t + 1, this.q3), this.m.multiplyLowerTo(this.q3, this.m.t + 1, this.r2); t3.compareTo(this.r2) < 0; ) t3.dAddOffset(1, this.m.t + 1);
            for (t3.subTo(this.r2, t3); t3.compareTo(this.m) >= 0; ) t3.subTo(this.m, t3);
          }, q.prototype.mulTo = function Pt(t3, e2, r3) {
            t3.multiplyTo(e2, r3), this.reduce(r3);
          }, q.prototype.sqrTo = function Ct(t3, e2) {
            t3.squareTo(e2), this.reduce(e2);
          };
          var Tt = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997], Rt = (1 << 26) / Tt[Tt.length - 1];
          function It() {
            this.i = 0, this.j = 0, this.S = new Array();
          }
          w.prototype.chunkSize = function Dt(t3) {
            return Math.floor(Math.LN2 * this.DB / Math.log(t3));
          }, w.prototype.toRadix = function Lt(t3) {
            if (null == t3 && (t3 = 10), 0 == this.signum() || t3 < 2 || t3 > 36) return "0";
            var e2 = this.chunkSize(t3), r3 = Math.pow(t3, e2), n2 = I(r3), i2 = F(), o2 = F(), s2 = "";
            for (this.divRemTo(n2, i2, o2); i2.signum() > 0; ) s2 = (r3 + o2.intValue()).toString(t3).substr(1) + s2, i2.divRemTo(n2, i2, o2);
            return o2.intValue().toString(t3) + s2;
          }, w.prototype.fromRadix = function Nt(t3, e2) {
            this.fromInt(0), null == e2 && (e2 = 10);
            for (var r3 = this.chunkSize(e2), n2 = Math.pow(e2, r3), i2 = false, o2 = 0, s2 = 0, a2 = 0; a2 < t3.length; ++a2) {
              var u2 = R(t3, a2);
              u2 < 0 ? "-" == t3.charAt(a2) && 0 == this.signum() && (i2 = true) : (s2 = e2 * s2 + u2, ++o2 >= r3 && (this.dMultiply(n2), this.dAddOffset(s2, 0), o2 = 0, s2 = 0));
            }
            o2 > 0 && (this.dMultiply(Math.pow(e2, o2)), this.dAddOffset(s2, 0)), i2 && w.ZERO.subTo(this, this);
          }, w.prototype.fromNumber = function Ut(t3, e2, r3) {
            if ("number" == typeof e2) if (t3 < 2) this.fromInt(1);
            else for (this.fromNumber(t3, r3), this.testBit(t3 - 1) || this.bitwiseTo(w.ONE.shiftLeft(t3 - 1), B, this), this.isEven() && this.dAddOffset(1, 0); !this.isProbablePrime(e2); ) this.dAddOffset(2, 0), this.bitLength() > t3 && this.subTo(w.ONE.shiftLeft(t3 - 1), this);
            else {
              var n2 = new Array(), i2 = 7 & t3;
              n2.length = 1 + (t3 >> 3), e2.nextBytes(n2), i2 > 0 ? n2[0] &= (1 << i2) - 1 : n2[0] = 0, this.fromString(n2, 256);
            }
          }, w.prototype.bitwiseTo = function Bt(t3, e2, r3) {
            var n2, i2, o2 = Math.min(t3.t, this.t);
            for (n2 = 0; n2 < o2; ++n2) r3[n2] = e2(this[n2], t3[n2]);
            if (t3.t < this.t) {
              for (i2 = t3.s & this.DM, n2 = o2; n2 < this.t; ++n2) r3[n2] = e2(this[n2], i2);
              r3.t = this.t;
            } else {
              for (i2 = this.s & this.DM, n2 = o2; n2 < t3.t; ++n2) r3[n2] = e2(i2, t3[n2]);
              r3.t = t3.t;
            }
            r3.s = e2(this.s, t3.s), r3.clamp();
          }, w.prototype.changeBit = function Ot(t3, e2) {
            var r3 = w.ONE.shiftLeft(t3);
            return this.bitwiseTo(r3, e2, r3), r3;
          }, w.prototype.addTo = function jt(t3, e2) {
            for (var r3 = 0, n2 = 0, i2 = Math.min(t3.t, this.t); r3 < i2; ) n2 += this[r3] + t3[r3], e2[r3++] = n2 & this.DM, n2 >>= this.DB;
            if (t3.t < this.t) {
              for (n2 += t3.s; r3 < this.t; ) n2 += this[r3], e2[r3++] = n2 & this.DM, n2 >>= this.DB;
              n2 += this.s;
            } else {
              for (n2 += this.s; r3 < t3.t; ) n2 += t3[r3], e2[r3++] = n2 & this.DM, n2 >>= this.DB;
              n2 += t3.s;
            }
            e2.s = n2 < 0 ? -1 : 0, n2 > 0 ? e2[r3++] = n2 : n2 < -1 && (e2[r3++] = this.DV + n2), e2.t = r3, e2.clamp();
          }, w.prototype.dMultiply = function Mt(t3) {
            this[this.t] = this.am(0, t3 - 1, this, 0, 0, this.t), ++this.t, this.clamp();
          }, w.prototype.dAddOffset = function Ht(t3, e2) {
            if (0 != t3) {
              for (; this.t <= e2; ) this[this.t++] = 0;
              for (this[e2] += t3; this[e2] >= this.DV; ) this[e2] -= this.DV, ++e2 >= this.t && (this[this.t++] = 0), ++this[e2];
            }
          }, w.prototype.multiplyLowerTo = function Vt(t3, e2, r3) {
            var n2, i2 = Math.min(this.t + t3.t, e2);
            for (r3.s = 0, r3.t = i2; i2 > 0; ) r3[--i2] = 0;
            for (n2 = r3.t - this.t; i2 < n2; ++i2) r3[i2 + this.t] = this.am(0, t3[i2], r3, i2, 0, this.t);
            for (n2 = Math.min(t3.t, e2); i2 < n2; ++i2) this.am(0, t3[i2], r3, i2, 0, e2 - i2);
            r3.clamp();
          }, w.prototype.multiplyUpperTo = function Kt(t3, e2, r3) {
            --e2;
            var n2 = r3.t = this.t + t3.t - e2;
            for (r3.s = 0; --n2 >= 0; ) r3[n2] = 0;
            for (n2 = Math.max(e2 - this.t, 0); n2 < t3.t; ++n2) r3[this.t + n2 - e2] = this.am(e2 - n2, t3[n2], r3, 0, 0, this.t + n2 - e2);
            r3.clamp(), r3.drShiftTo(1, r3);
          }, w.prototype.modInt = function qt(t3) {
            if (t3 <= 0) return 0;
            var e2 = this.DV % t3, r3 = this.s < 0 ? t3 - 1 : 0;
            if (this.t > 0) if (0 == e2) r3 = this[0] % t3;
            else for (var n2 = this.t - 1; n2 >= 0; --n2) r3 = (e2 * r3 + this[n2]) % t3;
            return r3;
          }, w.prototype.millerRabin = function Jt(t3) {
            var e2 = this.subtract(w.ONE), r3 = e2.getLowestSetBit();
            if (r3 <= 0) return false;
            var n2 = e2.shiftRight(r3);
            (t3 = t3 + 1 >> 1) > Tt.length && (t3 = Tt.length);
            for (var i2 = F(), o2 = 0; o2 < t3; ++o2) {
              i2.fromInt(Tt[Math.floor(Math.random() * Tt.length)]);
              var s2 = i2.modPow(n2, this);
              if (0 != s2.compareTo(w.ONE) && 0 != s2.compareTo(e2)) {
                for (var a2 = 1; a2++ < r3 && 0 != s2.compareTo(e2); ) if (0 == (s2 = s2.modPowInt(2, this)).compareTo(w.ONE)) return false;
                if (0 != s2.compareTo(e2)) return false;
              }
            }
            return true;
          }, w.prototype.clone = /*! (c) Tom Wu | http://www-cs-students.stanford.edu/~tjw/jsbn/
           */
          function Wt() {
            var t3 = F();
            return this.copyTo(t3), t3;
          }, w.prototype.intValue = function zt() {
            if (this.s < 0) {
              if (1 == this.t) return this[0] - this.DV;
              if (0 == this.t) return -1;
            } else {
              if (1 == this.t) return this[0];
              if (0 == this.t) return 0;
            }
            return (this[1] & (1 << 32 - this.DB) - 1) << this.DB | this[0];
          }, w.prototype.byteValue = function Yt() {
            return 0 == this.t ? this.s : this[0] << 24 >> 24;
          }, w.prototype.shortValue = function Gt() {
            return 0 == this.t ? this.s : this[0] << 16 >> 16;
          }, w.prototype.signum = function Xt() {
            return this.s < 0 ? -1 : this.t <= 0 || 1 == this.t && this[0] <= 0 ? 0 : 1;
          }, w.prototype.toByteArray = function $t() {
            var t3 = this.t, e2 = new Array();
            e2[0] = this.s;
            var r3, n2 = this.DB - t3 * this.DB % 8, i2 = 0;
            if (t3-- > 0) for (n2 < this.DB && (r3 = this[t3] >> n2) != (this.s & this.DM) >> n2 && (e2[i2++] = r3 | this.s << this.DB - n2); t3 >= 0; ) n2 < 8 ? (r3 = (this[t3] & (1 << n2) - 1) << 8 - n2, r3 |= this[--t3] >> (n2 += this.DB - 8)) : (r3 = this[t3] >> (n2 -= 8) & 255, n2 <= 0 && (n2 += this.DB, --t3)), 0 != (128 & r3) && (r3 |= -256), 0 == i2 && (128 & this.s) != (128 & r3) && ++i2, (i2 > 0 || r3 != this.s) && (e2[i2++] = r3);
            return e2;
          }, w.prototype.equals = function Qt(t3) {
            return 0 == this.compareTo(t3);
          }, w.prototype.min = function Zt(t3) {
            return this.compareTo(t3) < 0 ? this : t3;
          }, w.prototype.max = function te(t3) {
            return this.compareTo(t3) > 0 ? this : t3;
          }, w.prototype.and = function ee(t3) {
            var e2 = F();
            return this.bitwiseTo(t3, U, e2), e2;
          }, w.prototype.or = function re(t3) {
            var e2 = F();
            return this.bitwiseTo(t3, B, e2), e2;
          }, w.prototype.xor = function ne(t3) {
            var e2 = F();
            return this.bitwiseTo(t3, O, e2), e2;
          }, w.prototype.andNot = function ie(t3) {
            var e2 = F();
            return this.bitwiseTo(t3, j, e2), e2;
          }, w.prototype.not = function oe() {
            for (var t3 = F(), e2 = 0; e2 < this.t; ++e2) t3[e2] = this.DM & ~this[e2];
            return t3.t = this.t, t3.s = ~this.s, t3;
          }, w.prototype.shiftLeft = function se(t3) {
            var e2 = F();
            return t3 < 0 ? this.rShiftTo(-t3, e2) : this.lShiftTo(t3, e2), e2;
          }, w.prototype.shiftRight = function ae(t3) {
            var e2 = F();
            return t3 < 0 ? this.lShiftTo(-t3, e2) : this.rShiftTo(t3, e2), e2;
          }, w.prototype.getLowestSetBit = function ue() {
            for (var t3 = 0; t3 < this.t; ++t3) if (0 != this[t3]) return t3 * this.DB + M(this[t3]);
            return this.s < 0 ? this.t * this.DB : -1;
          }, w.prototype.bitCount = function ce() {
            for (var t3 = 0, e2 = this.s & this.DM, r3 = 0; r3 < this.t; ++r3) t3 += H(this[r3] ^ e2);
            return t3;
          }, w.prototype.testBit = function he(t3) {
            var e2 = Math.floor(t3 / this.DB);
            return e2 >= this.t ? 0 != this.s : 0 != (this[e2] & 1 << t3 % this.DB);
          }, w.prototype.setBit = function le(t3) {
            return this.changeBit(t3, B);
          }, w.prototype.clearBit = function fe(t3) {
            return this.changeBit(t3, j);
          }, w.prototype.flipBit = function ge(t3) {
            return this.changeBit(t3, O);
          }, w.prototype.add = function de(t3) {
            var e2 = F();
            return this.addTo(t3, e2), e2;
          }, w.prototype.subtract = function pe(t3) {
            var e2 = F();
            return this.subTo(t3, e2), e2;
          }, w.prototype.multiply = function ve(t3) {
            var e2 = F();
            return this.multiplyTo(t3, e2), e2;
          }, w.prototype.divide = function ye(t3) {
            var e2 = F();
            return this.divRemTo(t3, e2, null), e2;
          }, w.prototype.remainder = function me(t3) {
            var e2 = F();
            return this.divRemTo(t3, null, e2), e2;
          }, w.prototype.divideAndRemainder = function _e(t3) {
            var e2 = F(), r3 = F();
            return this.divRemTo(t3, e2, r3), new Array(e2, r3);
          }, w.prototype.modPow = function Se(t3, e2) {
            var r3, n2, i2 = t3.bitLength(), o2 = I(1);
            if (i2 <= 0) return o2;
            r3 = i2 < 18 ? 1 : i2 < 48 ? 3 : i2 < 144 ? 4 : i2 < 768 ? 5 : 6, n2 = i2 < 8 ? new L(e2) : e2.isEven() ? new q(e2) : new N(e2);
            var s2 = new Array(), a2 = 3, u2 = r3 - 1, c2 = (1 << r3) - 1;
            if (s2[1] = n2.convert(this), r3 > 1) {
              var h2 = F();
              for (n2.sqrTo(s2[1], h2); a2 <= c2; ) s2[a2] = F(), n2.mulTo(h2, s2[a2 - 2], s2[a2]), a2 += 2;
            }
            var l2, f2, g2 = t3.t - 1, d2 = true, p2 = F();
            for (i2 = D(t3[g2]) - 1; g2 >= 0; ) {
              for (i2 >= u2 ? l2 = t3[g2] >> i2 - u2 & c2 : (l2 = (t3[g2] & (1 << i2 + 1) - 1) << u2 - i2, g2 > 0 && (l2 |= t3[g2 - 1] >> this.DB + i2 - u2)), a2 = r3; 0 == (1 & l2); ) l2 >>= 1, --a2;
              if ((i2 -= a2) < 0 && (i2 += this.DB, --g2), d2) s2[l2].copyTo(o2), d2 = false;
              else {
                for (; a2 > 1; ) n2.sqrTo(o2, p2), n2.sqrTo(p2, o2), a2 -= 2;
                a2 > 0 ? n2.sqrTo(o2, p2) : (f2 = o2, o2 = p2, p2 = f2), n2.mulTo(p2, s2[l2], o2);
              }
              for (; g2 >= 0 && 0 == (t3[g2] & 1 << i2); ) n2.sqrTo(o2, p2), f2 = o2, o2 = p2, p2 = f2, --i2 < 0 && (i2 = this.DB - 1, --g2);
            }
            return n2.revert(o2);
          }, w.prototype.modInverse = function be(t3) {
            var e2 = t3.isEven();
            if (this.isEven() && e2 || 0 == t3.signum()) return w.ZERO;
            for (var r3 = t3.clone(), n2 = this.clone(), i2 = I(1), o2 = I(0), s2 = I(0), a2 = I(1); 0 != r3.signum(); ) {
              for (; r3.isEven(); ) r3.rShiftTo(1, r3), e2 ? (i2.isEven() && o2.isEven() || (i2.addTo(this, i2), o2.subTo(t3, o2)), i2.rShiftTo(1, i2)) : o2.isEven() || o2.subTo(t3, o2), o2.rShiftTo(1, o2);
              for (; n2.isEven(); ) n2.rShiftTo(1, n2), e2 ? (s2.isEven() && a2.isEven() || (s2.addTo(this, s2), a2.subTo(t3, a2)), s2.rShiftTo(1, s2)) : a2.isEven() || a2.subTo(t3, a2), a2.rShiftTo(1, a2);
              r3.compareTo(n2) >= 0 ? (r3.subTo(n2, r3), e2 && i2.subTo(s2, i2), o2.subTo(a2, o2)) : (n2.subTo(r3, n2), e2 && s2.subTo(i2, s2), a2.subTo(o2, a2));
            }
            return 0 != n2.compareTo(w.ONE) ? w.ZERO : a2.compareTo(t3) >= 0 ? a2.subtract(t3) : a2.signum() < 0 ? (a2.addTo(t3, a2), a2.signum() < 0 ? a2.add(t3) : a2) : a2;
          }, w.prototype.pow = function we(t3) {
            return this.exp(t3, new V());
          }, w.prototype.gcd = function Fe(t3) {
            var e2 = this.s < 0 ? this.negate() : this.clone(), r3 = t3.s < 0 ? t3.negate() : t3.clone();
            if (e2.compareTo(r3) < 0) {
              var n2 = e2;
              e2 = r3, r3 = n2;
            }
            var i2 = e2.getLowestSetBit(), o2 = r3.getLowestSetBit();
            if (o2 < 0) return e2;
            for (i2 < o2 && (o2 = i2), o2 > 0 && (e2.rShiftTo(o2, e2), r3.rShiftTo(o2, r3)); e2.signum() > 0; ) (i2 = e2.getLowestSetBit()) > 0 && e2.rShiftTo(i2, e2), (i2 = r3.getLowestSetBit()) > 0 && r3.rShiftTo(i2, r3), e2.compareTo(r3) >= 0 ? (e2.subTo(r3, e2), e2.rShiftTo(1, e2)) : (r3.subTo(e2, r3), r3.rShiftTo(1, r3));
            return o2 > 0 && r3.lShiftTo(o2, r3), r3;
          }, w.prototype.isProbablePrime = function Ee(t3) {
            var e2, r3 = this.abs();
            if (1 == r3.t && r3[0] <= Tt[Tt.length - 1]) {
              for (e2 = 0; e2 < Tt.length; ++e2) if (r3[0] == Tt[e2]) return true;
              return false;
            }
            if (r3.isEven()) return false;
            for (e2 = 1; e2 < Tt.length; ) {
              for (var n2 = Tt[e2], i2 = e2 + 1; i2 < Tt.length && n2 < Rt; ) n2 *= Tt[i2++];
              for (n2 = r3.modInt(n2); e2 < i2; ) if (n2 % Tt[e2++] == 0) return false;
            }
            return r3.millerRabin(t3);
          }, w.prototype.square = function xe() {
            var t3 = F();
            return this.squareTo(t3), t3;
          }, It.prototype.init = function Ae(t3) {
            var e2, r3, n2;
            for (e2 = 0; e2 < 256; ++e2) this.S[e2] = e2;
            for (r3 = 0, e2 = 0; e2 < 256; ++e2) r3 = r3 + this.S[e2] + t3[e2 % t3.length] & 255, n2 = this.S[e2], this.S[e2] = this.S[r3], this.S[r3] = n2;
            this.i = 0, this.j = 0;
          }, It.prototype.next = function ke() {
            var t3;
            return this.i = this.i + 1 & 255, this.j = this.j + this.S[this.i] & 255, t3 = this.S[this.i], this.S[this.i] = this.S[this.j], this.S[this.j] = t3, this.S[t3 + this.S[this.i] & 255];
          };
          var Pe, Ce, Te;
          function Re() {
            !(function t3(e2) {
              Ce[Te++] ^= 255 & e2, Ce[Te++] ^= e2 >> 8 & 255, Ce[Te++] ^= e2 >> 16 & 255, Ce[Te++] ^= e2 >> 24 & 255, Te >= 256 && (Te -= 256);
            })((/* @__PURE__ */ new Date()).getTime());
          }
          if (null == Ce) {
            var Ie;
            if (Ce = new Array(), Te = 0, void 0 !== p && (void 0 !== p.crypto || void 0 !== p.msCrypto)) {
              var De = p.crypto || p.msCrypto;
              if (De.getRandomValues) {
                var Le = new Uint8Array(32);
                for (De.getRandomValues(Le), Ie = 0; Ie < 32; ++Ie) Ce[Te++] = Le[Ie];
              } else if ("Netscape" == d.appName && d.appVersion < "5") {
                var Ne = p.crypto.random(32);
                for (Ie = 0; Ie < Ne.length; ++Ie) Ce[Te++] = 255 & Ne.charCodeAt(Ie);
              }
            }
            for (; Te < 256; ) Ie = Math.floor(65536 * Math.random()), Ce[Te++] = Ie >>> 8, Ce[Te++] = 255 & Ie;
            Te = 0, Re();
          }
          function Ue() {
            if (null == Pe) {
              for (Re(), (Pe = (function t3() {
                return new It();
              })()).init(Ce), Te = 0; Te < Ce.length; ++Te) Ce[Te] = 0;
              Te = 0;
            }
            return Pe.next();
          }
          function Be() {
          }
          function Oe(t3, e2) {
            return new w(t3, e2);
          }
          function je(t3, e2, r3) {
            for (var n2 = "", i2 = 0; n2.length < e2; ) n2 += r3(String.fromCharCode.apply(String, t3.concat([(4278190080 & i2) >> 24, (16711680 & i2) >> 16, (65280 & i2) >> 8, 255 & i2]))), i2 += 1;
            return n2;
          }
          function Me() {
            this.n = null, this.e = 0, this.d = null, this.p = null, this.q = null, this.dmp1 = null, this.dmq1 = null, this.coeff = null;
          }
          function He(t3, e2) {
            this.x = e2, this.q = t3;
          }
          function Ve(t3, e2, r3, n2) {
            this.curve = t3, this.x = e2, this.y = r3, this.z = null == n2 ? w.ONE : n2, this.zinv = null;
          }
          function Ke(t3, e2, r3) {
            this.q = t3, this.a = this.fromBigInteger(e2), this.b = this.fromBigInteger(r3), this.infinity = new Ve(this, null, null);
          }
          Be.prototype.nextBytes = function qe(t3) {
            var e2;
            for (e2 = 0; e2 < t3.length; ++e2) t3[e2] = Ue();
          }, Me.prototype.doPublic = function Je(t3) {
            return t3.modPowInt(this.e, this.n);
          }, Me.prototype.setPublic = function We(t3, e2) {
            if (this.isPublic = true, this.isPrivate = false, "string" != typeof t3) this.n = t3, this.e = e2;
            else {
              if (!(null != t3 && null != e2 && t3.length > 0 && e2.length > 0)) throw "Invalid RSA public key";
              this.n = Oe(t3, 16), this.e = parseInt(e2, 16);
            }
          }, Me.prototype.encrypt = function ze(t3) {
            var e2 = (function r3(t4, e3) {
              if (e3 < t4.length + 11) throw "Message too long for RSA";
              for (var r4 = new Array(), n3 = t4.length - 1; n3 >= 0 && e3 > 0; ) {
                var i3 = t4.charCodeAt(n3--);
                i3 < 128 ? r4[--e3] = i3 : i3 > 127 && i3 < 2048 ? (r4[--e3] = 63 & i3 | 128, r4[--e3] = i3 >> 6 | 192) : (r4[--e3] = 63 & i3 | 128, r4[--e3] = i3 >> 6 & 63 | 128, r4[--e3] = i3 >> 12 | 224);
              }
              r4[--e3] = 0;
              for (var o2 = new Be(), s2 = new Array(); e3 > 2; ) {
                for (s2[0] = 0; 0 == s2[0]; ) o2.nextBytes(s2);
                r4[--e3] = s2[0];
              }
              return r4[--e3] = 2, r4[--e3] = 0, new w(r4);
            })(t3, this.n.bitLength() + 7 >> 3);
            if (null == e2) return null;
            var n2 = this.doPublic(e2);
            if (null == n2) return null;
            var i2 = n2.toString(16);
            return 0 == (1 & i2.length) ? i2 : "0" + i2;
          }, Me.prototype.encryptOAEP = function Ye(t3, e2, r3) {
            var n2 = (function i2(t4, e3, r4, n3) {
              var i3 = Sr.crypto.MessageDigest, o3 = Sr.crypto.Util, s3 = null;
              if (r4 || (r4 = "sha1"), "string" == typeof r4 && (s3 = i3.getCanonicalAlgName(r4), n3 = i3.getHashLength(s3), r4 = function t5(e4) {
                return Lr(o3.hashHex(Nr(e4), s3));
              }), t4.length + 2 * n3 + 2 > e3) throw "Message too long for RSA";
              var a2, u2 = "";
              for (a2 = 0; a2 < e3 - t4.length - 2 * n3 - 2; a2 += 1) u2 += "\0";
              var c2 = r4("") + u2 + "" + t4, h2 = new Array(n3);
              new Be().nextBytes(h2);
              var l2 = je(h2, c2.length, r4), f2 = [];
              for (a2 = 0; a2 < c2.length; a2 += 1) f2[a2] = c2.charCodeAt(a2) ^ l2.charCodeAt(a2);
              var g2 = je(f2, h2.length, r4), d2 = [0];
              for (a2 = 0; a2 < h2.length; a2 += 1) d2[a2 + 1] = h2[a2] ^ g2.charCodeAt(a2);
              return new w(d2.concat(f2));
            })(t3, this.n.bitLength() + 7 >> 3, e2, r3);
            if (null == n2) return null;
            var o2 = this.doPublic(n2);
            if (null == o2) return null;
            var s2 = o2.toString(16);
            return 0 == (1 & s2.length) ? s2 : "0" + s2;
          }, Me.prototype.type = "RSA", He.prototype.equals = function Ge(t3) {
            return t3 == this || this.q.equals(t3.q) && this.x.equals(t3.x);
          }, He.prototype.toBigInteger = function Xe() {
            return this.x;
          }, He.prototype.negate = function $e() {
            return new He(this.q, this.x.negate().mod(this.q));
          }, He.prototype.add = function Qe(t3) {
            return new He(this.q, this.x.add(t3.toBigInteger()).mod(this.q));
          }, He.prototype.subtract = function Ze(t3) {
            return new He(this.q, this.x.subtract(t3.toBigInteger()).mod(this.q));
          }, He.prototype.multiply = function tr(t3) {
            return new He(this.q, this.x.multiply(t3.toBigInteger()).mod(this.q));
          }, He.prototype.square = function er() {
            return new He(this.q, this.x.square().mod(this.q));
          }, He.prototype.divide = function rr(t3) {
            return new He(this.q, this.x.multiply(t3.toBigInteger().modInverse(this.q)).mod(this.q));
          }, Ve.prototype.getX = function nr() {
            return null == this.zinv && (this.zinv = this.z.modInverse(this.curve.q)), this.curve.fromBigInteger(this.x.toBigInteger().multiply(this.zinv).mod(this.curve.q));
          }, Ve.prototype.getY = function ir() {
            return null == this.zinv && (this.zinv = this.z.modInverse(this.curve.q)), this.curve.fromBigInteger(this.y.toBigInteger().multiply(this.zinv).mod(this.curve.q));
          }, Ve.prototype.equals = function or(t3) {
            return t3 == this || (this.isInfinity() ? t3.isInfinity() : t3.isInfinity() ? this.isInfinity() : !!t3.y.toBigInteger().multiply(this.z).subtract(this.y.toBigInteger().multiply(t3.z)).mod(this.curve.q).equals(w.ZERO) && t3.x.toBigInteger().multiply(this.z).subtract(this.x.toBigInteger().multiply(t3.z)).mod(this.curve.q).equals(w.ZERO));
          }, Ve.prototype.isInfinity = function sr() {
            return null == this.x && null == this.y || this.z.equals(w.ZERO) && !this.y.toBigInteger().equals(w.ZERO);
          }, Ve.prototype.negate = function ar() {
            return new Ve(this.curve, this.x, this.y.negate(), this.z);
          }, Ve.prototype.add = function ur(t3) {
            if (this.isInfinity()) return t3;
            if (t3.isInfinity()) return this;
            var e2 = t3.y.toBigInteger().multiply(this.z).subtract(this.y.toBigInteger().multiply(t3.z)).mod(this.curve.q), r3 = t3.x.toBigInteger().multiply(this.z).subtract(this.x.toBigInteger().multiply(t3.z)).mod(this.curve.q);
            if (w.ZERO.equals(r3)) return w.ZERO.equals(e2) ? this.twice() : this.curve.getInfinity();
            var n2 = new w("3"), i2 = this.x.toBigInteger(), o2 = this.y.toBigInteger(), s2 = (t3.x.toBigInteger(), t3.y.toBigInteger(), r3.square()), a2 = s2.multiply(r3), u2 = i2.multiply(s2), c2 = e2.square().multiply(this.z), h2 = c2.subtract(u2.shiftLeft(1)).multiply(t3.z).subtract(a2).multiply(r3).mod(this.curve.q), l2 = u2.multiply(n2).multiply(e2).subtract(o2.multiply(a2)).subtract(c2.multiply(e2)).multiply(t3.z).add(e2.multiply(a2)).mod(this.curve.q), f2 = a2.multiply(this.z).multiply(t3.z).mod(this.curve.q);
            return new Ve(this.curve, this.curve.fromBigInteger(h2), this.curve.fromBigInteger(l2), f2);
          }, Ve.prototype.twice = function cr() {
            if (this.isInfinity()) return this;
            if (0 == this.y.toBigInteger().signum()) return this.curve.getInfinity();
            var t3 = new w("3"), e2 = this.x.toBigInteger(), r3 = this.y.toBigInteger(), n2 = r3.multiply(this.z), i2 = n2.multiply(r3).mod(this.curve.q), o2 = this.curve.a.toBigInteger(), s2 = e2.square().multiply(t3);
            w.ZERO.equals(o2) || (s2 = s2.add(this.z.square().multiply(o2)));
            var a2 = (s2 = s2.mod(this.curve.q)).square().subtract(e2.shiftLeft(3).multiply(i2)).shiftLeft(1).multiply(n2).mod(this.curve.q), u2 = s2.multiply(t3).multiply(e2).subtract(i2.shiftLeft(1)).shiftLeft(2).multiply(i2).subtract(s2.square().multiply(s2)).mod(this.curve.q), c2 = n2.square().multiply(n2).shiftLeft(3).mod(this.curve.q);
            return new Ve(this.curve, this.curve.fromBigInteger(a2), this.curve.fromBigInteger(u2), c2);
          }, Ve.prototype.multiply = function hr(t3) {
            if (this.isInfinity()) return this;
            if (0 == t3.signum()) return this.curve.getInfinity();
            var e2, r3 = t3, n2 = r3.multiply(new w("3")), i2 = this.negate(), o2 = this, s2 = this.curve.q.subtract(t3), a2 = s2.multiply(new w("3")), u2 = new Ve(this.curve, this.x, this.y), c2 = u2.negate();
            for (e2 = n2.bitLength() - 2; e2 > 0; --e2) {
              o2 = o2.twice();
              var h2 = n2.testBit(e2);
              h2 != r3.testBit(e2) && (o2 = o2.add(h2 ? this : i2));
            }
            for (e2 = a2.bitLength() - 2; e2 > 0; --e2) {
              u2 = u2.twice();
              var l2 = a2.testBit(e2);
              l2 != s2.testBit(e2) && (u2 = u2.add(l2 ? u2 : c2));
            }
            return o2;
          }, Ve.prototype.multiplyTwo = function lr(t3, e2, r3) {
            var n2;
            n2 = t3.bitLength() > r3.bitLength() ? t3.bitLength() - 1 : r3.bitLength() - 1;
            for (var i2 = this.curve.getInfinity(), o2 = this.add(e2); n2 >= 0; ) i2 = i2.twice(), t3.testBit(n2) ? i2 = r3.testBit(n2) ? i2.add(o2) : i2.add(this) : r3.testBit(n2) && (i2 = i2.add(e2)), --n2;
            return i2;
          }, Ke.prototype.getQ = function fr() {
            return this.q;
          }, Ke.prototype.getA = function gr() {
            return this.a;
          }, Ke.prototype.getB = function dr() {
            return this.b;
          }, Ke.prototype.equals = function pr(t3) {
            return t3 == this || this.q.equals(t3.q) && this.a.equals(t3.a) && this.b.equals(t3.b);
          }, Ke.prototype.getInfinity = function vr() {
            return this.infinity;
          }, Ke.prototype.fromBigInteger = function yr(t3) {
            return new He(this.q, t3);
          }, Ke.prototype.decodePointHex = function mr(t3) {
            switch (parseInt(t3.substr(0, 2), 16)) {
              case 0:
                return this.infinity;
              case 2:
              case 3:
                return null;
              case 4:
              case 6:
              case 7:
                var e2 = (t3.length - 2) / 2, r3 = t3.substr(2, e2), n2 = t3.substr(e2 + 2, e2);
                return new Ve(this, this.fromBigInteger(new w(r3, 16)), this.fromBigInteger(new w(n2, 16)));
              default:
                return null;
            }
          }, /*! (c) Stefan Thomas | https://github.com/bitcoinjs/bitcoinjs-lib
           */
          He.prototype.getByteLength = function() {
            return Math.floor((this.toBigInteger().bitLength() + 7) / 8);
          }, Ve.prototype.getEncoded = function(t3) {
            var e2 = function t4(e3, r4) {
              var n3 = e3.toByteArrayUnsigned();
              if (r4 < n3.length) n3 = n3.slice(n3.length - r4);
              else for (; r4 > n3.length; ) n3.unshift(0);
              return n3;
            }, r3 = this.getX().toBigInteger(), n2 = this.getY().toBigInteger(), i2 = e2(r3, 32);
            return t3 ? n2.isEven() ? i2.unshift(2) : i2.unshift(3) : (i2.unshift(4), i2 = i2.concat(e2(n2, 32))), i2;
          }, Ve.decodeFrom = function(t3, e2) {
            e2[0];
            var r3 = e2.length - 1, n2 = e2.slice(1, 1 + r3 / 2), i2 = e2.slice(1 + r3 / 2, 1 + r3);
            n2.unshift(0), i2.unshift(0);
            var o2 = new w(n2), s2 = new w(i2);
            return new Ve(t3, t3.fromBigInteger(o2), t3.fromBigInteger(s2));
          }, Ve.decodeFromHex = function(t3, e2) {
            e2.substr(0, 2);
            var r3 = e2.length - 2, n2 = e2.substr(2, r3 / 2), i2 = e2.substr(2 + r3 / 2, r3 / 2), o2 = new w(n2, 16), s2 = new w(i2, 16);
            return new Ve(t3, t3.fromBigInteger(o2), t3.fromBigInteger(s2));
          }, Ve.prototype.add2D = function(t3) {
            if (this.isInfinity()) return t3;
            if (t3.isInfinity()) return this;
            if (this.x.equals(t3.x)) return this.y.equals(t3.y) ? this.twice() : this.curve.getInfinity();
            var e2 = t3.x.subtract(this.x), r3 = t3.y.subtract(this.y).divide(e2), n2 = r3.square().subtract(this.x).subtract(t3.x), i2 = r3.multiply(this.x.subtract(n2)).subtract(this.y);
            return new Ve(this.curve, n2, i2);
          }, Ve.prototype.twice2D = function() {
            if (this.isInfinity()) return this;
            if (0 == this.y.toBigInteger().signum()) return this.curve.getInfinity();
            var t3 = this.curve.fromBigInteger(w.valueOf(2)), e2 = this.curve.fromBigInteger(w.valueOf(3)), r3 = this.x.square().multiply(e2).add(this.curve.a).divide(this.y.multiply(t3)), n2 = r3.square().subtract(this.x.multiply(t3)), i2 = r3.multiply(this.x.subtract(n2)).subtract(this.y);
            return new Ve(this.curve, n2, i2);
          }, Ve.prototype.multiply2D = function(t3) {
            if (this.isInfinity()) return this;
            if (0 == t3.signum()) return this.curve.getInfinity();
            var e2, r3 = t3, n2 = r3.multiply(new w("3")), i2 = this.negate(), o2 = this;
            for (e2 = n2.bitLength() - 2; e2 > 0; --e2) {
              o2 = o2.twice();
              var s2 = n2.testBit(e2);
              s2 != r3.testBit(e2) && (o2 = o2.add2D(s2 ? this : i2));
            }
            return o2;
          }, Ve.prototype.isOnCurve = function() {
            var t3 = this.getX().toBigInteger(), e2 = this.getY().toBigInteger(), r3 = this.curve.getA().toBigInteger(), n2 = this.curve.getB().toBigInteger(), i2 = this.curve.getQ(), o2 = e2.multiply(e2).mod(i2), s2 = t3.multiply(t3).multiply(t3).add(r3.multiply(t3)).add(n2).mod(i2);
            return o2.equals(s2);
          }, Ve.prototype.toString = function() {
            return "(" + this.getX().toBigInteger().toString() + "," + this.getY().toBigInteger().toString() + ")";
          }, Ve.prototype.validate = function() {
            var t3 = this.curve.getQ();
            if (this.isInfinity()) throw new Error("Point is at infinity.");
            var e2 = this.getX().toBigInteger(), r3 = this.getY().toBigInteger();
            if (e2.compareTo(w.ONE) < 0 || e2.compareTo(t3.subtract(w.ONE)) > 0) throw new Error("x coordinate out of bounds");
            if (r3.compareTo(w.ONE) < 0 || r3.compareTo(t3.subtract(w.ONE)) > 0) throw new Error("y coordinate out of bounds");
            if (!this.isOnCurve()) throw new Error("Point is not on the curve.");
            if (this.multiply(t3).isInfinity()) throw new Error("Point is not a scalar multiple of G.");
            return true;
          };
          var _r = (function() {
            var t3 = new RegExp('(?:false|true|null|[\\{\\}\\[\\]]|(?:-?\\b(?:0|[1-9][0-9]*)(?:\\.[0-9]+)?(?:[eE][+-]?[0-9]+)?\\b)|(?:"(?:[^\\0-\\x08\\x0a-\\x1f"\\\\]|\\\\(?:["/\\\\bfnrt]|u[0-9A-Fa-f]{4}))*"))', "g"), e2 = new RegExp("\\\\(?:([^u])|u(.{4}))", "g"), r3 = { '"': '"', "/": "/", "\\": "\\", b: "\b", f: "\f", n: "\n", r: "\r", t: "	" };
            function n2(t4, e3, n3) {
              return e3 ? r3[e3] : String.fromCharCode(parseInt(n3, 16));
            }
            var i2 = new String(""), o2 = Object.hasOwnProperty;
            return function(r4, s2) {
              var a2, u2, c2 = r4.match(t3), h2 = c2[0], l2 = false;
              "{" === h2 ? a2 = {} : "[" === h2 ? a2 = [] : (a2 = [], l2 = true);
              for (var f2 = [a2], d2 = 1 - l2, p2 = c2.length; d2 < p2; ++d2) {
                var v2;
                switch ((h2 = c2[d2]).charCodeAt(0)) {
                  default:
                    (v2 = f2[0])[u2 || v2.length] = +h2, u2 = void 0;
                    break;
                  case 34:
                    if (-1 !== (h2 = h2.substring(1, h2.length - 1)).indexOf("\\") && (h2 = h2.replace(e2, n2)), v2 = f2[0], !u2) {
                      if (!(v2 instanceof Array)) {
                        u2 = h2 || i2;
                        break;
                      }
                      u2 = v2.length;
                    }
                    v2[u2] = h2, u2 = void 0;
                    break;
                  case 91:
                    v2 = f2[0], f2.unshift(v2[u2 || v2.length] = []), u2 = void 0;
                    break;
                  case 93:
                    f2.shift();
                    break;
                  case 102:
                    (v2 = f2[0])[u2 || v2.length] = false, u2 = void 0;
                    break;
                  case 110:
                    (v2 = f2[0])[u2 || v2.length] = null, u2 = void 0;
                    break;
                  case 116:
                    (v2 = f2[0])[u2 || v2.length] = true, u2 = void 0;
                    break;
                  case 123:
                    v2 = f2[0], f2.unshift(v2[u2 || v2.length] = {}), u2 = void 0;
                    break;
                  case 125:
                    f2.shift();
                }
              }
              if (l2) {
                if (1 !== f2.length) throw new Error();
                a2 = a2[0];
              } else if (f2.length) throw new Error();
              if (s2) {
                a2 = (function t4(e3, r5) {
                  var n3 = e3[r5];
                  if (n3 && "object" === (void 0 === n3 ? "undefined" : g(n3))) {
                    var i3 = null;
                    for (var a3 in n3) if (o2.call(n3, a3) && n3 !== e3) {
                      var u3 = t4(n3, a3);
                      void 0 !== u3 ? n3[a3] = u3 : (i3 || (i3 = []), i3.push(a3));
                    }
                    if (i3) for (var c3 = i3.length; --c3 >= 0; ) delete n3[i3[c3]];
                  }
                  return s2.call(e3, r5, n3);
                })({ "": a2 }, "");
              }
              return a2;
            };
          })();
          void 0 !== Sr && Sr || (e.KJUR = Sr = {}), void 0 !== Sr.asn1 && Sr.asn1 || (Sr.asn1 = {}), Sr.asn1.ASN1Util = new function() {
            this.integerToByteHex = function(t3) {
              var e2 = t3.toString(16);
              return e2.length % 2 == 1 && (e2 = "0" + e2), e2;
            }, this.bigIntToMinTwosComplementsHex = function(t3) {
              var e2 = t3.toString(16);
              if ("-" != e2.substr(0, 1)) e2.length % 2 == 1 ? e2 = "0" + e2 : e2.match(/^[0-7]/) || (e2 = "00" + e2);
              else {
                var r3 = e2.substr(1).length;
                r3 % 2 == 1 ? r3 += 1 : e2.match(/^[0-7]/) || (r3 += 2);
                for (var n2 = "", i2 = 0; i2 < r3; i2++) n2 += "f";
                e2 = new w(n2, 16).xor(t3).add(w.ONE).toString(16).replace(/^-/, "");
              }
              return e2;
            }, this.getPEMStringFromHex = function(t3, e2) {
              return jr(t3, e2);
            }, this.newObject = function(t3) {
              var e2 = Sr.asn1, r3 = e2.ASN1Object, n2 = e2.DERBoolean, i2 = e2.DERInteger, o2 = e2.DERBitString, s2 = e2.DEROctetString, a2 = e2.DERNull, u2 = e2.DERObjectIdentifier, c2 = e2.DEREnumerated, h2 = e2.DERUTF8String, l2 = e2.DERNumericString, f2 = e2.DERPrintableString, g2 = e2.DERTeletexString, d2 = e2.DERIA5String, p2 = e2.DERUTCTime, v2 = e2.DERGeneralizedTime, y2 = e2.DERVisibleString, m2 = e2.DERBMPString, _2 = e2.DERSequence, S2 = e2.DERSet, b2 = e2.DERTaggedObject, w2 = e2.ASN1Util.newObject;
              if (t3 instanceof e2.ASN1Object) return t3;
              var F2 = Object.keys(t3);
              if (1 != F2.length) throw new Error("key of param shall be only one.");
              var E = F2[0];
              if (-1 == ":asn1:bool:int:bitstr:octstr:null:oid:enum:utf8str:numstr:prnstr:telstr:ia5str:utctime:gentime:visstr:bmpstr:seq:set:tag:".indexOf(":" + E + ":")) throw new Error("undefined key: " + E);
              if ("bool" == E) return new n2(t3[E]);
              if ("int" == E) return new i2(t3[E]);
              if ("bitstr" == E) return new o2(t3[E]);
              if ("octstr" == E) return new s2(t3[E]);
              if ("null" == E) return new a2(t3[E]);
              if ("oid" == E) return new u2(t3[E]);
              if ("enum" == E) return new c2(t3[E]);
              if ("utf8str" == E) return new h2(t3[E]);
              if ("numstr" == E) return new l2(t3[E]);
              if ("prnstr" == E) return new f2(t3[E]);
              if ("telstr" == E) return new g2(t3[E]);
              if ("ia5str" == E) return new d2(t3[E]);
              if ("utctime" == E) return new p2(t3[E]);
              if ("gentime" == E) return new v2(t3[E]);
              if ("visstr" == E) return new y2(t3[E]);
              if ("bmpstr" == E) return new m2(t3[E]);
              if ("asn1" == E) return new r3(t3[E]);
              if ("seq" == E) {
                for (var x = t3[E], A = [], k2 = 0; k2 < x.length; k2++) {
                  var P2 = w2(x[k2]);
                  A.push(P2);
                }
                return new _2({ array: A });
              }
              if ("set" == E) {
                for (x = t3[E], A = [], k2 = 0; k2 < x.length; k2++) {
                  P2 = w2(x[k2]);
                  A.push(P2);
                }
                return new S2({ array: A });
              }
              if ("tag" == E) {
                var C2 = t3[E];
                if ("[object Array]" === Object.prototype.toString.call(C2) && 3 == C2.length) {
                  var T2 = w2(C2[2]);
                  return new b2({ tag: C2[0], explicit: C2[1], obj: T2 });
                }
                return new b2(C2);
              }
            }, this.jsonToASN1HEX = function(t3) {
              return this.newObject(t3).getEncodedHex();
            };
          }(), Sr.asn1.ASN1Util.oidHexToInt = function(t3) {
            for (var e2 = "", r3 = parseInt(t3.substr(0, 2), 16), n2 = (e2 = Math.floor(r3 / 40) + "." + r3 % 40, ""), i2 = 2; i2 < t3.length; i2 += 2) {
              var o2 = ("00000000" + parseInt(t3.substr(i2, 2), 16).toString(2)).slice(-8);
              if (n2 += o2.substr(1, 7), "0" == o2.substr(0, 1)) e2 = e2 + "." + new w(n2, 2).toString(10), n2 = "";
            }
            return e2;
          }, Sr.asn1.ASN1Util.oidIntToHex = function(t3) {
            var e2 = function t4(e3) {
              var r4 = e3.toString(16);
              return 1 == r4.length && (r4 = "0" + r4), r4;
            }, r3 = function t4(r4) {
              var n3 = "", i3 = new w(r4, 10).toString(2), o3 = 7 - i3.length % 7;
              7 == o3 && (o3 = 0);
              for (var s3 = "", a2 = 0; a2 < o3; a2++) s3 += "0";
              i3 = s3 + i3;
              for (a2 = 0; a2 < i3.length - 1; a2 += 7) {
                var u2 = i3.substr(a2, 7);
                a2 != i3.length - 7 && (u2 = "1" + u2), n3 += e2(parseInt(u2, 2));
              }
              return n3;
            };
            if (!t3.match(/^[0-9.]+$/)) throw "malformed oid string: " + t3;
            var n2 = "", i2 = t3.split("."), o2 = 40 * parseInt(i2[0]) + parseInt(i2[1]);
            n2 += e2(o2), i2.splice(0, 2);
            for (var s2 = 0; s2 < i2.length; s2++) n2 += r3(i2[s2]);
            return n2;
          }, Sr.asn1.ASN1Object = function(t3) {
            this.params = null, this.getLengthHexFromValue = function() {
              if (void 0 === this.hV || null == this.hV) throw new Error("this.hV is null or undefined");
              if (this.hV.length % 2 == 1) throw new Error("value hex must be even length: n=" + "".length + ",v=" + this.hV);
              var t4 = this.hV.length / 2, e2 = t4.toString(16);
              if (e2.length % 2 == 1 && (e2 = "0" + e2), t4 < 128) return e2;
              var r3 = e2.length / 2;
              if (r3 > 15) throw "ASN.1 length too long to represent by 8x: n = " + t4.toString(16);
              return (128 + r3).toString(16) + e2;
            }, this.getEncodedHex = function() {
              return (null == this.hTLV || this.isModified) && (this.hV = this.getFreshValueHex(), this.hL = this.getLengthHexFromValue(), this.hTLV = this.hT + this.hL + this.hV, this.isModified = false), this.hTLV;
            }, this.getValueHex = function() {
              return this.getEncodedHex(), this.hV;
            }, this.getFreshValueHex = function() {
              return "";
            }, this.setByParam = function(t4) {
              this.params = t4;
            }, null != t3 && null != t3.tlv && (this.hTLV = t3.tlv, this.isModified = false);
          }, Sr.asn1.DERAbstractString = function(t3) {
            Sr.asn1.DERAbstractString.superclass.constructor.call(this);
            this.getString = function() {
              return this.s;
            }, this.setString = function(t4) {
              this.hTLV = null, this.isModified = true, this.s = t4, this.hV = Ir(this.s).toLowerCase();
            }, this.setStringHex = function(t4) {
              this.hTLV = null, this.isModified = true, this.s = null, this.hV = t4;
            }, this.getFreshValueHex = function() {
              return this.hV;
            }, void 0 !== t3 && ("string" == typeof t3 ? this.setString(t3) : void 0 !== t3.str ? this.setString(t3.str) : void 0 !== t3.hex && this.setStringHex(t3.hex));
          }, Zr(Sr.asn1.DERAbstractString, Sr.asn1.ASN1Object), Sr.asn1.DERAbstractTime = function(t3) {
            Sr.asn1.DERAbstractTime.superclass.constructor.call(this);
            this.localDateToUTC = function(t4) {
              var e2 = t4.getTime() + 6e4 * t4.getTimezoneOffset();
              return new Date(e2);
            }, this.formatDate = function(t4, e2, r3) {
              var n2 = this.zeroPadding, i2 = this.localDateToUTC(t4), o2 = String(i2.getFullYear());
              "utc" == e2 && (o2 = o2.substr(2, 2));
              var s2 = o2 + n2(String(i2.getMonth() + 1), 2) + n2(String(i2.getDate()), 2) + n2(String(i2.getHours()), 2) + n2(String(i2.getMinutes()), 2) + n2(String(i2.getSeconds()), 2);
              if (true === r3) {
                var a2 = i2.getMilliseconds();
                if (0 != a2) {
                  var u2 = n2(String(a2), 3);
                  s2 = s2 + "." + (u2 = u2.replace(/[0]+$/, ""));
                }
              }
              return s2 + "Z";
            }, this.zeroPadding = function(t4, e2) {
              return t4.length >= e2 ? t4 : new Array(e2 - t4.length + 1).join("0") + t4;
            }, this.getString = function() {
              return this.s;
            }, this.setString = function(t4) {
              this.hTLV = null, this.isModified = true, this.s = t4, this.hV = kr(t4);
            }, this.setByDateValue = function(t4, e2, r3, n2, i2, o2) {
              var s2 = new Date(Date.UTC(t4, e2 - 1, r3, n2, i2, o2, 0));
              this.setByDate(s2);
            }, this.getFreshValueHex = function() {
              return this.hV;
            };
          }, Zr(Sr.asn1.DERAbstractTime, Sr.asn1.ASN1Object), Sr.asn1.DERAbstractStructured = function(t3) {
            Sr.asn1.DERAbstractString.superclass.constructor.call(this);
            this.setByASN1ObjectArray = function(t4) {
              this.hTLV = null, this.isModified = true, this.asn1Array = t4;
            }, this.appendASN1Object = function(t4) {
              this.hTLV = null, this.isModified = true, this.asn1Array.push(t4);
            }, this.asn1Array = new Array(), void 0 !== t3 && void 0 !== t3.array && (this.asn1Array = t3.array);
          }, Zr(Sr.asn1.DERAbstractStructured, Sr.asn1.ASN1Object), Sr.asn1.DERBoolean = function(t3) {
            Sr.asn1.DERBoolean.superclass.constructor.call(this), this.hT = "01", this.hTLV = 0 == t3 ? "010100" : "0101ff";
          }, Zr(Sr.asn1.DERBoolean, Sr.asn1.ASN1Object), Sr.asn1.DERInteger = function(t3) {
            Sr.asn1.DERInteger.superclass.constructor.call(this), this.hT = "02", this.setByBigInteger = function(t4) {
              this.hTLV = null, this.isModified = true, this.hV = Sr.asn1.ASN1Util.bigIntToMinTwosComplementsHex(t4);
            }, this.setByInteger = function(t4) {
              var e2 = new w(String(t4), 10);
              this.setByBigInteger(e2);
            }, this.setValueHex = function(t4) {
              this.hV = t4;
            }, this.getFreshValueHex = function() {
              return this.hV;
            }, void 0 !== t3 && (void 0 !== t3.bigint ? this.setByBigInteger(t3.bigint) : void 0 !== t3.int ? this.setByInteger(t3.int) : "number" == typeof t3 ? this.setByInteger(t3) : void 0 !== t3.hex && this.setValueHex(t3.hex));
          }, Zr(Sr.asn1.DERInteger, Sr.asn1.ASN1Object), Sr.asn1.DERBitString = function(t3) {
            if (void 0 !== t3 && void 0 !== t3.obj) {
              var e2 = Sr.asn1.ASN1Util.newObject(t3.obj);
              t3.hex = "00" + e2.getEncodedHex();
            }
            Sr.asn1.DERBitString.superclass.constructor.call(this), this.hT = "03", this.setHexValueIncludingUnusedBits = function(t4) {
              this.hTLV = null, this.isModified = true, this.hV = t4;
            }, this.setUnusedBitsAndHexValue = function(t4, e3) {
              if (t4 < 0 || 7 < t4) throw "unused bits shall be from 0 to 7: u = " + t4;
              var r3 = "0" + t4;
              this.hTLV = null, this.isModified = true, this.hV = r3 + e3;
            }, this.setByBinaryString = function(t4) {
              var e3 = 8 - (t4 = t4.replace(/0+$/, "")).length % 8;
              8 == e3 && (e3 = 0);
              for (var r3 = 0; r3 <= e3; r3++) t4 += "0";
              var n2 = "";
              for (r3 = 0; r3 < t4.length - 1; r3 += 8) {
                var i2 = t4.substr(r3, 8), o2 = parseInt(i2, 2).toString(16);
                1 == o2.length && (o2 = "0" + o2), n2 += o2;
              }
              this.hTLV = null, this.isModified = true, this.hV = "0" + e3 + n2;
            }, this.setByBooleanArray = function(t4) {
              for (var e3 = "", r3 = 0; r3 < t4.length; r3++) 1 == t4[r3] ? e3 += "1" : e3 += "0";
              this.setByBinaryString(e3);
            }, this.newFalseArray = function(t4) {
              for (var e3 = new Array(t4), r3 = 0; r3 < t4; r3++) e3[r3] = false;
              return e3;
            }, this.getFreshValueHex = function() {
              return this.hV;
            }, void 0 !== t3 && ("string" == typeof t3 && t3.toLowerCase().match(/^[0-9a-f]+$/) ? this.setHexValueIncludingUnusedBits(t3) : void 0 !== t3.hex ? this.setHexValueIncludingUnusedBits(t3.hex) : void 0 !== t3.bin ? this.setByBinaryString(t3.bin) : void 0 !== t3.array && this.setByBooleanArray(t3.array));
          }, Zr(Sr.asn1.DERBitString, Sr.asn1.ASN1Object), Sr.asn1.DEROctetString = function(t3) {
            if (void 0 !== t3 && void 0 !== t3.obj) {
              var e2 = Sr.asn1.ASN1Util.newObject(t3.obj);
              t3.hex = e2.getEncodedHex();
            }
            Sr.asn1.DEROctetString.superclass.constructor.call(this, t3), this.hT = "04";
          }, Zr(Sr.asn1.DEROctetString, Sr.asn1.DERAbstractString), Sr.asn1.DERNull = function() {
            Sr.asn1.DERNull.superclass.constructor.call(this), this.hT = "05", this.hTLV = "0500";
          }, Zr(Sr.asn1.DERNull, Sr.asn1.ASN1Object), Sr.asn1.DERObjectIdentifier = function(t3) {
            Sr.asn1.DERObjectIdentifier.superclass.constructor.call(this), this.hT = "06", this.setValueHex = function(t4) {
              this.hTLV = null, this.isModified = true, this.s = null, this.hV = t4;
            }, this.setValueOidString = function(t4) {
              var e2 = (function r3(t5) {
                var e3 = function t6(e4) {
                  var r5 = e4.toString(16);
                  return 1 == r5.length && (r5 = "0" + r5), r5;
                }, r4 = function t6(r5) {
                  var n3 = "", i3 = parseInt(r5, 10).toString(2), o3 = 7 - i3.length % 7;
                  7 == o3 && (o3 = 0);
                  for (var s3 = "", a2 = 0; a2 < o3; a2++) s3 += "0";
                  i3 = s3 + i3;
                  for (a2 = 0; a2 < i3.length - 1; a2 += 7) {
                    var u2 = i3.substr(a2, 7);
                    a2 != i3.length - 7 && (u2 = "1" + u2), n3 += e3(parseInt(u2, 2));
                  }
                  return n3;
                };
                try {
                  if (!t5.match(/^[0-9.]+$/)) return null;
                  var n2 = "", i2 = t5.split("."), o2 = 40 * parseInt(i2[0], 10) + parseInt(i2[1], 10);
                  n2 += e3(o2), i2.splice(0, 2);
                  for (var s2 = 0; s2 < i2.length; s2++) n2 += r4(i2[s2]);
                  return n2;
                } catch (t6) {
                  return null;
                }
              })(t4);
              if (null == e2) throw new Error("malformed oid string: " + t4);
              this.hTLV = null, this.isModified = true, this.s = null, this.hV = e2;
            }, this.setValueName = function(t4) {
              var e2 = Sr.asn1.x509.OID.name2oid(t4);
              if ("" === e2) throw new Error("DERObjectIdentifier oidName undefined: " + t4);
              this.setValueOidString(e2);
            }, this.setValueNameOrOid = function(t4) {
              t4.match(/^[0-2].[0-9.]+$/) ? this.setValueOidString(t4) : this.setValueName(t4);
            }, this.getFreshValueHex = function() {
              return this.hV;
            }, this.setByParam = function(t4) {
              "string" == typeof t4 ? this.setValueNameOrOid(t4) : void 0 !== t4.oid ? this.setValueNameOrOid(t4.oid) : void 0 !== t4.name ? this.setValueNameOrOid(t4.name) : void 0 !== t4.hex && this.setValueHex(t4.hex);
            }, void 0 !== t3 && this.setByParam(t3);
          }, Zr(Sr.asn1.DERObjectIdentifier, Sr.asn1.ASN1Object), Sr.asn1.DEREnumerated = function(t3) {
            Sr.asn1.DEREnumerated.superclass.constructor.call(this), this.hT = "0a", this.setByBigInteger = function(t4) {
              this.hTLV = null, this.isModified = true, this.hV = Sr.asn1.ASN1Util.bigIntToMinTwosComplementsHex(t4);
            }, this.setByInteger = function(t4) {
              var e2 = new w(String(t4), 10);
              this.setByBigInteger(e2);
            }, this.setValueHex = function(t4) {
              this.hV = t4;
            }, this.getFreshValueHex = function() {
              return this.hV;
            }, void 0 !== t3 && (void 0 !== t3.int ? this.setByInteger(t3.int) : "number" == typeof t3 ? this.setByInteger(t3) : void 0 !== t3.hex && this.setValueHex(t3.hex));
          }, Zr(Sr.asn1.DEREnumerated, Sr.asn1.ASN1Object), Sr.asn1.DERUTF8String = function(t3) {
            Sr.asn1.DERUTF8String.superclass.constructor.call(this, t3), this.hT = "0c";
          }, Zr(Sr.asn1.DERUTF8String, Sr.asn1.DERAbstractString), Sr.asn1.DERNumericString = function(t3) {
            Sr.asn1.DERNumericString.superclass.constructor.call(this, t3), this.hT = "12";
          }, Zr(Sr.asn1.DERNumericString, Sr.asn1.DERAbstractString), Sr.asn1.DERPrintableString = function(t3) {
            Sr.asn1.DERPrintableString.superclass.constructor.call(this, t3), this.hT = "13";
          }, Zr(Sr.asn1.DERPrintableString, Sr.asn1.DERAbstractString), Sr.asn1.DERTeletexString = function(t3) {
            Sr.asn1.DERTeletexString.superclass.constructor.call(this, t3), this.hT = "14";
          }, Zr(Sr.asn1.DERTeletexString, Sr.asn1.DERAbstractString), Sr.asn1.DERIA5String = function(t3) {
            Sr.asn1.DERIA5String.superclass.constructor.call(this, t3), this.hT = "16";
          }, Zr(Sr.asn1.DERIA5String, Sr.asn1.DERAbstractString), Sr.asn1.DERVisibleString = function(t3) {
            Sr.asn1.DERIA5String.superclass.constructor.call(this, t3), this.hT = "1a";
          }, Zr(Sr.asn1.DERVisibleString, Sr.asn1.DERAbstractString), Sr.asn1.DERBMPString = function(t3) {
            Sr.asn1.DERBMPString.superclass.constructor.call(this, t3), this.hT = "1e";
          }, Zr(Sr.asn1.DERBMPString, Sr.asn1.DERAbstractString), Sr.asn1.DERUTCTime = function(t3) {
            Sr.asn1.DERUTCTime.superclass.constructor.call(this, t3), this.hT = "17", this.setByDate = function(t4) {
              this.hTLV = null, this.isModified = true, this.date = t4, this.s = this.formatDate(this.date, "utc"), this.hV = kr(this.s);
            }, this.getFreshValueHex = function() {
              return void 0 === this.date && void 0 === this.s && (this.date = /* @__PURE__ */ new Date(), this.s = this.formatDate(this.date, "utc"), this.hV = kr(this.s)), this.hV;
            }, void 0 !== t3 && (void 0 !== t3.str ? this.setString(t3.str) : "string" == typeof t3 && t3.match(/^[0-9]{12}Z$/) ? this.setString(t3) : void 0 !== t3.hex ? this.setStringHex(t3.hex) : void 0 !== t3.date && this.setByDate(t3.date));
          }, Zr(Sr.asn1.DERUTCTime, Sr.asn1.DERAbstractTime), Sr.asn1.DERGeneralizedTime = function(t3) {
            Sr.asn1.DERGeneralizedTime.superclass.constructor.call(this, t3), this.hT = "18", this.withMillis = false, this.setByDate = function(t4) {
              this.hTLV = null, this.isModified = true, this.date = t4, this.s = this.formatDate(this.date, "gen", this.withMillis), this.hV = kr(this.s);
            }, this.getFreshValueHex = function() {
              return void 0 === this.date && void 0 === this.s && (this.date = /* @__PURE__ */ new Date(), this.s = this.formatDate(this.date, "gen", this.withMillis), this.hV = kr(this.s)), this.hV;
            }, void 0 !== t3 && (void 0 !== t3.str ? this.setString(t3.str) : "string" == typeof t3 && t3.match(/^[0-9]{14}Z$/) ? this.setString(t3) : void 0 !== t3.hex ? this.setStringHex(t3.hex) : void 0 !== t3.date && this.setByDate(t3.date), true === t3.millis && (this.withMillis = true));
          }, Zr(Sr.asn1.DERGeneralizedTime, Sr.asn1.DERAbstractTime), Sr.asn1.DERSequence = function(t3) {
            Sr.asn1.DERSequence.superclass.constructor.call(this, t3), this.hT = "30", this.getFreshValueHex = function() {
              for (var t4 = "", e2 = 0; e2 < this.asn1Array.length; e2++) {
                t4 += this.asn1Array[e2].getEncodedHex();
              }
              return this.hV = t4, this.hV;
            };
          }, Zr(Sr.asn1.DERSequence, Sr.asn1.DERAbstractStructured), Sr.asn1.DERSet = function(t3) {
            Sr.asn1.DERSet.superclass.constructor.call(this, t3), this.hT = "31", this.sortFlag = true, this.getFreshValueHex = function() {
              for (var t4 = new Array(), e2 = 0; e2 < this.asn1Array.length; e2++) {
                var r3 = this.asn1Array[e2];
                t4.push(r3.getEncodedHex());
              }
              return 1 == this.sortFlag && t4.sort(), this.hV = t4.join(""), this.hV;
            }, void 0 !== t3 && void 0 !== t3.sortflag && 0 == t3.sortflag && (this.sortFlag = false);
          }, Zr(Sr.asn1.DERSet, Sr.asn1.DERAbstractStructured), Sr.asn1.DERTaggedObject = function(t3) {
            Sr.asn1.DERTaggedObject.superclass.constructor.call(this);
            var e2 = Sr.asn1;
            this.hT = "a0", this.hV = "", this.isExplicit = true, this.asn1Object = null, this.setASN1Object = function(t4, e3, r3) {
              this.hT = e3, this.isExplicit = t4, this.asn1Object = r3, this.isExplicit ? (this.hV = this.asn1Object.getEncodedHex(), this.hTLV = null, this.isModified = true) : (this.hV = null, this.hTLV = r3.getEncodedHex(), this.hTLV = this.hTLV.replace(/^../, e3), this.isModified = false);
            }, this.getFreshValueHex = function() {
              return this.hV;
            }, this.setByParam = function(t4) {
              null != t4.tag && (this.hT = t4.tag), null != t4.explicit && (this.isExplicit = t4.explicit), null != t4.tage && (this.hT = t4.tage, this.isExplicit = true), null != t4.tagi && (this.hT = t4.tagi, this.isExplicit = false), null != t4.obj && (t4.obj instanceof e2.ASN1Object ? (this.asn1Object = t4.obj, this.setASN1Object(this.isExplicit, this.hT, this.asn1Object)) : "object" == g(t4.obj) && (this.asn1Object = e2.ASN1Util.newObject(t4.obj), this.setASN1Object(this.isExplicit, this.hT, this.asn1Object)));
            }, null != t3 && this.setByParam(t3);
          }, Zr(Sr.asn1.DERTaggedObject, Sr.asn1.ASN1Object);
          var Sr, br, wr, Fr = new function() {
          }();
          function Er(t3) {
            for (var e2 = new Array(), r3 = 0; r3 < t3.length; r3++) e2[r3] = t3.charCodeAt(r3);
            return e2;
          }
          function xr(t3) {
            for (var e2 = "", r3 = 0; r3 < t3.length; r3++) e2 += String.fromCharCode(t3[r3]);
            return e2;
          }
          function Ar(t3) {
            for (var e2 = "", r3 = 0; r3 < t3.length; r3++) {
              var n2 = t3[r3].toString(16);
              1 == n2.length && (n2 = "0" + n2), e2 += n2;
            }
            return e2;
          }
          function kr(t3) {
            return Ar(Er(t3));
          }
          function Pr(t3) {
            return t3 = (t3 = (t3 = t3.replace(/\=/g, "")).replace(/\+/g, "-")).replace(/\//g, "_");
          }
          function Cr(t3) {
            return t3.length % 4 == 2 ? t3 += "==" : t3.length % 4 == 3 && (t3 += "="), t3 = (t3 = t3.replace(/-/g, "+")).replace(/_/g, "/");
          }
          function Tr(t3) {
            return t3.length % 2 == 1 && (t3 = "0" + t3), Pr(_(t3));
          }
          function Rr(t3) {
            return S(Cr(t3));
          }
          function Ir(t3) {
            return Kr(Gr(t3));
          }
          function Dr(t3) {
            return decodeURIComponent(qr(t3));
          }
          function Lr(t3) {
            for (var e2 = "", r3 = 0; r3 < t3.length - 1; r3 += 2) e2 += String.fromCharCode(parseInt(t3.substr(r3, 2), 16));
            return e2;
          }
          function Nr(t3) {
            for (var e2 = "", r3 = 0; r3 < t3.length; r3++) e2 += ("0" + t3.charCodeAt(r3).toString(16)).slice(-2);
            return e2;
          }
          function Ur(t3) {
            return _(t3);
          }
          function Br(t3) {
            var e2 = Ur(t3).replace(/(.{64})/g, "$1\r\n");
            return e2 = e2.replace(/\r\n$/, "");
          }
          function Or(t3) {
            return S(t3.replace(/[^0-9A-Za-z\/+=]*/g, ""));
          }
          function jr(t3, e2) {
            return "-----BEGIN " + e2 + "-----\r\n" + Br(t3) + "\r\n-----END " + e2 + "-----\r\n";
          }
          function Mr(t3, e2) {
            if (-1 == t3.indexOf("-----BEGIN ")) throw "can't find PEM header: " + e2;
            return Or(t3 = void 0 !== e2 ? (t3 = t3.replace(new RegExp("^[^]*-----BEGIN " + e2 + "-----"), "")).replace(new RegExp("-----END " + e2 + "-----[^]*$"), "") : (t3 = t3.replace(/^[^]*-----BEGIN [^-]+-----/, "")).replace(/-----END [^-]+-----[^]*$/, ""));
          }
          function Hr(t3) {
            var e2, r3, n2, i2, o2, s2, a2, u2, c2, h2, l2;
            if (l2 = t3.match(/^(\d{2}|\d{4})(\d\d)(\d\d)(\d\d)(\d\d)(\d\d)(|\.\d+)Z$/)) return u2 = l2[1], e2 = parseInt(u2), 2 === u2.length && (50 <= e2 && e2 < 100 ? e2 = 1900 + e2 : 0 <= e2 && e2 < 50 && (e2 = 2e3 + e2)), r3 = parseInt(l2[2]) - 1, n2 = parseInt(l2[3]), i2 = parseInt(l2[4]), o2 = parseInt(l2[5]), s2 = parseInt(l2[6]), a2 = 0, "" !== (c2 = l2[7]) && (h2 = (c2.substr(1) + "00").substr(0, 3), a2 = parseInt(h2)), Date.UTC(e2, r3, n2, i2, o2, s2, a2);
            throw "unsupported zulu format: " + t3;
          }
          function Vr(t3) {
            return ~~(Hr(t3) / 1e3);
          }
          function Kr(t3) {
            return t3.replace(/%/g, "");
          }
          function qr(t3) {
            return t3.replace(/(..)/g, "%$1");
          }
          function Jr(t3) {
            var e2 = "malformed IPv6 address";
            if (!t3.match(/^[0-9A-Fa-f:]+$/)) throw e2;
            var r3 = (t3 = t3.toLowerCase()).split(":").length - 1;
            if (r3 < 2) throw e2;
            var n2 = ":".repeat(7 - r3 + 2), i2 = (t3 = t3.replace("::", n2)).split(":");
            if (8 != i2.length) throw e2;
            for (var o2 = 0; o2 < 8; o2++) i2[o2] = ("0000" + i2[o2]).slice(-4);
            return i2.join("");
          }
          function Wr(t3) {
            if (!t3.match(/^[0-9A-Fa-f]{32}$/)) throw "malformed IPv6 address octet";
            for (var e2 = (t3 = t3.toLowerCase()).match(/.{1,4}/g), r3 = 0; r3 < 8; r3++) e2[r3] = e2[r3].replace(/^0+/, ""), "" == e2[r3] && (e2[r3] = "0");
            var n2 = (t3 = ":" + e2.join(":") + ":").match(/:(0:){2,}/g);
            if (null === n2) return t3.slice(1, -1);
            var i2 = "";
            for (r3 = 0; r3 < n2.length; r3++) n2[r3].length > i2.length && (i2 = n2[r3]);
            return (t3 = t3.replace(i2, "::")).slice(1, -1);
          }
          function zr(t3) {
            var e2 = "malformed hex value";
            if (!t3.match(/^([0-9A-Fa-f][0-9A-Fa-f]){1,}$/)) throw e2;
            if (8 != t3.length) return 32 == t3.length ? Wr(t3) : t3;
            try {
              return parseInt(t3.substr(0, 2), 16) + "." + parseInt(t3.substr(2, 2), 16) + "." + parseInt(t3.substr(4, 2), 16) + "." + parseInt(t3.substr(6, 2), 16);
            } catch (t4) {
              throw e2;
            }
          }
          function Yr(t3) {
            return t3.match(/.{4}/g).map((function e2(t4) {
              var e3 = parseInt(t4.substr(0, 2), 16), r3 = parseInt(t4.substr(2), 16);
              if (0 == e3 & r3 < 128) return String.fromCharCode(r3);
              if (e3 < 8) {
                var n2 = 128 | 63 & r3;
                return Dr((192 | (7 & e3) << 3 | (192 & r3) >> 6).toString(16) + n2.toString(16));
              }
              n2 = 128 | (15 & e3) << 2 | (192 & r3) >> 6;
              var i2 = 128 | 63 & r3;
              return Dr((224 | (240 & e3) >> 4).toString(16) + n2.toString(16) + i2.toString(16));
            })).join("");
          }
          function Gr(t3) {
            for (var e2 = encodeURIComponent(t3), r3 = "", n2 = 0; n2 < e2.length; n2++) "%" == e2[n2] ? (r3 += e2.substr(n2, 3), n2 += 2) : r3 = r3 + "%" + kr(e2[n2]);
            return r3;
          }
          function Xr(t3) {
            return !(t3.length % 2 != 0 || !t3.match(/^[0-9a-f]+$/) && !t3.match(/^[0-9A-F]+$/));
          }
          function $r(t3) {
            return t3.length % 2 == 1 ? "0" + t3 : t3.substr(0, 1) > "7" ? "00" + t3 : t3;
          }
          Fr.getLblen = function(t3, e2) {
            if ("8" != t3.substr(e2 + 2, 1)) return 1;
            var r3 = parseInt(t3.substr(e2 + 3, 1));
            return 0 == r3 ? -1 : 0 < r3 && r3 < 10 ? r3 + 1 : -2;
          }, Fr.getL = function(t3, e2) {
            var r3 = Fr.getLblen(t3, e2);
            return r3 < 1 ? "" : t3.substr(e2 + 2, 2 * r3);
          }, Fr.getVblen = function(t3, e2) {
            var r3;
            return "" == (r3 = Fr.getL(t3, e2)) ? -1 : ("8" === r3.substr(0, 1) ? new w(r3.substr(2), 16) : new w(r3, 16)).intValue();
          }, Fr.getVidx = function(t3, e2) {
            var r3 = Fr.getLblen(t3, e2);
            return r3 < 0 ? r3 : e2 + 2 * (r3 + 1);
          }, Fr.getV = function(t3, e2) {
            var r3 = Fr.getVidx(t3, e2), n2 = Fr.getVblen(t3, e2);
            return t3.substr(r3, 2 * n2);
          }, Fr.getTLV = function(t3, e2) {
            return t3.substr(e2, 2) + Fr.getL(t3, e2) + Fr.getV(t3, e2);
          }, Fr.getTLVblen = function(t3, e2) {
            return 2 + 2 * Fr.getLblen(t3, e2) + 2 * Fr.getVblen(t3, e2);
          }, Fr.getNextSiblingIdx = function(t3, e2) {
            return Fr.getVidx(t3, e2) + 2 * Fr.getVblen(t3, e2);
          }, Fr.getChildIdx = function(t3, e2) {
            var r3, n2, i2, o2 = Fr, s2 = [];
            r3 = o2.getVidx(t3, e2), n2 = 2 * o2.getVblen(t3, e2), "03" == t3.substr(e2, 2) && (r3 += 2, n2 -= 2), i2 = 0;
            for (var a2 = r3; i2 <= n2; ) {
              var u2 = o2.getTLVblen(t3, a2);
              if ((i2 += u2) <= n2 && s2.push(a2), a2 += u2, i2 >= n2) break;
            }
            return s2;
          }, Fr.getNthChildIdx = function(t3, e2, r3) {
            return Fr.getChildIdx(t3, e2)[r3];
          }, Fr.getIdxbyList = function(t3, e2, r3, n2) {
            var i2, o2, s2 = Fr;
            return 0 == r3.length ? void 0 !== n2 && t3.substr(e2, 2) !== n2 ? -1 : e2 : (i2 = r3.shift()) >= (o2 = s2.getChildIdx(t3, e2)).length ? -1 : s2.getIdxbyList(t3, o2[i2], r3, n2);
          }, Fr.getIdxbyListEx = function(t3, e2, r3, n2) {
            var i2, o2, s2 = Fr;
            if (0 == r3.length) return void 0 !== n2 && t3.substr(e2, 2) !== n2 ? -1 : e2;
            i2 = r3.shift(), o2 = s2.getChildIdx(t3, e2);
            for (var a2 = 0, u2 = 0; u2 < o2.length; u2++) {
              var c2 = t3.substr(o2[u2], 2);
              if ("number" == typeof i2 && !s2.isContextTag(c2) && a2 == i2 || "string" == typeof i2 && s2.isContextTag(c2, i2)) return s2.getIdxbyListEx(t3, o2[u2], r3, n2);
              s2.isContextTag(c2) || a2++;
            }
            return -1;
          }, Fr.getTLVbyList = function(t3, e2, r3, n2) {
            var i2 = Fr, o2 = i2.getIdxbyList(t3, e2, r3, n2);
            return -1 == o2 || o2 >= t3.length ? null : i2.getTLV(t3, o2);
          }, Fr.getTLVbyListEx = function(t3, e2, r3, n2) {
            var i2 = Fr, o2 = i2.getIdxbyListEx(t3, e2, r3, n2);
            return -1 == o2 ? null : i2.getTLV(t3, o2);
          }, Fr.getVbyList = function(t3, e2, r3, n2, i2) {
            var o2, s2, a2 = Fr;
            return -1 == (o2 = a2.getIdxbyList(t3, e2, r3, n2)) || o2 >= t3.length ? null : (s2 = a2.getV(t3, o2), true === i2 && (s2 = s2.substr(2)), s2);
          }, Fr.getVbyListEx = function(t3, e2, r3, n2, i2) {
            var o2, s2, a2 = Fr;
            return -1 == (o2 = a2.getIdxbyListEx(t3, e2, r3, n2)) ? null : (s2 = a2.getV(t3, o2), "03" == t3.substr(o2, 2) && false !== i2 && (s2 = s2.substr(2)), s2);
          }, Fr.getInt = function(t3, e2, r3) {
            null == r3 && (r3 = -1);
            try {
              var n2 = t3.substr(e2, 2);
              if ("02" != n2 && "03" != n2) return r3;
              var i2 = Fr.getV(t3, e2);
              return "02" == n2 ? parseInt(i2, 16) : (function o2(t4) {
                try {
                  var e3 = t4.substr(0, 2);
                  if ("00" == e3) return parseInt(t4.substr(2), 16);
                  var r4 = parseInt(e3, 16), n3 = t4.substr(2), i3 = parseInt(n3, 16).toString(2);
                  return "0" == i3 && (i3 = "00000000"), i3 = i3.slice(0, 0 - r4), parseInt(i3, 2);
                } catch (t5) {
                  return -1;
                }
              })(i2);
            } catch (t4) {
              return r3;
            }
          }, Fr.getOID = function(t3, e2, r3) {
            null == r3 && (r3 = null);
            try {
              return "06" != t3.substr(e2, 2) ? r3 : (function n2(t4) {
                if (!Xr(t4)) return null;
                try {
                  var e3 = [], r4 = t4.substr(0, 2), n3 = parseInt(r4, 16);
                  e3[0] = new String(Math.floor(n3 / 40)), e3[1] = new String(n3 % 40);
                  for (var i2 = t4.substr(2), o2 = [], s2 = 0; s2 < i2.length / 2; s2++) o2.push(parseInt(i2.substr(2 * s2, 2), 16));
                  var a2 = [], u2 = "";
                  for (s2 = 0; s2 < o2.length; s2++) 128 & o2[s2] ? u2 += Qr((127 & o2[s2]).toString(2), 7) : (u2 += Qr((127 & o2[s2]).toString(2), 7), a2.push(new String(parseInt(u2, 2))), u2 = "");
                  var c2 = e3.join(".");
                  return a2.length > 0 && (c2 = c2 + "." + a2.join(".")), c2;
                } catch (t5) {
                  return null;
                }
              })(Fr.getV(t3, e2));
            } catch (t4) {
              return r3;
            }
          }, Fr.getOIDName = function(t3, e2, r3) {
            null == r3 && (r3 = null);
            try {
              var n2 = Fr.getOID(t3, e2, r3);
              if (n2 == r3) return r3;
              var i2 = Sr.asn1.x509.OID.oid2name(n2);
              return "" == i2 ? n2 : i2;
            } catch (t4) {
              return r3;
            }
          }, Fr.getString = function(t3, e2, r3) {
            null == r3 && (r3 = null);
            try {
              return Lr(Fr.getV(t3, e2));
            } catch (t4) {
              return r3;
            }
          }, Fr.hextooidstr = function(t3) {
            var e2 = function t4(e3, r4) {
              return e3.length >= r4 ? e3 : new Array(r4 - e3.length + 1).join("0") + e3;
            }, r3 = [], n2 = t3.substr(0, 2), i2 = parseInt(n2, 16);
            r3[0] = new String(Math.floor(i2 / 40)), r3[1] = new String(i2 % 40);
            for (var o2 = t3.substr(2), s2 = [], a2 = 0; a2 < o2.length / 2; a2++) s2.push(parseInt(o2.substr(2 * a2, 2), 16));
            var u2 = [], c2 = "";
            for (a2 = 0; a2 < s2.length; a2++) 128 & s2[a2] ? c2 += e2((127 & s2[a2]).toString(2), 7) : (c2 += e2((127 & s2[a2]).toString(2), 7), u2.push(new String(parseInt(c2, 2))), c2 = "");
            var h2 = r3.join(".");
            return u2.length > 0 && (h2 = h2 + "." + u2.join(".")), h2;
          }, Fr.dump = function(t3, e2, r3, n2) {
            var i2 = Fr, o2 = i2.getV, s2 = i2.dump, a2 = i2.getChildIdx, u2 = t3;
            t3 instanceof Sr.asn1.ASN1Object && (u2 = t3.getEncodedHex());
            var c2 = function t4(e3, r4) {
              return e3.length <= 2 * r4 ? e3 : e3.substr(0, r4) + "..(total " + e3.length / 2 + "bytes).." + e3.substr(e3.length - r4, r4);
            };
            void 0 === e2 && (e2 = { ommit_long_octet: 32 }), void 0 === r3 && (r3 = 0), void 0 === n2 && (n2 = "");
            var h2, l2 = e2.ommit_long_octet;
            if ("01" == (h2 = u2.substr(r3, 2))) return "00" == (f2 = o2(u2, r3)) ? n2 + "BOOLEAN FALSE\n" : n2 + "BOOLEAN TRUE\n";
            if ("02" == h2) return n2 + "INTEGER " + c2(f2 = o2(u2, r3), l2) + "\n";
            if ("03" == h2) {
              var f2 = o2(u2, r3);
              if (i2.isASN1HEX(f2.substr(2))) {
                var g2 = n2 + "BITSTRING, encapsulates\n";
                return g2 += s2(f2.substr(2), e2, 0, n2 + "  ");
              }
              return n2 + "BITSTRING " + c2(f2, l2) + "\n";
            }
            if ("04" == h2) {
              f2 = o2(u2, r3);
              if (i2.isASN1HEX(f2)) {
                g2 = n2 + "OCTETSTRING, encapsulates\n";
                return g2 += s2(f2, e2, 0, n2 + "  ");
              }
              return n2 + "OCTETSTRING " + c2(f2, l2) + "\n";
            }
            if ("05" == h2) return n2 + "NULL\n";
            if ("06" == h2) {
              var d2 = o2(u2, r3), p2 = Sr.asn1.ASN1Util.oidHexToInt(d2), v2 = Sr.asn1.x509.OID.oid2name(p2), y2 = p2.replace(/\./g, " ");
              return "" != v2 ? n2 + "ObjectIdentifier " + v2 + " (" + y2 + ")\n" : n2 + "ObjectIdentifier (" + y2 + ")\n";
            }
            if ("0a" == h2) return n2 + "ENUMERATED " + parseInt(o2(u2, r3)) + "\n";
            if ("0c" == h2) return n2 + "UTF8String '" + Dr(o2(u2, r3)) + "'\n";
            if ("13" == h2) return n2 + "PrintableString '" + Dr(o2(u2, r3)) + "'\n";
            if ("14" == h2) return n2 + "TeletexString '" + Dr(o2(u2, r3)) + "'\n";
            if ("16" == h2) return n2 + "IA5String '" + Dr(o2(u2, r3)) + "'\n";
            if ("17" == h2) return n2 + "UTCTime " + Dr(o2(u2, r3)) + "\n";
            if ("18" == h2) return n2 + "GeneralizedTime " + Dr(o2(u2, r3)) + "\n";
            if ("1a" == h2) return n2 + "VisualString '" + Dr(o2(u2, r3)) + "'\n";
            if ("1e" == h2) return n2 + "BMPString '" + Yr(o2(u2, r3)) + "'\n";
            if ("30" == h2) {
              if ("3000" == u2.substr(r3, 4)) return n2 + "SEQUENCE {}\n";
              g2 = n2 + "SEQUENCE\n";
              var m2 = e2;
              if ((2 == (b2 = a2(u2, r3)).length || 3 == b2.length) && "06" == u2.substr(b2[0], 2) && "04" == u2.substr(b2[b2.length - 1], 2)) {
                v2 = i2.oidname(o2(u2, b2[0]));
                var _2 = JSON.parse(JSON.stringify(e2));
                _2.x509ExtName = v2, m2 = _2;
              }
              for (var S2 = 0; S2 < b2.length; S2++) g2 += s2(u2, m2, b2[S2], n2 + "  ");
              return g2;
            }
            if ("31" == h2) {
              g2 = n2 + "SET\n";
              var b2 = a2(u2, r3);
              for (S2 = 0; S2 < b2.length; S2++) g2 += s2(u2, e2, b2[S2], n2 + "  ");
              return g2;
            }
            if (0 != (128 & (h2 = parseInt(h2, 16)))) {
              var w2 = 31 & h2;
              if (0 != (32 & h2)) {
                for (g2 = n2 + "[" + w2 + "]\n", b2 = a2(u2, r3), S2 = 0; S2 < b2.length; S2++) g2 += s2(u2, e2, b2[S2], n2 + "  ");
                return g2;
              }
              f2 = o2(u2, r3);
              if (Fr.isASN1HEX(f2)) {
                var g2 = n2 + "[" + w2 + "]\n";
                return g2 += s2(f2, e2, 0, n2 + "  ");
              }
              return ("68747470" == f2.substr(0, 8) || "subjectAltName" === e2.x509ExtName && 2 == w2) && (f2 = Dr(f2)), g2 = n2 + "[" + w2 + "] " + f2 + "\n";
            }
            return n2 + "UNKNOWN(" + h2 + ") " + o2(u2, r3) + "\n";
          }, Fr.isContextTag = function(t3, e2) {
            var r3, n2;
            t3 = t3.toLowerCase();
            try {
              r3 = parseInt(t3, 16);
            } catch (t4) {
              return -1;
            }
            if (void 0 === e2) return 128 == (192 & r3);
            try {
              return null != e2.match(/^\[[0-9]+\]$/) && (!((n2 = parseInt(e2.substr(1, e2.length - 1), 10)) > 31) && (128 == (192 & r3) && (31 & r3) == n2));
            } catch (t4) {
              return false;
            }
          }, Fr.isASN1HEX = function(t3) {
            var e2 = Fr;
            if (t3.length % 2 == 1) return false;
            var r3 = e2.getVblen(t3, 0), n2 = t3.substr(0, 2), i2 = e2.getL(t3, 0);
            return t3.length - n2.length - i2.length == 2 * r3;
          }, Fr.checkStrictDER = function(t3, e2, r3, n2, i2) {
            var o2 = Fr;
            if (void 0 === r3) {
              if ("string" != typeof t3) throw new Error("not hex string");
              if (t3 = t3.toLowerCase(), !Sr.lang.String.isHex(t3)) throw new Error("not hex string");
              r3 = t3.length, i2 = (n2 = t3.length / 2) < 128 ? 1 : Math.ceil(n2.toString(16)) + 1;
            }
            if (o2.getL(t3, e2).length > 2 * i2) throw new Error("L of TLV too long: idx=" + e2);
            var s2 = o2.getVblen(t3, e2);
            if (s2 > n2) throw new Error("value of L too long than hex: idx=" + e2);
            var a2 = o2.getTLV(t3, e2), u2 = a2.length - 2 - o2.getL(t3, e2).length;
            if (u2 !== 2 * s2) throw new Error("V string length and L's value not the same:" + u2 + "/" + 2 * s2);
            if (0 === e2 && t3.length != a2.length) throw new Error("total length and TLV length unmatch:" + t3.length + "!=" + a2.length);
            var c2 = t3.substr(e2, 2);
            if ("02" === c2) {
              var h2 = o2.getVidx(t3, e2);
              if ("00" == t3.substr(h2, 2) && t3.charCodeAt(h2 + 2) < 56) throw new Error("not least zeros for DER INTEGER");
            }
            if (32 & parseInt(c2, 16)) {
              for (var l2 = o2.getVblen(t3, e2), f2 = 0, g2 = o2.getChildIdx(t3, e2), d2 = 0; d2 < g2.length; d2++) {
                f2 += o2.getTLV(t3, g2[d2]).length, o2.checkStrictDER(t3, g2[d2], r3, n2, i2);
              }
              if (2 * l2 != f2) throw new Error("sum of children's TLV length and L unmatch: " + 2 * l2 + "!=" + f2);
            }
          }, Fr.oidname = function(t3) {
            var e2 = Sr.asn1;
            Sr.lang.String.isHex(t3) && (t3 = e2.ASN1Util.oidHexToInt(t3));
            var r3 = e2.x509.OID.oid2name(t3);
            return "" === r3 && (r3 = t3), r3;
          }, void 0 !== Sr && Sr || (e.KJUR = Sr = {}), void 0 !== Sr.lang && Sr.lang || (Sr.lang = {}), Sr.lang.String = function() {
          }, "function" == typeof t2 ? (e.utf8tob64u = br = function e2(r3) {
            return Pr(t2.from(r3, "utf8").toString("base64"));
          }, e.b64utoutf8 = wr = function e2(r3) {
            return t2.from(Cr(r3), "base64").toString("utf8");
          }) : (e.utf8tob64u = br = function t3(e2) {
            return Tr(Kr(Gr(e2)));
          }, e.b64utoutf8 = wr = function t3(e2) {
            return decodeURIComponent(qr(Rr(e2)));
          }), Sr.lang.String.isInteger = function(t3) {
            return !!t3.match(/^[0-9]+$/) || !!t3.match(/^-[0-9]+$/);
          }, Sr.lang.String.isHex = function(t3) {
            return Xr(t3);
          }, Sr.lang.String.isBase64 = function(t3) {
            return !(!(t3 = t3.replace(/\s+/g, "")).match(/^[0-9A-Za-z+\/]+={0,3}$/) || t3.length % 4 != 0);
          }, Sr.lang.String.isBase64URL = function(t3) {
            return !t3.match(/[+/=]/) && (t3 = Cr(t3), Sr.lang.String.isBase64(t3));
          }, Sr.lang.String.isIntegerArray = function(t3) {
            return !!(t3 = t3.replace(/\s+/g, "")).match(/^\[[0-9,]+\]$/);
          }, Sr.lang.String.isPrintable = function(t3) {
            return null !== t3.match(/^[0-9A-Za-z '()+,-./:=?]*$/);
          }, Sr.lang.String.isIA5 = function(t3) {
            return null !== t3.match(/^[\x20-\x21\x23-\x7f]*$/);
          }, Sr.lang.String.isMail = function(t3) {
            return null !== t3.match(/^[A-Za-z0-9]{1}[A-Za-z0-9_.-]*@{1}[A-Za-z0-9_.-]{1,}\.[A-Za-z0-9]{1,}$/);
          };
          var Qr = function t3(e2, r3, n2) {
            return null == n2 && (n2 = "0"), e2.length >= r3 ? e2 : new Array(r3 - e2.length + 1).join(n2) + e2;
          };
          function Zr(t3, e2) {
            var r3 = function t4() {
            };
            r3.prototype = e2.prototype, t3.prototype = new r3(), t3.prototype.constructor = t3, t3.superclass = e2.prototype, e2.prototype.constructor == Object.prototype.constructor && (e2.prototype.constructor = e2);
          }
          void 0 !== Sr && Sr || (e.KJUR = Sr = {}), void 0 !== Sr.crypto && Sr.crypto || (Sr.crypto = {}), Sr.crypto.Util = new function() {
            this.DIGESTINFOHEAD = { sha1: "3021300906052b0e03021a05000414", sha224: "302d300d06096086480165030402040500041c", sha256: "3031300d060960864801650304020105000420", sha384: "3041300d060960864801650304020205000430", sha512: "3051300d060960864801650304020305000440", md2: "3020300c06082a864886f70d020205000410", md5: "3020300c06082a864886f70d020505000410", ripemd160: "3021300906052b2403020105000414" }, this.DEFAULTPROVIDER = { md5: "cryptojs", sha1: "cryptojs", sha224: "cryptojs", sha256: "cryptojs", sha384: "cryptojs", sha512: "cryptojs", ripemd160: "cryptojs", hmacmd5: "cryptojs", hmacsha1: "cryptojs", hmacsha224: "cryptojs", hmacsha256: "cryptojs", hmacsha384: "cryptojs", hmacsha512: "cryptojs", hmacripemd160: "cryptojs", MD5withRSA: "cryptojs/jsrsa", SHA1withRSA: "cryptojs/jsrsa", SHA224withRSA: "cryptojs/jsrsa", SHA256withRSA: "cryptojs/jsrsa", SHA384withRSA: "cryptojs/jsrsa", SHA512withRSA: "cryptojs/jsrsa", RIPEMD160withRSA: "cryptojs/jsrsa", MD5withECDSA: "cryptojs/jsrsa", SHA1withECDSA: "cryptojs/jsrsa", SHA224withECDSA: "cryptojs/jsrsa", SHA256withECDSA: "cryptojs/jsrsa", SHA384withECDSA: "cryptojs/jsrsa", SHA512withECDSA: "cryptojs/jsrsa", RIPEMD160withECDSA: "cryptojs/jsrsa", SHA1withDSA: "cryptojs/jsrsa", SHA224withDSA: "cryptojs/jsrsa", SHA256withDSA: "cryptojs/jsrsa", MD5withRSAandMGF1: "cryptojs/jsrsa", SHAwithRSAandMGF1: "cryptojs/jsrsa", SHA1withRSAandMGF1: "cryptojs/jsrsa", SHA224withRSAandMGF1: "cryptojs/jsrsa", SHA256withRSAandMGF1: "cryptojs/jsrsa", SHA384withRSAandMGF1: "cryptojs/jsrsa", SHA512withRSAandMGF1: "cryptojs/jsrsa", RIPEMD160withRSAandMGF1: "cryptojs/jsrsa" }, this.CRYPTOJSMESSAGEDIGESTNAME = { md5: v.algo.MD5, sha1: v.algo.SHA1, sha224: v.algo.SHA224, sha256: v.algo.SHA256, sha384: v.algo.SHA384, sha512: v.algo.SHA512, ripemd160: v.algo.RIPEMD160 }, this.getDigestInfoHex = function(t3, e2) {
              if (void 0 === this.DIGESTINFOHEAD[e2]) throw "alg not supported in Util.DIGESTINFOHEAD: " + e2;
              return this.DIGESTINFOHEAD[e2] + t3;
            }, this.getPaddedDigestInfoHex = function(t3, e2, r3) {
              var n2 = this.getDigestInfoHex(t3, e2), i2 = r3 / 4;
              if (n2.length + 22 > i2) throw "key is too short for SigAlg: keylen=" + r3 + "," + e2;
              for (var o2 = "0001", s2 = "00" + n2, a2 = "", u2 = i2 - o2.length - s2.length, c2 = 0; c2 < u2; c2 += 2) a2 += "ff";
              return o2 + a2 + s2;
            }, this.hashString = function(t3, e2) {
              return new Sr.crypto.MessageDigest({ alg: e2 }).digestString(t3);
            }, this.hashHex = function(t3, e2) {
              return new Sr.crypto.MessageDigest({ alg: e2 }).digestHex(t3);
            }, this.sha1 = function(t3) {
              return this.hashString(t3, "sha1");
            }, this.sha256 = function(t3) {
              return this.hashString(t3, "sha256");
            }, this.sha256Hex = function(t3) {
              return this.hashHex(t3, "sha256");
            }, this.sha512 = function(t3) {
              return this.hashString(t3, "sha512");
            }, this.sha512Hex = function(t3) {
              return this.hashHex(t3, "sha512");
            }, this.isKey = function(t3) {
              return t3 instanceof Me || t3 instanceof Sr.crypto.DSA || t3 instanceof Sr.crypto.ECDSA;
            };
          }(), Sr.crypto.Util.md5 = function(t3) {
            return new Sr.crypto.MessageDigest({ alg: "md5", prov: "cryptojs" }).digestString(t3);
          }, Sr.crypto.Util.ripemd160 = function(t3) {
            return new Sr.crypto.MessageDigest({ alg: "ripemd160", prov: "cryptojs" }).digestString(t3);
          }, Sr.crypto.Util.SECURERANDOMGEN = new Be(), Sr.crypto.Util.getRandomHexOfNbytes = function(t3) {
            var e2 = new Array(t3);
            return Sr.crypto.Util.SECURERANDOMGEN.nextBytes(e2), Ar(e2);
          }, Sr.crypto.Util.getRandomBigIntegerOfNbytes = function(t3) {
            return new w(Sr.crypto.Util.getRandomHexOfNbytes(t3), 16);
          }, Sr.crypto.Util.getRandomHexOfNbits = function(t3) {
            var e2 = t3 % 8, r3 = new Array((t3 - e2) / 8 + 1);
            return Sr.crypto.Util.SECURERANDOMGEN.nextBytes(r3), r3[0] = (255 << e2 & 255 ^ 255) & r3[0], Ar(r3);
          }, Sr.crypto.Util.getRandomBigIntegerOfNbits = function(t3) {
            return new w(Sr.crypto.Util.getRandomHexOfNbits(t3), 16);
          }, Sr.crypto.Util.getRandomBigIntegerZeroToMax = function(t3) {
            for (var e2 = t3.bitLength(); ; ) {
              var r3 = Sr.crypto.Util.getRandomBigIntegerOfNbits(e2);
              if (-1 != t3.compareTo(r3)) return r3;
            }
          }, Sr.crypto.Util.getRandomBigIntegerMinToMax = function(t3, e2) {
            var r3 = t3.compareTo(e2);
            if (1 == r3) throw "biMin is greater than biMax";
            if (0 == r3) return t3;
            var n2 = e2.subtract(t3);
            return Sr.crypto.Util.getRandomBigIntegerZeroToMax(n2).add(t3);
          }, Sr.crypto.MessageDigest = function(t3) {
            this.setAlgAndProvider = function(t4, e2) {
              if (null !== (t4 = Sr.crypto.MessageDigest.getCanonicalAlgName(t4)) && void 0 === e2 && (e2 = Sr.crypto.Util.DEFAULTPROVIDER[t4]), -1 != ":md5:sha1:sha224:sha256:sha384:sha512:ripemd160:".indexOf(t4) && "cryptojs" == e2) {
                try {
                  this.md = Sr.crypto.Util.CRYPTOJSMESSAGEDIGESTNAME[t4].create();
                } catch (e3) {
                  throw "setAlgAndProvider hash alg set fail alg=" + t4 + "/" + e3;
                }
                this.updateString = function(t5) {
                  this.md.update(t5);
                }, this.updateHex = function(t5) {
                  var e3 = v.enc.Hex.parse(t5);
                  this.md.update(e3);
                }, this.digest = function() {
                  return this.md.finalize().toString(v.enc.Hex);
                }, this.digestString = function(t5) {
                  return this.updateString(t5), this.digest();
                }, this.digestHex = function(t5) {
                  return this.updateHex(t5), this.digest();
                };
              }
              if (-1 != ":sha256:".indexOf(t4) && "sjcl" == e2) {
                try {
                  this.md = new sjcl.hash.sha256();
                } catch (e3) {
                  throw "setAlgAndProvider hash alg set fail alg=" + t4 + "/" + e3;
                }
                this.updateString = function(t5) {
                  this.md.update(t5);
                }, this.updateHex = function(t5) {
                  var e3 = sjcl.codec.hex.toBits(t5);
                  this.md.update(e3);
                }, this.digest = function() {
                  var t5 = this.md.finalize();
                  return sjcl.codec.hex.fromBits(t5);
                }, this.digestString = function(t5) {
                  return this.updateString(t5), this.digest();
                }, this.digestHex = function(t5) {
                  return this.updateHex(t5), this.digest();
                };
              }
            }, this.updateString = function(t4) {
              throw "updateString(str) not supported for this alg/prov: " + this.algName + "/" + this.provName;
            }, this.updateHex = function(t4) {
              throw "updateHex(hex) not supported for this alg/prov: " + this.algName + "/" + this.provName;
            }, this.digest = function() {
              throw "digest() not supported for this alg/prov: " + this.algName + "/" + this.provName;
            }, this.digestString = function(t4) {
              throw "digestString(str) not supported for this alg/prov: " + this.algName + "/" + this.provName;
            }, this.digestHex = function(t4) {
              throw "digestHex(hex) not supported for this alg/prov: " + this.algName + "/" + this.provName;
            }, void 0 !== t3 && void 0 !== t3.alg && (this.algName = t3.alg, void 0 === t3.prov && (this.provName = Sr.crypto.Util.DEFAULTPROVIDER[this.algName]), this.setAlgAndProvider(this.algName, this.provName));
          }, Sr.crypto.MessageDigest.getCanonicalAlgName = function(t3) {
            return "string" == typeof t3 && (t3 = (t3 = t3.toLowerCase()).replace(/-/, "")), t3;
          }, Sr.crypto.MessageDigest.getHashLength = function(t3) {
            var e2 = Sr.crypto.MessageDigest, r3 = e2.getCanonicalAlgName(t3);
            if (void 0 === e2.HASHLENGTH[r3]) throw "not supported algorithm: " + t3;
            return e2.HASHLENGTH[r3];
          }, Sr.crypto.MessageDigest.HASHLENGTH = { md5: 16, sha1: 20, sha224: 28, sha256: 32, sha384: 48, sha512: 64, ripemd160: 20 }, Sr.crypto.Mac = function(t3) {
            this.setAlgAndProvider = function(t4, e2) {
              if (null == (t4 = t4.toLowerCase()) && (t4 = "hmacsha1"), "hmac" != (t4 = t4.toLowerCase()).substr(0, 4)) throw "setAlgAndProvider unsupported HMAC alg: " + t4;
              void 0 === e2 && (e2 = Sr.crypto.Util.DEFAULTPROVIDER[t4]), this.algProv = t4 + "/" + e2;
              var r3 = t4.substr(4);
              if (-1 != ":md5:sha1:sha224:sha256:sha384:sha512:ripemd160:".indexOf(r3) && "cryptojs" == e2) {
                try {
                  var n2 = Sr.crypto.Util.CRYPTOJSMESSAGEDIGESTNAME[r3];
                  this.mac = v.algo.HMAC.create(n2, this.pass);
                } catch (t5) {
                  throw "setAlgAndProvider hash alg set fail hashAlg=" + r3 + "/" + t5;
                }
                this.updateString = function(t5) {
                  this.mac.update(t5);
                }, this.updateHex = function(t5) {
                  var e3 = v.enc.Hex.parse(t5);
                  this.mac.update(e3);
                }, this.doFinal = function() {
                  return this.mac.finalize().toString(v.enc.Hex);
                }, this.doFinalString = function(t5) {
                  return this.updateString(t5), this.doFinal();
                }, this.doFinalHex = function(t5) {
                  return this.updateHex(t5), this.doFinal();
                };
              }
            }, this.updateString = function(t4) {
              throw "updateString(str) not supported for this alg/prov: " + this.algProv;
            }, this.updateHex = function(t4) {
              throw "updateHex(hex) not supported for this alg/prov: " + this.algProv;
            }, this.doFinal = function() {
              throw "digest() not supported for this alg/prov: " + this.algProv;
            }, this.doFinalString = function(t4) {
              throw "digestString(str) not supported for this alg/prov: " + this.algProv;
            }, this.doFinalHex = function(t4) {
              throw "digestHex(hex) not supported for this alg/prov: " + this.algProv;
            }, this.setPassword = function(t4) {
              if ("string" == typeof t4) {
                var e2 = t4;
                return t4.length % 2 != 1 && t4.match(/^[0-9A-Fa-f]+$/) || (e2 = Nr(t4)), void (this.pass = v.enc.Hex.parse(e2));
              }
              if ("object" != (void 0 === t4 ? "undefined" : g(t4))) throw "KJUR.crypto.Mac unsupported password type: " + t4;
              e2 = null;
              if (void 0 !== t4.hex) {
                if (t4.hex.length % 2 != 0 || !t4.hex.match(/^[0-9A-Fa-f]+$/)) throw "Mac: wrong hex password: " + t4.hex;
                e2 = t4.hex;
              }
              if (void 0 !== t4.utf8 && (e2 = Ir(t4.utf8)), void 0 !== t4.rstr && (e2 = Nr(t4.rstr)), void 0 !== t4.b64 && (e2 = S(t4.b64)), void 0 !== t4.b64u && (e2 = Rr(t4.b64u)), null == e2) throw "KJUR.crypto.Mac unsupported password type: " + t4;
              this.pass = v.enc.Hex.parse(e2);
            }, void 0 !== t3 && (void 0 !== t3.pass && this.setPassword(t3.pass), void 0 !== t3.alg && (this.algName = t3.alg, void 0 === t3.prov && (this.provName = Sr.crypto.Util.DEFAULTPROVIDER[this.algName]), this.setAlgAndProvider(this.algName, this.provName)));
          }, Sr.crypto.Signature = function(t3) {
            var e2 = null;
            if (this._setAlgNames = function() {
              var t4 = this.algName.match(/^(.+)with(.+)$/);
              t4 && (this.mdAlgName = t4[1].toLowerCase(), this.pubkeyAlgName = t4[2].toLowerCase(), "rsaandmgf1" == this.pubkeyAlgName && "sha" == this.mdAlgName && (this.mdAlgName = "sha1"));
            }, this._zeroPaddingOfSignature = function(t4, e3) {
              for (var r3 = "", n2 = e3 / 4 - t4.length, i2 = 0; i2 < n2; i2++) r3 += "0";
              return r3 + t4;
            }, this.setAlgAndProvider = function(t4, e3) {
              if (this._setAlgNames(), "cryptojs/jsrsa" != e3) throw new Error("provider not supported: " + e3);
              if (-1 != ":md5:sha1:sha224:sha256:sha384:sha512:ripemd160:".indexOf(this.mdAlgName)) {
                try {
                  this.md = new Sr.crypto.MessageDigest({ alg: this.mdAlgName });
                } catch (t5) {
                  throw new Error("setAlgAndProvider hash alg set fail alg=" + this.mdAlgName + "/" + t5);
                }
                this.init = function(t5, e4) {
                  var r3 = null;
                  try {
                    r3 = void 0 === e4 ? tn.getKey(t5) : tn.getKey(t5, e4);
                  } catch (t6) {
                    throw "init failed:" + t6;
                  }
                  if (true === r3.isPrivate) this.prvKey = r3, this.state = "SIGN";
                  else {
                    if (true !== r3.isPublic) throw "init failed.:" + r3;
                    this.pubKey = r3, this.state = "VERIFY";
                  }
                }, this.updateString = function(t5) {
                  this.md.updateString(t5);
                }, this.updateHex = function(t5) {
                  this.md.updateHex(t5);
                }, this.sign = function() {
                  if (this.sHashHex = this.md.digest(), void 0 === this.prvKey && void 0 !== this.ecprvhex && void 0 !== this.eccurvename && void 0 !== Sr.crypto.ECDSA && (this.prvKey = new Sr.crypto.ECDSA({ curve: this.eccurvename, prv: this.ecprvhex })), this.prvKey instanceof Me && "rsaandmgf1" === this.pubkeyAlgName) this.hSign = this.prvKey.signWithMessageHashPSS(this.sHashHex, this.mdAlgName, this.pssSaltLen);
                  else if (this.prvKey instanceof Me && "rsa" === this.pubkeyAlgName) this.hSign = this.prvKey.signWithMessageHash(this.sHashHex, this.mdAlgName);
                  else if (this.prvKey instanceof Sr.crypto.ECDSA) this.hSign = this.prvKey.signWithMessageHash(this.sHashHex);
                  else {
                    if (!(this.prvKey instanceof Sr.crypto.DSA)) throw "Signature: unsupported private key alg: " + this.pubkeyAlgName;
                    this.hSign = this.prvKey.signWithMessageHash(this.sHashHex);
                  }
                  return this.hSign;
                }, this.signString = function(t5) {
                  return this.updateString(t5), this.sign();
                }, this.signHex = function(t5) {
                  return this.updateHex(t5), this.sign();
                }, this.verify = function(t5) {
                  if (this.sHashHex = this.md.digest(), void 0 === this.pubKey && void 0 !== this.ecpubhex && void 0 !== this.eccurvename && void 0 !== Sr.crypto.ECDSA && (this.pubKey = new Sr.crypto.ECDSA({ curve: this.eccurvename, pub: this.ecpubhex })), this.pubKey instanceof Me && "rsaandmgf1" === this.pubkeyAlgName) return this.pubKey.verifyWithMessageHashPSS(this.sHashHex, t5, this.mdAlgName, this.pssSaltLen);
                  if (this.pubKey instanceof Me && "rsa" === this.pubkeyAlgName) return this.pubKey.verifyWithMessageHash(this.sHashHex, t5);
                  if (void 0 !== Sr.crypto.ECDSA && this.pubKey instanceof Sr.crypto.ECDSA) return this.pubKey.verifyWithMessageHash(this.sHashHex, t5);
                  if (void 0 !== Sr.crypto.DSA && this.pubKey instanceof Sr.crypto.DSA) return this.pubKey.verifyWithMessageHash(this.sHashHex, t5);
                  throw "Signature: unsupported public key alg: " + this.pubkeyAlgName;
                };
              }
            }, this.init = function(t4, e3) {
              throw "init(key, pass) not supported for this alg:prov=" + this.algProvName;
            }, this.updateString = function(t4) {
              throw "updateString(str) not supported for this alg:prov=" + this.algProvName;
            }, this.updateHex = function(t4) {
              throw "updateHex(hex) not supported for this alg:prov=" + this.algProvName;
            }, this.sign = function() {
              throw "sign() not supported for this alg:prov=" + this.algProvName;
            }, this.signString = function(t4) {
              throw "digestString(str) not supported for this alg:prov=" + this.algProvName;
            }, this.signHex = function(t4) {
              throw "digestHex(hex) not supported for this alg:prov=" + this.algProvName;
            }, this.verify = function(t4) {
              throw "verify(hSigVal) not supported for this alg:prov=" + this.algProvName;
            }, this.initParams = t3, void 0 !== t3 && (void 0 !== t3.alg && (this.algName = t3.alg, void 0 === t3.prov ? this.provName = Sr.crypto.Util.DEFAULTPROVIDER[this.algName] : this.provName = t3.prov, this.algProvName = this.algName + ":" + this.provName, this.setAlgAndProvider(this.algName, this.provName), this._setAlgNames()), void 0 !== t3.psssaltlen && (this.pssSaltLen = t3.psssaltlen), void 0 !== t3.prvkeypem)) {
              if (void 0 !== t3.prvkeypas) throw "both prvkeypem and prvkeypas parameters not supported";
              try {
                e2 = tn.getKey(t3.prvkeypem);
                this.init(e2);
              } catch (t4) {
                throw "fatal error to load pem private key: " + t4;
              }
            }
          }, Sr.crypto.Cipher = function(t3) {
          }, Sr.crypto.Cipher.encrypt = function(t3, e2, r3) {
            if (e2 instanceof Me && e2.isPublic) {
              var n2 = Sr.crypto.Cipher.getAlgByKeyAndName(e2, r3);
              if ("RSA" === n2) return e2.encrypt(t3);
              if ("RSAOAEP" === n2) return e2.encryptOAEP(t3, "sha1");
              var i2 = n2.match(/^RSAOAEP(\d+)$/);
              if (null !== i2) return e2.encryptOAEP(t3, "sha" + i2[1]);
              throw "Cipher.encrypt: unsupported algorithm for RSAKey: " + r3;
            }
            throw "Cipher.encrypt: unsupported key or algorithm";
          }, Sr.crypto.Cipher.decrypt = function(t3, e2, r3) {
            if (e2 instanceof Me && e2.isPrivate) {
              var n2 = Sr.crypto.Cipher.getAlgByKeyAndName(e2, r3);
              if ("RSA" === n2) return e2.decrypt(t3);
              if ("RSAOAEP" === n2) return e2.decryptOAEP(t3, "sha1");
              var i2 = n2.match(/^RSAOAEP(\d+)$/);
              if (null !== i2) return e2.decryptOAEP(t3, "sha" + i2[1]);
              throw "Cipher.decrypt: unsupported algorithm for RSAKey: " + r3;
            }
            throw "Cipher.decrypt: unsupported key or algorithm";
          }, Sr.crypto.Cipher.getAlgByKeyAndName = function(t3, e2) {
            if (t3 instanceof Me) {
              if (-1 != ":RSA:RSAOAEP:RSAOAEP224:RSAOAEP256:RSAOAEP384:RSAOAEP512:".indexOf(e2)) return e2;
              if (null == e2) return "RSA";
              throw "getAlgByKeyAndName: not supported algorithm name for RSAKey: " + e2;
            }
            throw "getAlgByKeyAndName: not supported algorithm name: " + e2;
          }, Sr.crypto.OID = new function() {
            this.oidhex2name = { "2a864886f70d010101": "rsaEncryption", "2a8648ce3d0201": "ecPublicKey", "2a8648ce380401": "dsa", "2a8648ce3d030107": "secp256r1", "2b8104001f": "secp192k1", "2b81040021": "secp224r1", "2b8104000a": "secp256k1", "2b81040023": "secp521r1", "2b81040022": "secp384r1", "2a8648ce380403": "SHA1withDSA", "608648016503040301": "SHA224withDSA", "608648016503040302": "SHA256withDSA" };
          }(), void 0 !== Sr && Sr || (e.KJUR = Sr = {}), void 0 !== Sr.crypto && Sr.crypto || (Sr.crypto = {}), Sr.crypto.ECDSA = function(t3) {
            var e2 = Error, r3 = w, n2 = Ve, i2 = Sr.crypto.ECDSA, o2 = Sr.crypto.ECParameterDB, s2 = i2.getName, a2 = Fr, u2 = a2.getVbyListEx, c2 = a2.isASN1HEX, h2 = new Be();
            this.type = "EC", this.isPrivate = false, this.isPublic = false, this.getBigRandom = function(t4) {
              return new r3(t4.bitLength(), h2).mod(t4.subtract(r3.ONE)).add(r3.ONE);
            }, this.setNamedCurve = function(t4) {
              this.ecparams = o2.getByName(t4), this.prvKeyHex = null, this.pubKeyHex = null, this.curveName = t4;
            }, this.setPrivateKeyHex = function(t4) {
              this.isPrivate = true, this.prvKeyHex = t4;
            }, this.setPublicKeyHex = function(t4) {
              this.isPublic = true, this.pubKeyHex = t4;
            }, this.getPublicKeyXYHex = function() {
              var t4 = this.pubKeyHex;
              if ("04" !== t4.substr(0, 2)) throw "this method supports uncompressed format(04) only";
              var e3 = this.ecparams.keylen / 4;
              if (t4.length !== 2 + 2 * e3) throw "malformed public key hex length";
              var r4 = {};
              return r4.x = t4.substr(2, e3), r4.y = t4.substr(2 + e3), r4;
            }, this.getShortNISTPCurveName = function() {
              var t4 = this.curveName;
              return "secp256r1" === t4 || "NIST P-256" === t4 || "P-256" === t4 || "prime256v1" === t4 ? "P-256" : "secp384r1" === t4 || "NIST P-384" === t4 || "P-384" === t4 ? "P-384" : null;
            }, this.generateKeyPairHex = function() {
              var t4 = this.ecparams.n, e3 = this.getBigRandom(t4), r4 = this.ecparams.G.multiply(e3), n3 = r4.getX().toBigInteger(), i3 = r4.getY().toBigInteger(), o3 = this.ecparams.keylen / 4, s3 = ("0000000000" + e3.toString(16)).slice(-o3), a3 = "04" + ("0000000000" + n3.toString(16)).slice(-o3) + ("0000000000" + i3.toString(16)).slice(-o3);
              return this.setPrivateKeyHex(s3), this.setPublicKeyHex(a3), { ecprvhex: s3, ecpubhex: a3 };
            }, this.signWithMessageHash = function(t4) {
              return this.signHex(t4, this.prvKeyHex);
            }, this.signHex = function(t4, e3) {
              var n3 = new r3(e3, 16), o3 = this.ecparams.n, s3 = new r3(t4.substring(0, this.ecparams.keylen / 4), 16);
              do {
                var a3 = this.getBigRandom(o3), u3 = this.ecparams.G.multiply(a3).getX().toBigInteger().mod(o3);
              } while (u3.compareTo(r3.ZERO) <= 0);
              var c3 = a3.modInverse(o3).multiply(s3.add(n3.multiply(u3))).mod(o3);
              return i2.biRSSigToASN1Sig(u3, c3);
            }, this.sign = function(t4, e3) {
              var n3 = e3, i3 = this.ecparams.n, o3 = r3.fromByteArrayUnsigned(t4);
              do {
                var s3 = this.getBigRandom(i3), a3 = this.ecparams.G.multiply(s3).getX().toBigInteger().mod(i3);
              } while (a3.compareTo(w.ZERO) <= 0);
              var u3 = s3.modInverse(i3).multiply(o3.add(n3.multiply(a3))).mod(i3);
              return this.serializeSig(a3, u3);
            }, this.verifyWithMessageHash = function(t4, e3) {
              return this.verifyHex(t4, e3, this.pubKeyHex);
            }, this.verifyHex = function(t4, e3, o3) {
              try {
                var s3, a3, u3 = i2.parseSigHex(e3);
                s3 = u3.r, a3 = u3.s;
                var c3 = n2.decodeFromHex(this.ecparams.curve, o3), h3 = new r3(t4.substring(0, this.ecparams.keylen / 4), 16);
                return this.verifyRaw(h3, s3, a3, c3);
              } catch (t5) {
                return false;
              }
            }, this.verify = function(t4, e3, i3) {
              var o3, s3, a3;
              if (Bitcoin.Util.isArray(e3)) {
                var u3 = this.parseSig(e3);
                o3 = u3.r, s3 = u3.s;
              } else {
                if ("object" !== (void 0 === e3 ? "undefined" : g(e3)) || !e3.r || !e3.s) throw "Invalid value for signature";
                o3 = e3.r, s3 = e3.s;
              }
              if (i3 instanceof Ve) a3 = i3;
              else {
                if (!Bitcoin.Util.isArray(i3)) throw "Invalid format for pubkey value, must be byte array or ECPointFp";
                a3 = n2.decodeFrom(this.ecparams.curve, i3);
              }
              var c3 = r3.fromByteArrayUnsigned(t4);
              return this.verifyRaw(c3, o3, s3, a3);
            }, this.verifyRaw = function(t4, e3, n3, i3) {
              var o3 = this.ecparams.n, s3 = this.ecparams.G;
              if (e3.compareTo(r3.ONE) < 0 || e3.compareTo(o3) >= 0) return false;
              if (n3.compareTo(r3.ONE) < 0 || n3.compareTo(o3) >= 0) return false;
              var a3 = n3.modInverse(o3), u3 = t4.multiply(a3).mod(o3), c3 = e3.multiply(a3).mod(o3);
              return s3.multiply(u3).add(i3.multiply(c3)).getX().toBigInteger().mod(o3).equals(e3);
            }, this.serializeSig = function(t4, e3) {
              var r4 = t4.toByteArraySigned(), n3 = e3.toByteArraySigned(), i3 = [];
              return i3.push(2), i3.push(r4.length), (i3 = i3.concat(r4)).push(2), i3.push(n3.length), (i3 = i3.concat(n3)).unshift(i3.length), i3.unshift(48), i3;
            }, this.parseSig = function(t4) {
              var e3;
              if (48 != t4[0]) throw new Error("Signature not a valid DERSequence");
              if (2 != t4[e3 = 2]) throw new Error("First element in signature must be a DERInteger");
              var n3 = t4.slice(e3 + 2, e3 + 2 + t4[e3 + 1]);
              if (2 != t4[e3 += 2 + t4[e3 + 1]]) throw new Error("Second element in signature must be a DERInteger");
              var i3 = t4.slice(e3 + 2, e3 + 2 + t4[e3 + 1]);
              return e3 += 2 + t4[e3 + 1], { r: r3.fromByteArrayUnsigned(n3), s: r3.fromByteArrayUnsigned(i3) };
            }, this.parseSigCompact = function(t4) {
              if (65 !== t4.length) throw "Signature has the wrong length";
              var e3 = t4[0] - 27;
              if (e3 < 0 || e3 > 7) throw "Invalid signature type";
              var n3 = this.ecparams.n;
              return { r: r3.fromByteArrayUnsigned(t4.slice(1, 33)).mod(n3), s: r3.fromByteArrayUnsigned(t4.slice(33, 65)).mod(n3), i: e3 };
            }, this.readPKCS5PrvKeyHex = function(t4) {
              if (false === c2(t4)) throw new Error("not ASN.1 hex string");
              var e3, r4, n3;
              try {
                e3 = u2(t4, 0, ["[0]", 0], "06"), r4 = u2(t4, 0, [1], "04");
                try {
                  n3 = u2(t4, 0, ["[1]", 0], "03");
                } catch (t5) {
                }
              } catch (t5) {
                throw new Error("malformed PKCS#1/5 plain ECC private key");
              }
              if (this.curveName = s2(e3), void 0 === this.curveName) throw "unsupported curve name";
              this.setNamedCurve(this.curveName), this.setPublicKeyHex(n3), this.setPrivateKeyHex(r4), this.isPublic = false;
            }, this.readPKCS8PrvKeyHex = function(t4) {
              if (false === c2(t4)) throw new e2("not ASN.1 hex string");
              var r4, n3, i3;
              try {
                u2(t4, 0, [1, 0], "06"), r4 = u2(t4, 0, [1, 1], "06"), n3 = u2(t4, 0, [2, 0, 1], "04");
                try {
                  i3 = u2(t4, 0, [2, 0, "[1]", 0], "03");
                } catch (t5) {
                }
              } catch (t5) {
                throw new e2("malformed PKCS#8 plain ECC private key");
              }
              if (this.curveName = s2(r4), void 0 === this.curveName) throw new e2("unsupported curve name");
              this.setNamedCurve(this.curveName), this.setPublicKeyHex(i3), this.setPrivateKeyHex(n3), this.isPublic = false;
            }, this.readPKCS8PubKeyHex = function(t4) {
              if (false === c2(t4)) throw new e2("not ASN.1 hex string");
              var r4, n3;
              try {
                u2(t4, 0, [0, 0], "06"), r4 = u2(t4, 0, [0, 1], "06"), n3 = u2(t4, 0, [1], "03");
              } catch (t5) {
                throw new e2("malformed PKCS#8 ECC public key");
              }
              if (this.curveName = s2(r4), null === this.curveName) throw new e2("unsupported curve name");
              this.setNamedCurve(this.curveName), this.setPublicKeyHex(n3);
            }, this.readCertPubKeyHex = function(t4, r4) {
              if (false === c2(t4)) throw new e2("not ASN.1 hex string");
              var n3, i3;
              try {
                n3 = u2(t4, 0, [0, 5, 0, 1], "06"), i3 = u2(t4, 0, [0, 5, 1], "03");
              } catch (t5) {
                throw new e2("malformed X.509 certificate ECC public key");
              }
              if (this.curveName = s2(n3), null === this.curveName) throw new e2("unsupported curve name");
              this.setNamedCurve(this.curveName), this.setPublicKeyHex(i3);
            }, void 0 !== t3 && void 0 !== t3.curve && (this.curveName = t3.curve), void 0 === this.curveName && (this.curveName = "secp256r1"), this.setNamedCurve(this.curveName), void 0 !== t3 && (void 0 !== t3.prv && this.setPrivateKeyHex(t3.prv), void 0 !== t3.pub && this.setPublicKeyHex(t3.pub));
          }, Sr.crypto.ECDSA.parseSigHex = function(t3) {
            var e2 = Sr.crypto.ECDSA.parseSigHexInHexRS(t3);
            return { r: new w(e2.r, 16), s: new w(e2.s, 16) };
          }, Sr.crypto.ECDSA.parseSigHexInHexRS = function(t3) {
            var e2 = Fr, r3 = e2.getChildIdx, n2 = e2.getV;
            if (e2.checkStrictDER(t3, 0), "30" != t3.substr(0, 2)) throw new Error("signature is not a ASN.1 sequence");
            var i2 = r3(t3, 0);
            if (2 != i2.length) throw new Error("signature shall have two elements");
            var o2 = i2[0], s2 = i2[1];
            if ("02" != t3.substr(o2, 2)) throw new Error("1st item not ASN.1 integer");
            if ("02" != t3.substr(s2, 2)) throw new Error("2nd item not ASN.1 integer");
            return { r: n2(t3, o2), s: n2(t3, s2) };
          }, Sr.crypto.ECDSA.asn1SigToConcatSig = function(t3) {
            var e2 = Sr.crypto.ECDSA.parseSigHexInHexRS(t3), r3 = e2.r, n2 = e2.s;
            if ("00" == r3.substr(0, 2) && r3.length % 32 == 2 && (r3 = r3.substr(2)), "00" == n2.substr(0, 2) && n2.length % 32 == 2 && (n2 = n2.substr(2)), r3.length % 32 == 30 && (r3 = "00" + r3), n2.length % 32 == 30 && (n2 = "00" + n2), r3.length % 32 != 0) throw "unknown ECDSA sig r length error";
            if (n2.length % 32 != 0) throw "unknown ECDSA sig s length error";
            return r3 + n2;
          }, Sr.crypto.ECDSA.concatSigToASN1Sig = function(t3) {
            if (t3.length / 2 * 8 % 128 != 0) throw "unknown ECDSA concatinated r-s sig  length error";
            var e2 = t3.substr(0, t3.length / 2), r3 = t3.substr(t3.length / 2);
            return Sr.crypto.ECDSA.hexRSSigToASN1Sig(e2, r3);
          }, Sr.crypto.ECDSA.hexRSSigToASN1Sig = function(t3, e2) {
            var r3 = new w(t3, 16), n2 = new w(e2, 16);
            return Sr.crypto.ECDSA.biRSSigToASN1Sig(r3, n2);
          }, Sr.crypto.ECDSA.biRSSigToASN1Sig = function(t3, e2) {
            var r3 = Sr.asn1, n2 = new r3.DERInteger({ bigint: t3 }), i2 = new r3.DERInteger({ bigint: e2 });
            return new r3.DERSequence({ array: [n2, i2] }).getEncodedHex();
          }, Sr.crypto.ECDSA.getName = function(t3) {
            return "2b8104001f" === t3 ? "secp192k1" : "2a8648ce3d030107" === t3 ? "secp256r1" : "2b8104000a" === t3 ? "secp256k1" : "2b81040021" === t3 ? "secp224r1" : "2b81040022" === t3 ? "secp384r1" : -1 !== "|secp256r1|NIST P-256|P-256|prime256v1|".indexOf(t3) ? "secp256r1" : -1 !== "|secp256k1|".indexOf(t3) ? "secp256k1" : -1 !== "|secp224r1|NIST P-224|P-224|".indexOf(t3) ? "secp224r1" : -1 !== "|secp384r1|NIST P-384|P-384|".indexOf(t3) ? "secp384r1" : null;
          }, void 0 !== Sr && Sr || (e.KJUR = Sr = {}), void 0 !== Sr.crypto && Sr.crypto || (Sr.crypto = {}), Sr.crypto.ECParameterDB = new function() {
            var t3 = {}, e2 = {};
            function r3(t4) {
              return new w(t4, 16);
            }
            this.getByName = function(r4) {
              var n2 = r4;
              if (void 0 !== e2[n2] && (n2 = e2[r4]), void 0 !== t3[n2]) return t3[n2];
              throw "unregistered EC curve name: " + n2;
            }, this.regist = function(n2, i2, o2, s2, a2, u2, c2, h2, l2, f2, g2, d2) {
              t3[n2] = {};
              var p2 = r3(o2), v2 = r3(s2), y2 = r3(a2), m2 = r3(u2), _2 = r3(c2), S2 = new Ke(p2, v2, y2), b2 = S2.decodePointHex("04" + h2 + l2);
              t3[n2].name = n2, t3[n2].keylen = i2, t3[n2].curve = S2, t3[n2].G = b2, t3[n2].n = m2, t3[n2].h = _2, t3[n2].oid = g2, t3[n2].info = d2;
              for (var w2 = 0; w2 < f2.length; w2++) e2[f2[w2]] = n2;
            };
          }(), Sr.crypto.ECParameterDB.regist("secp128r1", 128, "FFFFFFFDFFFFFFFFFFFFFFFFFFFFFFFF", "FFFFFFFDFFFFFFFFFFFFFFFFFFFFFFFC", "E87579C11079F43DD824993C2CEE5ED3", "FFFFFFFE0000000075A30D1B9038A115", "1", "161FF7528B899B2D0C28607CA52C5B86", "CF5AC8395BAFEB13C02DA292DDED7A83", [], "", "secp128r1 : SECG curve over a 128 bit prime field"), Sr.crypto.ECParameterDB.regist("secp160k1", 160, "FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFAC73", "0", "7", "0100000000000000000001B8FA16DFAB9ACA16B6B3", "1", "3B4C382CE37AA192A4019E763036F4F5DD4D7EBB", "938CF935318FDCED6BC28286531733C3F03C4FEE", [], "", "secp160k1 : SECG curve over a 160 bit prime field"), Sr.crypto.ECParameterDB.regist("secp160r1", 160, "FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF7FFFFFFF", "FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF7FFFFFFC", "1C97BEFC54BD7A8B65ACF89F81D4D4ADC565FA45", "0100000000000000000001F4C8F927AED3CA752257", "1", "4A96B5688EF573284664698968C38BB913CBFC82", "23A628553168947D59DCC912042351377AC5FB32", [], "", "secp160r1 : SECG curve over a 160 bit prime field"), Sr.crypto.ECParameterDB.regist("secp192k1", 192, "FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFEE37", "0", "3", "FFFFFFFFFFFFFFFFFFFFFFFE26F2FC170F69466A74DEFD8D", "1", "DB4FF10EC057E9AE26B07D0280B7F4341DA5D1B1EAE06C7D", "9B2F2F6D9C5628A7844163D015BE86344082AA88D95E2F9D", []), Sr.crypto.ECParameterDB.regist("secp192r1", 192, "FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFF", "FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFC", "64210519E59C80E70FA7E9AB72243049FEB8DEECC146B9B1", "FFFFFFFFFFFFFFFFFFFFFFFF99DEF836146BC9B1B4D22831", "1", "188DA80EB03090F67CBF20EB43A18800F4FF0AFD82FF1012", "07192B95FFC8DA78631011ED6B24CDD573F977A11E794811", []), Sr.crypto.ECParameterDB.regist("secp224r1", 224, "FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF000000000000000000000001", "FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFFFFFFFFFE", "B4050A850C04B3ABF54132565044B0B7D7BFD8BA270B39432355FFB4", "FFFFFFFFFFFFFFFFFFFFFFFFFFFF16A2E0B8F03E13DD29455C5C2A3D", "1", "B70E0CBD6BB4BF7F321390B94A03C1D356C21122343280D6115C1D21", "BD376388B5F723FB4C22DFE6CD4375A05A07476444D5819985007E34", []), Sr.crypto.ECParameterDB.regist("secp256k1", 256, "FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFC2F", "0", "7", "FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141", "1", "79BE667EF9DCBBAC55A06295CE870B07029BFCDB2DCE28D959F2815B16F81798", "483ADA7726A3C4655DA4FBFC0E1108A8FD17B448A68554199C47D08FFB10D4B8", []), Sr.crypto.ECParameterDB.regist("secp256r1", 256, "FFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFF", "FFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFC", "5AC635D8AA3A93E7B3EBBD55769886BC651D06B0CC53B0F63BCE3C3E27D2604B", "FFFFFFFF00000000FFFFFFFFFFFFFFFFBCE6FAADA7179E84F3B9CAC2FC632551", "1", "6B17D1F2E12C4247F8BCE6E563A440F277037D812DEB33A0F4A13945D898C296", "4FE342E2FE1A7F9B8EE7EB4A7C0F9E162BCE33576B315ECECBB6406837BF51F5", ["NIST P-256", "P-256", "prime256v1"]), Sr.crypto.ECParameterDB.regist("secp384r1", 384, "FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFF0000000000000000FFFFFFFF", "FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFF0000000000000000FFFFFFFC", "B3312FA7E23EE7E4988E056BE3F82D19181D9C6EFE8141120314088F5013875AC656398D8A2ED19D2A85C8EDD3EC2AEF", "FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFC7634D81F4372DDF581A0DB248B0A77AECEC196ACCC52973", "1", "AA87CA22BE8B05378EB1C71EF320AD746E1D3B628BA79B9859F741E082542A385502F25DBF55296C3A545E3872760AB7", "3617de4a96262c6f5d9e98bf9292dc29f8f41dbd289a147ce9da3113b5f0b8c00a60b1ce1d7e819d7a431d7c90ea0e5f", ["NIST P-384", "P-384"]), Sr.crypto.ECParameterDB.regist("secp521r1", 521, "1FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF", "1FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFC", "051953EB9618E1C9A1F929A21A0B68540EEA2DA725B99B315F3B8B489918EF109E156193951EC7E937B1652C0BD3BB1BF073573DF883D2C34F1EF451FD46B503F00", "1FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFA51868783BF2F966B7FCC0148F709A5D03BB5C9B8899C47AEBB6FB71E91386409", "1", "C6858E06B70404E9CD9E3ECB662395B4429C648139053FB521F828AF606B4D3DBAA14B5E77EFE75928FE1DC127A2FFA8DE3348B3C1856A429BF97E7E31C2E5BD66", "011839296a789a3bc0045c8a5fb42c7d1bd998f54449579b446817afbd17273e662c97ee72995ef42640c550b9013fad0761353c7086a272c24088be94769fd16650", ["NIST P-521", "P-521"]);
          var tn = /* @__PURE__ */ (function() {
            var t3 = function t4(r4, n3, i3) {
              return e2(v.AES, r4, n3, i3);
            }, e2 = function t4(e3, r4, n3, i3) {
              var o3 = v.enc.Hex.parse(r4), s3 = v.enc.Hex.parse(n3), a3 = v.enc.Hex.parse(i3), u2 = {};
              u2.key = s3, u2.iv = a3, u2.ciphertext = o3;
              var c2 = e3.decrypt(u2, s3, { iv: a3 });
              return v.enc.Hex.stringify(c2);
            }, r3 = function t4(e3, r4, i3) {
              return n2(v.AES, e3, r4, i3);
            }, n2 = function t4(e3, r4, n3, i3) {
              var o3 = v.enc.Hex.parse(r4), s3 = v.enc.Hex.parse(n3), a3 = v.enc.Hex.parse(i3), u2 = e3.encrypt(o3, s3, { iv: a3 }), c2 = v.enc.Hex.parse(u2.toString());
              return v.enc.Base64.stringify(c2);
            }, i2 = { "AES-256-CBC": { proc: t3, eproc: r3, keylen: 32, ivlen: 16 }, "AES-192-CBC": { proc: t3, eproc: r3, keylen: 24, ivlen: 16 }, "AES-128-CBC": { proc: t3, eproc: r3, keylen: 16, ivlen: 16 }, "DES-EDE3-CBC": { proc: function t4(r4, n3, i3) {
              return e2(v.TripleDES, r4, n3, i3);
            }, eproc: function t4(e3, r4, i3) {
              return n2(v.TripleDES, e3, r4, i3);
            }, keylen: 24, ivlen: 8 }, "DES-CBC": { proc: function t4(r4, n3, i3) {
              return e2(v.DES, r4, n3, i3);
            }, eproc: function t4(e3, r4, i3) {
              return n2(v.DES, e3, r4, i3);
            }, keylen: 8, ivlen: 8 } }, o2 = function t4(e3) {
              var r4 = {}, n3 = e3.match(new RegExp("DEK-Info: ([^,]+),([0-9A-Fa-f]+)", "m"));
              n3 && (r4.cipher = n3[1], r4.ivsalt = n3[2]);
              var i3 = e3.match(new RegExp("-----BEGIN ([A-Z]+) PRIVATE KEY-----"));
              i3 && (r4.type = i3[1]);
              var o3 = -1, s3 = 0;
              -1 != e3.indexOf("\r\n\r\n") && (o3 = e3.indexOf("\r\n\r\n"), s3 = 2), -1 != e3.indexOf("\n\n") && (o3 = e3.indexOf("\n\n"), s3 = 1);
              var a3 = e3.indexOf("-----END");
              if (-1 != o3 && -1 != a3) {
                var u2 = e3.substring(o3 + 2 * s3, a3 - s3);
                u2 = u2.replace(/\s+/g, ""), r4.data = u2;
              }
              return r4;
            }, s2 = function t4(e3, r4, n3) {
              for (var o3 = n3.substring(0, 16), s3 = v.enc.Hex.parse(o3), a3 = v.enc.Utf8.parse(r4), u2 = i2[e3].keylen + i2[e3].ivlen, c2 = "", h2 = null; ; ) {
                var l2 = v.algo.MD5.create();
                if (null != h2 && l2.update(h2), l2.update(a3), l2.update(s3), h2 = l2.finalize(), (c2 += v.enc.Hex.stringify(h2)).length >= 2 * u2) break;
              }
              var f2 = {};
              return f2.keyhex = c2.substr(0, 2 * i2[e3].keylen), f2.ivhex = c2.substr(2 * i2[e3].keylen, 2 * i2[e3].ivlen), f2;
            }, a2 = function t4(e3, r4, n3, o3) {
              var s3 = v.enc.Base64.parse(e3), a3 = v.enc.Hex.stringify(s3);
              return (0, i2[r4].proc)(a3, n3, o3);
            };
            return { version: "1.0.0", parsePKCS5PEM: function t4(e3) {
              return o2(e3);
            }, getKeyAndUnusedIvByPasscodeAndIvsalt: function t4(e3, r4, n3) {
              return s2(e3, r4, n3);
            }, decryptKeyB64: function t4(e3, r4, n3, i3) {
              return a2(e3, r4, n3, i3);
            }, getDecryptedKeyHex: function t4(e3, r4) {
              var n3 = o2(e3), i3 = (n3.type, n3.cipher), u2 = n3.ivsalt, c2 = n3.data, h2 = s2(i3, r4, u2).keyhex;
              return a2(c2, i3, h2, u2);
            }, getEncryptedPKCS5PEMFromPrvKeyHex: function t4(e3, r4, n3, o3, a3) {
              var u2 = "";
              if (void 0 !== o3 && null != o3 || (o3 = "AES-256-CBC"), void 0 === i2[o3]) throw new Error("KEYUTIL unsupported algorithm: " + o3);
              void 0 !== a3 && null != a3 || (a3 = (function t5(e4) {
                var r5 = v.lib.WordArray.random(e4);
                return v.enc.Hex.stringify(r5);
              })(i2[o3].ivlen).toUpperCase());
              var c2 = (function t5(e4, r5, n4, o4) {
                return (0, i2[r5].eproc)(e4, n4, o4);
              })(r4, o3, s2(o3, n3, a3).keyhex, a3);
              u2 = "-----BEGIN " + e3 + " PRIVATE KEY-----\r\n";
              return u2 += "Proc-Type: 4,ENCRYPTED\r\n", u2 += "DEK-Info: " + o3 + "," + a3 + "\r\n", u2 += "\r\n", u2 += c2.replace(/(.{64})/g, "$1\r\n"), u2 += "\r\n-----END " + e3 + " PRIVATE KEY-----\r\n";
            }, parseHexOfEncryptedPKCS8: function t4(e3) {
              var r4 = Fr, n3 = r4.getChildIdx, i3 = r4.getV, o3 = {}, s3 = n3(e3, 0);
              if (2 != s3.length) throw new Error("malformed format: SEQUENCE(0).items != 2: " + s3.length);
              o3.ciphertext = i3(e3, s3[1]);
              var a3 = n3(e3, s3[0]);
              if (2 != a3.length) throw new Error("malformed format: SEQUENCE(0.0).items != 2: " + a3.length);
              if ("2a864886f70d01050d" != i3(e3, a3[0])) throw new Error("this only supports pkcs5PBES2");
              var u2 = n3(e3, a3[1]);
              if (2 != a3.length) throw new Error("malformed format: SEQUENCE(0.0.1).items != 2: " + u2.length);
              var c2 = n3(e3, u2[1]);
              if (2 != c2.length) throw new Error("malformed format: SEQUENCE(0.0.1.1).items != 2: " + c2.length);
              if ("2a864886f70d0307" != i3(e3, c2[0])) throw "this only supports TripleDES";
              o3.encryptionSchemeAlg = "TripleDES", o3.encryptionSchemeIV = i3(e3, c2[1]);
              var h2 = n3(e3, u2[0]);
              if (2 != h2.length) throw new Error("malformed format: SEQUENCE(0.0.1.0).items != 2: " + h2.length);
              if ("2a864886f70d01050c" != i3(e3, h2[0])) throw new Error("this only supports pkcs5PBKDF2");
              var l2 = n3(e3, h2[1]);
              if (l2.length < 2) throw new Error("malformed format: SEQUENCE(0.0.1.0.1).items < 2: " + l2.length);
              o3.pbkdf2Salt = i3(e3, l2[0]);
              var f2 = i3(e3, l2[1]);
              try {
                o3.pbkdf2Iter = parseInt(f2, 16);
              } catch (t5) {
                throw new Error("malformed format pbkdf2Iter: " + f2);
              }
              return o3;
            }, getPBKDF2KeyHexFromParam: function t4(e3, r4) {
              var n3 = v.enc.Hex.parse(e3.pbkdf2Salt), i3 = e3.pbkdf2Iter, o3 = v.PBKDF2(r4, n3, { keySize: 6, iterations: i3 });
              return v.enc.Hex.stringify(o3);
            }, _getPlainPKCS8HexFromEncryptedPKCS8PEM: function t4(e3, r4) {
              var n3 = Mr(e3, "ENCRYPTED PRIVATE KEY"), i3 = this.parseHexOfEncryptedPKCS8(n3), o3 = tn.getPBKDF2KeyHexFromParam(i3, r4), s3 = {};
              s3.ciphertext = v.enc.Hex.parse(i3.ciphertext);
              var a3 = v.enc.Hex.parse(o3), u2 = v.enc.Hex.parse(i3.encryptionSchemeIV), c2 = v.TripleDES.decrypt(s3, a3, { iv: u2 });
              return v.enc.Hex.stringify(c2);
            }, getKeyFromEncryptedPKCS8PEM: function t4(e3, r4) {
              var n3 = this._getPlainPKCS8HexFromEncryptedPKCS8PEM(e3, r4);
              return this.getKeyFromPlainPrivatePKCS8Hex(n3);
            }, parsePlainPrivatePKCS8Hex: function t4(e3) {
              var r4 = Fr, n3 = r4.getChildIdx, i3 = r4.getV, o3 = { algparam: null };
              if ("30" != e3.substr(0, 2)) throw new Error("malformed plain PKCS8 private key(code:001)");
              var s3 = n3(e3, 0);
              if (s3.length < 3) throw new Error("malformed plain PKCS8 private key(code:002)");
              if ("30" != e3.substr(s3[1], 2)) throw new Error("malformed PKCS8 private key(code:003)");
              var a3 = n3(e3, s3[1]);
              if (2 != a3.length) throw new Error("malformed PKCS8 private key(code:004)");
              if ("06" != e3.substr(a3[0], 2)) throw new Error("malformed PKCS8 private key(code:005)");
              if (o3.algoid = i3(e3, a3[0]), "06" == e3.substr(a3[1], 2) && (o3.algparam = i3(e3, a3[1])), "04" != e3.substr(s3[2], 2)) throw new Error("malformed PKCS8 private key(code:006)");
              return o3.keyidx = r4.getVidx(e3, s3[2]), o3;
            }, getKeyFromPlainPrivatePKCS8PEM: function t4(e3) {
              var r4 = Mr(e3, "PRIVATE KEY");
              return this.getKeyFromPlainPrivatePKCS8Hex(r4);
            }, getKeyFromPlainPrivatePKCS8Hex: function t4(e3) {
              var r4, n3 = this.parsePlainPrivatePKCS8Hex(e3);
              if ("2a864886f70d010101" == n3.algoid) r4 = new Me();
              else if ("2a8648ce380401" == n3.algoid) r4 = new Sr.crypto.DSA();
              else {
                if ("2a8648ce3d0201" != n3.algoid) throw new Error("unsupported private key algorithm");
                r4 = new Sr.crypto.ECDSA();
              }
              return r4.readPKCS8PrvKeyHex(e3), r4;
            }, _getKeyFromPublicPKCS8Hex: function t4(e3) {
              var r4, n3 = Fr.getVbyList(e3, 0, [0, 0], "06");
              if ("2a864886f70d010101" === n3) r4 = new Me();
              else if ("2a8648ce380401" === n3) r4 = new Sr.crypto.DSA();
              else {
                if ("2a8648ce3d0201" !== n3) throw new Error("unsupported PKCS#8 public key hex");
                r4 = new Sr.crypto.ECDSA();
              }
              return r4.readPKCS8PubKeyHex(e3), r4;
            }, parsePublicRawRSAKeyHex: function t4(e3) {
              var r4 = Fr, n3 = r4.getChildIdx, i3 = r4.getV, o3 = {};
              if ("30" != e3.substr(0, 2)) throw new Error("malformed RSA key(code:001)");
              var s3 = n3(e3, 0);
              if (2 != s3.length) throw new Error("malformed RSA key(code:002)");
              if ("02" != e3.substr(s3[0], 2)) throw new Error("malformed RSA key(code:003)");
              if (o3.n = i3(e3, s3[0]), "02" != e3.substr(s3[1], 2)) throw new Error("malformed RSA key(code:004)");
              return o3.e = i3(e3, s3[1]), o3;
            }, parsePublicPKCS8Hex: function t4(e3) {
              var r4 = Fr, n3 = r4.getChildIdx, i3 = r4.getV, o3 = { algparam: null }, s3 = n3(e3, 0);
              if (2 != s3.length) throw new Error("outer DERSequence shall have 2 elements: " + s3.length);
              var a3 = s3[0];
              if ("30" != e3.substr(a3, 2)) throw new Error("malformed PKCS8 public key(code:001)");
              var u2 = n3(e3, a3);
              if (2 != u2.length) throw new Error("malformed PKCS8 public key(code:002)");
              if ("06" != e3.substr(u2[0], 2)) throw new Error("malformed PKCS8 public key(code:003)");
              if (o3.algoid = i3(e3, u2[0]), "06" == e3.substr(u2[1], 2) ? o3.algparam = i3(e3, u2[1]) : "30" == e3.substr(u2[1], 2) && (o3.algparam = {}, o3.algparam.p = r4.getVbyList(e3, u2[1], [0], "02"), o3.algparam.q = r4.getVbyList(e3, u2[1], [1], "02"), o3.algparam.g = r4.getVbyList(e3, u2[1], [2], "02")), "03" != e3.substr(s3[1], 2)) throw new Error("malformed PKCS8 public key(code:004)");
              return o3.key = i3(e3, s3[1]).substr(2), o3;
            } };
          })();
          tn.getKey = function(t3, e2, r3) {
            var n2 = (v2 = Fr).getChildIdx, i2 = (v2.getV, v2.getVbyList), o2 = Sr.crypto, s2 = o2.ECDSA, a2 = o2.DSA, u2 = Me, c2 = Mr, h2 = tn;
            if (void 0 !== u2 && t3 instanceof u2) return t3;
            if (void 0 !== s2 && t3 instanceof s2) return t3;
            if (void 0 !== a2 && t3 instanceof a2) return t3;
            if (void 0 !== t3.curve && void 0 !== t3.xy && void 0 === t3.d) return new s2({ pub: t3.xy, curve: t3.curve });
            if (void 0 !== t3.curve && void 0 !== t3.d) return new s2({ prv: t3.d, curve: t3.curve });
            if (void 0 === t3.kty && void 0 !== t3.n && void 0 !== t3.e && void 0 === t3.d) return (P2 = new u2()).setPublic(t3.n, t3.e), P2;
            if (void 0 === t3.kty && void 0 !== t3.n && void 0 !== t3.e && void 0 !== t3.d && void 0 !== t3.p && void 0 !== t3.q && void 0 !== t3.dp && void 0 !== t3.dq && void 0 !== t3.co && void 0 === t3.qi) return (P2 = new u2()).setPrivateEx(t3.n, t3.e, t3.d, t3.p, t3.q, t3.dp, t3.dq, t3.co), P2;
            if (void 0 === t3.kty && void 0 !== t3.n && void 0 !== t3.e && void 0 !== t3.d && void 0 === t3.p) return (P2 = new u2()).setPrivate(t3.n, t3.e, t3.d), P2;
            if (void 0 !== t3.p && void 0 !== t3.q && void 0 !== t3.g && void 0 !== t3.y && void 0 === t3.x) return (P2 = new a2()).setPublic(t3.p, t3.q, t3.g, t3.y), P2;
            if (void 0 !== t3.p && void 0 !== t3.q && void 0 !== t3.g && void 0 !== t3.y && void 0 !== t3.x) return (P2 = new a2()).setPrivate(t3.p, t3.q, t3.g, t3.y, t3.x), P2;
            if ("RSA" === t3.kty && void 0 !== t3.n && void 0 !== t3.e && void 0 === t3.d) return (P2 = new u2()).setPublic(Rr(t3.n), Rr(t3.e)), P2;
            if ("RSA" === t3.kty && void 0 !== t3.n && void 0 !== t3.e && void 0 !== t3.d && void 0 !== t3.p && void 0 !== t3.q && void 0 !== t3.dp && void 0 !== t3.dq && void 0 !== t3.qi) return (P2 = new u2()).setPrivateEx(Rr(t3.n), Rr(t3.e), Rr(t3.d), Rr(t3.p), Rr(t3.q), Rr(t3.dp), Rr(t3.dq), Rr(t3.qi)), P2;
            if ("RSA" === t3.kty && void 0 !== t3.n && void 0 !== t3.e && void 0 !== t3.d) return (P2 = new u2()).setPrivate(Rr(t3.n), Rr(t3.e), Rr(t3.d)), P2;
            if ("EC" === t3.kty && void 0 !== t3.crv && void 0 !== t3.x && void 0 !== t3.y && void 0 === t3.d) {
              var l2 = (k2 = new s2({ curve: t3.crv })).ecparams.keylen / 4, f2 = "04" + ("0000000000" + Rr(t3.x)).slice(-l2) + ("0000000000" + Rr(t3.y)).slice(-l2);
              return k2.setPublicKeyHex(f2), k2;
            }
            if ("EC" === t3.kty && void 0 !== t3.crv && void 0 !== t3.x && void 0 !== t3.y && void 0 !== t3.d) {
              l2 = (k2 = new s2({ curve: t3.crv })).ecparams.keylen / 4, f2 = "04" + ("0000000000" + Rr(t3.x)).slice(-l2) + ("0000000000" + Rr(t3.y)).slice(-l2);
              var g2 = ("0000000000" + Rr(t3.d)).slice(-l2);
              return k2.setPublicKeyHex(f2), k2.setPrivateKeyHex(g2), k2;
            }
            if ("pkcs5prv" === r3) {
              var d2, p2 = t3, v2 = Fr;
              if (9 === (d2 = n2(p2, 0)).length) (P2 = new u2()).readPKCS5PrvKeyHex(p2);
              else if (6 === d2.length) (P2 = new a2()).readPKCS5PrvKeyHex(p2);
              else {
                if (!(d2.length > 2 && "04" === p2.substr(d2[1], 2))) throw new Error("unsupported PKCS#1/5 hexadecimal key");
                (P2 = new s2()).readPKCS5PrvKeyHex(p2);
              }
              return P2;
            }
            if ("pkcs8prv" === r3) return P2 = h2.getKeyFromPlainPrivatePKCS8Hex(t3);
            if ("pkcs8pub" === r3) return h2._getKeyFromPublicPKCS8Hex(t3);
            if ("x509pub" === r3) return on.getPublicKeyFromCertHex(t3);
            if (-1 != t3.indexOf("-END CERTIFICATE-", 0) || -1 != t3.indexOf("-END X509 CERTIFICATE-", 0) || -1 != t3.indexOf("-END TRUSTED CERTIFICATE-", 0)) return on.getPublicKeyFromCertPEM(t3);
            if (-1 != t3.indexOf("-END PUBLIC KEY-")) {
              var y2 = Mr(t3, "PUBLIC KEY");
              return h2._getKeyFromPublicPKCS8Hex(y2);
            }
            if (-1 != t3.indexOf("-END RSA PRIVATE KEY-") && -1 == t3.indexOf("4,ENCRYPTED")) {
              var m2 = c2(t3, "RSA PRIVATE KEY");
              return h2.getKey(m2, null, "pkcs5prv");
            }
            if (-1 != t3.indexOf("-END DSA PRIVATE KEY-") && -1 == t3.indexOf("4,ENCRYPTED")) {
              var _2 = i2(R2 = c2(t3, "DSA PRIVATE KEY"), 0, [1], "02"), S2 = i2(R2, 0, [2], "02"), b2 = i2(R2, 0, [3], "02"), F2 = i2(R2, 0, [4], "02"), E = i2(R2, 0, [5], "02");
              return (P2 = new a2()).setPrivate(new w(_2, 16), new w(S2, 16), new w(b2, 16), new w(F2, 16), new w(E, 16)), P2;
            }
            if (-1 != t3.indexOf("-END EC PRIVATE KEY-") && -1 == t3.indexOf("4,ENCRYPTED")) {
              m2 = c2(t3, "EC PRIVATE KEY");
              return h2.getKey(m2, null, "pkcs5prv");
            }
            if (-1 != t3.indexOf("-END PRIVATE KEY-")) return h2.getKeyFromPlainPrivatePKCS8PEM(t3);
            if (-1 != t3.indexOf("-END RSA PRIVATE KEY-") && -1 != t3.indexOf("4,ENCRYPTED")) {
              var x = h2.getDecryptedKeyHex(t3, e2), A = new Me();
              return A.readPKCS5PrvKeyHex(x), A;
            }
            if (-1 != t3.indexOf("-END EC PRIVATE KEY-") && -1 != t3.indexOf("4,ENCRYPTED")) {
              var k2, P2 = i2(R2 = h2.getDecryptedKeyHex(t3, e2), 0, [1], "04"), C2 = i2(R2, 0, [2, 0], "06"), T2 = i2(R2, 0, [3, 0], "03").substr(2);
              if (void 0 === Sr.crypto.OID.oidhex2name[C2]) throw new Error("undefined OID(hex) in KJUR.crypto.OID: " + C2);
              return (k2 = new s2({ curve: Sr.crypto.OID.oidhex2name[C2] })).setPublicKeyHex(T2), k2.setPrivateKeyHex(P2), k2.isPublic = false, k2;
            }
            if (-1 != t3.indexOf("-END DSA PRIVATE KEY-") && -1 != t3.indexOf("4,ENCRYPTED")) {
              var R2;
              _2 = i2(R2 = h2.getDecryptedKeyHex(t3, e2), 0, [1], "02"), S2 = i2(R2, 0, [2], "02"), b2 = i2(R2, 0, [3], "02"), F2 = i2(R2, 0, [4], "02"), E = i2(R2, 0, [5], "02");
              return (P2 = new a2()).setPrivate(new w(_2, 16), new w(S2, 16), new w(b2, 16), new w(F2, 16), new w(E, 16)), P2;
            }
            if (-1 != t3.indexOf("-END ENCRYPTED PRIVATE KEY-")) return h2.getKeyFromEncryptedPKCS8PEM(t3, e2);
            throw new Error("not supported argument");
          }, tn.generateKeypair = function(t3, e2) {
            if ("RSA" == t3) {
              var r3 = e2;
              (s2 = new Me()).generate(r3, "10001"), s2.isPrivate = true, s2.isPublic = true;
              var n2 = new Me(), i2 = s2.n.toString(16), o2 = s2.e.toString(16);
              return n2.setPublic(i2, o2), n2.isPrivate = false, n2.isPublic = true, (a2 = {}).prvKeyObj = s2, a2.pubKeyObj = n2, a2;
            }
            if ("EC" == t3) {
              var s2, a2, u2 = e2, c2 = new Sr.crypto.ECDSA({ curve: u2 }).generateKeyPairHex();
              return (s2 = new Sr.crypto.ECDSA({ curve: u2 })).setPublicKeyHex(c2.ecpubhex), s2.setPrivateKeyHex(c2.ecprvhex), s2.isPrivate = true, s2.isPublic = false, (n2 = new Sr.crypto.ECDSA({ curve: u2 })).setPublicKeyHex(c2.ecpubhex), n2.isPrivate = false, n2.isPublic = true, (a2 = {}).prvKeyObj = s2, a2.pubKeyObj = n2, a2;
            }
            throw new Error("unknown algorithm: " + t3);
          }, tn.getPEM = function(t3, e2, r3, n2, i2, o2) {
            var s2 = Sr, a2 = s2.asn1, u2 = a2.DERObjectIdentifier, c2 = a2.DERInteger, h2 = a2.ASN1Util.newObject, l2 = a2.x509.SubjectPublicKeyInfo, f2 = s2.crypto, g2 = f2.DSA, d2 = f2.ECDSA, p2 = Me;
            function y2(t4) {
              return h2({ seq: [{ int: 0 }, { int: { bigint: t4.n } }, { int: t4.e }, { int: { bigint: t4.d } }, { int: { bigint: t4.p } }, { int: { bigint: t4.q } }, { int: { bigint: t4.dmp1 } }, { int: { bigint: t4.dmq1 } }, { int: { bigint: t4.coeff } }] });
            }
            function m2(t4) {
              return h2({ seq: [{ int: 1 }, { octstr: { hex: t4.prvKeyHex } }, { tag: ["a0", true, { oid: { name: t4.curveName } }] }, { tag: ["a1", true, { bitstr: { hex: "00" + t4.pubKeyHex } }] }] });
            }
            function _2(t4) {
              return h2({ seq: [{ int: 0 }, { int: { bigint: t4.p } }, { int: { bigint: t4.q } }, { int: { bigint: t4.g } }, { int: { bigint: t4.y } }, { int: { bigint: t4.x } }] });
            }
            if ((void 0 !== p2 && t3 instanceof p2 || void 0 !== g2 && t3 instanceof g2 || void 0 !== d2 && t3 instanceof d2) && 1 == t3.isPublic && (void 0 === e2 || "PKCS8PUB" == e2)) return jr(F2 = new l2(t3).getEncodedHex(), "PUBLIC KEY");
            if ("PKCS1PRV" == e2 && void 0 !== p2 && t3 instanceof p2 && (void 0 === r3 || null == r3) && 1 == t3.isPrivate) return jr(F2 = y2(t3).getEncodedHex(), "RSA PRIVATE KEY");
            if ("PKCS1PRV" == e2 && void 0 !== d2 && t3 instanceof d2 && (void 0 === r3 || null == r3) && 1 == t3.isPrivate) {
              var S2 = new u2({ name: t3.curveName }).getEncodedHex(), b2 = m2(t3).getEncodedHex(), w2 = "";
              return w2 += jr(S2, "EC PARAMETERS"), w2 += jr(b2, "EC PRIVATE KEY");
            }
            if ("PKCS1PRV" == e2 && void 0 !== g2 && t3 instanceof g2 && (void 0 === r3 || null == r3) && 1 == t3.isPrivate) return jr(F2 = _2(t3).getEncodedHex(), "DSA PRIVATE KEY");
            if ("PKCS5PRV" == e2 && void 0 !== p2 && t3 instanceof p2 && void 0 !== r3 && null != r3 && 1 == t3.isPrivate) {
              var F2 = y2(t3).getEncodedHex();
              return void 0 === n2 && (n2 = "DES-EDE3-CBC"), this.getEncryptedPKCS5PEMFromPrvKeyHex("RSA", F2, r3, n2, o2);
            }
            if ("PKCS5PRV" == e2 && void 0 !== d2 && t3 instanceof d2 && void 0 !== r3 && null != r3 && 1 == t3.isPrivate) {
              F2 = m2(t3).getEncodedHex();
              return void 0 === n2 && (n2 = "DES-EDE3-CBC"), this.getEncryptedPKCS5PEMFromPrvKeyHex("EC", F2, r3, n2, o2);
            }
            if ("PKCS5PRV" == e2 && void 0 !== g2 && t3 instanceof g2 && void 0 !== r3 && null != r3 && 1 == t3.isPrivate) {
              F2 = _2(t3).getEncodedHex();
              return void 0 === n2 && (n2 = "DES-EDE3-CBC"), this.getEncryptedPKCS5PEMFromPrvKeyHex("DSA", F2, r3, n2, o2);
            }
            var E = function t4(e3, r4) {
              var n3 = x(e3, r4);
              return new h2({ seq: [{ seq: [{ oid: { name: "pkcs5PBES2" } }, { seq: [{ seq: [{ oid: { name: "pkcs5PBKDF2" } }, { seq: [{ octstr: { hex: n3.pbkdf2Salt } }, { int: n3.pbkdf2Iter }] }] }, { seq: [{ oid: { name: "des-EDE3-CBC" } }, { octstr: { hex: n3.encryptionSchemeIV } }] }] }] }, { octstr: { hex: n3.ciphertext } }] }).getEncodedHex();
            }, x = function t4(e3, r4) {
              var n3 = v.lib.WordArray.random(8), i3 = v.lib.WordArray.random(8), o3 = v.PBKDF2(r4, n3, { keySize: 6, iterations: 100 }), s3 = v.enc.Hex.parse(e3), a3 = v.TripleDES.encrypt(s3, o3, { iv: i3 }) + "", u3 = {};
              return u3.ciphertext = a3, u3.pbkdf2Salt = v.enc.Hex.stringify(n3), u3.pbkdf2Iter = 100, u3.encryptionSchemeAlg = "DES-EDE3-CBC", u3.encryptionSchemeIV = v.enc.Hex.stringify(i3), u3;
            };
            if ("PKCS8PRV" == e2 && null != p2 && t3 instanceof p2 && 1 == t3.isPrivate) {
              var A = y2(t3).getEncodedHex();
              F2 = h2({ seq: [{ int: 0 }, { seq: [{ oid: { name: "rsaEncryption" } }, { null: true }] }, { octstr: { hex: A } }] }).getEncodedHex();
              return void 0 === r3 || null == r3 ? jr(F2, "PRIVATE KEY") : jr(b2 = E(F2, r3), "ENCRYPTED PRIVATE KEY");
            }
            if ("PKCS8PRV" == e2 && void 0 !== d2 && t3 instanceof d2 && 1 == t3.isPrivate) {
              A = new h2({ seq: [{ int: 1 }, { octstr: { hex: t3.prvKeyHex } }, { tag: ["a1", true, { bitstr: { hex: "00" + t3.pubKeyHex } }] }] }).getEncodedHex(), F2 = h2({ seq: [{ int: 0 }, { seq: [{ oid: { name: "ecPublicKey" } }, { oid: { name: t3.curveName } }] }, { octstr: { hex: A } }] }).getEncodedHex();
              return void 0 === r3 || null == r3 ? jr(F2, "PRIVATE KEY") : jr(b2 = E(F2, r3), "ENCRYPTED PRIVATE KEY");
            }
            if ("PKCS8PRV" == e2 && void 0 !== g2 && t3 instanceof g2 && 1 == t3.isPrivate) {
              A = new c2({ bigint: t3.x }).getEncodedHex(), F2 = h2({ seq: [{ int: 0 }, { seq: [{ oid: { name: "dsa" } }, { seq: [{ int: { bigint: t3.p } }, { int: { bigint: t3.q } }, { int: { bigint: t3.g } }] }] }, { octstr: { hex: A } }] }).getEncodedHex();
              return void 0 === r3 || null == r3 ? jr(F2, "PRIVATE KEY") : jr(b2 = E(F2, r3), "ENCRYPTED PRIVATE KEY");
            }
            throw new Error("unsupported object nor format");
          }, tn.getKeyFromCSRPEM = function(t3) {
            var e2 = Mr(t3, "CERTIFICATE REQUEST");
            return tn.getKeyFromCSRHex(e2);
          }, tn.getKeyFromCSRHex = function(t3) {
            var e2 = tn.parseCSRHex(t3);
            return tn.getKey(e2.p8pubkeyhex, null, "pkcs8pub");
          }, tn.parseCSRHex = function(t3) {
            var e2 = Fr, r3 = e2.getChildIdx, n2 = e2.getTLV, i2 = {}, o2 = t3;
            if ("30" != o2.substr(0, 2)) throw new Error("malformed CSR(code:001)");
            var s2 = r3(o2, 0);
            if (s2.length < 1) throw new Error("malformed CSR(code:002)");
            if ("30" != o2.substr(s2[0], 2)) throw new Error("malformed CSR(code:003)");
            var a2 = r3(o2, s2[0]);
            if (a2.length < 3) throw new Error("malformed CSR(code:004)");
            return i2.p8pubkeyhex = n2(o2, a2[2]), i2;
          }, tn.getKeyID = function(t3) {
            var e2 = tn, r3 = Fr;
            "string" == typeof t3 && -1 != t3.indexOf("BEGIN ") && (t3 = e2.getKey(t3));
            var n2 = Mr(e2.getPEM(t3)), i2 = r3.getIdxbyList(n2, 0, [1]), o2 = r3.getV(n2, i2).substring(2);
            return Sr.crypto.Util.hashHex(o2, "sha1");
          }, tn.getJWKFromKey = function(t3) {
            var e2 = {};
            if (t3 instanceof Me && t3.isPrivate) return e2.kty = "RSA", e2.n = Tr(t3.n.toString(16)), e2.e = Tr(t3.e.toString(16)), e2.d = Tr(t3.d.toString(16)), e2.p = Tr(t3.p.toString(16)), e2.q = Tr(t3.q.toString(16)), e2.dp = Tr(t3.dmp1.toString(16)), e2.dq = Tr(t3.dmq1.toString(16)), e2.qi = Tr(t3.coeff.toString(16)), e2;
            if (t3 instanceof Me && t3.isPublic) return e2.kty = "RSA", e2.n = Tr(t3.n.toString(16)), e2.e = Tr(t3.e.toString(16)), e2;
            if (t3 instanceof Sr.crypto.ECDSA && t3.isPrivate) {
              if ("P-256" !== (n2 = t3.getShortNISTPCurveName()) && "P-384" !== n2) throw new Error("unsupported curve name for JWT: " + n2);
              var r3 = t3.getPublicKeyXYHex();
              return e2.kty = "EC", e2.crv = n2, e2.x = Tr(r3.x), e2.y = Tr(r3.y), e2.d = Tr(t3.prvKeyHex), e2;
            }
            if (t3 instanceof Sr.crypto.ECDSA && t3.isPublic) {
              var n2;
              if ("P-256" !== (n2 = t3.getShortNISTPCurveName()) && "P-384" !== n2) throw new Error("unsupported curve name for JWT: " + n2);
              r3 = t3.getPublicKeyXYHex();
              return e2.kty = "EC", e2.crv = n2, e2.x = Tr(r3.x), e2.y = Tr(r3.y), e2;
            }
            throw new Error("not supported key object");
          }, Me.getPosArrayOfChildrenFromHex = function(t3) {
            return Fr.getChildIdx(t3, 0);
          }, Me.getHexValueArrayOfChildrenFromHex = function(t3) {
            var e2, r3 = Fr.getV, n2 = r3(t3, (e2 = Me.getPosArrayOfChildrenFromHex(t3))[0]), i2 = r3(t3, e2[1]), o2 = r3(t3, e2[2]), s2 = r3(t3, e2[3]), a2 = r3(t3, e2[4]), u2 = r3(t3, e2[5]), c2 = r3(t3, e2[6]), h2 = r3(t3, e2[7]), l2 = r3(t3, e2[8]);
            return (e2 = new Array()).push(n2, i2, o2, s2, a2, u2, c2, h2, l2), e2;
          }, Me.prototype.readPrivateKeyFromPEMString = function(t3) {
            var e2 = Mr(t3), r3 = Me.getHexValueArrayOfChildrenFromHex(e2);
            this.setPrivateEx(r3[1], r3[2], r3[3], r3[4], r3[5], r3[6], r3[7], r3[8]);
          }, Me.prototype.readPKCS5PrvKeyHex = function(t3) {
            var e2 = Me.getHexValueArrayOfChildrenFromHex(t3);
            this.setPrivateEx(e2[1], e2[2], e2[3], e2[4], e2[5], e2[6], e2[7], e2[8]);
          }, Me.prototype.readPKCS8PrvKeyHex = function(t3) {
            var e2, r3, n2, i2, o2, s2, a2, u2, c2 = Fr, h2 = c2.getVbyListEx;
            if (false === c2.isASN1HEX(t3)) throw new Error("not ASN.1 hex string");
            try {
              e2 = h2(t3, 0, [2, 0, 1], "02"), r3 = h2(t3, 0, [2, 0, 2], "02"), n2 = h2(t3, 0, [2, 0, 3], "02"), i2 = h2(t3, 0, [2, 0, 4], "02"), o2 = h2(t3, 0, [2, 0, 5], "02"), s2 = h2(t3, 0, [2, 0, 6], "02"), a2 = h2(t3, 0, [2, 0, 7], "02"), u2 = h2(t3, 0, [2, 0, 8], "02");
            } catch (t4) {
              throw new Error("malformed PKCS#8 plain RSA private key");
            }
            this.setPrivateEx(e2, r3, n2, i2, o2, s2, a2, u2);
          }, Me.prototype.readPKCS5PubKeyHex = function(t3) {
            var e2 = Fr, r3 = e2.getV;
            if (false === e2.isASN1HEX(t3)) throw new Error("keyHex is not ASN.1 hex string");
            var n2 = e2.getChildIdx(t3, 0);
            if (2 !== n2.length || "02" !== t3.substr(n2[0], 2) || "02" !== t3.substr(n2[1], 2)) throw new Error("wrong hex for PKCS#5 public key");
            var i2 = r3(t3, n2[0]), o2 = r3(t3, n2[1]);
            this.setPublic(i2, o2);
          }, Me.prototype.readPKCS8PubKeyHex = function(t3) {
            var e2 = Fr;
            if (false === e2.isASN1HEX(t3)) throw new Error("not ASN.1 hex string");
            if ("06092a864886f70d010101" !== e2.getTLVbyListEx(t3, 0, [0, 0])) throw new Error("not PKCS8 RSA public key");
            var r3 = e2.getTLVbyListEx(t3, 0, [1, 0]);
            this.readPKCS5PubKeyHex(r3);
          }, Me.prototype.readCertPubKeyHex = function(t3, e2) {
            var r3, n2;
            (r3 = new on()).readCertHex(t3), n2 = r3.getPublicKeyHex(), this.readPKCS8PubKeyHex(n2);
          };
          new RegExp("[^0-9a-f]", "gi");
          function en(t3, e2) {
            for (var r3 = "", n2 = e2 / 4 - t3.length, i2 = 0; i2 < n2; i2++) r3 += "0";
            return r3 + t3;
          }
          function rn(t3, e2, r3) {
            for (var n2 = "", i2 = 0; n2.length < e2; ) n2 += Lr(r3(Nr(t3 + String.fromCharCode.apply(String, [(4278190080 & i2) >> 24, (16711680 & i2) >> 16, (65280 & i2) >> 8, 255 & i2])))), i2 += 1;
            return n2;
          }
          function nn(t3) {
            for (var e2 in Sr.crypto.Util.DIGESTINFOHEAD) {
              var r3 = Sr.crypto.Util.DIGESTINFOHEAD[e2], n2 = r3.length;
              if (t3.substring(0, n2) == r3) return [e2, t3.substring(n2)];
            }
            return [];
          }
          function on(t3) {
            var e2, r3 = Fr, n2 = r3.getChildIdx, i2 = r3.getV, o2 = r3.getTLV, s2 = r3.getVbyList, a2 = r3.getVbyListEx, u2 = r3.getTLVbyList, c2 = r3.getTLVbyListEx, h2 = r3.getIdxbyList, l2 = r3.getIdxbyListEx, f2 = r3.getVidx, g2 = r3.getInt, d2 = r3.oidname, p2 = r3.hextooidstr, v2 = Mr;
            try {
              e2 = Sr.asn1.x509.AlgorithmIdentifier.PSSNAME2ASN1TLV;
            } catch (t4) {
            }
            this.HEX2STAG = { "0c": "utf8", 13: "prn", 16: "ia5", "1a": "vis", "1e": "bmp" }, this.hex = null, this.version = 0, this.foffset = 0, this.aExtInfo = null, this.getVersion = function() {
              if (null === this.hex || 0 !== this.version) return this.version;
              var t4 = u2(this.hex, 0, [0, 0]);
              if ("a0" == t4.substr(0, 2)) {
                var e3 = u2(t4, 0, [0]), r4 = g2(e3, 0);
                if (r4 < 0 || 2 < r4) throw new Error("malformed version field");
                return this.version = r4 + 1, this.version;
              }
              return this.version = 1, this.foffset = -1, 1;
            }, this.getSerialNumberHex = function() {
              return a2(this.hex, 0, [0, 0], "02");
            }, this.getSignatureAlgorithmField = function() {
              var t4 = c2(this.hex, 0, [0, 1]);
              return this.getAlgorithmIdentifierName(t4);
            }, this.getAlgorithmIdentifierName = function(t4) {
              for (var r4 in e2) if (t4 === e2[r4]) return r4;
              return d2(a2(t4, 0, [0], "06"));
            }, this.getIssuer = function() {
              return this.getX500Name(this.getIssuerHex());
            }, this.getIssuerHex = function() {
              return u2(this.hex, 0, [0, 3 + this.foffset], "30");
            }, this.getIssuerString = function() {
              return this.getIssuer().str;
            }, this.getSubject = function() {
              return this.getX500Name(this.getSubjectHex());
            }, this.getSubjectHex = function() {
              return u2(this.hex, 0, [0, 5 + this.foffset], "30");
            }, this.getSubjectString = function() {
              return this.getSubject().str;
            }, this.getNotBefore = function() {
              var t4 = s2(this.hex, 0, [0, 4 + this.foffset, 0]);
              return t4 = t4.replace(/(..)/g, "%$1"), t4 = decodeURIComponent(t4);
            }, this.getNotAfter = function() {
              var t4 = s2(this.hex, 0, [0, 4 + this.foffset, 1]);
              return t4 = t4.replace(/(..)/g, "%$1"), t4 = decodeURIComponent(t4);
            }, this.getPublicKeyHex = function() {
              return r3.getTLVbyList(this.hex, 0, [0, 6 + this.foffset], "30");
            }, this.getPublicKeyIdx = function() {
              return h2(this.hex, 0, [0, 6 + this.foffset], "30");
            }, this.getPublicKeyContentIdx = function() {
              var t4 = this.getPublicKeyIdx();
              return h2(this.hex, t4, [1, 0], "30");
            }, this.getPublicKey = function() {
              return tn.getKey(this.getPublicKeyHex(), null, "pkcs8pub");
            }, this.getSignatureAlgorithmName = function() {
              var t4 = u2(this.hex, 0, [1], "30");
              return this.getAlgorithmIdentifierName(t4);
            }, this.getSignatureValueHex = function() {
              return s2(this.hex, 0, [2], "03", true);
            }, this.verifySignature = function(t4) {
              var e3 = this.getSignatureAlgorithmField(), r4 = this.getSignatureValueHex(), n3 = u2(this.hex, 0, [0], "30"), i3 = new Sr.crypto.Signature({ alg: e3 });
              return i3.init(t4), i3.updateHex(n3), i3.verify(r4);
            }, this.parseExt = function(t4) {
              var e3, o3, a3;
              if (void 0 === t4) {
                if (a3 = this.hex, 3 !== this.version) return -1;
                e3 = h2(a3, 0, [0, 7, 0], "30"), o3 = n2(a3, e3);
              } else {
                a3 = Mr(t4);
                var u3 = h2(a3, 0, [0, 3, 0, 0], "06");
                if ("2a864886f70d01090e" != i2(a3, u3)) return void (this.aExtInfo = new Array());
                e3 = h2(a3, 0, [0, 3, 0, 1, 0], "30"), o3 = n2(a3, e3), this.hex = a3;
              }
              this.aExtInfo = new Array();
              for (var c3 = 0; c3 < o3.length; c3++) {
                var l3 = { critical: false }, g3 = 0;
                3 === n2(a3, o3[c3]).length && (l3.critical = true, g3 = 1), l3.oid = r3.hextooidstr(s2(a3, o3[c3], [0], "06"));
                var d3 = h2(a3, o3[c3], [1 + g3]);
                l3.vidx = f2(a3, d3), this.aExtInfo.push(l3);
              }
            }, this.getExtInfo = function(t4) {
              var e3 = this.aExtInfo, r4 = t4;
              if (t4.match(/^[0-9.]+$/) || (r4 = Sr.asn1.x509.OID.name2oid(t4)), "" !== r4) {
                for (var n3 = 0; n3 < e3.length; n3++) if (e3[n3].oid === r4) return e3[n3];
              }
            }, this.getExtBasicConstraints = function(t4, e3) {
              if (void 0 === t4 && void 0 === e3) {
                var r4 = this.getExtInfo("basicConstraints");
                if (void 0 === r4) return;
                t4 = o2(this.hex, r4.vidx), e3 = r4.critical;
              }
              var n3 = { extname: "basicConstraints" };
              if (e3 && (n3.critical = true), "3000" === t4) return n3;
              if ("30030101ff" === t4) return n3.cA = true, n3;
              if ("30060101ff02" === t4.substr(0, 12)) {
                var s3 = i2(t4, 10), a3 = parseInt(s3, 16);
                return n3.cA = true, n3.pathLen = a3, n3;
              }
              throw new Error("hExtV parse error: " + t4);
            }, this.getExtKeyUsage = function(t4, e3) {
              if (void 0 === t4 && void 0 === e3) {
                var r4 = this.getExtInfo("keyUsage");
                if (void 0 === r4) return;
                t4 = o2(this.hex, r4.vidx), e3 = r4.critical;
              }
              var n3 = { extname: "keyUsage" };
              return e3 && (n3.critical = true), n3.names = this.getExtKeyUsageString(t4).split(","), n3;
            }, this.getExtKeyUsageBin = function(t4) {
              if (void 0 === t4) {
                var e3 = this.getExtInfo("keyUsage");
                if (void 0 === e3) return "";
                t4 = o2(this.hex, e3.vidx);
              }
              if (8 != t4.length && 10 != t4.length) throw new Error("malformed key usage value: " + t4);
              var r4 = "000000000000000" + parseInt(t4.substr(6), 16).toString(2);
              return 8 == t4.length && (r4 = r4.slice(-8)), 10 == t4.length && (r4 = r4.slice(-16)), "" == (r4 = r4.replace(/0+$/, "")) && (r4 = "0"), r4;
            }, this.getExtKeyUsageString = function(t4) {
              for (var e3 = this.getExtKeyUsageBin(t4), r4 = new Array(), n3 = 0; n3 < e3.length; n3++) "1" == e3.substr(n3, 1) && r4.push(on.KEYUSAGE_NAME[n3]);
              return r4.join(",");
            }, this.getExtSubjectKeyIdentifier = function(t4, e3) {
              if (void 0 === t4 && void 0 === e3) {
                var r4 = this.getExtInfo("subjectKeyIdentifier");
                if (void 0 === r4) return;
                t4 = o2(this.hex, r4.vidx), e3 = r4.critical;
              }
              var n3 = { extname: "subjectKeyIdentifier" };
              e3 && (n3.critical = true);
              var s3 = i2(t4, 0);
              return n3.kid = { hex: s3 }, n3;
            }, this.getExtAuthorityKeyIdentifier = function(t4, e3) {
              if (void 0 === t4 && void 0 === e3) {
                var r4 = this.getExtInfo("authorityKeyIdentifier");
                if (void 0 === r4) return;
                t4 = o2(this.hex, r4.vidx), e3 = r4.critical;
              }
              var s3 = { extname: "authorityKeyIdentifier" };
              e3 && (s3.critical = true);
              for (var a3 = n2(t4, 0), u3 = 0; u3 < a3.length; u3++) {
                var c3 = t4.substr(a3[u3], 2);
                if ("80" === c3 && (s3.kid = { hex: i2(t4, a3[u3]) }), "a1" === c3) {
                  var h3 = o2(t4, a3[u3]), l3 = this.getGeneralNames(h3);
                  s3.issuer = l3[0].dn;
                }
                "82" === c3 && (s3.sn = { hex: i2(t4, a3[u3]) });
              }
              return s3;
            }, this.getExtExtKeyUsage = function(t4, e3) {
              if (void 0 === t4 && void 0 === e3) {
                var r4 = this.getExtInfo("extKeyUsage");
                if (void 0 === r4) return;
                t4 = o2(this.hex, r4.vidx), e3 = r4.critical;
              }
              var s3 = { extname: "extKeyUsage", array: [] };
              e3 && (s3.critical = true);
              for (var a3 = n2(t4, 0), u3 = 0; u3 < a3.length; u3++) s3.array.push(d2(i2(t4, a3[u3])));
              return s3;
            }, this.getExtExtKeyUsageName = function() {
              var t4 = this.getExtInfo("extKeyUsage");
              if (void 0 === t4) return t4;
              var e3 = new Array(), r4 = o2(this.hex, t4.vidx);
              if ("" === r4) return e3;
              for (var s3 = n2(r4, 0), a3 = 0; a3 < s3.length; a3++) e3.push(d2(i2(r4, s3[a3])));
              return e3;
            }, this.getExtSubjectAltName = function(t4, e3) {
              if (void 0 === t4 && void 0 === e3) {
                var r4 = this.getExtInfo("subjectAltName");
                if (void 0 === r4) return;
                t4 = o2(this.hex, r4.vidx), e3 = r4.critical;
              }
              var n3 = { extname: "subjectAltName", array: [] };
              return e3 && (n3.critical = true), n3.array = this.getGeneralNames(t4), n3;
            }, this.getExtIssuerAltName = function(t4, e3) {
              if (void 0 === t4 && void 0 === e3) {
                var r4 = this.getExtInfo("issuerAltName");
                if (void 0 === r4) return;
                t4 = o2(this.hex, r4.vidx), e3 = r4.critical;
              }
              var n3 = { extname: "issuerAltName", array: [] };
              return e3 && (n3.critical = true), n3.array = this.getGeneralNames(t4), n3;
            }, this.getGeneralNames = function(t4) {
              for (var e3 = n2(t4, 0), r4 = [], i3 = 0; i3 < e3.length; i3++) {
                var s3 = this.getGeneralName(o2(t4, e3[i3]));
                void 0 !== s3 && r4.push(s3);
              }
              return r4;
            }, this.getGeneralName = function(t4) {
              var e3 = t4.substr(0, 2), r4 = i2(t4, 0), n3 = Lr(r4);
              return "81" == e3 ? { rfc822: n3 } : "82" == e3 ? { dns: n3 } : "86" == e3 ? { uri: n3 } : "87" == e3 ? { ip: zr(r4) } : "a4" == e3 ? { dn: this.getX500Name(r4) } : void 0;
            }, this.getExtSubjectAltName2 = function() {
              var t4, e3, r4, s3 = this.getExtInfo("subjectAltName");
              if (void 0 === s3) return s3;
              for (var a3 = new Array(), u3 = o2(this.hex, s3.vidx), c3 = n2(u3, 0), h3 = 0; h3 < c3.length; h3++) r4 = u3.substr(c3[h3], 2), t4 = i2(u3, c3[h3]), "81" === r4 && (e3 = Dr(t4), a3.push(["MAIL", e3])), "82" === r4 && (e3 = Dr(t4), a3.push(["DNS", e3])), "84" === r4 && (e3 = on.hex2dn(t4, 0), a3.push(["DN", e3])), "86" === r4 && (e3 = Dr(t4), a3.push(["URI", e3])), "87" === r4 && (e3 = zr(t4), a3.push(["IP", e3]));
              return a3;
            }, this.getExtCRLDistributionPoints = function(t4, e3) {
              if (void 0 === t4 && void 0 === e3) {
                var r4 = this.getExtInfo("cRLDistributionPoints");
                if (void 0 === r4) return;
                t4 = o2(this.hex, r4.vidx), e3 = r4.critical;
              }
              var i3 = { extname: "cRLDistributionPoints", array: [] };
              e3 && (i3.critical = true);
              for (var s3 = n2(t4, 0), a3 = 0; a3 < s3.length; a3++) {
                var u3 = o2(t4, s3[a3]);
                i3.array.push(this.getDistributionPoint(u3));
              }
              return i3;
            }, this.getDistributionPoint = function(t4) {
              for (var e3 = {}, r4 = n2(t4, 0), i3 = 0; i3 < r4.length; i3++) {
                var s3 = t4.substr(r4[i3], 2), a3 = o2(t4, r4[i3]);
                "a0" == s3 && (e3.dpname = this.getDistributionPointName(a3));
              }
              return e3;
            }, this.getDistributionPointName = function(t4) {
              for (var e3 = {}, r4 = n2(t4, 0), i3 = 0; i3 < r4.length; i3++) {
                var s3 = t4.substr(r4[i3], 2), a3 = o2(t4, r4[i3]);
                "a0" == s3 && (e3.full = this.getGeneralNames(a3));
              }
              return e3;
            }, this.getExtCRLDistributionPointsURI = function() {
              var t4 = this.getExtInfo("cRLDistributionPoints");
              if (void 0 === t4) return t4;
              for (var e3 = new Array(), r4 = n2(this.hex, t4.vidx), i3 = 0; i3 < r4.length; i3++) try {
                var o3 = Dr(s2(this.hex, r4[i3], [0, 0, 0], "86"));
                e3.push(o3);
              } catch (t5) {
              }
              return e3;
            }, this.getExtAIAInfo = function() {
              var t4 = this.getExtInfo("authorityInfoAccess");
              if (void 0 === t4) return t4;
              for (var e3 = { ocsp: [], caissuer: [] }, r4 = n2(this.hex, t4.vidx), i3 = 0; i3 < r4.length; i3++) {
                var o3 = s2(this.hex, r4[i3], [0], "06"), a3 = s2(this.hex, r4[i3], [1], "86");
                "2b06010505073001" === o3 && e3.ocsp.push(Dr(a3)), "2b06010505073002" === o3 && e3.caissuer.push(Dr(a3));
              }
              return e3;
            }, this.getExtAuthorityInfoAccess = function(t4, e3) {
              if (void 0 === t4 && void 0 === e3) {
                var r4 = this.getExtInfo("authorityInfoAccess");
                if (void 0 === r4) return;
                t4 = o2(this.hex, r4.vidx), e3 = r4.critical;
              }
              var i3 = { extname: "authorityInfoAccess", array: [] };
              e3 && (i3.critical = true);
              for (var u3 = n2(t4, 0), c3 = 0; c3 < u3.length; c3++) {
                var h3 = a2(t4, u3[c3], [0], "06"), l3 = Dr(s2(t4, u3[c3], [1], "86"));
                if ("2b06010505073001" == h3) i3.array.push({ ocsp: l3 });
                else {
                  if ("2b06010505073002" != h3) throw new Error("unknown method: " + h3);
                  i3.array.push({ caissuer: l3 });
                }
              }
              return i3;
            }, this.getExtCertificatePolicies = function(t4, e3) {
              if (void 0 === t4 && void 0 === e3) {
                var r4 = this.getExtInfo("certificatePolicies");
                if (void 0 === r4) return;
                t4 = o2(this.hex, r4.vidx), e3 = r4.critical;
              }
              var i3 = { extname: "certificatePolicies", array: [] };
              e3 && (i3.critical = true);
              for (var s3 = n2(t4, 0), a3 = 0; a3 < s3.length; a3++) {
                var u3 = o2(t4, s3[a3]), c3 = this.getPolicyInformation(u3);
                i3.array.push(c3);
              }
              return i3;
            }, this.getPolicyInformation = function(t4) {
              var e3 = {}, r4 = s2(t4, 0, [0], "06");
              e3.policyoid = d2(r4);
              var i3 = l2(t4, 0, [1], "30");
              if (-1 != i3) {
                e3.array = [];
                for (var a3 = n2(t4, i3), u3 = 0; u3 < a3.length; u3++) {
                  var c3 = o2(t4, a3[u3]), h3 = this.getPolicyQualifierInfo(c3);
                  e3.array.push(h3);
                }
              }
              return e3;
            }, this.getPolicyQualifierInfo = function(t4) {
              var e3 = {}, r4 = s2(t4, 0, [0], "06");
              if ("2b06010505070201" === r4) {
                var n3 = a2(t4, 0, [1], "16");
                e3.cps = Lr(n3);
              } else if ("2b06010505070202" === r4) {
                var i3 = u2(t4, 0, [1], "30");
                e3.unotice = this.getUserNotice(i3);
              }
              return e3;
            }, this.getUserNotice = function(t4) {
              for (var e3 = {}, r4 = n2(t4, 0), i3 = 0; i3 < r4.length; i3++) {
                var s3 = o2(t4, r4[i3]);
                "30" != s3.substr(0, 2) && (e3.exptext = this.getDisplayText(s3));
              }
              return e3;
            }, this.getDisplayText = function(t4) {
              var e3 = {};
              return e3.type = { "0c": "utf8", 16: "ia5", "1a": "vis", "1e": "bmp" }[t4.substr(0, 2)], e3.str = Lr(i2(t4, 0)), e3;
            }, this.getExtCRLNumber = function(t4, e3) {
              var r4 = { extname: "cRLNumber" };
              if (e3 && (r4.critical = true), "02" == t4.substr(0, 2)) return r4.num = { hex: i2(t4, 0) }, r4;
              throw new Error("hExtV parse error: " + t4);
            }, this.getExtCRLReason = function(t4, e3) {
              var r4 = { extname: "cRLReason" };
              if (e3 && (r4.critical = true), "0a" == t4.substr(0, 2)) return r4.code = parseInt(i2(t4, 0), 16), r4;
              throw new Error("hExtV parse error: " + t4);
            }, this.getExtOcspNonce = function(t4, e3) {
              var r4 = { extname: "ocspNonce" };
              e3 && (r4.critical = true);
              var n3 = i2(t4, 0);
              return r4.hex = n3, r4;
            }, this.getExtOcspNoCheck = function(t4, e3) {
              var r4 = { extname: "ocspNoCheck" };
              return e3 && (r4.critical = true), r4;
            }, this.getExtAdobeTimeStamp = function(t4, e3) {
              if (void 0 === t4 && void 0 === e3) {
                var r4 = this.getExtInfo("adobeTimeStamp");
                if (void 0 === r4) return;
                t4 = o2(this.hex, r4.vidx), e3 = r4.critical;
              }
              var i3 = { extname: "adobeTimeStamp" };
              e3 && (i3.critical = true);
              var s3 = n2(t4, 0);
              if (s3.length > 1) {
                var a3 = o2(t4, s3[1]), u3 = this.getGeneralName(a3);
                null != u3.uri && (i3.uri = u3.uri);
              }
              if (s3.length > 2) {
                var c3 = o2(t4, s3[2]);
                "0101ff" == c3 && (i3.reqauth = true), "010100" == c3 && (i3.reqauth = false);
              }
              return i3;
            }, this.getX500NameRule = function(t4) {
              for (var e3 = null, r4 = [], n3 = 0; n3 < t4.length; n3++) for (var i3 = t4[n3], o3 = 0; o3 < i3.length; o3++) r4.push(i3[o3]);
              for (n3 = 0; n3 < r4.length; n3++) {
                var s3 = r4[n3], a3 = s3.ds, u3 = s3.value, c3 = s3.type;
                if (":" + a3, "prn" != a3 && "utf8" != a3 && "ia5" != a3) return "mixed";
                if ("ia5" == a3) {
                  if ("CN" != c3) return "mixed";
                  if (Sr.lang.String.isMail(u3)) continue;
                  return "mixed";
                }
                if ("C" == c3) {
                  if ("prn" == a3) continue;
                  return "mixed";
                }
                if (":" + a3, null == e3) e3 = a3;
                else if (e3 !== a3) return "mixed";
              }
              return null == e3 ? "prn" : e3;
            }, this.getX500Name = function(t4) {
              var e3 = this.getX500NameArray(t4);
              return { array: e3, str: this.dnarraytostr(e3) };
            }, this.getX500NameArray = function(t4) {
              for (var e3 = [], r4 = n2(t4, 0), i3 = 0; i3 < r4.length; i3++) e3.push(this.getRDN(o2(t4, r4[i3])));
              return e3;
            }, this.getRDN = function(t4) {
              for (var e3 = [], r4 = n2(t4, 0), i3 = 0; i3 < r4.length; i3++) e3.push(this.getAttrTypeAndValue(o2(t4, r4[i3])));
              return e3;
            }, this.getAttrTypeAndValue = function(t4) {
              var e3 = { type: null, value: null, ds: null }, r4 = n2(t4, 0), i3 = s2(t4, r4[0], [], "06"), o3 = s2(t4, r4[1], []), a3 = Sr.asn1.ASN1Util.oidHexToInt(i3);
              return e3.type = Sr.asn1.x509.OID.oid2atype(a3), e3.ds = this.HEX2STAG[t4.substr(r4[1], 2)], "bmp" != e3.ds ? e3.value = Dr(o3) : e3.value = Yr(o3), e3;
            }, this.readCertPEM = function(t4) {
              this.readCertHex(v2(t4));
            }, this.readCertHex = function(t4) {
              this.hex = t4, this.getVersion();
              try {
                h2(this.hex, 0, [0, 7], "a3"), this.parseExt();
              } catch (t5) {
              }
            }, this.getParam = function() {
              var t4 = {};
              return t4.version = this.getVersion(), t4.serial = { hex: this.getSerialNumberHex() }, t4.sigalg = this.getSignatureAlgorithmField(), t4.issuer = this.getIssuer(), t4.notbefore = this.getNotBefore(), t4.notafter = this.getNotAfter(), t4.subject = this.getSubject(), t4.sbjpubkey = jr(this.getPublicKeyHex(), "PUBLIC KEY"), this.aExtInfo.length > 0 && (t4.ext = this.getExtParamArray()), t4.sighex = this.getSignatureValueHex(), t4;
            }, this.getExtParamArray = function(t4) {
              null == t4 && (-1 != l2(this.hex, 0, [0, "[3]"]) && (t4 = c2(this.hex, 0, [0, "[3]", 0], "30")));
              for (var e3 = [], r4 = n2(t4, 0), i3 = 0; i3 < r4.length; i3++) {
                var s3 = o2(t4, r4[i3]), a3 = this.getExtParam(s3);
                null != a3 && e3.push(a3);
              }
              return e3;
            }, this.getExtParam = function(t4) {
              var e3 = n2(t4, 0).length;
              if (2 != e3 && 3 != e3) throw new Error("wrong number elements in Extension: " + e3 + " " + t4);
              var r4 = p2(s2(t4, 0, [0], "06")), i3 = false;
              3 == e3 && "0101ff" == u2(t4, 0, [1]) && (i3 = true);
              var o3 = u2(t4, 0, [e3 - 1, 0]), a3 = void 0;
              if ("2.5.29.14" == r4 ? a3 = this.getExtSubjectKeyIdentifier(o3, i3) : "2.5.29.15" == r4 ? a3 = this.getExtKeyUsage(o3, i3) : "2.5.29.17" == r4 ? a3 = this.getExtSubjectAltName(o3, i3) : "2.5.29.18" == r4 ? a3 = this.getExtIssuerAltName(o3, i3) : "2.5.29.19" == r4 ? a3 = this.getExtBasicConstraints(o3, i3) : "2.5.29.31" == r4 ? a3 = this.getExtCRLDistributionPoints(o3, i3) : "2.5.29.32" == r4 ? a3 = this.getExtCertificatePolicies(o3, i3) : "2.5.29.35" == r4 ? a3 = this.getExtAuthorityKeyIdentifier(o3, i3) : "2.5.29.37" == r4 ? a3 = this.getExtExtKeyUsage(o3, i3) : "1.3.6.1.5.5.7.1.1" == r4 ? a3 = this.getExtAuthorityInfoAccess(o3, i3) : "2.5.29.20" == r4 ? a3 = this.getExtCRLNumber(o3, i3) : "2.5.29.21" == r4 ? a3 = this.getExtCRLReason(o3, i3) : "1.3.6.1.5.5.7.48.1.2" == r4 ? a3 = this.getExtOcspNonce(o3, i3) : "1.3.6.1.5.5.7.48.1.5" == r4 ? a3 = this.getExtOcspNoCheck(o3, i3) : "1.2.840.113583.1.1.9.1" == r4 && (a3 = this.getExtAdobeTimeStamp(o3, i3)), null != a3) return a3;
              var c3 = { extname: r4, extn: o3 };
              return i3 && (c3.critical = true), c3;
            }, this.findExt = function(t4, e3) {
              for (var r4 = 0; r4 < t4.length; r4++) if (t4[r4].extname == e3) return t4[r4];
              return null;
            }, this.updateExtCDPFullURI = function(t4, e3) {
              var r4 = this.findExt(t4, "cRLDistributionPoints");
              if (null != r4 && null != r4.array) {
                for (var n3 = r4.array, i3 = 0; i3 < n3.length; i3++) if (null != n3[i3].dpname && null != n3[i3].dpname.full) for (var o3 = n3[i3].dpname.full, s3 = 0; s3 < o3.length; s3++) {
                  var a3 = o3[i3];
                  null != a3.uri && (a3.uri = e3);
                }
              }
            }, this.updateExtAIAOCSP = function(t4, e3) {
              var r4 = this.findExt(t4, "authorityInfoAccess");
              if (null != r4 && null != r4.array) for (var n3 = r4.array, i3 = 0; i3 < n3.length; i3++) null != n3[i3].ocsp && (n3[i3].ocsp = e3);
            }, this.updateExtAIACAIssuer = function(t4, e3) {
              var r4 = this.findExt(t4, "authorityInfoAccess");
              if (null != r4 && null != r4.array) for (var n3 = r4.array, i3 = 0; i3 < n3.length; i3++) null != n3[i3].caissuer && (n3[i3].caissuer = e3);
            }, this.dnarraytostr = function(t4) {
              return "/" + t4.map((function(t5) {
                return (function e3(t6) {
                  return t6.map((function(t7) {
                    return (function e4(t8) {
                      return t8.type + "=" + t8.value;
                    })(t7).replace(/\+/, "\\+");
                  })).join("+");
                })(t5).replace(/\//, "\\/");
              })).join("/");
            }, this.getInfo = function() {
              var t4, e3, r4, n3 = function t5(e4) {
                return JSON.stringify(e4.array).replace(/[\[\]\{\}\"]/g, "");
              }, i3 = function t5(e4) {
                for (var r5 = "", n4 = e4.array, i4 = 0; i4 < n4.length; i4++) {
                  var o4 = n4[i4];
                  if (r5 += "    policy oid: " + o4.policyoid + "\n", void 0 !== o4.array) for (var s4 = 0; s4 < o4.array.length; s4++) {
                    var a4 = o4.array[s4];
                    void 0 !== a4.cps && (r5 += "    cps: " + a4.cps + "\n");
                  }
                }
                return r5;
              }, o3 = function t5(e4) {
                for (var r5 = "", n4 = e4.array, i4 = 0; i4 < n4.length; i4++) {
                  var o4 = n4[i4];
                  try {
                    void 0 !== o4.dpname.full[0].uri && (r5 += "    " + o4.dpname.full[0].uri + "\n");
                  } catch (t6) {
                  }
                  try {
                    void 0 !== o4.dname.full[0].dn.hex && (r5 += "    " + on.hex2dn(o4.dpname.full[0].dn.hex) + "\n");
                  } catch (t6) {
                  }
                }
                return r5;
              }, s3 = function t5(e4) {
                for (var r5 = "", n4 = e4.array, i4 = 0; i4 < n4.length; i4++) {
                  var o4 = n4[i4];
                  void 0 !== o4.caissuer && (r5 += "    caissuer: " + o4.caissuer + "\n"), void 0 !== o4.ocsp && (r5 += "    ocsp: " + o4.ocsp + "\n");
                }
                return r5;
              };
              if (t4 = "Basic Fields\n", t4 += "  serial number: " + this.getSerialNumberHex() + "\n", t4 += "  signature algorithm: " + this.getSignatureAlgorithmField() + "\n", t4 += "  issuer: " + this.getIssuerString() + "\n", t4 += "  notBefore: " + this.getNotBefore() + "\n", t4 += "  notAfter: " + this.getNotAfter() + "\n", t4 += "  subject: " + this.getSubjectString() + "\n", t4 += "  subject public key info: \n", t4 += "    key algorithm: " + (e3 = this.getPublicKey()).type + "\n", "RSA" === e3.type && (t4 += "    n=" + $r(e3.n.toString(16)).substr(0, 16) + "...\n", t4 += "    e=" + $r(e3.e.toString(16)) + "\n"), null != (r4 = this.aExtInfo)) {
                t4 += "X509v3 Extensions:\n";
                for (var a3 = 0; a3 < r4.length; a3++) {
                  var u3 = r4[a3], c3 = Sr.asn1.x509.OID.oid2name(u3.oid);
                  "" === c3 && (c3 = u3.oid);
                  var h3 = "";
                  if (true === u3.critical && (h3 = "CRITICAL"), t4 += "  " + c3 + " " + h3 + ":\n", "basicConstraints" === c3) {
                    var l3 = this.getExtBasicConstraints();
                    void 0 === l3.cA ? t4 += "    {}\n" : (t4 += "    cA=true", void 0 !== l3.pathLen && (t4 += ", pathLen=" + l3.pathLen), t4 += "\n");
                  } else if ("keyUsage" === c3) t4 += "    " + this.getExtKeyUsageString() + "\n";
                  else if ("subjectKeyIdentifier" === c3) t4 += "    " + this.getExtSubjectKeyIdentifier().kid.hex + "\n";
                  else if ("authorityKeyIdentifier" === c3) {
                    var f3 = this.getExtAuthorityKeyIdentifier();
                    void 0 !== f3.kid && (t4 += "    kid=" + f3.kid.hex + "\n");
                  } else {
                    if ("extKeyUsage" === c3) t4 += "    " + this.getExtExtKeyUsage().array.join(", ") + "\n";
                    else if ("subjectAltName" === c3) t4 += "    " + n3(this.getExtSubjectAltName()) + "\n";
                    else if ("cRLDistributionPoints" === c3) t4 += o3(this.getExtCRLDistributionPoints());
                    else if ("authorityInfoAccess" === c3) t4 += s3(this.getExtAuthorityInfoAccess());
                    else "certificatePolicies" === c3 && (t4 += i3(this.getExtCertificatePolicies()));
                  }
                }
              }
              return t4 += "signature algorithm: " + this.getSignatureAlgorithmName() + "\n", t4 += "signature: " + this.getSignatureValueHex().substr(0, 16) + "...\n";
            }, "string" == typeof t3 && (-1 != t3.indexOf("-----BEGIN") ? this.readCertPEM(t3) : Sr.lang.String.isHex(t3) && this.readCertHex(t3));
          }
          Me.prototype.sign = function(t3, e2) {
            var r3 = (function t4(r4) {
              return Sr.crypto.Util.hashString(r4, e2);
            })(t3);
            return this.signWithMessageHash(r3, e2);
          }, Me.prototype.signWithMessageHash = function(t3, e2) {
            var r3 = Oe(Sr.crypto.Util.getPaddedDigestInfoHex(t3, e2, this.n.bitLength()), 16);
            return en(this.doPrivate(r3).toString(16), this.n.bitLength());
          }, Me.prototype.signPSS = function(t3, e2, r3) {
            var n2 = (function t4(r4) {
              return Sr.crypto.Util.hashHex(r4, e2);
            })(Nr(t3));
            return void 0 === r3 && (r3 = -1), this.signWithMessageHashPSS(n2, e2, r3);
          }, Me.prototype.signWithMessageHashPSS = function(t3, e2, r3) {
            var n2, i2 = Lr(t3), o2 = i2.length, s2 = this.n.bitLength() - 1, a2 = Math.ceil(s2 / 8), u2 = function t4(r4) {
              return Sr.crypto.Util.hashHex(r4, e2);
            };
            if (-1 === r3 || void 0 === r3) r3 = o2;
            else if (-2 === r3) r3 = a2 - o2 - 2;
            else if (r3 < -2) throw new Error("invalid salt length");
            if (a2 < o2 + r3 + 2) throw new Error("data too long");
            var c2 = "";
            r3 > 0 && (c2 = new Array(r3), new Be().nextBytes(c2), c2 = String.fromCharCode.apply(String, c2));
            var h2 = Lr(u2(Nr("\0\0\0\0\0\0\0\0" + i2 + c2))), l2 = [];
            for (n2 = 0; n2 < a2 - r3 - o2 - 2; n2 += 1) l2[n2] = 0;
            var f2 = String.fromCharCode.apply(String, l2) + "" + c2, g2 = rn(h2, f2.length, u2), d2 = [];
            for (n2 = 0; n2 < f2.length; n2 += 1) d2[n2] = f2.charCodeAt(n2) ^ g2.charCodeAt(n2);
            var p2 = 65280 >> 8 * a2 - s2 & 255;
            for (d2[0] &= ~p2, n2 = 0; n2 < o2; n2++) d2.push(h2.charCodeAt(n2));
            return d2.push(188), en(this.doPrivate(new w(d2)).toString(16), this.n.bitLength());
          }, Me.prototype.verify = function(t3, e2) {
            if (null == (e2 = e2.toLowerCase()).match(/^[0-9a-f]+$/)) return false;
            var r3 = Oe(e2, 16), n2 = this.n.bitLength();
            if (r3.bitLength() > n2) return false;
            var i2 = this.doPublic(r3).toString(16);
            if (i2.length + 3 != n2 / 4) return false;
            var o2 = nn(i2.replace(/^1f+00/, ""));
            if (0 == o2.length) return false;
            var s2 = o2[0];
            return o2[1] == (function t4(e3) {
              return Sr.crypto.Util.hashString(e3, s2);
            })(t3);
          }, Me.prototype.verifyWithMessageHash = function(t3, e2) {
            if (e2.length != Math.ceil(this.n.bitLength() / 4)) return false;
            var r3 = Oe(e2, 16);
            if (r3.bitLength() > this.n.bitLength()) return 0;
            var n2 = nn(this.doPublic(r3).toString(16).replace(/^1f+00/, ""));
            if (0 == n2.length) return false;
            n2[0];
            return n2[1] == t3;
          }, Me.prototype.verifyPSS = function(t3, e2, r3, n2) {
            var i2 = (function t4(e3) {
              return Sr.crypto.Util.hashHex(e3, r3);
            })(Nr(t3));
            return void 0 === n2 && (n2 = -1), this.verifyWithMessageHashPSS(i2, e2, r3, n2);
          }, Me.prototype.verifyWithMessageHashPSS = function(t3, e2, r3, n2) {
            if (e2.length != Math.ceil(this.n.bitLength() / 4)) return false;
            var i2, o2 = new w(e2, 16), s2 = function t4(e3) {
              return Sr.crypto.Util.hashHex(e3, r3);
            }, a2 = Lr(t3), u2 = a2.length, c2 = this.n.bitLength() - 1, h2 = Math.ceil(c2 / 8);
            if (-1 === n2 || void 0 === n2) n2 = u2;
            else if (-2 === n2) n2 = h2 - u2 - 2;
            else if (n2 < -2) throw new Error("invalid salt length");
            if (h2 < u2 + n2 + 2) throw new Error("data too long");
            var l2 = this.doPublic(o2).toByteArray();
            for (i2 = 0; i2 < l2.length; i2 += 1) l2[i2] &= 255;
            for (; l2.length < h2; ) l2.unshift(0);
            if (188 !== l2[h2 - 1]) throw new Error("encoded message does not end in 0xbc");
            var f2 = (l2 = String.fromCharCode.apply(String, l2)).substr(0, h2 - u2 - 1), g2 = l2.substr(f2.length, u2), d2 = 65280 >> 8 * h2 - c2 & 255;
            if (0 != (f2.charCodeAt(0) & d2)) throw new Error("bits beyond keysize not zero");
            var p2 = rn(g2, f2.length, s2), v2 = [];
            for (i2 = 0; i2 < f2.length; i2 += 1) v2[i2] = f2.charCodeAt(i2) ^ p2.charCodeAt(i2);
            v2[0] &= ~d2;
            var y2 = h2 - u2 - n2 - 2;
            for (i2 = 0; i2 < y2; i2 += 1) if (0 !== v2[i2]) throw new Error("leftmost octets not zero");
            if (1 !== v2[y2]) throw new Error("0x01 marker not found");
            return g2 === Lr(s2(Nr("\0\0\0\0\0\0\0\0" + a2 + String.fromCharCode.apply(String, v2.slice(-n2)))));
          }, Me.SALT_LEN_HLEN = -1, Me.SALT_LEN_MAX = -2, Me.SALT_LEN_RECOVER = -2, on.hex2dn = function(t3, e2) {
            void 0 === e2 && (e2 = 0);
            var r3 = new on();
            Fr.getTLV(t3, e2);
            return r3.getX500Name(t3).str;
          }, on.hex2rdn = function(t3, e2) {
            if (void 0 === e2 && (e2 = 0), "31" !== t3.substr(e2, 2)) throw new Error("malformed RDN");
            for (var r3 = new Array(), n2 = Fr.getChildIdx(t3, e2), i2 = 0; i2 < n2.length; i2++) r3.push(on.hex2attrTypeValue(t3, n2[i2]));
            return (r3 = r3.map((function(t4) {
              return t4.replace("+", "\\+");
            }))).join("+");
          }, on.hex2attrTypeValue = function(t3, e2) {
            var r3 = Fr, n2 = r3.getV;
            if (void 0 === e2 && (e2 = 0), "30" !== t3.substr(e2, 2)) throw new Error("malformed attribute type and value");
            var i2 = r3.getChildIdx(t3, e2);
            2 !== i2.length || t3.substr(i2[0], 2);
            var o2 = n2(t3, i2[0]), s2 = Sr.asn1.ASN1Util.oidHexToInt(o2);
            return Sr.asn1.x509.OID.oid2atype(s2) + "=" + Lr(n2(t3, i2[1]));
          }, on.getPublicKeyFromCertHex = function(t3) {
            var e2 = new on();
            return e2.readCertHex(t3), e2.getPublicKey();
          }, on.getPublicKeyFromCertPEM = function(t3) {
            var e2 = new on();
            return e2.readCertPEM(t3), e2.getPublicKey();
          }, on.getPublicKeyInfoPropOfCertPEM = function(t3) {
            var e2, r3, n2 = Fr.getVbyList, i2 = {};
            return i2.algparam = null, (e2 = new on()).readCertPEM(t3), r3 = e2.getPublicKeyHex(), i2.keyhex = n2(r3, 0, [1], "03").substr(2), i2.algoid = n2(r3, 0, [0, 0], "06"), "2a8648ce3d0201" === i2.algoid && (i2.algparam = n2(r3, 0, [0, 1], "06")), i2;
          }, on.KEYUSAGE_NAME = ["digitalSignature", "nonRepudiation", "keyEncipherment", "dataEncipherment", "keyAgreement", "keyCertSign", "cRLSign", "encipherOnly", "decipherOnly"], void 0 !== Sr && Sr || (e.KJUR = Sr = {}), void 0 !== Sr.jws && Sr.jws || (Sr.jws = {}), Sr.jws.JWS = function() {
            var t3 = Sr.jws.JWS.isSafeJSONString;
            this.parseJWS = function(e2, r3) {
              if (void 0 === this.parsedJWS || !r3 && void 0 === this.parsedJWS.sigvalH) {
                var n2 = e2.match(/^([^.]+)\.([^.]+)\.([^.]+)$/);
                if (null == n2) throw "JWS signature is not a form of 'Head.Payload.SigValue'.";
                var i2 = n2[1], o2 = n2[2], s2 = n2[3], a2 = i2 + "." + o2;
                if (this.parsedJWS = {}, this.parsedJWS.headB64U = i2, this.parsedJWS.payloadB64U = o2, this.parsedJWS.sigvalB64U = s2, this.parsedJWS.si = a2, !r3) {
                  var u2 = Rr(s2), c2 = Oe(u2, 16);
                  this.parsedJWS.sigvalH = u2, this.parsedJWS.sigvalBI = c2;
                }
                var h2 = wr(i2), l2 = wr(o2);
                if (this.parsedJWS.headS = h2, this.parsedJWS.payloadS = l2, !t3(h2, this.parsedJWS, "headP")) throw "malformed JSON string for JWS Head: " + h2;
              }
            };
          }, Sr.jws.JWS.sign = function(t3, e2, r3, n2, i2) {
            var o2, s2, a2, u2 = Sr, c2 = u2.jws.JWS, h2 = c2.readSafeJSONString, l2 = c2.isSafeJSONString, f2 = u2.crypto, d2 = (f2.ECDSA, f2.Mac), p2 = f2.Signature, v2 = JSON;
            if ("string" != typeof e2 && "object" != (void 0 === e2 ? "undefined" : g(e2))) throw "spHeader must be JSON string or object: " + e2;
            if ("object" == (void 0 === e2 ? "undefined" : g(e2)) && (s2 = e2, o2 = v2.stringify(s2)), "string" == typeof e2) {
              if (!l2(o2 = e2)) throw "JWS Head is not safe JSON string: " + o2;
              s2 = h2(o2);
            }
            if (a2 = r3, "object" == (void 0 === r3 ? "undefined" : g(r3)) && (a2 = v2.stringify(r3)), "" != t3 && null != t3 || void 0 === s2.alg || (t3 = s2.alg), "" != t3 && null != t3 && void 0 === s2.alg && (s2.alg = t3, o2 = v2.stringify(s2)), t3 !== s2.alg) throw "alg and sHeader.alg doesn't match: " + t3 + "!=" + s2.alg;
            var y2 = null;
            if (void 0 === c2.jwsalg2sigalg[t3]) throw "unsupported alg name: " + t3;
            y2 = c2.jwsalg2sigalg[t3];
            var m2 = br(o2) + "." + br(a2), _2 = "";
            if ("Hmac" == y2.substr(0, 4)) {
              if (void 0 === n2) throw "mac key shall be specified for HS* alg";
              var S2 = new d2({ alg: y2, prov: "cryptojs", pass: n2 });
              S2.updateString(m2), _2 = S2.doFinal();
            } else if (-1 != y2.indexOf("withECDSA")) {
              (w2 = new p2({ alg: y2 })).init(n2, i2), w2.updateString(m2);
              var b2 = w2.sign();
              _2 = Sr.crypto.ECDSA.asn1SigToConcatSig(b2);
            } else {
              var w2;
              if ("none" != y2) (w2 = new p2({ alg: y2 })).init(n2, i2), w2.updateString(m2), _2 = w2.sign();
            }
            return m2 + "." + Tr(_2);
          }, Sr.jws.JWS.verify = function(t3, e2, r3) {
            var n2, i2 = Sr, o2 = i2.jws.JWS, s2 = o2.readSafeJSONString, a2 = i2.crypto, u2 = a2.ECDSA, c2 = a2.Mac, h2 = a2.Signature;
            void 0 !== g(Me) && (n2 = Me);
            var l2 = t3.split(".");
            if (3 !== l2.length) return false;
            var f2 = l2[0] + "." + l2[1], d2 = Rr(l2[2]), p2 = s2(wr(l2[0])), v2 = null, y2 = null;
            if (void 0 === p2.alg) throw "algorithm not specified in header";
            if ((y2 = (v2 = p2.alg).substr(0, 2), null != r3 && "[object Array]" === Object.prototype.toString.call(r3) && r3.length > 0) && -1 == (":" + r3.join(":") + ":").indexOf(":" + v2 + ":")) throw "algorithm '" + v2 + "' not accepted in the list";
            if ("none" != v2 && null === e2) throw "key shall be specified to verify.";
            if ("string" == typeof e2 && -1 != e2.indexOf("-----BEGIN ") && (e2 = tn.getKey(e2)), !("RS" != y2 && "PS" != y2 || e2 instanceof n2)) throw "key shall be a RSAKey obj for RS* and PS* algs";
            if ("ES" == y2 && !(e2 instanceof u2)) throw "key shall be a ECDSA obj for ES* algs";
            var m2 = null;
            if (void 0 === o2.jwsalg2sigalg[p2.alg]) throw "unsupported alg name: " + v2;
            if ("none" == (m2 = o2.jwsalg2sigalg[v2])) throw "not supported";
            if ("Hmac" == m2.substr(0, 4)) {
              if (void 0 === e2) throw "hexadecimal key shall be specified for HMAC";
              var _2 = new c2({ alg: m2, pass: e2 });
              return _2.updateString(f2), d2 == _2.doFinal();
            }
            if (-1 != m2.indexOf("withECDSA")) {
              var S2, b2 = null;
              try {
                b2 = u2.concatSigToASN1Sig(d2);
              } catch (t4) {
                return false;
              }
              return (S2 = new h2({ alg: m2 })).init(e2), S2.updateString(f2), S2.verify(b2);
            }
            return (S2 = new h2({ alg: m2 })).init(e2), S2.updateString(f2), S2.verify(d2);
          }, Sr.jws.JWS.parse = function(t3) {
            var e2, r3, n2, i2 = t3.split("."), o2 = {};
            if (2 != i2.length && 3 != i2.length) throw "malformed sJWS: wrong number of '.' splitted elements";
            return e2 = i2[0], r3 = i2[1], 3 == i2.length && (n2 = i2[2]), o2.headerObj = Sr.jws.JWS.readSafeJSONString(wr(e2)), o2.payloadObj = Sr.jws.JWS.readSafeJSONString(wr(r3)), o2.headerPP = JSON.stringify(o2.headerObj, null, "  "), null == o2.payloadObj ? o2.payloadPP = wr(r3) : o2.payloadPP = JSON.stringify(o2.payloadObj, null, "  "), void 0 !== n2 && (o2.sigHex = Rr(n2)), o2;
          }, Sr.jws.JWS.verifyJWT = function(t3, e2, r3) {
            var n2 = Sr.jws, i2 = n2.JWS, o2 = i2.readSafeJSONString, s2 = i2.inArray, a2 = i2.includedArray, u2 = t3.split("."), c2 = u2[0], h2 = u2[1], l2 = (Rr(u2[2]), o2(wr(c2))), f2 = o2(wr(h2));
            if (void 0 === l2.alg) return false;
            if (void 0 === r3.alg) throw "acceptField.alg shall be specified";
            if (!s2(l2.alg, r3.alg)) return false;
            if (void 0 !== f2.iss && "object" === g(r3.iss) && !s2(f2.iss, r3.iss)) return false;
            if (void 0 !== f2.sub && "object" === g(r3.sub) && !s2(f2.sub, r3.sub)) return false;
            if (void 0 !== f2.aud && "object" === g(r3.aud)) {
              if ("string" == typeof f2.aud) {
                if (!s2(f2.aud, r3.aud)) return false;
              } else if ("object" == g(f2.aud) && !a2(f2.aud, r3.aud)) return false;
            }
            var d2 = n2.IntDate.getNow();
            return void 0 !== r3.verifyAt && "number" == typeof r3.verifyAt && (d2 = r3.verifyAt), void 0 !== r3.gracePeriod && "number" == typeof r3.gracePeriod || (r3.gracePeriod = 0), !(void 0 !== f2.exp && "number" == typeof f2.exp && f2.exp + r3.gracePeriod < d2) && (!(void 0 !== f2.nbf && "number" == typeof f2.nbf && d2 < f2.nbf - r3.gracePeriod) && (!(void 0 !== f2.iat && "number" == typeof f2.iat && d2 < f2.iat - r3.gracePeriod) && ((void 0 === f2.jti || void 0 === r3.jti || f2.jti === r3.jti) && !!i2.verify(t3, e2, r3.alg))));
          }, Sr.jws.JWS.includedArray = function(t3, e2) {
            var r3 = Sr.jws.JWS.inArray;
            if (null === t3) return false;
            if ("object" !== (void 0 === t3 ? "undefined" : g(t3))) return false;
            if ("number" != typeof t3.length) return false;
            for (var n2 = 0; n2 < t3.length; n2++) if (!r3(t3[n2], e2)) return false;
            return true;
          }, Sr.jws.JWS.inArray = function(t3, e2) {
            if (null === e2) return false;
            if ("object" !== (void 0 === e2 ? "undefined" : g(e2))) return false;
            if ("number" != typeof e2.length) return false;
            for (var r3 = 0; r3 < e2.length; r3++) if (e2[r3] == t3) return true;
            return false;
          }, Sr.jws.JWS.jwsalg2sigalg = { HS256: "HmacSHA256", HS384: "HmacSHA384", HS512: "HmacSHA512", RS256: "SHA256withRSA", RS384: "SHA384withRSA", RS512: "SHA512withRSA", ES256: "SHA256withECDSA", ES384: "SHA384withECDSA", PS256: "SHA256withRSAandMGF1", PS384: "SHA384withRSAandMGF1", PS512: "SHA512withRSAandMGF1", none: "none" }, Sr.jws.JWS.isSafeJSONString = function(t3, e2, r3) {
            var n2 = null;
            try {
              return "object" != (void 0 === (n2 = _r(t3)) ? "undefined" : g(n2)) || n2.constructor === Array ? 0 : (e2 && (e2[r3] = n2), 1);
            } catch (t4) {
              return 0;
            }
          }, Sr.jws.JWS.readSafeJSONString = function(t3) {
            var e2 = null;
            try {
              return "object" != (void 0 === (e2 = _r(t3)) ? "undefined" : g(e2)) || e2.constructor === Array ? null : e2;
            } catch (t4) {
              return null;
            }
          }, Sr.jws.JWS.getEncodedSignatureValueFromJWS = function(t3) {
            var e2 = t3.match(/^[^.]+\.[^.]+\.([^.]+)$/);
            if (null == e2) throw "JWS signature is not a form of 'Head.Payload.SigValue'.";
            return e2[1];
          }, Sr.jws.JWS.getJWKthumbprint = function(t3) {
            if ("RSA" !== t3.kty && "EC" !== t3.kty && "oct" !== t3.kty) throw "unsupported algorithm for JWK Thumprint";
            var e2 = "{";
            if ("RSA" === t3.kty) {
              if ("string" != typeof t3.n || "string" != typeof t3.e) throw "wrong n and e value for RSA key";
              e2 += '"e":"' + t3.e + '",', e2 += '"kty":"' + t3.kty + '",', e2 += '"n":"' + t3.n + '"}';
            } else if ("EC" === t3.kty) {
              if ("string" != typeof t3.crv || "string" != typeof t3.x || "string" != typeof t3.y) throw "wrong crv, x and y value for EC key";
              e2 += '"crv":"' + t3.crv + '",', e2 += '"kty":"' + t3.kty + '",', e2 += '"x":"' + t3.x + '",', e2 += '"y":"' + t3.y + '"}';
            } else if ("oct" === t3.kty) {
              if ("string" != typeof t3.k) throw "wrong k value for oct(symmetric) key";
              e2 += '"kty":"' + t3.kty + '",', e2 += '"k":"' + t3.k + '"}';
            }
            var r3 = Nr(e2);
            return Tr(Sr.crypto.Util.hashHex(r3, "sha256"));
          }, Sr.jws.IntDate = {}, Sr.jws.IntDate.get = function(t3) {
            var e2 = Sr.jws.IntDate, r3 = e2.getNow, n2 = e2.getZulu;
            if ("now" == t3) return r3();
            if ("now + 1hour" == t3) return r3() + 3600;
            if ("now + 1day" == t3) return r3() + 86400;
            if ("now + 1month" == t3) return r3() + 2592e3;
            if ("now + 1year" == t3) return r3() + 31536e3;
            if (t3.match(/Z$/)) return n2(t3);
            if (t3.match(/^[0-9]+$/)) return parseInt(t3);
            throw "unsupported format: " + t3;
          }, Sr.jws.IntDate.getZulu = function(t3) {
            return Vr(t3);
          }, Sr.jws.IntDate.getNow = function() {
            return ~~(/* @__PURE__ */ new Date() / 1e3);
          }, Sr.jws.IntDate.intDate2UTCString = function(t3) {
            return new Date(1e3 * t3).toUTCString();
          }, Sr.jws.IntDate.intDate2Zulu = function(t3) {
            var e2 = new Date(1e3 * t3);
            return ("0000" + e2.getUTCFullYear()).slice(-4) + ("00" + (e2.getUTCMonth() + 1)).slice(-2) + ("00" + e2.getUTCDate()).slice(-2) + ("00" + e2.getUTCHours()).slice(-2) + ("00" + e2.getUTCMinutes()).slice(-2) + ("00" + e2.getUTCSeconds()).slice(-2) + "Z";
          }, e.SecureRandom = Be, e.rng_seed_time = Re, e.BigInteger = w, e.RSAKey = Me;
          var sn = Sr.crypto.EDSA;
          e.EDSA = sn;
          var an = Sr.crypto.DSA;
          e.DSA = an;
          var un = Sr.crypto.Signature;
          e.Signature = un;
          var cn = Sr.crypto.MessageDigest;
          e.MessageDigest = cn;
          var hn = Sr.crypto.Mac;
          e.Mac = hn;
          var ln = Sr.crypto.Cipher;
          e.Cipher = ln, e.KEYUTIL = tn, e.ASN1HEX = Fr, e.X509 = on, e.CryptoJS = v, e.b64tohex = S, e.b64toBA = b, e.stoBA = Er, e.BAtos = xr, e.BAtohex = Ar, e.stohex = kr, e.stob64 = function fn(t3) {
            return _(kr(t3));
          }, e.stob64u = function gn(t3) {
            return Pr(_(kr(t3)));
          }, e.b64utos = function dn(t3) {
            return xr(b(Cr(t3)));
          }, e.b64tob64u = Pr, e.b64utob64 = Cr, e.hex2b64 = _, e.hextob64u = Tr, e.b64utohex = Rr, e.utf8tob64u = br, e.b64utoutf8 = wr, e.utf8tob64 = function pn(t3) {
            return _(Kr(Gr(t3)));
          }, e.b64toutf8 = function vn(t3) {
            return decodeURIComponent(qr(S(t3)));
          }, e.utf8tohex = Ir, e.hextoutf8 = Dr, e.hextorstr = Lr, e.rstrtohex = Nr, e.hextob64 = Ur, e.hextob64nl = Br, e.b64nltohex = Or, e.hextopem = jr, e.pemtohex = Mr, e.hextoArrayBuffer = function yn(t3) {
            if (t3.length % 2 != 0) throw "input is not even length";
            if (null == t3.match(/^[0-9A-Fa-f]+$/)) throw "input is not hexadecimal";
            for (var e2 = new ArrayBuffer(t3.length / 2), r3 = new DataView(e2), n2 = 0; n2 < t3.length / 2; n2++) r3.setUint8(n2, parseInt(t3.substr(2 * n2, 2), 16));
            return e2;
          }, e.ArrayBuffertohex = function mn(t3) {
            for (var e2 = "", r3 = new DataView(t3), n2 = 0; n2 < t3.byteLength; n2++) e2 += ("00" + r3.getUint8(n2).toString(16)).slice(-2);
            return e2;
          }, e.zulutomsec = Hr, e.zulutosec = Vr, e.zulutodate = function _n(t3) {
            return new Date(Hr(t3));
          }, e.datetozulu = function Sn(t3, e2, r3) {
            var n2, i2 = t3.getUTCFullYear();
            if (e2) {
              if (i2 < 1950 || 2049 < i2) throw "not proper year for UTCTime: " + i2;
              n2 = ("" + i2).slice(-2);
            } else n2 = ("000" + i2).slice(-4);
            if (n2 += ("0" + (t3.getUTCMonth() + 1)).slice(-2), n2 += ("0" + t3.getUTCDate()).slice(-2), n2 += ("0" + t3.getUTCHours()).slice(-2), n2 += ("0" + t3.getUTCMinutes()).slice(-2), n2 += ("0" + t3.getUTCSeconds()).slice(-2), r3) {
              var o2 = t3.getUTCMilliseconds();
              0 !== o2 && (n2 += "." + (o2 = (o2 = ("00" + o2).slice(-3)).replace(/0+$/g, "")));
            }
            return n2 += "Z";
          }, e.uricmptohex = Kr, e.hextouricmp = qr, e.ipv6tohex = Jr, e.hextoipv6 = Wr, e.hextoip = zr, e.iptohex = function bn(t3) {
            var e2 = "malformed IP address";
            if (!(t3 = t3.toLowerCase(t3)).match(/^[0-9.]+$/)) {
              if (t3.match(/^[0-9a-f:]+$/) && -1 !== t3.indexOf(":")) return Jr(t3);
              throw e2;
            }
            var r3 = t3.split(".");
            if (4 !== r3.length) throw e2;
            var n2 = "";
            try {
              for (var i2 = 0; i2 < 4; i2++) {
                n2 += ("0" + parseInt(r3[i2]).toString(16)).slice(-2);
              }
              return n2;
            } catch (t4) {
              throw e2;
            }
          }, e.encodeURIComponentAll = Gr, e.newline_toUnix = function wn(t3) {
            return t3 = t3.replace(/\r\n/gm, "\n");
          }, e.newline_toDos = function Fn(t3) {
            return t3 = (t3 = t3.replace(/\r\n/gm, "\n")).replace(/\n/gm, "\r\n");
          }, e.hextoposhex = $r, e.intarystrtohex = function En(t3) {
            t3 = (t3 = (t3 = t3.replace(/^\s*\[\s*/, "")).replace(/\s*\]\s*$/, "")).replace(/\s*/g, "");
            try {
              return t3.split(/,/).map((function(t4, e2, r3) {
                var n2 = parseInt(t4);
                if (n2 < 0 || 255 < n2) throw "integer not in range 0-255";
                return ("00" + n2.toString(16)).slice(-2);
              })).join("");
            } catch (t4) {
              throw "malformed integer array string: " + t4;
            }
          }, e.strdiffidx = function t3(e2, r3) {
            var n2 = e2.length;
            e2.length > r3.length && (n2 = r3.length);
            for (var i2 = 0; i2 < n2; i2++) if (e2.charCodeAt(i2) != r3.charCodeAt(i2)) return i2;
            return e2.length != r3.length ? n2 : -1;
          }, e.KJUR = Sr;
          var xn = Sr.crypto;
          e.crypto = xn;
          var An = Sr.asn1;
          e.asn1 = An;
          var kn = Sr.jws;
          e.jws = kn;
          var Pn = Sr.lang;
          e.lang = Pn;
        }).call(this, r(28).Buffer);
      }, function(t, e, r) {
        "use strict";
        (function(t2) {
          var n = r(30), i = r(31), o = r(32);
          function s() {
            return u.TYPED_ARRAY_SUPPORT ? 2147483647 : 1073741823;
          }
          function a(t3, e2) {
            if (s() < e2) throw new RangeError("Invalid typed array length");
            return u.TYPED_ARRAY_SUPPORT ? (t3 = new Uint8Array(e2)).__proto__ = u.prototype : (null === t3 && (t3 = new u(e2)), t3.length = e2), t3;
          }
          function u(t3, e2, r2) {
            if (!(u.TYPED_ARRAY_SUPPORT || this instanceof u)) return new u(t3, e2, r2);
            if ("number" == typeof t3) {
              if ("string" == typeof e2) throw new Error("If encoding is specified then the first argument must be a string");
              return l(this, t3);
            }
            return c(this, t3, e2, r2);
          }
          function c(t3, e2, r2, n2) {
            if ("number" == typeof e2) throw new TypeError('"value" argument must not be a number');
            return "undefined" != typeof ArrayBuffer && e2 instanceof ArrayBuffer ? (function i2(t4, e3, r3, n3) {
              if (e3.byteLength, r3 < 0 || e3.byteLength < r3) throw new RangeError("'offset' is out of bounds");
              if (e3.byteLength < r3 + (n3 || 0)) throw new RangeError("'length' is out of bounds");
              e3 = void 0 === r3 && void 0 === n3 ? new Uint8Array(e3) : void 0 === n3 ? new Uint8Array(e3, r3) : new Uint8Array(e3, r3, n3);
              u.TYPED_ARRAY_SUPPORT ? (t4 = e3).__proto__ = u.prototype : t4 = f(t4, e3);
              return t4;
            })(t3, e2, r2, n2) : "string" == typeof e2 ? (function s2(t4, e3, r3) {
              "string" == typeof r3 && "" !== r3 || (r3 = "utf8");
              if (!u.isEncoding(r3)) throw new TypeError('"encoding" must be a valid string encoding');
              var n3 = 0 | d(e3, r3), i2 = (t4 = a(t4, n3)).write(e3, r3);
              i2 !== n3 && (t4 = t4.slice(0, i2));
              return t4;
            })(t3, e2, r2) : (function c2(t4, e3) {
              if (u.isBuffer(e3)) {
                var r3 = 0 | g(e3.length);
                return 0 === (t4 = a(t4, r3)).length || e3.copy(t4, 0, 0, r3), t4;
              }
              if (e3) {
                if ("undefined" != typeof ArrayBuffer && e3.buffer instanceof ArrayBuffer || "length" in e3) return "number" != typeof e3.length || (function n3(t5) {
                  return t5 != t5;
                })(e3.length) ? a(t4, 0) : f(t4, e3);
                if ("Buffer" === e3.type && o(e3.data)) return f(t4, e3.data);
              }
              throw new TypeError("First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.");
            })(t3, e2);
          }
          function h(t3) {
            if ("number" != typeof t3) throw new TypeError('"size" argument must be a number');
            if (t3 < 0) throw new RangeError('"size" argument must not be negative');
          }
          function l(t3, e2) {
            if (h(e2), t3 = a(t3, e2 < 0 ? 0 : 0 | g(e2)), !u.TYPED_ARRAY_SUPPORT) for (var r2 = 0; r2 < e2; ++r2) t3[r2] = 0;
            return t3;
          }
          function f(t3, e2) {
            var r2 = e2.length < 0 ? 0 : 0 | g(e2.length);
            t3 = a(t3, r2);
            for (var n2 = 0; n2 < r2; n2 += 1) t3[n2] = 255 & e2[n2];
            return t3;
          }
          function g(t3) {
            if (t3 >= s()) throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + s().toString(16) + " bytes");
            return 0 | t3;
          }
          function d(t3, e2) {
            if (u.isBuffer(t3)) return t3.length;
            if ("undefined" != typeof ArrayBuffer && "function" == typeof ArrayBuffer.isView && (ArrayBuffer.isView(t3) || t3 instanceof ArrayBuffer)) return t3.byteLength;
            "string" != typeof t3 && (t3 = "" + t3);
            var r2 = t3.length;
            if (0 === r2) return 0;
            for (var n2 = false; ; ) switch (e2) {
              case "ascii":
              case "latin1":
              case "binary":
                return r2;
              case "utf8":
              case "utf-8":
              case void 0:
                return K(t3).length;
              case "ucs2":
              case "ucs-2":
              case "utf16le":
              case "utf-16le":
                return 2 * r2;
              case "hex":
                return r2 >>> 1;
              case "base64":
                return q(t3).length;
              default:
                if (n2) return K(t3).length;
                e2 = ("" + e2).toLowerCase(), n2 = true;
            }
          }
          function p(t3, e2, r2) {
            var n2 = false;
            if ((void 0 === e2 || e2 < 0) && (e2 = 0), e2 > this.length) return "";
            if ((void 0 === r2 || r2 > this.length) && (r2 = this.length), r2 <= 0) return "";
            if ((r2 >>>= 0) <= (e2 >>>= 0)) return "";
            for (t3 || (t3 = "utf8"); ; ) switch (t3) {
              case "hex":
                return I(this, e2, r2);
              case "utf8":
              case "utf-8":
                return A(this, e2, r2);
              case "ascii":
                return T(this, e2, r2);
              case "latin1":
              case "binary":
                return R(this, e2, r2);
              case "base64":
                return x(this, e2, r2);
              case "ucs2":
              case "ucs-2":
              case "utf16le":
              case "utf-16le":
                return D(this, e2, r2);
              default:
                if (n2) throw new TypeError("Unknown encoding: " + t3);
                t3 = (t3 + "").toLowerCase(), n2 = true;
            }
          }
          function v(t3, e2, r2) {
            var n2 = t3[e2];
            t3[e2] = t3[r2], t3[r2] = n2;
          }
          function y(t3, e2, r2, n2, i2) {
            if (0 === t3.length) return -1;
            if ("string" == typeof r2 ? (n2 = r2, r2 = 0) : r2 > 2147483647 ? r2 = 2147483647 : r2 < -2147483648 && (r2 = -2147483648), r2 = +r2, isNaN(r2) && (r2 = i2 ? 0 : t3.length - 1), r2 < 0 && (r2 = t3.length + r2), r2 >= t3.length) {
              if (i2) return -1;
              r2 = t3.length - 1;
            } else if (r2 < 0) {
              if (!i2) return -1;
              r2 = 0;
            }
            if ("string" == typeof e2 && (e2 = u.from(e2, n2)), u.isBuffer(e2)) return 0 === e2.length ? -1 : m(t3, e2, r2, n2, i2);
            if ("number" == typeof e2) return e2 &= 255, u.TYPED_ARRAY_SUPPORT && "function" == typeof Uint8Array.prototype.indexOf ? i2 ? Uint8Array.prototype.indexOf.call(t3, e2, r2) : Uint8Array.prototype.lastIndexOf.call(t3, e2, r2) : m(t3, [e2], r2, n2, i2);
            throw new TypeError("val must be string, number or Buffer");
          }
          function m(t3, e2, r2, n2, i2) {
            var o2, s2 = 1, a2 = t3.length, u2 = e2.length;
            if (void 0 !== n2 && ("ucs2" === (n2 = String(n2).toLowerCase()) || "ucs-2" === n2 || "utf16le" === n2 || "utf-16le" === n2)) {
              if (t3.length < 2 || e2.length < 2) return -1;
              s2 = 2, a2 /= 2, u2 /= 2, r2 /= 2;
            }
            function c2(t4, e3) {
              return 1 === s2 ? t4[e3] : t4.readUInt16BE(e3 * s2);
            }
            if (i2) {
              var h2 = -1;
              for (o2 = r2; o2 < a2; o2++) if (c2(t3, o2) === c2(e2, -1 === h2 ? 0 : o2 - h2)) {
                if (-1 === h2 && (h2 = o2), o2 - h2 + 1 === u2) return h2 * s2;
              } else -1 !== h2 && (o2 -= o2 - h2), h2 = -1;
            } else for (r2 + u2 > a2 && (r2 = a2 - u2), o2 = r2; o2 >= 0; o2--) {
              for (var l2 = true, f2 = 0; f2 < u2; f2++) if (c2(t3, o2 + f2) !== c2(e2, f2)) {
                l2 = false;
                break;
              }
              if (l2) return o2;
            }
            return -1;
          }
          function _(t3, e2, r2, n2) {
            r2 = Number(r2) || 0;
            var i2 = t3.length - r2;
            n2 ? (n2 = Number(n2)) > i2 && (n2 = i2) : n2 = i2;
            var o2 = e2.length;
            if (o2 % 2 != 0) throw new TypeError("Invalid hex string");
            n2 > o2 / 2 && (n2 = o2 / 2);
            for (var s2 = 0; s2 < n2; ++s2) {
              var a2 = parseInt(e2.substr(2 * s2, 2), 16);
              if (isNaN(a2)) return s2;
              t3[r2 + s2] = a2;
            }
            return s2;
          }
          function S(t3, e2, r2, n2) {
            return J(K(e2, t3.length - r2), t3, r2, n2);
          }
          function b(t3, e2, r2, n2) {
            return J((function i2(t4) {
              for (var e3 = [], r3 = 0; r3 < t4.length; ++r3) e3.push(255 & t4.charCodeAt(r3));
              return e3;
            })(e2), t3, r2, n2);
          }
          function w(t3, e2, r2, n2) {
            return b(t3, e2, r2, n2);
          }
          function F(t3, e2, r2, n2) {
            return J(q(e2), t3, r2, n2);
          }
          function E(t3, e2, r2, n2) {
            return J((function i2(t4, e3) {
              for (var r3, n3, i3, o2 = [], s2 = 0; s2 < t4.length && !((e3 -= 2) < 0); ++s2) n3 = (r3 = t4.charCodeAt(s2)) >> 8, i3 = r3 % 256, o2.push(i3), o2.push(n3);
              return o2;
            })(e2, t3.length - r2), t3, r2, n2);
          }
          function x(t3, e2, r2) {
            return 0 === e2 && r2 === t3.length ? n.fromByteArray(t3) : n.fromByteArray(t3.slice(e2, r2));
          }
          function A(t3, e2, r2) {
            r2 = Math.min(t3.length, r2);
            for (var n2 = [], i2 = e2; i2 < r2; ) {
              var o2, s2, a2, u2, c2 = t3[i2], h2 = null, l2 = c2 > 239 ? 4 : c2 > 223 ? 3 : c2 > 191 ? 2 : 1;
              if (i2 + l2 <= r2) switch (l2) {
                case 1:
                  c2 < 128 && (h2 = c2);
                  break;
                case 2:
                  128 == (192 & (o2 = t3[i2 + 1])) && (u2 = (31 & c2) << 6 | 63 & o2) > 127 && (h2 = u2);
                  break;
                case 3:
                  o2 = t3[i2 + 1], s2 = t3[i2 + 2], 128 == (192 & o2) && 128 == (192 & s2) && (u2 = (15 & c2) << 12 | (63 & o2) << 6 | 63 & s2) > 2047 && (u2 < 55296 || u2 > 57343) && (h2 = u2);
                  break;
                case 4:
                  o2 = t3[i2 + 1], s2 = t3[i2 + 2], a2 = t3[i2 + 3], 128 == (192 & o2) && 128 == (192 & s2) && 128 == (192 & a2) && (u2 = (15 & c2) << 18 | (63 & o2) << 12 | (63 & s2) << 6 | 63 & a2) > 65535 && u2 < 1114112 && (h2 = u2);
              }
              null === h2 ? (h2 = 65533, l2 = 1) : h2 > 65535 && (h2 -= 65536, n2.push(h2 >>> 10 & 1023 | 55296), h2 = 56320 | 1023 & h2), n2.push(h2), i2 += l2;
            }
            return (function f2(t4) {
              var e3 = t4.length;
              if (e3 <= C) return String.fromCharCode.apply(String, t4);
              var r3 = "", n3 = 0;
              for (; n3 < e3; ) r3 += String.fromCharCode.apply(String, t4.slice(n3, n3 += C));
              return r3;
            })(n2);
          }
          e.Buffer = u, e.SlowBuffer = function k(t3) {
            +t3 != t3 && (t3 = 0);
            return u.alloc(+t3);
          }, e.INSPECT_MAX_BYTES = 50, u.TYPED_ARRAY_SUPPORT = void 0 !== t2.TYPED_ARRAY_SUPPORT ? t2.TYPED_ARRAY_SUPPORT : (function P() {
            try {
              var t3 = new Uint8Array(1);
              return t3.__proto__ = { __proto__: Uint8Array.prototype, foo: function() {
                return 42;
              } }, 42 === t3.foo() && "function" == typeof t3.subarray && 0 === t3.subarray(1, 1).byteLength;
            } catch (t4) {
              return false;
            }
          })(), e.kMaxLength = s(), u.poolSize = 8192, u._augment = function(t3) {
            return t3.__proto__ = u.prototype, t3;
          }, u.from = function(t3, e2, r2) {
            return c(null, t3, e2, r2);
          }, u.TYPED_ARRAY_SUPPORT && (u.prototype.__proto__ = Uint8Array.prototype, u.__proto__ = Uint8Array, "undefined" != typeof Symbol && Symbol.species && u[Symbol.species] === u && Object.defineProperty(u, Symbol.species, { value: null, configurable: true })), u.alloc = function(t3, e2, r2) {
            return (function n2(t4, e3, r3, i2) {
              return h(e3), e3 <= 0 ? a(t4, e3) : void 0 !== r3 ? "string" == typeof i2 ? a(t4, e3).fill(r3, i2) : a(t4, e3).fill(r3) : a(t4, e3);
            })(null, t3, e2, r2);
          }, u.allocUnsafe = function(t3) {
            return l(null, t3);
          }, u.allocUnsafeSlow = function(t3) {
            return l(null, t3);
          }, u.isBuffer = function t3(e2) {
            return !(null == e2 || !e2._isBuffer);
          }, u.compare = function t3(e2, r2) {
            if (!u.isBuffer(e2) || !u.isBuffer(r2)) throw new TypeError("Arguments must be Buffers");
            if (e2 === r2) return 0;
            for (var n2 = e2.length, i2 = r2.length, o2 = 0, s2 = Math.min(n2, i2); o2 < s2; ++o2) if (e2[o2] !== r2[o2]) {
              n2 = e2[o2], i2 = r2[o2];
              break;
            }
            return n2 < i2 ? -1 : i2 < n2 ? 1 : 0;
          }, u.isEncoding = function t3(e2) {
            switch (String(e2).toLowerCase()) {
              case "hex":
              case "utf8":
              case "utf-8":
              case "ascii":
              case "latin1":
              case "binary":
              case "base64":
              case "ucs2":
              case "ucs-2":
              case "utf16le":
              case "utf-16le":
                return true;
              default:
                return false;
            }
          }, u.concat = function t3(e2, r2) {
            if (!o(e2)) throw new TypeError('"list" argument must be an Array of Buffers');
            if (0 === e2.length) return u.alloc(0);
            var n2;
            if (void 0 === r2) for (r2 = 0, n2 = 0; n2 < e2.length; ++n2) r2 += e2[n2].length;
            var i2 = u.allocUnsafe(r2), s2 = 0;
            for (n2 = 0; n2 < e2.length; ++n2) {
              var a2 = e2[n2];
              if (!u.isBuffer(a2)) throw new TypeError('"list" argument must be an Array of Buffers');
              a2.copy(i2, s2), s2 += a2.length;
            }
            return i2;
          }, u.byteLength = d, u.prototype._isBuffer = true, u.prototype.swap16 = function t3() {
            var e2 = this.length;
            if (e2 % 2 != 0) throw new RangeError("Buffer size must be a multiple of 16-bits");
            for (var r2 = 0; r2 < e2; r2 += 2) v(this, r2, r2 + 1);
            return this;
          }, u.prototype.swap32 = function t3() {
            var e2 = this.length;
            if (e2 % 4 != 0) throw new RangeError("Buffer size must be a multiple of 32-bits");
            for (var r2 = 0; r2 < e2; r2 += 4) v(this, r2, r2 + 3), v(this, r2 + 1, r2 + 2);
            return this;
          }, u.prototype.swap64 = function t3() {
            var e2 = this.length;
            if (e2 % 8 != 0) throw new RangeError("Buffer size must be a multiple of 64-bits");
            for (var r2 = 0; r2 < e2; r2 += 8) v(this, r2, r2 + 7), v(this, r2 + 1, r2 + 6), v(this, r2 + 2, r2 + 5), v(this, r2 + 3, r2 + 4);
            return this;
          }, u.prototype.toString = function t3() {
            var e2 = 0 | this.length;
            return 0 === e2 ? "" : 0 === arguments.length ? A(this, 0, e2) : p.apply(this, arguments);
          }, u.prototype.equals = function t3(e2) {
            if (!u.isBuffer(e2)) throw new TypeError("Argument must be a Buffer");
            return this === e2 || 0 === u.compare(this, e2);
          }, u.prototype.inspect = function t3() {
            var r2 = "", n2 = e.INSPECT_MAX_BYTES;
            return this.length > 0 && (r2 = this.toString("hex", 0, n2).match(/.{2}/g).join(" "), this.length > n2 && (r2 += " ... ")), "<Buffer " + r2 + ">";
          }, u.prototype.compare = function t3(e2, r2, n2, i2, o2) {
            if (!u.isBuffer(e2)) throw new TypeError("Argument must be a Buffer");
            if (void 0 === r2 && (r2 = 0), void 0 === n2 && (n2 = e2 ? e2.length : 0), void 0 === i2 && (i2 = 0), void 0 === o2 && (o2 = this.length), r2 < 0 || n2 > e2.length || i2 < 0 || o2 > this.length) throw new RangeError("out of range index");
            if (i2 >= o2 && r2 >= n2) return 0;
            if (i2 >= o2) return -1;
            if (r2 >= n2) return 1;
            if (this === e2) return 0;
            for (var s2 = (o2 >>>= 0) - (i2 >>>= 0), a2 = (n2 >>>= 0) - (r2 >>>= 0), c2 = Math.min(s2, a2), h2 = this.slice(i2, o2), l2 = e2.slice(r2, n2), f2 = 0; f2 < c2; ++f2) if (h2[f2] !== l2[f2]) {
              s2 = h2[f2], a2 = l2[f2];
              break;
            }
            return s2 < a2 ? -1 : a2 < s2 ? 1 : 0;
          }, u.prototype.includes = function t3(e2, r2, n2) {
            return -1 !== this.indexOf(e2, r2, n2);
          }, u.prototype.indexOf = function t3(e2, r2, n2) {
            return y(this, e2, r2, n2, true);
          }, u.prototype.lastIndexOf = function t3(e2, r2, n2) {
            return y(this, e2, r2, n2, false);
          }, u.prototype.write = function t3(e2, r2, n2, i2) {
            if (void 0 === r2) i2 = "utf8", n2 = this.length, r2 = 0;
            else if (void 0 === n2 && "string" == typeof r2) i2 = r2, n2 = this.length, r2 = 0;
            else {
              if (!isFinite(r2)) throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
              r2 |= 0, isFinite(n2) ? (n2 |= 0, void 0 === i2 && (i2 = "utf8")) : (i2 = n2, n2 = void 0);
            }
            var o2 = this.length - r2;
            if ((void 0 === n2 || n2 > o2) && (n2 = o2), e2.length > 0 && (n2 < 0 || r2 < 0) || r2 > this.length) throw new RangeError("Attempt to write outside buffer bounds");
            i2 || (i2 = "utf8");
            for (var s2 = false; ; ) switch (i2) {
              case "hex":
                return _(this, e2, r2, n2);
              case "utf8":
              case "utf-8":
                return S(this, e2, r2, n2);
              case "ascii":
                return b(this, e2, r2, n2);
              case "latin1":
              case "binary":
                return w(this, e2, r2, n2);
              case "base64":
                return F(this, e2, r2, n2);
              case "ucs2":
              case "ucs-2":
              case "utf16le":
              case "utf-16le":
                return E(this, e2, r2, n2);
              default:
                if (s2) throw new TypeError("Unknown encoding: " + i2);
                i2 = ("" + i2).toLowerCase(), s2 = true;
            }
          }, u.prototype.toJSON = function t3() {
            return { type: "Buffer", data: Array.prototype.slice.call(this._arr || this, 0) };
          };
          var C = 4096;
          function T(t3, e2, r2) {
            var n2 = "";
            r2 = Math.min(t3.length, r2);
            for (var i2 = e2; i2 < r2; ++i2) n2 += String.fromCharCode(127 & t3[i2]);
            return n2;
          }
          function R(t3, e2, r2) {
            var n2 = "";
            r2 = Math.min(t3.length, r2);
            for (var i2 = e2; i2 < r2; ++i2) n2 += String.fromCharCode(t3[i2]);
            return n2;
          }
          function I(t3, e2, r2) {
            var n2 = t3.length;
            (!e2 || e2 < 0) && (e2 = 0), (!r2 || r2 < 0 || r2 > n2) && (r2 = n2);
            for (var i2 = "", o2 = e2; o2 < r2; ++o2) i2 += V(t3[o2]);
            return i2;
          }
          function D(t3, e2, r2) {
            for (var n2 = t3.slice(e2, r2), i2 = "", o2 = 0; o2 < n2.length; o2 += 2) i2 += String.fromCharCode(n2[o2] + 256 * n2[o2 + 1]);
            return i2;
          }
          function L(t3, e2, r2) {
            if (t3 % 1 != 0 || t3 < 0) throw new RangeError("offset is not uint");
            if (t3 + e2 > r2) throw new RangeError("Trying to access beyond buffer length");
          }
          function N(t3, e2, r2, n2, i2, o2) {
            if (!u.isBuffer(t3)) throw new TypeError('"buffer" argument must be a Buffer instance');
            if (e2 > i2 || e2 < o2) throw new RangeError('"value" argument is out of bounds');
            if (r2 + n2 > t3.length) throw new RangeError("Index out of range");
          }
          function U(t3, e2, r2, n2) {
            e2 < 0 && (e2 = 65535 + e2 + 1);
            for (var i2 = 0, o2 = Math.min(t3.length - r2, 2); i2 < o2; ++i2) t3[r2 + i2] = (e2 & 255 << 8 * (n2 ? i2 : 1 - i2)) >>> 8 * (n2 ? i2 : 1 - i2);
          }
          function B(t3, e2, r2, n2) {
            e2 < 0 && (e2 = 4294967295 + e2 + 1);
            for (var i2 = 0, o2 = Math.min(t3.length - r2, 4); i2 < o2; ++i2) t3[r2 + i2] = e2 >>> 8 * (n2 ? i2 : 3 - i2) & 255;
          }
          function O(t3, e2, r2, n2, i2, o2) {
            if (r2 + n2 > t3.length) throw new RangeError("Index out of range");
            if (r2 < 0) throw new RangeError("Index out of range");
          }
          function j(t3, e2, r2, n2, o2) {
            return o2 || O(t3, 0, r2, 4), i.write(t3, e2, r2, n2, 23, 4), r2 + 4;
          }
          function M(t3, e2, r2, n2, o2) {
            return o2 || O(t3, 0, r2, 8), i.write(t3, e2, r2, n2, 52, 8), r2 + 8;
          }
          u.prototype.slice = function t3(e2, r2) {
            var n2, i2 = this.length;
            if ((e2 = ~~e2) < 0 ? (e2 += i2) < 0 && (e2 = 0) : e2 > i2 && (e2 = i2), (r2 = void 0 === r2 ? i2 : ~~r2) < 0 ? (r2 += i2) < 0 && (r2 = 0) : r2 > i2 && (r2 = i2), r2 < e2 && (r2 = e2), u.TYPED_ARRAY_SUPPORT) (n2 = this.subarray(e2, r2)).__proto__ = u.prototype;
            else {
              var o2 = r2 - e2;
              n2 = new u(o2, void 0);
              for (var s2 = 0; s2 < o2; ++s2) n2[s2] = this[s2 + e2];
            }
            return n2;
          }, u.prototype.readUIntLE = function t3(e2, r2, n2) {
            e2 |= 0, r2 |= 0, n2 || L(e2, r2, this.length);
            for (var i2 = this[e2], o2 = 1, s2 = 0; ++s2 < r2 && (o2 *= 256); ) i2 += this[e2 + s2] * o2;
            return i2;
          }, u.prototype.readUIntBE = function t3(e2, r2, n2) {
            e2 |= 0, r2 |= 0, n2 || L(e2, r2, this.length);
            for (var i2 = this[e2 + --r2], o2 = 1; r2 > 0 && (o2 *= 256); ) i2 += this[e2 + --r2] * o2;
            return i2;
          }, u.prototype.readUInt8 = function t3(e2, r2) {
            return r2 || L(e2, 1, this.length), this[e2];
          }, u.prototype.readUInt16LE = function t3(e2, r2) {
            return r2 || L(e2, 2, this.length), this[e2] | this[e2 + 1] << 8;
          }, u.prototype.readUInt16BE = function t3(e2, r2) {
            return r2 || L(e2, 2, this.length), this[e2] << 8 | this[e2 + 1];
          }, u.prototype.readUInt32LE = function t3(e2, r2) {
            return r2 || L(e2, 4, this.length), (this[e2] | this[e2 + 1] << 8 | this[e2 + 2] << 16) + 16777216 * this[e2 + 3];
          }, u.prototype.readUInt32BE = function t3(e2, r2) {
            return r2 || L(e2, 4, this.length), 16777216 * this[e2] + (this[e2 + 1] << 16 | this[e2 + 2] << 8 | this[e2 + 3]);
          }, u.prototype.readIntLE = function t3(e2, r2, n2) {
            e2 |= 0, r2 |= 0, n2 || L(e2, r2, this.length);
            for (var i2 = this[e2], o2 = 1, s2 = 0; ++s2 < r2 && (o2 *= 256); ) i2 += this[e2 + s2] * o2;
            return i2 >= (o2 *= 128) && (i2 -= Math.pow(2, 8 * r2)), i2;
          }, u.prototype.readIntBE = function t3(e2, r2, n2) {
            e2 |= 0, r2 |= 0, n2 || L(e2, r2, this.length);
            for (var i2 = r2, o2 = 1, s2 = this[e2 + --i2]; i2 > 0 && (o2 *= 256); ) s2 += this[e2 + --i2] * o2;
            return s2 >= (o2 *= 128) && (s2 -= Math.pow(2, 8 * r2)), s2;
          }, u.prototype.readInt8 = function t3(e2, r2) {
            return r2 || L(e2, 1, this.length), 128 & this[e2] ? -1 * (255 - this[e2] + 1) : this[e2];
          }, u.prototype.readInt16LE = function t3(e2, r2) {
            r2 || L(e2, 2, this.length);
            var n2 = this[e2] | this[e2 + 1] << 8;
            return 32768 & n2 ? 4294901760 | n2 : n2;
          }, u.prototype.readInt16BE = function t3(e2, r2) {
            r2 || L(e2, 2, this.length);
            var n2 = this[e2 + 1] | this[e2] << 8;
            return 32768 & n2 ? 4294901760 | n2 : n2;
          }, u.prototype.readInt32LE = function t3(e2, r2) {
            return r2 || L(e2, 4, this.length), this[e2] | this[e2 + 1] << 8 | this[e2 + 2] << 16 | this[e2 + 3] << 24;
          }, u.prototype.readInt32BE = function t3(e2, r2) {
            return r2 || L(e2, 4, this.length), this[e2] << 24 | this[e2 + 1] << 16 | this[e2 + 2] << 8 | this[e2 + 3];
          }, u.prototype.readFloatLE = function t3(e2, r2) {
            return r2 || L(e2, 4, this.length), i.read(this, e2, true, 23, 4);
          }, u.prototype.readFloatBE = function t3(e2, r2) {
            return r2 || L(e2, 4, this.length), i.read(this, e2, false, 23, 4);
          }, u.prototype.readDoubleLE = function t3(e2, r2) {
            return r2 || L(e2, 8, this.length), i.read(this, e2, true, 52, 8);
          }, u.prototype.readDoubleBE = function t3(e2, r2) {
            return r2 || L(e2, 8, this.length), i.read(this, e2, false, 52, 8);
          }, u.prototype.writeUIntLE = function t3(e2, r2, n2, i2) {
            (e2 = +e2, r2 |= 0, n2 |= 0, i2) || N(this, e2, r2, n2, Math.pow(2, 8 * n2) - 1, 0);
            var o2 = 1, s2 = 0;
            for (this[r2] = 255 & e2; ++s2 < n2 && (o2 *= 256); ) this[r2 + s2] = e2 / o2 & 255;
            return r2 + n2;
          }, u.prototype.writeUIntBE = function t3(e2, r2, n2, i2) {
            (e2 = +e2, r2 |= 0, n2 |= 0, i2) || N(this, e2, r2, n2, Math.pow(2, 8 * n2) - 1, 0);
            var o2 = n2 - 1, s2 = 1;
            for (this[r2 + o2] = 255 & e2; --o2 >= 0 && (s2 *= 256); ) this[r2 + o2] = e2 / s2 & 255;
            return r2 + n2;
          }, u.prototype.writeUInt8 = function t3(e2, r2, n2) {
            return e2 = +e2, r2 |= 0, n2 || N(this, e2, r2, 1, 255, 0), u.TYPED_ARRAY_SUPPORT || (e2 = Math.floor(e2)), this[r2] = 255 & e2, r2 + 1;
          }, u.prototype.writeUInt16LE = function t3(e2, r2, n2) {
            return e2 = +e2, r2 |= 0, n2 || N(this, e2, r2, 2, 65535, 0), u.TYPED_ARRAY_SUPPORT ? (this[r2] = 255 & e2, this[r2 + 1] = e2 >>> 8) : U(this, e2, r2, true), r2 + 2;
          }, u.prototype.writeUInt16BE = function t3(e2, r2, n2) {
            return e2 = +e2, r2 |= 0, n2 || N(this, e2, r2, 2, 65535, 0), u.TYPED_ARRAY_SUPPORT ? (this[r2] = e2 >>> 8, this[r2 + 1] = 255 & e2) : U(this, e2, r2, false), r2 + 2;
          }, u.prototype.writeUInt32LE = function t3(e2, r2, n2) {
            return e2 = +e2, r2 |= 0, n2 || N(this, e2, r2, 4, 4294967295, 0), u.TYPED_ARRAY_SUPPORT ? (this[r2 + 3] = e2 >>> 24, this[r2 + 2] = e2 >>> 16, this[r2 + 1] = e2 >>> 8, this[r2] = 255 & e2) : B(this, e2, r2, true), r2 + 4;
          }, u.prototype.writeUInt32BE = function t3(e2, r2, n2) {
            return e2 = +e2, r2 |= 0, n2 || N(this, e2, r2, 4, 4294967295, 0), u.TYPED_ARRAY_SUPPORT ? (this[r2] = e2 >>> 24, this[r2 + 1] = e2 >>> 16, this[r2 + 2] = e2 >>> 8, this[r2 + 3] = 255 & e2) : B(this, e2, r2, false), r2 + 4;
          }, u.prototype.writeIntLE = function t3(e2, r2, n2, i2) {
            if (e2 = +e2, r2 |= 0, !i2) {
              var o2 = Math.pow(2, 8 * n2 - 1);
              N(this, e2, r2, n2, o2 - 1, -o2);
            }
            var s2 = 0, a2 = 1, u2 = 0;
            for (this[r2] = 255 & e2; ++s2 < n2 && (a2 *= 256); ) e2 < 0 && 0 === u2 && 0 !== this[r2 + s2 - 1] && (u2 = 1), this[r2 + s2] = (e2 / a2 >> 0) - u2 & 255;
            return r2 + n2;
          }, u.prototype.writeIntBE = function t3(e2, r2, n2, i2) {
            if (e2 = +e2, r2 |= 0, !i2) {
              var o2 = Math.pow(2, 8 * n2 - 1);
              N(this, e2, r2, n2, o2 - 1, -o2);
            }
            var s2 = n2 - 1, a2 = 1, u2 = 0;
            for (this[r2 + s2] = 255 & e2; --s2 >= 0 && (a2 *= 256); ) e2 < 0 && 0 === u2 && 0 !== this[r2 + s2 + 1] && (u2 = 1), this[r2 + s2] = (e2 / a2 >> 0) - u2 & 255;
            return r2 + n2;
          }, u.prototype.writeInt8 = function t3(e2, r2, n2) {
            return e2 = +e2, r2 |= 0, n2 || N(this, e2, r2, 1, 127, -128), u.TYPED_ARRAY_SUPPORT || (e2 = Math.floor(e2)), e2 < 0 && (e2 = 255 + e2 + 1), this[r2] = 255 & e2, r2 + 1;
          }, u.prototype.writeInt16LE = function t3(e2, r2, n2) {
            return e2 = +e2, r2 |= 0, n2 || N(this, e2, r2, 2, 32767, -32768), u.TYPED_ARRAY_SUPPORT ? (this[r2] = 255 & e2, this[r2 + 1] = e2 >>> 8) : U(this, e2, r2, true), r2 + 2;
          }, u.prototype.writeInt16BE = function t3(e2, r2, n2) {
            return e2 = +e2, r2 |= 0, n2 || N(this, e2, r2, 2, 32767, -32768), u.TYPED_ARRAY_SUPPORT ? (this[r2] = e2 >>> 8, this[r2 + 1] = 255 & e2) : U(this, e2, r2, false), r2 + 2;
          }, u.prototype.writeInt32LE = function t3(e2, r2, n2) {
            return e2 = +e2, r2 |= 0, n2 || N(this, e2, r2, 4, 2147483647, -2147483648), u.TYPED_ARRAY_SUPPORT ? (this[r2] = 255 & e2, this[r2 + 1] = e2 >>> 8, this[r2 + 2] = e2 >>> 16, this[r2 + 3] = e2 >>> 24) : B(this, e2, r2, true), r2 + 4;
          }, u.prototype.writeInt32BE = function t3(e2, r2, n2) {
            return e2 = +e2, r2 |= 0, n2 || N(this, e2, r2, 4, 2147483647, -2147483648), e2 < 0 && (e2 = 4294967295 + e2 + 1), u.TYPED_ARRAY_SUPPORT ? (this[r2] = e2 >>> 24, this[r2 + 1] = e2 >>> 16, this[r2 + 2] = e2 >>> 8, this[r2 + 3] = 255 & e2) : B(this, e2, r2, false), r2 + 4;
          }, u.prototype.writeFloatLE = function t3(e2, r2, n2) {
            return j(this, e2, r2, true, n2);
          }, u.prototype.writeFloatBE = function t3(e2, r2, n2) {
            return j(this, e2, r2, false, n2);
          }, u.prototype.writeDoubleLE = function t3(e2, r2, n2) {
            return M(this, e2, r2, true, n2);
          }, u.prototype.writeDoubleBE = function t3(e2, r2, n2) {
            return M(this, e2, r2, false, n2);
          }, u.prototype.copy = function t3(e2, r2, n2, i2) {
            if (n2 || (n2 = 0), i2 || 0 === i2 || (i2 = this.length), r2 >= e2.length && (r2 = e2.length), r2 || (r2 = 0), i2 > 0 && i2 < n2 && (i2 = n2), i2 === n2) return 0;
            if (0 === e2.length || 0 === this.length) return 0;
            if (r2 < 0) throw new RangeError("targetStart out of bounds");
            if (n2 < 0 || n2 >= this.length) throw new RangeError("sourceStart out of bounds");
            if (i2 < 0) throw new RangeError("sourceEnd out of bounds");
            i2 > this.length && (i2 = this.length), e2.length - r2 < i2 - n2 && (i2 = e2.length - r2 + n2);
            var o2, s2 = i2 - n2;
            if (this === e2 && n2 < r2 && r2 < i2) for (o2 = s2 - 1; o2 >= 0; --o2) e2[o2 + r2] = this[o2 + n2];
            else if (s2 < 1e3 || !u.TYPED_ARRAY_SUPPORT) for (o2 = 0; o2 < s2; ++o2) e2[o2 + r2] = this[o2 + n2];
            else Uint8Array.prototype.set.call(e2, this.subarray(n2, n2 + s2), r2);
            return s2;
          }, u.prototype.fill = function t3(e2, r2, n2, i2) {
            if ("string" == typeof e2) {
              if ("string" == typeof r2 ? (i2 = r2, r2 = 0, n2 = this.length) : "string" == typeof n2 && (i2 = n2, n2 = this.length), 1 === e2.length) {
                var o2 = e2.charCodeAt(0);
                o2 < 256 && (e2 = o2);
              }
              if (void 0 !== i2 && "string" != typeof i2) throw new TypeError("encoding must be a string");
              if ("string" == typeof i2 && !u.isEncoding(i2)) throw new TypeError("Unknown encoding: " + i2);
            } else "number" == typeof e2 && (e2 &= 255);
            if (r2 < 0 || this.length < r2 || this.length < n2) throw new RangeError("Out of range index");
            if (n2 <= r2) return this;
            var s2;
            if (r2 >>>= 0, n2 = void 0 === n2 ? this.length : n2 >>> 0, e2 || (e2 = 0), "number" == typeof e2) for (s2 = r2; s2 < n2; ++s2) this[s2] = e2;
            else {
              var a2 = u.isBuffer(e2) ? e2 : K(new u(e2, i2).toString()), c2 = a2.length;
              for (s2 = 0; s2 < n2 - r2; ++s2) this[s2 + r2] = a2[s2 % c2];
            }
            return this;
          };
          var H = /[^+\/0-9A-Za-z-_]/g;
          function V(t3) {
            return t3 < 16 ? "0" + t3.toString(16) : t3.toString(16);
          }
          function K(t3, e2) {
            var r2;
            e2 = e2 || 1 / 0;
            for (var n2 = t3.length, i2 = null, o2 = [], s2 = 0; s2 < n2; ++s2) {
              if ((r2 = t3.charCodeAt(s2)) > 55295 && r2 < 57344) {
                if (!i2) {
                  if (r2 > 56319) {
                    (e2 -= 3) > -1 && o2.push(239, 191, 189);
                    continue;
                  }
                  if (s2 + 1 === n2) {
                    (e2 -= 3) > -1 && o2.push(239, 191, 189);
                    continue;
                  }
                  i2 = r2;
                  continue;
                }
                if (r2 < 56320) {
                  (e2 -= 3) > -1 && o2.push(239, 191, 189), i2 = r2;
                  continue;
                }
                r2 = 65536 + (i2 - 55296 << 10 | r2 - 56320);
              } else i2 && (e2 -= 3) > -1 && o2.push(239, 191, 189);
              if (i2 = null, r2 < 128) {
                if ((e2 -= 1) < 0) break;
                o2.push(r2);
              } else if (r2 < 2048) {
                if ((e2 -= 2) < 0) break;
                o2.push(r2 >> 6 | 192, 63 & r2 | 128);
              } else if (r2 < 65536) {
                if ((e2 -= 3) < 0) break;
                o2.push(r2 >> 12 | 224, r2 >> 6 & 63 | 128, 63 & r2 | 128);
              } else {
                if (!(r2 < 1114112)) throw new Error("Invalid code point");
                if ((e2 -= 4) < 0) break;
                o2.push(r2 >> 18 | 240, r2 >> 12 & 63 | 128, r2 >> 6 & 63 | 128, 63 & r2 | 128);
              }
            }
            return o2;
          }
          function q(t3) {
            return n.toByteArray((function e2(t4) {
              if ((t4 = (function e3(t5) {
                return t5.trim ? t5.trim() : t5.replace(/^\s+|\s+$/g, "");
              })(t4).replace(H, "")).length < 2) return "";
              for (; t4.length % 4 != 0; ) t4 += "=";
              return t4;
            })(t3));
          }
          function J(t3, e2, r2, n2) {
            for (var i2 = 0; i2 < n2 && !(i2 + r2 >= e2.length || i2 >= t3.length); ++i2) e2[i2 + r2] = t3[i2];
            return i2;
          }
        }).call(this, r(29));
      }, function(t, e) {
        var r;
        r = /* @__PURE__ */ (function() {
          return this;
        })();
        try {
          r = r || new Function("return this")();
        } catch (t2) {
          "object" == typeof window && (r = window);
        }
        t.exports = r;
      }, function(t, e, r) {
        "use strict";
        e.byteLength = function n(t2) {
          var e2 = f(t2), r2 = e2[0], n2 = e2[1];
          return 3 * (r2 + n2) / 4 - n2;
        }, e.toByteArray = function i(t2) {
          var e2, r2, n = f(t2), i2 = n[0], o = n[1], s2 = new u((function c2(t3, e3, r3) {
            return 3 * (e3 + r3) / 4 - r3;
          })(0, i2, o)), h2 = 0, l2 = o > 0 ? i2 - 4 : i2;
          for (r2 = 0; r2 < l2; r2 += 4) e2 = a[t2.charCodeAt(r2)] << 18 | a[t2.charCodeAt(r2 + 1)] << 12 | a[t2.charCodeAt(r2 + 2)] << 6 | a[t2.charCodeAt(r2 + 3)], s2[h2++] = e2 >> 16 & 255, s2[h2++] = e2 >> 8 & 255, s2[h2++] = 255 & e2;
          2 === o && (e2 = a[t2.charCodeAt(r2)] << 2 | a[t2.charCodeAt(r2 + 1)] >> 4, s2[h2++] = 255 & e2);
          1 === o && (e2 = a[t2.charCodeAt(r2)] << 10 | a[t2.charCodeAt(r2 + 1)] << 4 | a[t2.charCodeAt(r2 + 2)] >> 2, s2[h2++] = e2 >> 8 & 255, s2[h2++] = 255 & e2);
          return s2;
        }, e.fromByteArray = function o(t2) {
          for (var e2, r2 = t2.length, n = r2 % 3, i = [], o2 = 16383, a2 = 0, u2 = r2 - n; a2 < u2; a2 += o2) i.push(g(t2, a2, a2 + o2 > u2 ? u2 : a2 + o2));
          1 === n ? (e2 = t2[r2 - 1], i.push(s[e2 >> 2] + s[e2 << 4 & 63] + "==")) : 2 === n && (e2 = (t2[r2 - 2] << 8) + t2[r2 - 1], i.push(s[e2 >> 10] + s[e2 >> 4 & 63] + s[e2 << 2 & 63] + "="));
          return i.join("");
        };
        for (var s = [], a = [], u = "undefined" != typeof Uint8Array ? Uint8Array : Array, c = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", h = 0, l = c.length; h < l; ++h) s[h] = c[h], a[c.charCodeAt(h)] = h;
        function f(t2) {
          var e2 = t2.length;
          if (e2 % 4 > 0) throw new Error("Invalid string. Length must be a multiple of 4");
          var r2 = t2.indexOf("=");
          return -1 === r2 && (r2 = e2), [r2, r2 === e2 ? 0 : 4 - r2 % 4];
        }
        function g(t2, e2, r2) {
          for (var n, i, o = [], a2 = e2; a2 < r2; a2 += 3) n = (t2[a2] << 16 & 16711680) + (t2[a2 + 1] << 8 & 65280) + (255 & t2[a2 + 2]), o.push(s[(i = n) >> 18 & 63] + s[i >> 12 & 63] + s[i >> 6 & 63] + s[63 & i]);
          return o.join("");
        }
        a["-".charCodeAt(0)] = 62, a["_".charCodeAt(0)] = 63;
      }, function(t, e) {
        e.read = function(t2, e2, r, n, i) {
          var o, s, a = 8 * i - n - 1, u = (1 << a) - 1, c = u >> 1, h = -7, l = r ? i - 1 : 0, f = r ? -1 : 1, g = t2[e2 + l];
          for (l += f, o = g & (1 << -h) - 1, g >>= -h, h += a; h > 0; o = 256 * o + t2[e2 + l], l += f, h -= 8) ;
          for (s = o & (1 << -h) - 1, o >>= -h, h += n; h > 0; s = 256 * s + t2[e2 + l], l += f, h -= 8) ;
          if (0 === o) o = 1 - c;
          else {
            if (o === u) return s ? NaN : 1 / 0 * (g ? -1 : 1);
            s += Math.pow(2, n), o -= c;
          }
          return (g ? -1 : 1) * s * Math.pow(2, o - n);
        }, e.write = function(t2, e2, r, n, i, o) {
          var s, a, u, c = 8 * o - i - 1, h = (1 << c) - 1, l = h >> 1, f = 23 === i ? Math.pow(2, -24) - Math.pow(2, -77) : 0, g = n ? 0 : o - 1, d = n ? 1 : -1, p = e2 < 0 || 0 === e2 && 1 / e2 < 0 ? 1 : 0;
          for (e2 = Math.abs(e2), isNaN(e2) || e2 === 1 / 0 ? (a = isNaN(e2) ? 1 : 0, s = h) : (s = Math.floor(Math.log(e2) / Math.LN2), e2 * (u = Math.pow(2, -s)) < 1 && (s--, u *= 2), (e2 += s + l >= 1 ? f / u : f * Math.pow(2, 1 - l)) * u >= 2 && (s++, u /= 2), s + l >= h ? (a = 0, s = h) : s + l >= 1 ? (a = (e2 * u - 1) * Math.pow(2, i), s += l) : (a = e2 * Math.pow(2, l - 1) * Math.pow(2, i), s = 0)); i >= 8; t2[r + g] = 255 & a, g += d, a /= 256, i -= 8) ;
          for (s = s << i | a, c += i; c > 0; t2[r + g] = 255 & s, g += d, s /= 256, c -= 8) ;
          t2[r + g - d] |= 128 * p;
        };
      }, function(t, e) {
        var r = {}.toString;
        t.exports = Array.isArray || function(t2) {
          return "[object Array]" == r.call(t2);
        };
      }, function(t, e, r) {
        "use strict";
        Object.defineProperty(e, "__esModule", { value: true }), e.default = function n(t2) {
          var e2 = t2.jws, r2 = t2.KeyUtil, n2 = t2.X509, o = t2.crypto, s = t2.hextob64u, a = t2.b64tohex, u = t2.AllowedSigningAlgs;
          return (function() {
            function t3() {
              !(function e3(t4, r3) {
                if (!(t4 instanceof r3)) throw new TypeError("Cannot call a class as a function");
              })(this, t3);
            }
            return t3.parseJwt = function t4(r3) {
              i.Log.debug("JoseUtil.parseJwt");
              try {
                var n3 = e2.JWS.parse(r3);
                return { header: n3.headerObj, payload: n3.payloadObj };
              } catch (t5) {
                i.Log.error(t5);
              }
            }, t3.validateJwt = function e3(o2, s2, u2, c, h, l, f) {
              i.Log.debug("JoseUtil.validateJwt");
              try {
                if ("RSA" === s2.kty) if (s2.e && s2.n) s2 = r2.getKey(s2);
                else {
                  if (!s2.x5c || !s2.x5c.length) return i.Log.error("JoseUtil.validateJwt: RSA key missing key material", s2), Promise.reject(new Error("RSA key missing key material"));
                  var g = a(s2.x5c[0]);
                  s2 = n2.getPublicKeyFromCertHex(g);
                }
                else {
                  if ("EC" !== s2.kty) return i.Log.error("JoseUtil.validateJwt: Unsupported key type", s2 && s2.kty), Promise.reject(new Error(s2.kty));
                  if (!(s2.crv && s2.x && s2.y)) return i.Log.error("JoseUtil.validateJwt: EC key missing key material", s2), Promise.reject(new Error("EC key missing key material"));
                  s2 = r2.getKey(s2);
                }
                return t3._validateJwt(o2, s2, u2, c, h, l, f);
              } catch (t4) {
                return i.Log.error(t4 && t4.message || t4), Promise.reject("JWT validation failed");
              }
            }, t3.validateJwtAttributes = function e3(r3, n3, o2, s2, a2, u2) {
              s2 || (s2 = 0), a2 || (a2 = parseInt(Date.now() / 1e3));
              var c = t3.parseJwt(r3).payload;
              if (!c.iss) return i.Log.error("JoseUtil._validateJwt: issuer was not provided"), Promise.reject(new Error("issuer was not provided"));
              if (c.iss !== n3) return i.Log.error("JoseUtil._validateJwt: Invalid issuer in token", c.iss), Promise.reject(new Error("Invalid issuer in token: " + c.iss));
              if (!c.aud) return i.Log.error("JoseUtil._validateJwt: aud was not provided"), Promise.reject(new Error("aud was not provided"));
              if (!(c.aud === o2 || Array.isArray(c.aud) && c.aud.indexOf(o2) >= 0)) return i.Log.error("JoseUtil._validateJwt: Invalid audience in token", c.aud), Promise.reject(new Error("Invalid audience in token: " + c.aud));
              if (c.azp && c.azp !== o2) return i.Log.error("JoseUtil._validateJwt: Invalid azp in token", c.azp), Promise.reject(new Error("Invalid azp in token: " + c.azp));
              if (!u2) {
                var h = a2 + s2, l = a2 - s2;
                if (!c.iat) return i.Log.error("JoseUtil._validateJwt: iat was not provided"), Promise.reject(new Error("iat was not provided"));
                if (h < c.iat) return i.Log.error("JoseUtil._validateJwt: iat is in the future", c.iat), Promise.reject(new Error("iat is in the future: " + c.iat));
                if (c.nbf && h < c.nbf) return i.Log.error("JoseUtil._validateJwt: nbf is in the future", c.nbf), Promise.reject(new Error("nbf is in the future: " + c.nbf));
                if (!c.exp) return i.Log.error("JoseUtil._validateJwt: exp was not provided"), Promise.reject(new Error("exp was not provided"));
                if (c.exp < l) return i.Log.error("JoseUtil._validateJwt: exp is in the past", c.exp), Promise.reject(new Error("exp is in the past:" + c.exp));
              }
              return Promise.resolve(c);
            }, t3._validateJwt = function r3(n3, o2, s2, a2, c, h, l) {
              return t3.validateJwtAttributes(n3, s2, a2, c, h, l).then((function(t4) {
                try {
                  return e2.JWS.verify(n3, o2, u) ? t4 : (i.Log.error("JoseUtil._validateJwt: signature validation failed"), Promise.reject(new Error("signature validation failed")));
                } catch (t5) {
                  return i.Log.error(t5 && t5.message || t5), Promise.reject(new Error("signature validation failed"));
                }
              }));
            }, t3.hashString = function t4(e3, r3) {
              try {
                return o.Util.hashString(e3, r3);
              } catch (t5) {
                i.Log.error(t5);
              }
            }, t3.hexToBase64Url = function t4(e3) {
              try {
                return s(e3);
              } catch (t5) {
                i.Log.error(t5);
              }
            }, t3;
          })();
        };
        var i = r(0);
        t.exports = e.default;
      }, function(t, e, r) {
        "use strict";
        Object.defineProperty(e, "__esModule", { value: true }), e.SigninResponse = void 0;
        var n = /* @__PURE__ */ (function() {
          function t2(t3, e2) {
            for (var r2 = 0; r2 < e2.length; r2++) {
              var n2 = e2[r2];
              n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(t3, n2.key, n2);
            }
          }
          return function(e2, r2, n2) {
            return r2 && t2(e2.prototype, r2), n2 && t2(e2, n2), e2;
          };
        })(), i = r(3);
        function o(t2, e2) {
          if (!(t2 instanceof e2)) throw new TypeError("Cannot call a class as a function");
        }
        e.SigninResponse = (function() {
          function t2(e2) {
            var r2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "#";
            o(this, t2);
            var n2 = i.UrlUtility.parseUrlFragment(e2, r2);
            this.error = n2.error, this.error_description = n2.error_description, this.error_uri = n2.error_uri, this.code = n2.code, this.state = n2.state, this.id_token = n2.id_token, this.session_state = n2.session_state, this.access_token = n2.access_token, this.token_type = n2.token_type, this.scope = n2.scope, this.profile = void 0, this.expires_in = n2.expires_in;
          }
          return n(t2, [{ key: "expires_in", get: function t3() {
            if (this.expires_at) {
              var e2 = parseInt(Date.now() / 1e3);
              return this.expires_at - e2;
            }
          }, set: function t3(e2) {
            var r2 = parseInt(e2);
            if ("number" == typeof r2 && r2 > 0) {
              var n2 = parseInt(Date.now() / 1e3);
              this.expires_at = n2 + r2;
            }
          } }, { key: "expired", get: function t3() {
            var e2 = this.expires_in;
            if (void 0 !== e2) return e2 <= 0;
          } }, { key: "scopes", get: function t3() {
            return (this.scope || "").split(" ");
          } }, { key: "isOpenIdConnect", get: function t3() {
            return this.scopes.indexOf("openid") >= 0 || !!this.id_token;
          } }]), t2;
        })();
      }, function(t, e, r) {
        "use strict";
        Object.defineProperty(e, "__esModule", { value: true }), e.SignoutRequest = void 0;
        var n = r(0), i = r(3), o = r(9);
        e.SignoutRequest = function t2(e2) {
          var r2 = e2.url, s = e2.id_token_hint, a = e2.post_logout_redirect_uri, u = e2.data, c = e2.extraQueryParams, h = e2.request_type;
          if ((function l(t3, e3) {
            if (!(t3 instanceof e3)) throw new TypeError("Cannot call a class as a function");
          })(this, t2), !r2) throw n.Log.error("SignoutRequest.ctor: No url passed"), new Error("url");
          for (var f in s && (r2 = i.UrlUtility.addQueryParam(r2, "id_token_hint", s)), a && (r2 = i.UrlUtility.addQueryParam(r2, "post_logout_redirect_uri", a), u && (this.state = new o.State({ data: u, request_type: h }), r2 = i.UrlUtility.addQueryParam(r2, "state", this.state.id))), c) r2 = i.UrlUtility.addQueryParam(r2, f, c[f]);
          this.url = r2;
        };
      }, function(t, e, r) {
        "use strict";
        Object.defineProperty(e, "__esModule", { value: true }), e.SignoutResponse = void 0;
        var n = r(3);
        e.SignoutResponse = function t2(e2) {
          !(function r2(t3, e3) {
            if (!(t3 instanceof e3)) throw new TypeError("Cannot call a class as a function");
          })(this, t2);
          var i = n.UrlUtility.parseUrlFragment(e2, "?");
          this.error = i.error, this.error_description = i.error_description, this.error_uri = i.error_uri, this.state = i.state;
        };
      }, function(t, e, r) {
        "use strict";
        Object.defineProperty(e, "__esModule", { value: true }), e.InMemoryWebStorage = void 0;
        var n = /* @__PURE__ */ (function() {
          function t2(t3, e2) {
            for (var r2 = 0; r2 < e2.length; r2++) {
              var n2 = e2[r2];
              n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(t3, n2.key, n2);
            }
          }
          return function(e2, r2, n2) {
            return r2 && t2(e2.prototype, r2), n2 && t2(e2, n2), e2;
          };
        })(), i = r(0);
        e.InMemoryWebStorage = (function() {
          function t2() {
            !(function e2(t3, r2) {
              if (!(t3 instanceof r2)) throw new TypeError("Cannot call a class as a function");
            })(this, t2), this._data = {};
          }
          return t2.prototype.getItem = function t3(e2) {
            return i.Log.debug("InMemoryWebStorage.getItem", e2), this._data[e2];
          }, t2.prototype.setItem = function t3(e2, r2) {
            i.Log.debug("InMemoryWebStorage.setItem", e2), this._data[e2] = r2;
          }, t2.prototype.removeItem = function t3(e2) {
            i.Log.debug("InMemoryWebStorage.removeItem", e2), delete this._data[e2];
          }, t2.prototype.key = function t3(e2) {
            return Object.getOwnPropertyNames(this._data)[e2];
          }, n(t2, [{ key: "length", get: function t3() {
            return Object.getOwnPropertyNames(this._data).length;
          } }]), t2;
        })();
      }, function(t, e, r) {
        "use strict";
        Object.defineProperty(e, "__esModule", { value: true }), e.UserManager = void 0;
        var n = /* @__PURE__ */ (function() {
          function t2(t3, e2) {
            for (var r2 = 0; r2 < e2.length; r2++) {
              var n2 = e2[r2];
              n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(t3, n2.key, n2);
            }
          }
          return function(e2, r2, n2) {
            return r2 && t2(e2.prototype, r2), n2 && t2(e2, n2), e2;
          };
        })(), i = r(0), o = r(10), s = r(39), a = r(15), u = r(45), c = r(47), h = r(18), l = r(8), f = r(20), g = r(11), d = r(4);
        function p(t2, e2) {
          if (!(t2 instanceof e2)) throw new TypeError("Cannot call a class as a function");
        }
        function v(t2, e2) {
          if (!t2) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
          return !e2 || "object" != typeof e2 && "function" != typeof e2 ? t2 : e2;
        }
        e.UserManager = (function(t2) {
          function e2() {
            var r2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, n2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : c.SilentRenewService, o2 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : h.SessionMonitor, a2 = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : f.TokenRevocationClient, l2 = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : g.TokenClient, y = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : d.JoseUtil;
            p(this, e2), r2 instanceof s.UserManagerSettings || (r2 = new s.UserManagerSettings(r2));
            var m = v(this, t2.call(this, r2));
            return m._events = new u.UserManagerEvents(r2), m._silentRenewService = new n2(m), m.settings.automaticSilentRenew && (i.Log.debug("UserManager.ctor: automaticSilentRenew is configured, setting up silent renew"), m.startSilentRenew()), m.settings.monitorSession && (i.Log.debug("UserManager.ctor: monitorSession is configured, setting up session monitor"), m._sessionMonitor = new o2(m)), m._tokenRevocationClient = new a2(m._settings), m._tokenClient = new l2(m._settings), m._joseUtil = y, m;
          }
          return (function r2(t3, e3) {
            if ("function" != typeof e3 && null !== e3) throw new TypeError("Super expression must either be null or a function, not " + typeof e3);
            t3.prototype = Object.create(e3 && e3.prototype, { constructor: { value: t3, enumerable: false, writable: true, configurable: true } }), e3 && (Object.setPrototypeOf ? Object.setPrototypeOf(t3, e3) : t3.__proto__ = e3);
          })(e2, t2), e2.prototype.getUser = function t3() {
            var e3 = this;
            return this._loadUser().then((function(t4) {
              return t4 ? (i.Log.info("UserManager.getUser: user loaded"), e3._events.load(t4, false), t4) : (i.Log.info("UserManager.getUser: user not found in storage"), null);
            }));
          }, e2.prototype.removeUser = function t3() {
            var e3 = this;
            return this.storeUser(null).then((function() {
              i.Log.info("UserManager.removeUser: user removed from storage"), e3._events.unload();
            }));
          }, e2.prototype.signinRedirect = function t3() {
            var e3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
            (e3 = Object.assign({}, e3)).request_type = "si:r";
            var r2 = { useReplaceToNavigate: e3.useReplaceToNavigate };
            return this._signinStart(e3, this._redirectNavigator, r2).then((function() {
              i.Log.info("UserManager.signinRedirect: successful");
            }));
          }, e2.prototype.signinRedirectCallback = function t3(e3) {
            return this._signinEnd(e3 || this._redirectNavigator.url).then((function(t4) {
              return t4.profile && t4.profile.sub ? i.Log.info("UserManager.signinRedirectCallback: successful, signed in sub: ", t4.profile.sub) : i.Log.info("UserManager.signinRedirectCallback: no sub"), t4;
            }));
          }, e2.prototype.signinPopup = function t3() {
            var e3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
            (e3 = Object.assign({}, e3)).request_type = "si:p";
            var r2 = e3.redirect_uri || this.settings.popup_redirect_uri || this.settings.redirect_uri;
            return r2 ? (e3.redirect_uri = r2, e3.display = "popup", this._signin(e3, this._popupNavigator, { startUrl: r2, popupWindowFeatures: e3.popupWindowFeatures || this.settings.popupWindowFeatures, popupWindowTarget: e3.popupWindowTarget || this.settings.popupWindowTarget }).then((function(t4) {
              return t4 && (t4.profile && t4.profile.sub ? i.Log.info("UserManager.signinPopup: signinPopup successful, signed in sub: ", t4.profile.sub) : i.Log.info("UserManager.signinPopup: no sub")), t4;
            }))) : (i.Log.error("UserManager.signinPopup: No popup_redirect_uri or redirect_uri configured"), Promise.reject(new Error("No popup_redirect_uri or redirect_uri configured")));
          }, e2.prototype.signinPopupCallback = function t3(e3) {
            return this._signinCallback(e3, this._popupNavigator).then((function(t4) {
              return t4 && (t4.profile && t4.profile.sub ? i.Log.info("UserManager.signinPopupCallback: successful, signed in sub: ", t4.profile.sub) : i.Log.info("UserManager.signinPopupCallback: no sub")), t4;
            })).catch((function(t4) {
              i.Log.error(t4.message);
            }));
          }, e2.prototype.signinSilent = function t3() {
            var e3 = this, r2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
            return r2 = Object.assign({}, r2), this._loadUser().then((function(t4) {
              return t4 && t4.refresh_token ? (r2.refresh_token = t4.refresh_token, e3._useRefreshToken(r2)) : (r2.request_type = "si:s", r2.id_token_hint = r2.id_token_hint || e3.settings.includeIdTokenInSilentRenew && t4 && t4.id_token, t4 && e3._settings.validateSubOnSilentRenew && (i.Log.debug("UserManager.signinSilent, subject prior to silent renew: ", t4.profile.sub), r2.current_sub = t4.profile.sub), e3._signinSilentIframe(r2));
            }));
          }, e2.prototype._useRefreshToken = function t3() {
            var e3 = this, r2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
            return this._tokenClient.exchangeRefreshToken(r2).then((function(t4) {
              return t4 ? t4.access_token ? e3._loadUser().then((function(r3) {
                if (r3) {
                  var n2 = Promise.resolve();
                  return t4.id_token && (n2 = e3._validateIdTokenFromTokenRefreshToken(r3.profile, t4.id_token)), n2.then((function() {
                    return i.Log.debug("UserManager._useRefreshToken: refresh token response success"), r3.id_token = t4.id_token || r3.id_token, r3.access_token = t4.access_token, r3.refresh_token = t4.refresh_token || r3.refresh_token, r3.expires_in = t4.expires_in, e3.storeUser(r3).then((function() {
                      return e3._events.load(r3), r3;
                    }));
                  }));
                }
                return null;
              })) : (i.Log.error("UserManager._useRefreshToken: No access token returned from token endpoint"), Promise.reject("No access token returned from token endpoint")) : (i.Log.error("UserManager._useRefreshToken: No response returned from token endpoint"), Promise.reject("No response returned from token endpoint"));
            }));
          }, e2.prototype._validateIdTokenFromTokenRefreshToken = function t3(e3, r2) {
            var n2 = this;
            return this._metadataService.getIssuer().then((function(t4) {
              return n2.settings.getEpochTime().then((function(o2) {
                return n2._joseUtil.validateJwtAttributes(r2, t4, n2._settings.client_id, n2._settings.clockSkew, o2).then((function(t5) {
                  return t5 ? t5.sub !== e3.sub ? (i.Log.error("UserManager._validateIdTokenFromTokenRefreshToken: sub in id_token does not match current sub"), Promise.reject(new Error("sub in id_token does not match current sub"))) : t5.auth_time && t5.auth_time !== e3.auth_time ? (i.Log.error("UserManager._validateIdTokenFromTokenRefreshToken: auth_time in id_token does not match original auth_time"), Promise.reject(new Error("auth_time in id_token does not match original auth_time"))) : t5.azp && t5.azp !== e3.azp ? (i.Log.error("UserManager._validateIdTokenFromTokenRefreshToken: azp in id_token does not match original azp"), Promise.reject(new Error("azp in id_token does not match original azp"))) : !t5.azp && e3.azp ? (i.Log.error("UserManager._validateIdTokenFromTokenRefreshToken: azp not in id_token, but present in original id_token"), Promise.reject(new Error("azp not in id_token, but present in original id_token"))) : void 0 : (i.Log.error("UserManager._validateIdTokenFromTokenRefreshToken: Failed to validate id_token"), Promise.reject(new Error("Failed to validate id_token")));
                }));
              }));
            }));
          }, e2.prototype._signinSilentIframe = function t3() {
            var e3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, r2 = e3.redirect_uri || this.settings.silent_redirect_uri || this.settings.redirect_uri;
            return r2 ? (e3.redirect_uri = r2, e3.prompt = e3.prompt || "none", this._signin(e3, this._iframeNavigator, { startUrl: r2, silentRequestTimeout: e3.silentRequestTimeout || this.settings.silentRequestTimeout }).then((function(t4) {
              return t4 && (t4.profile && t4.profile.sub ? i.Log.info("UserManager.signinSilent: successful, signed in sub: ", t4.profile.sub) : i.Log.info("UserManager.signinSilent: no sub")), t4;
            }))) : (i.Log.error("UserManager.signinSilent: No silent_redirect_uri configured"), Promise.reject(new Error("No silent_redirect_uri configured")));
          }, e2.prototype.signinSilentCallback = function t3(e3) {
            return this._signinCallback(e3, this._iframeNavigator).then((function(t4) {
              return t4 && (t4.profile && t4.profile.sub ? i.Log.info("UserManager.signinSilentCallback: successful, signed in sub: ", t4.profile.sub) : i.Log.info("UserManager.signinSilentCallback: no sub")), t4;
            }));
          }, e2.prototype.signinCallback = function t3(e3) {
            var r2 = this;
            return this.readSigninResponseState(e3).then((function(t4) {
              var n2 = t4.state;
              t4.response;
              return "si:r" === n2.request_type ? r2.signinRedirectCallback(e3) : "si:p" === n2.request_type ? r2.signinPopupCallback(e3) : "si:s" === n2.request_type ? r2.signinSilentCallback(e3) : Promise.reject(new Error("invalid response_type in state"));
            }));
          }, e2.prototype.signoutCallback = function t3(e3, r2) {
            var n2 = this;
            return this.readSignoutResponseState(e3).then((function(t4) {
              var i2 = t4.state, o2 = t4.response;
              return i2 ? "so:r" === i2.request_type ? n2.signoutRedirectCallback(e3) : "so:p" === i2.request_type ? n2.signoutPopupCallback(e3, r2) : Promise.reject(new Error("invalid response_type in state")) : o2;
            }));
          }, e2.prototype.querySessionStatus = function t3() {
            var e3 = this, r2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
            (r2 = Object.assign({}, r2)).request_type = "si:s";
            var n2 = r2.redirect_uri || this.settings.silent_redirect_uri || this.settings.redirect_uri;
            return n2 ? (r2.redirect_uri = n2, r2.prompt = "none", r2.response_type = r2.response_type || this.settings.query_status_response_type, r2.scope = r2.scope || "openid", r2.skipUserInfo = true, this._signinStart(r2, this._iframeNavigator, { startUrl: n2, silentRequestTimeout: r2.silentRequestTimeout || this.settings.silentRequestTimeout }).then((function(t4) {
              return e3.processSigninResponse(t4.url).then((function(t5) {
                if (i.Log.debug("UserManager.querySessionStatus: got signin response"), t5.session_state && t5.profile.sub) return i.Log.info("UserManager.querySessionStatus: querySessionStatus success for sub: ", t5.profile.sub), { session_state: t5.session_state, sub: t5.profile.sub, sid: t5.profile.sid };
                i.Log.info("querySessionStatus successful, user not authenticated");
              })).catch((function(t5) {
                if (t5.session_state && e3.settings.monitorAnonymousSession && ("login_required" == t5.message || "consent_required" == t5.message || "interaction_required" == t5.message || "account_selection_required" == t5.message)) return i.Log.info("UserManager.querySessionStatus: querySessionStatus success for anonymous user"), { session_state: t5.session_state };
                throw t5;
              }));
            }))) : (i.Log.error("UserManager.querySessionStatus: No silent_redirect_uri configured"), Promise.reject(new Error("No silent_redirect_uri configured")));
          }, e2.prototype._signin = function t3(e3, r2) {
            var n2 = this, i2 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
            return this._signinStart(e3, r2, i2).then((function(t4) {
              return n2._signinEnd(t4.url, e3);
            }));
          }, e2.prototype._signinStart = function t3(e3, r2) {
            var n2 = this, o2 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
            return r2.prepare(o2).then((function(t4) {
              return i.Log.debug("UserManager._signinStart: got navigator window handle"), n2.createSigninRequest(e3).then((function(e4) {
                return i.Log.debug("UserManager._signinStart: got signin request"), o2.url = e4.url, o2.id = e4.state.id, t4.navigate(o2);
              })).catch((function(e4) {
                throw t4.close && (i.Log.debug("UserManager._signinStart: Error after preparing navigator, closing navigator window"), t4.close()), e4;
              }));
            }));
          }, e2.prototype._signinEnd = function t3(e3) {
            var r2 = this, n2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
            return this.processSigninResponse(e3).then((function(t4) {
              i.Log.debug("UserManager._signinEnd: got signin response");
              var e4 = new a.User(t4);
              if (n2.current_sub) {
                if (n2.current_sub !== e4.profile.sub) return i.Log.debug("UserManager._signinEnd: current user does not match user returned from signin. sub from signin: ", e4.profile.sub), Promise.reject(new Error("login_required"));
                i.Log.debug("UserManager._signinEnd: current user matches user returned from signin");
              }
              return r2.storeUser(e4).then((function() {
                return i.Log.debug("UserManager._signinEnd: user stored"), r2._events.load(e4), e4;
              }));
            }));
          }, e2.prototype._signinCallback = function t3(e3, r2) {
            i.Log.debug("UserManager._signinCallback");
            var n2 = "query" === this._settings.response_mode || !this._settings.response_mode && l.SigninRequest.isCode(this._settings.response_type) ? "?" : "#";
            return r2.callback(e3, void 0, n2);
          }, e2.prototype.signoutRedirect = function t3() {
            var e3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
            (e3 = Object.assign({}, e3)).request_type = "so:r";
            var r2 = e3.post_logout_redirect_uri || this.settings.post_logout_redirect_uri;
            r2 && (e3.post_logout_redirect_uri = r2);
            var n2 = { useReplaceToNavigate: e3.useReplaceToNavigate };
            return this._signoutStart(e3, this._redirectNavigator, n2).then((function() {
              i.Log.info("UserManager.signoutRedirect: successful");
            }));
          }, e2.prototype.signoutRedirectCallback = function t3(e3) {
            return this._signoutEnd(e3 || this._redirectNavigator.url).then((function(t4) {
              return i.Log.info("UserManager.signoutRedirectCallback: successful"), t4;
            }));
          }, e2.prototype.signoutPopup = function t3() {
            var e3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
            (e3 = Object.assign({}, e3)).request_type = "so:p";
            var r2 = e3.post_logout_redirect_uri || this.settings.popup_post_logout_redirect_uri || this.settings.post_logout_redirect_uri;
            return e3.post_logout_redirect_uri = r2, e3.display = "popup", e3.post_logout_redirect_uri && (e3.state = e3.state || {}), this._signout(e3, this._popupNavigator, { startUrl: r2, popupWindowFeatures: e3.popupWindowFeatures || this.settings.popupWindowFeatures, popupWindowTarget: e3.popupWindowTarget || this.settings.popupWindowTarget }).then((function() {
              i.Log.info("UserManager.signoutPopup: successful");
            }));
          }, e2.prototype.signoutPopupCallback = function t3(e3, r2) {
            void 0 === r2 && "boolean" == typeof e3 && (r2 = e3, e3 = null);
            return this._popupNavigator.callback(e3, r2, "?").then((function() {
              i.Log.info("UserManager.signoutPopupCallback: successful");
            }));
          }, e2.prototype._signout = function t3(e3, r2) {
            var n2 = this, i2 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
            return this._signoutStart(e3, r2, i2).then((function(t4) {
              return n2._signoutEnd(t4.url);
            }));
          }, e2.prototype._signoutStart = function t3() {
            var e3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, r2 = this, n2 = arguments[1], o2 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
            return n2.prepare(o2).then((function(t4) {
              return i.Log.debug("UserManager._signoutStart: got navigator window handle"), r2._loadUser().then((function(n3) {
                return i.Log.debug("UserManager._signoutStart: loaded current user from storage"), (r2._settings.revokeAccessTokenOnSignout ? r2._revokeInternal(n3) : Promise.resolve()).then((function() {
                  var s2 = e3.id_token_hint || n3 && n3.id_token;
                  return s2 && (i.Log.debug("UserManager._signoutStart: Setting id_token into signout request"), e3.id_token_hint = s2), r2.removeUser().then((function() {
                    return i.Log.debug("UserManager._signoutStart: user removed, creating signout request"), r2.createSignoutRequest(e3).then((function(e4) {
                      return i.Log.debug("UserManager._signoutStart: got signout request"), o2.url = e4.url, e4.state && (o2.id = e4.state.id), t4.navigate(o2);
                    }));
                  }));
                }));
              })).catch((function(e4) {
                throw t4.close && (i.Log.debug("UserManager._signoutStart: Error after preparing navigator, closing navigator window"), t4.close()), e4;
              }));
            }));
          }, e2.prototype._signoutEnd = function t3(e3) {
            return this.processSignoutResponse(e3).then((function(t4) {
              return i.Log.debug("UserManager._signoutEnd: got signout response"), t4;
            }));
          }, e2.prototype.revokeAccessToken = function t3() {
            var e3 = this;
            return this._loadUser().then((function(t4) {
              return e3._revokeInternal(t4, true).then((function(r2) {
                if (r2) return i.Log.debug("UserManager.revokeAccessToken: removing token properties from user and re-storing"), t4.access_token = null, t4.refresh_token = null, t4.expires_at = null, t4.token_type = null, e3.storeUser(t4).then((function() {
                  i.Log.debug("UserManager.revokeAccessToken: user stored"), e3._events.load(t4);
                }));
              }));
            })).then((function() {
              i.Log.info("UserManager.revokeAccessToken: access token revoked successfully");
            }));
          }, e2.prototype._revokeInternal = function t3(e3, r2) {
            var n2 = this;
            if (e3) {
              var o2 = e3.access_token, s2 = e3.refresh_token;
              return this._revokeAccessTokenInternal(o2, r2).then((function(t4) {
                return n2._revokeRefreshTokenInternal(s2, r2).then((function(e4) {
                  return t4 || e4 || i.Log.debug("UserManager.revokeAccessToken: no need to revoke due to no token(s), or JWT format"), t4 || e4;
                }));
              }));
            }
            return Promise.resolve(false);
          }, e2.prototype._revokeAccessTokenInternal = function t3(e3, r2) {
            return !e3 || e3.indexOf(".") >= 0 ? Promise.resolve(false) : this._tokenRevocationClient.revoke(e3, r2).then((function() {
              return true;
            }));
          }, e2.prototype._revokeRefreshTokenInternal = function t3(e3, r2) {
            return e3 ? this._tokenRevocationClient.revoke(e3, r2, "refresh_token").then((function() {
              return true;
            })) : Promise.resolve(false);
          }, e2.prototype.startSilentRenew = function t3() {
            this._silentRenewService.start();
          }, e2.prototype.stopSilentRenew = function t3() {
            this._silentRenewService.stop();
          }, e2.prototype._loadUser = function t3() {
            return this._userStore.get(this._userStoreKey).then((function(t4) {
              return t4 ? (i.Log.debug("UserManager._loadUser: user storageString loaded"), a.User.fromStorageString(t4)) : (i.Log.debug("UserManager._loadUser: no user storageString"), null);
            }));
          }, e2.prototype.storeUser = function t3(e3) {
            if (e3) {
              i.Log.debug("UserManager.storeUser: storing user");
              var r2 = e3.toStorageString();
              return this._userStore.set(this._userStoreKey, r2);
            }
            return i.Log.debug("storeUser.storeUser: removing user"), this._userStore.remove(this._userStoreKey);
          }, n(e2, [{ key: "_redirectNavigator", get: function t3() {
            return this.settings.redirectNavigator;
          } }, { key: "_popupNavigator", get: function t3() {
            return this.settings.popupNavigator;
          } }, { key: "_iframeNavigator", get: function t3() {
            return this.settings.iframeNavigator;
          } }, { key: "_userStore", get: function t3() {
            return this.settings.userStore;
          } }, { key: "events", get: function t3() {
            return this._events;
          } }, { key: "_userStoreKey", get: function t3() {
            return "user:" + this.settings.authority + ":" + this.settings.client_id;
          } }]), e2;
        })(o.OidcClient);
      }, function(t, e, r) {
        "use strict";
        Object.defineProperty(e, "__esModule", { value: true }), e.UserManagerSettings = void 0;
        var n = /* @__PURE__ */ (function() {
          function t2(t3, e2) {
            for (var r2 = 0; r2 < e2.length; r2++) {
              var n2 = e2[r2];
              n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(t3, n2.key, n2);
            }
          }
          return function(e2, r2, n2) {
            return r2 && t2(e2.prototype, r2), n2 && t2(e2, n2), e2;
          };
        })(), i = (r(0), r(5)), o = r(40), s = r(41), a = r(43), u = r(6), c = r(1), h = r(8);
        function l(t2, e2) {
          if (!(t2 instanceof e2)) throw new TypeError("Cannot call a class as a function");
        }
        function f(t2, e2) {
          if (!t2) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
          return !e2 || "object" != typeof e2 && "function" != typeof e2 ? t2 : e2;
        }
        e.UserManagerSettings = (function(t2) {
          function e2() {
            var r2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, n2 = r2.popup_redirect_uri, i2 = r2.popup_post_logout_redirect_uri, g = r2.popupWindowFeatures, d = r2.popupWindowTarget, p = r2.silent_redirect_uri, v = r2.silentRequestTimeout, y = r2.automaticSilentRenew, m = void 0 !== y && y, _ = r2.validateSubOnSilentRenew, S = void 0 !== _ && _, b = r2.includeIdTokenInSilentRenew, w = void 0 === b || b, F = r2.monitorSession, E = void 0 === F || F, x = r2.monitorAnonymousSession, A = void 0 !== x && x, k = r2.checkSessionInterval, P = void 0 === k ? 2e3 : k, C = r2.stopCheckSessionOnError, T = void 0 === C || C, R = r2.query_status_response_type, I = r2.revokeAccessTokenOnSignout, D = void 0 !== I && I, L = r2.accessTokenExpiringNotificationTime, N = void 0 === L ? 60 : L, U = r2.redirectNavigator, B = void 0 === U ? new o.RedirectNavigator() : U, O = r2.popupNavigator, j = void 0 === O ? new s.PopupNavigator() : O, M = r2.iframeNavigator, H = void 0 === M ? new a.IFrameNavigator() : M, V = r2.userStore, K = void 0 === V ? new u.WebStorageStateStore({ store: c.Global.sessionStorage }) : V;
            l(this, e2);
            var q = f(this, t2.call(this, arguments[0]));
            return q._popup_redirect_uri = n2, q._popup_post_logout_redirect_uri = i2, q._popupWindowFeatures = g, q._popupWindowTarget = d, q._silent_redirect_uri = p, q._silentRequestTimeout = v, q._automaticSilentRenew = m, q._validateSubOnSilentRenew = S, q._includeIdTokenInSilentRenew = w, q._accessTokenExpiringNotificationTime = N, q._monitorSession = E, q._monitorAnonymousSession = A, q._checkSessionInterval = P, q._stopCheckSessionOnError = T, R ? q._query_status_response_type = R : arguments[0] && arguments[0].response_type ? q._query_status_response_type = h.SigninRequest.isOidc(arguments[0].response_type) ? "id_token" : "code" : q._query_status_response_type = "id_token", q._revokeAccessTokenOnSignout = D, q._redirectNavigator = B, q._popupNavigator = j, q._iframeNavigator = H, q._userStore = K, q;
          }
          return (function r2(t3, e3) {
            if ("function" != typeof e3 && null !== e3) throw new TypeError("Super expression must either be null or a function, not " + typeof e3);
            t3.prototype = Object.create(e3 && e3.prototype, { constructor: { value: t3, enumerable: false, writable: true, configurable: true } }), e3 && (Object.setPrototypeOf ? Object.setPrototypeOf(t3, e3) : t3.__proto__ = e3);
          })(e2, t2), n(e2, [{ key: "popup_redirect_uri", get: function t3() {
            return this._popup_redirect_uri;
          } }, { key: "popup_post_logout_redirect_uri", get: function t3() {
            return this._popup_post_logout_redirect_uri;
          } }, { key: "popupWindowFeatures", get: function t3() {
            return this._popupWindowFeatures;
          } }, { key: "popupWindowTarget", get: function t3() {
            return this._popupWindowTarget;
          } }, { key: "silent_redirect_uri", get: function t3() {
            return this._silent_redirect_uri;
          } }, { key: "silentRequestTimeout", get: function t3() {
            return this._silentRequestTimeout;
          } }, { key: "automaticSilentRenew", get: function t3() {
            return this._automaticSilentRenew;
          } }, { key: "validateSubOnSilentRenew", get: function t3() {
            return this._validateSubOnSilentRenew;
          } }, { key: "includeIdTokenInSilentRenew", get: function t3() {
            return this._includeIdTokenInSilentRenew;
          } }, { key: "accessTokenExpiringNotificationTime", get: function t3() {
            return this._accessTokenExpiringNotificationTime;
          } }, { key: "monitorSession", get: function t3() {
            return this._monitorSession;
          } }, { key: "monitorAnonymousSession", get: function t3() {
            return this._monitorAnonymousSession;
          } }, { key: "checkSessionInterval", get: function t3() {
            return this._checkSessionInterval;
          } }, { key: "stopCheckSessionOnError", get: function t3() {
            return this._stopCheckSessionOnError;
          } }, { key: "query_status_response_type", get: function t3() {
            return this._query_status_response_type;
          } }, { key: "revokeAccessTokenOnSignout", get: function t3() {
            return this._revokeAccessTokenOnSignout;
          } }, { key: "redirectNavigator", get: function t3() {
            return this._redirectNavigator;
          } }, { key: "popupNavigator", get: function t3() {
            return this._popupNavigator;
          } }, { key: "iframeNavigator", get: function t3() {
            return this._iframeNavigator;
          } }, { key: "userStore", get: function t3() {
            return this._userStore;
          } }]), e2;
        })(i.OidcClientSettings);
      }, function(t, e, r) {
        "use strict";
        Object.defineProperty(e, "__esModule", { value: true }), e.RedirectNavigator = void 0;
        var n = /* @__PURE__ */ (function() {
          function t2(t3, e2) {
            for (var r2 = 0; r2 < e2.length; r2++) {
              var n2 = e2[r2];
              n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(t3, n2.key, n2);
            }
          }
          return function(e2, r2, n2) {
            return r2 && t2(e2.prototype, r2), n2 && t2(e2, n2), e2;
          };
        })(), i = r(0);
        e.RedirectNavigator = (function() {
          function t2() {
            !(function e2(t3, r2) {
              if (!(t3 instanceof r2)) throw new TypeError("Cannot call a class as a function");
            })(this, t2);
          }
          return t2.prototype.prepare = function t3() {
            return Promise.resolve(this);
          }, t2.prototype.navigate = function t3(e2) {
            return e2 && e2.url ? (e2.useReplaceToNavigate ? window.location.replace(e2.url) : window.location = e2.url, Promise.resolve()) : (i.Log.error("RedirectNavigator.navigate: No url provided"), Promise.reject(new Error("No url provided")));
          }, n(t2, [{ key: "url", get: function t3() {
            return window.location.href;
          } }]), t2;
        })();
      }, function(t, e, r) {
        "use strict";
        Object.defineProperty(e, "__esModule", { value: true }), e.PopupNavigator = void 0;
        var n = r(0), i = r(42);
        e.PopupNavigator = (function() {
          function t2() {
            !(function e2(t3, r2) {
              if (!(t3 instanceof r2)) throw new TypeError("Cannot call a class as a function");
            })(this, t2);
          }
          return t2.prototype.prepare = function t3(e2) {
            var r2 = new i.PopupWindow(e2);
            return Promise.resolve(r2);
          }, t2.prototype.callback = function t3(e2, r2, o) {
            n.Log.debug("PopupNavigator.callback");
            try {
              return i.PopupWindow.notifyOpener(e2, r2, o), Promise.resolve();
            } catch (t4) {
              return Promise.reject(t4);
            }
          }, t2;
        })();
      }, function(t, e, r) {
        "use strict";
        Object.defineProperty(e, "__esModule", { value: true }), e.PopupWindow = void 0;
        var n = /* @__PURE__ */ (function() {
          function t2(t3, e2) {
            for (var r2 = 0; r2 < e2.length; r2++) {
              var n2 = e2[r2];
              n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(t3, n2.key, n2);
            }
          }
          return function(e2, r2, n2) {
            return r2 && t2(e2.prototype, r2), n2 && t2(e2, n2), e2;
          };
        })(), i = r(0), o = r(3);
        e.PopupWindow = (function() {
          function t2(e2) {
            var r2 = this;
            !(function n2(t3, e3) {
              if (!(t3 instanceof e3)) throw new TypeError("Cannot call a class as a function");
            })(this, t2), this._promise = new Promise((function(t3, e3) {
              r2._resolve = t3, r2._reject = e3;
            }));
            var o2 = e2.popupWindowTarget || "_blank", s = e2.popupWindowFeatures || "location=no,toolbar=no,width=500,height=500,left=100,top=100;";
            this._popup = window.open("", o2, s), this._popup && (i.Log.debug("PopupWindow.ctor: popup successfully created"), this._checkForPopupClosedTimer = window.setInterval(this._checkForPopupClosed.bind(this), 500));
          }
          return t2.prototype.navigate = function t3(e2) {
            return this._popup ? e2 && e2.url ? (i.Log.debug("PopupWindow.navigate: Setting URL in popup"), this._id = e2.id, this._id && (window["popupCallback_" + e2.id] = this._callback.bind(this)), this._popup.focus(), this._popup.window.location = e2.url) : (this._error("PopupWindow.navigate: no url provided"), this._error("No url provided")) : this._error("PopupWindow.navigate: Error opening popup window"), this.promise;
          }, t2.prototype._success = function t3(e2) {
            i.Log.debug("PopupWindow.callback: Successful response from popup window"), this._cleanup(), this._resolve(e2);
          }, t2.prototype._error = function t3(e2) {
            i.Log.error("PopupWindow.error: ", e2), this._cleanup(), this._reject(new Error(e2));
          }, t2.prototype.close = function t3() {
            this._cleanup(false);
          }, t2.prototype._cleanup = function t3(e2) {
            i.Log.debug("PopupWindow.cleanup"), window.clearInterval(this._checkForPopupClosedTimer), this._checkForPopupClosedTimer = null, delete window["popupCallback_" + this._id], this._popup && !e2 && this._popup.close(), this._popup = null;
          }, t2.prototype._checkForPopupClosed = function t3() {
            this._popup && !this._popup.closed || this._error("Popup window closed");
          }, t2.prototype._callback = function t3(e2, r2) {
            this._cleanup(r2), e2 ? (i.Log.debug("PopupWindow.callback success"), this._success({ url: e2 })) : (i.Log.debug("PopupWindow.callback: Invalid response from popup"), this._error("Invalid response from popup"));
          }, t2.notifyOpener = function t3(e2, r2, n2) {
            if (window.opener) {
              if (e2 = e2 || window.location.href) {
                var s = o.UrlUtility.parseUrlFragment(e2, n2);
                if (s.state) {
                  var a = "popupCallback_" + s.state, u = window.opener[a];
                  u ? (i.Log.debug("PopupWindow.notifyOpener: passing url message to opener"), u(e2, r2)) : i.Log.warn("PopupWindow.notifyOpener: no matching callback found on opener");
                } else i.Log.warn("PopupWindow.notifyOpener: no state found in response url");
              }
            } else i.Log.warn("PopupWindow.notifyOpener: no window.opener. Can't complete notification.");
          }, n(t2, [{ key: "promise", get: function t3() {
            return this._promise;
          } }]), t2;
        })();
      }, function(t, e, r) {
        "use strict";
        Object.defineProperty(e, "__esModule", { value: true }), e.IFrameNavigator = void 0;
        var n = r(0), i = r(44);
        e.IFrameNavigator = (function() {
          function t2() {
            !(function e2(t3, r2) {
              if (!(t3 instanceof r2)) throw new TypeError("Cannot call a class as a function");
            })(this, t2);
          }
          return t2.prototype.prepare = function t3(e2) {
            var r2 = new i.IFrameWindow(e2);
            return Promise.resolve(r2);
          }, t2.prototype.callback = function t3(e2) {
            n.Log.debug("IFrameNavigator.callback");
            try {
              return i.IFrameWindow.notifyParent(e2), Promise.resolve();
            } catch (t4) {
              return Promise.reject(t4);
            }
          }, t2;
        })();
      }, function(t, e, r) {
        "use strict";
        Object.defineProperty(e, "__esModule", { value: true }), e.IFrameWindow = void 0;
        var n = /* @__PURE__ */ (function() {
          function t2(t3, e2) {
            for (var r2 = 0; r2 < e2.length; r2++) {
              var n2 = e2[r2];
              n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(t3, n2.key, n2);
            }
          }
          return function(e2, r2, n2) {
            return r2 && t2(e2.prototype, r2), n2 && t2(e2, n2), e2;
          };
        })(), i = r(0);
        e.IFrameWindow = (function() {
          function t2(e2) {
            var r2 = this;
            !(function n2(t3, e3) {
              if (!(t3 instanceof e3)) throw new TypeError("Cannot call a class as a function");
            })(this, t2), this._promise = new Promise((function(t3, e3) {
              r2._resolve = t3, r2._reject = e3;
            })), this._boundMessageEvent = this._message.bind(this), window.addEventListener("message", this._boundMessageEvent, false), this._frame = window.document.createElement("iframe"), this._frame.style.visibility = "hidden", this._frame.style.position = "absolute", this._frame.width = 0, this._frame.height = 0, window.document.body.appendChild(this._frame);
          }
          return t2.prototype.navigate = function t3(e2) {
            if (e2 && e2.url) {
              var r2 = e2.silentRequestTimeout || 1e4;
              i.Log.debug("IFrameWindow.navigate: Using timeout of:", r2), this._timer = window.setTimeout(this._timeout.bind(this), r2), this._frame.src = e2.url;
            } else this._error("No url provided");
            return this.promise;
          }, t2.prototype._success = function t3(e2) {
            this._cleanup(), i.Log.debug("IFrameWindow: Successful response from frame window"), this._resolve(e2);
          }, t2.prototype._error = function t3(e2) {
            this._cleanup(), i.Log.error(e2), this._reject(new Error(e2));
          }, t2.prototype.close = function t3() {
            this._cleanup();
          }, t2.prototype._cleanup = function t3() {
            this._frame && (i.Log.debug("IFrameWindow: cleanup"), window.removeEventListener("message", this._boundMessageEvent, false), window.clearTimeout(this._timer), window.document.body.removeChild(this._frame), this._timer = null, this._frame = null, this._boundMessageEvent = null);
          }, t2.prototype._timeout = function t3() {
            i.Log.debug("IFrameWindow.timeout"), this._error("Frame window timed out");
          }, t2.prototype._message = function t3(e2) {
            if (i.Log.debug("IFrameWindow.message"), this._timer && e2.origin === this._origin && e2.source === this._frame.contentWindow && "string" == typeof e2.data && (e2.data.startsWith("http://") || e2.data.startsWith("https://"))) {
              var r2 = e2.data;
              r2 ? this._success({ url: r2 }) : this._error("Invalid response from frame");
            }
          }, t2.notifyParent = function t3(e2) {
            i.Log.debug("IFrameWindow.notifyParent"), (e2 = e2 || window.location.href) && (i.Log.debug("IFrameWindow.notifyParent: posting url message to parent"), window.parent.postMessage(e2, location.protocol + "//" + location.host));
          }, n(t2, [{ key: "promise", get: function t3() {
            return this._promise;
          } }, { key: "_origin", get: function t3() {
            return location.protocol + "//" + location.host;
          } }]), t2;
        })();
      }, function(t, e, r) {
        "use strict";
        Object.defineProperty(e, "__esModule", { value: true }), e.UserManagerEvents = void 0;
        var n = r(0), i = r(16), o = r(17);
        e.UserManagerEvents = (function(t2) {
          function e2(r2) {
            !(function n2(t3, e3) {
              if (!(t3 instanceof e3)) throw new TypeError("Cannot call a class as a function");
            })(this, e2);
            var i2 = (function s(t3, e3) {
              if (!t3) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              return !e3 || "object" != typeof e3 && "function" != typeof e3 ? t3 : e3;
            })(this, t2.call(this, r2));
            return i2._userLoaded = new o.Event("User loaded"), i2._userUnloaded = new o.Event("User unloaded"), i2._silentRenewError = new o.Event("Silent renew error"), i2._userSignedIn = new o.Event("User signed in"), i2._userSignedOut = new o.Event("User signed out"), i2._userSessionChanged = new o.Event("User session changed"), i2;
          }
          return (function r2(t3, e3) {
            if ("function" != typeof e3 && null !== e3) throw new TypeError("Super expression must either be null or a function, not " + typeof e3);
            t3.prototype = Object.create(e3 && e3.prototype, { constructor: { value: t3, enumerable: false, writable: true, configurable: true } }), e3 && (Object.setPrototypeOf ? Object.setPrototypeOf(t3, e3) : t3.__proto__ = e3);
          })(e2, t2), e2.prototype.load = function e3(r2) {
            var i2 = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];
            n.Log.debug("UserManagerEvents.load"), t2.prototype.load.call(this, r2), i2 && this._userLoaded.raise(r2);
          }, e2.prototype.unload = function e3() {
            n.Log.debug("UserManagerEvents.unload"), t2.prototype.unload.call(this), this._userUnloaded.raise();
          }, e2.prototype.addUserLoaded = function t3(e3) {
            this._userLoaded.addHandler(e3);
          }, e2.prototype.removeUserLoaded = function t3(e3) {
            this._userLoaded.removeHandler(e3);
          }, e2.prototype.addUserUnloaded = function t3(e3) {
            this._userUnloaded.addHandler(e3);
          }, e2.prototype.removeUserUnloaded = function t3(e3) {
            this._userUnloaded.removeHandler(e3);
          }, e2.prototype.addSilentRenewError = function t3(e3) {
            this._silentRenewError.addHandler(e3);
          }, e2.prototype.removeSilentRenewError = function t3(e3) {
            this._silentRenewError.removeHandler(e3);
          }, e2.prototype._raiseSilentRenewError = function t3(e3) {
            n.Log.debug("UserManagerEvents._raiseSilentRenewError", e3.message), this._silentRenewError.raise(e3);
          }, e2.prototype.addUserSignedIn = function t3(e3) {
            this._userSignedIn.addHandler(e3);
          }, e2.prototype.removeUserSignedIn = function t3(e3) {
            this._userSignedIn.removeHandler(e3);
          }, e2.prototype._raiseUserSignedIn = function t3() {
            n.Log.debug("UserManagerEvents._raiseUserSignedIn"), this._userSignedIn.raise();
          }, e2.prototype.addUserSignedOut = function t3(e3) {
            this._userSignedOut.addHandler(e3);
          }, e2.prototype.removeUserSignedOut = function t3(e3) {
            this._userSignedOut.removeHandler(e3);
          }, e2.prototype._raiseUserSignedOut = function t3() {
            n.Log.debug("UserManagerEvents._raiseUserSignedOut"), this._userSignedOut.raise();
          }, e2.prototype.addUserSessionChanged = function t3(e3) {
            this._userSessionChanged.addHandler(e3);
          }, e2.prototype.removeUserSessionChanged = function t3(e3) {
            this._userSessionChanged.removeHandler(e3);
          }, e2.prototype._raiseUserSessionChanged = function t3() {
            n.Log.debug("UserManagerEvents._raiseUserSessionChanged"), this._userSessionChanged.raise();
          }, e2;
        })(i.AccessTokenEvents);
      }, function(t, e, r) {
        "use strict";
        Object.defineProperty(e, "__esModule", { value: true }), e.Timer = void 0;
        var n = /* @__PURE__ */ (function() {
          function t2(t3, e2) {
            for (var r2 = 0; r2 < e2.length; r2++) {
              var n2 = e2[r2];
              n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(t3, n2.key, n2);
            }
          }
          return function(e2, r2, n2) {
            return r2 && t2(e2.prototype, r2), n2 && t2(e2, n2), e2;
          };
        })(), i = r(0), o = r(1), s = r(17);
        function a(t2, e2) {
          if (!(t2 instanceof e2)) throw new TypeError("Cannot call a class as a function");
        }
        function u(t2, e2) {
          if (!t2) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
          return !e2 || "object" != typeof e2 && "function" != typeof e2 ? t2 : e2;
        }
        e.Timer = (function(t2) {
          function e2(r2) {
            var n2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : o.Global.timer, i2 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : void 0;
            a(this, e2);
            var s2 = u(this, t2.call(this, r2));
            return s2._timer = n2, s2._nowFunc = i2 || function() {
              return Date.now() / 1e3;
            }, s2;
          }
          return (function r2(t3, e3) {
            if ("function" != typeof e3 && null !== e3) throw new TypeError("Super expression must either be null or a function, not " + typeof e3);
            t3.prototype = Object.create(e3 && e3.prototype, { constructor: { value: t3, enumerable: false, writable: true, configurable: true } }), e3 && (Object.setPrototypeOf ? Object.setPrototypeOf(t3, e3) : t3.__proto__ = e3);
          })(e2, t2), e2.prototype.init = function t3(e3) {
            e3 <= 0 && (e3 = 1), e3 = parseInt(e3);
            var r2 = this.now + e3;
            if (this.expiration === r2 && this._timerHandle) i.Log.debug("Timer.init timer " + this._name + " skipping initialization since already initialized for expiration:", this.expiration);
            else {
              this.cancel(), i.Log.debug("Timer.init timer " + this._name + " for duration:", e3), this._expiration = r2;
              var n2 = 5;
              e3 < n2 && (n2 = e3), this._timerHandle = this._timer.setInterval(this._callback.bind(this), 1e3 * n2);
            }
          }, e2.prototype.cancel = function t3() {
            this._timerHandle && (i.Log.debug("Timer.cancel: ", this._name), this._timer.clearInterval(this._timerHandle), this._timerHandle = null);
          }, e2.prototype._callback = function e3() {
            var r2 = this._expiration - this.now;
            i.Log.debug("Timer.callback; " + this._name + " timer expires in:", r2), this._expiration <= this.now && (this.cancel(), t2.prototype.raise.call(this));
          }, n(e2, [{ key: "now", get: function t3() {
            return parseInt(this._nowFunc());
          } }, { key: "expiration", get: function t3() {
            return this._expiration;
          } }]), e2;
        })(s.Event);
      }, function(t, e, r) {
        "use strict";
        Object.defineProperty(e, "__esModule", { value: true }), e.SilentRenewService = void 0;
        var n = r(0);
        e.SilentRenewService = (function() {
          function t2(e2) {
            !(function r2(t3, e3) {
              if (!(t3 instanceof e3)) throw new TypeError("Cannot call a class as a function");
            })(this, t2), this._userManager = e2;
          }
          return t2.prototype.start = function t3() {
            this._callback || (this._callback = this._tokenExpiring.bind(this), this._userManager.events.addAccessTokenExpiring(this._callback), this._userManager.getUser().then((function(t4) {
            })).catch((function(t4) {
              n.Log.error("SilentRenewService.start: Error from getUser:", t4.message);
            })));
          }, t2.prototype.stop = function t3() {
            this._callback && (this._userManager.events.removeAccessTokenExpiring(this._callback), delete this._callback);
          }, t2.prototype._tokenExpiring = function t3() {
            var e2 = this;
            this._userManager.signinSilent().then((function(t4) {
              n.Log.debug("SilentRenewService._tokenExpiring: Silent token renewal successful");
            }), (function(t4) {
              n.Log.error("SilentRenewService._tokenExpiring: Error from signinSilent:", t4.message), e2._userManager.events._raiseSilentRenewError(t4);
            }));
          }, t2;
        })();
      }, function(t, e, r) {
        "use strict";
        Object.defineProperty(e, "__esModule", { value: true }), e.CordovaPopupNavigator = void 0;
        var n = r(21);
        e.CordovaPopupNavigator = (function() {
          function t2() {
            !(function e2(t3, r2) {
              if (!(t3 instanceof r2)) throw new TypeError("Cannot call a class as a function");
            })(this, t2);
          }
          return t2.prototype.prepare = function t3(e2) {
            var r2 = new n.CordovaPopupWindow(e2);
            return Promise.resolve(r2);
          }, t2;
        })();
      }, function(t, e, r) {
        "use strict";
        Object.defineProperty(e, "__esModule", { value: true }), e.CordovaIFrameNavigator = void 0;
        var n = r(21);
        e.CordovaIFrameNavigator = (function() {
          function t2() {
            !(function e2(t3, r2) {
              if (!(t3 instanceof r2)) throw new TypeError("Cannot call a class as a function");
            })(this, t2);
          }
          return t2.prototype.prepare = function t3(e2) {
            e2.popupWindowFeatures = "hidden=yes";
            var r2 = new n.CordovaPopupWindow(e2);
            return Promise.resolve(r2);
          }, t2;
        })();
      }, function(t, e, r) {
        "use strict";
        Object.defineProperty(e, "__esModule", { value: true });
        e.Version = "1.11.6";
      }]);
    }));
  }
});

// node_modules/@inrupt/oidc-client-ext/dist/index.es.js
function processErrorResponse(responseBody, options) {
  if (responseBody.error === "invalid_redirect_uri") {
    throw new Error(`Dynamic client registration failed: the provided redirect uri [${options.redirectUrl?.toString()}] is invalid - ${responseBody.error_description ?? ""}`);
  }
  if (responseBody.error === "invalid_client_metadata") {
    throw new Error(`Dynamic client registration failed: the provided client metadata ${JSON.stringify(options)} is invalid - ${responseBody.error_description ?? ""}`);
  }
  throw new Error(`Dynamic client registration failed: ${responseBody.error} - ${responseBody.error_description ?? ""}`);
}
function hasClientId(body) {
  return typeof body.client_id === "string";
}
function hasRedirectUri(body) {
  return Array.isArray(body.redirect_uris) && body.redirect_uris.every((uri) => typeof uri === "string");
}
function validateRegistrationResponse(responseBody, options) {
  if (!hasClientId(responseBody)) {
    throw new Error(`Dynamic client registration failed: no client_id has been found on ${JSON.stringify(responseBody)}`);
  }
  if (options.redirectUrl && hasRedirectUri(responseBody) && responseBody.redirect_uris[0] !== options.redirectUrl.toString()) {
    throw new Error(`Dynamic client registration failed: the returned redirect URIs ${JSON.stringify(responseBody.redirect_uris)} don't match the provided ${JSON.stringify([
      options.redirectUrl.toString()
    ])}`);
  }
  return true;
}
async function registerClient(options, issuerConfig) {
  if (!issuerConfig.registrationEndpoint) {
    throw new Error("Dynamic Registration could not be completed because the issuer has no registration endpoint.");
  }
  if (!Array.isArray(issuerConfig.idTokenSigningAlgValuesSupported)) {
    throw new Error("The OIDC issuer discovery profile is missing the 'id_token_signing_alg_values_supported' value, which is mandatory.");
  }
  const signingAlg = determineSigningAlg(issuerConfig.idTokenSigningAlgValuesSupported, PREFERRED_SIGNING_ALG);
  const config2 = {
    /* eslint-disable camelcase */
    client_name: options.clientName,
    application_type: "web",
    redirect_uris: [options.redirectUrl?.toString()],
    subject_type: "public",
    token_endpoint_auth_method: "client_secret_basic",
    id_token_signed_response_alg: signingAlg,
    grant_types: ["authorization_code", "refresh_token"]
    /* eslint-enable camelcase */
  };
  const headers = {
    "Content-Type": "application/json"
  };
  const registerResponse = await fetch(issuerConfig.registrationEndpoint.toString(), {
    method: "POST",
    headers,
    body: JSON.stringify(config2)
  });
  if (registerResponse.ok) {
    const responseBody = await registerResponse.json();
    validateRegistrationResponse(responseBody, options);
    return {
      clientId: responseBody.client_id,
      clientSecret: responseBody.client_secret,
      expiresAt: responseBody.client_secret_expires_at,
      idTokenSignedResponseAlg: responseBody.id_token_signed_response_alg,
      clientType: "dynamic"
    };
  }
  if (registerResponse.status === 400) {
    processErrorResponse(await registerResponse.json(), options);
  }
  throw new Error(`Dynamic client registration failed: the server returned ${registerResponse.status} ${registerResponse.statusText} - ${await registerResponse.text()}`);
}
function hasError(value) {
  return value.error !== void 0 && typeof value.error === "string";
}
function hasErrorDescription(value) {
  return value.error_description !== void 0 && typeof value.error_description === "string";
}
function hasErrorUri(value) {
  return value.error_uri !== void 0 && typeof value.error_uri === "string";
}
function hasAccessToken(value) {
  return value.access_token !== void 0 && typeof value.access_token === "string";
}
function hasIdToken(value) {
  return value.id_token !== void 0 && typeof value.id_token === "string";
}
function hasRefreshToken(value) {
  return value.refresh_token !== void 0 && typeof value.refresh_token === "string";
}
function hasTokenType(value) {
  return value.token_type !== void 0 && typeof value.token_type === "string";
}
function hasExpiresIn(value) {
  return value.expires_in === void 0 || typeof value.expires_in === "number";
}
function validatePreconditions(issuer, data) {
  if (data.grantType && (!issuer.grantTypesSupported || !issuer.grantTypesSupported.includes(data.grantType))) {
    throw new Error(`The issuer [${issuer.issuer}] does not support the [${data.grantType}] grant`);
  }
  if (!issuer.tokenEndpoint) {
    throw new Error(`This issuer [${issuer.issuer}] does not have a token endpoint`);
  }
}
function validateTokenEndpointResponse(tokenResponse, dpop) {
  if (hasError(tokenResponse)) {
    throw new OidcProviderError(`Token endpoint returned error [${tokenResponse.error}]${hasErrorDescription(tokenResponse) ? `: ${tokenResponse.error_description}` : ""}${hasErrorUri(tokenResponse) ? ` (see ${tokenResponse.error_uri})` : ""}`, tokenResponse.error, hasErrorDescription(tokenResponse) ? tokenResponse.error_description : void 0);
  }
  if (!hasAccessToken(tokenResponse)) {
    throw new InvalidResponseError(["access_token"]);
  }
  if (!hasIdToken(tokenResponse)) {
    throw new InvalidResponseError(["id_token"]);
  }
  if (!hasTokenType(tokenResponse)) {
    throw new InvalidResponseError(["token_type"]);
  }
  if (!hasExpiresIn(tokenResponse)) {
    throw new InvalidResponseError(["expires_in"]);
  }
  if (!dpop && tokenResponse.token_type.toLowerCase() !== "bearer") {
    throw new Error(`Invalid token endpoint response: requested a [Bearer] token, but got a 'token_type' value of [${tokenResponse.token_type}].`);
  }
  return tokenResponse;
}
async function getTokens(issuer, client, data, dpop) {
  validatePreconditions(issuer, data);
  const headers = {
    "content-type": "application/x-www-form-urlencoded"
  };
  let dpopKey;
  if (dpop) {
    dpopKey = await generateDpopKeyPair();
    headers.DPoP = await createDpopHeader(issuer.tokenEndpoint, "POST", dpopKey);
  }
  if (client.clientSecret) {
    headers.Authorization = `Basic ${btoa(`${client.clientId}:${client.clientSecret}`)}`;
  }
  const requestBody = {
    /* eslint-disable camelcase */
    grant_type: data.grantType,
    redirect_uri: data.redirectUrl,
    code: data.code,
    code_verifier: data.codeVerifier,
    client_id: client.clientId
    /* eslint-enable camelcase */
  };
  const tokenRequestInit = {
    method: "POST",
    headers,
    body: new URLSearchParams(requestBody).toString()
  };
  const rawTokenResponse = await fetch(issuer.tokenEndpoint, tokenRequestInit);
  const jsonTokenResponse = await rawTokenResponse.json();
  const tokenResponse = validateTokenEndpointResponse(jsonTokenResponse, dpop);
  const { webId, clientId } = await getWebidFromTokenPayload(tokenResponse.id_token, issuer.jwksUri, issuer.issuer, client.clientId);
  return {
    accessToken: tokenResponse.access_token,
    idToken: tokenResponse.id_token,
    refreshToken: hasRefreshToken(tokenResponse) ? tokenResponse.refresh_token : void 0,
    webId,
    clientId,
    dpopKey,
    expiresIn: tokenResponse.expires_in
  };
}
async function refresh(refreshToken, issuer, client, dpopKey) {
  if (client.clientId === void 0) {
    throw new Error("No client ID available when trying to refresh the access token.");
  }
  const requestBody = {
    grant_type: "refresh_token",
    refresh_token: refreshToken
  };
  let dpopHeader = {};
  if (dpopKey !== void 0) {
    dpopHeader = {
      DPoP: await createDpopHeader(issuer.tokenEndpoint, "POST", dpopKey)
    };
  }
  let authHeader = {};
  if (client.clientSecret !== void 0) {
    authHeader = {
      // We assume that client_secret_basic is the client authentication method.
      // TODO: Get the authentication method from the IClient configuration object.
      Authorization: `Basic ${btoa(`${client.clientId}:${client.clientSecret}`)}`
    };
  } else if (isValidUrl2(client.clientId)) {
    requestBody.client_id = client.clientId;
  }
  const rawResponse = await fetch(issuer.tokenEndpoint, {
    method: "POST",
    body: new URLSearchParams(requestBody).toString(),
    headers: {
      ...dpopHeader,
      ...authHeader,
      "Content-Type": "application/x-www-form-urlencoded"
    }
  });
  let response;
  try {
    response = await rawResponse.json();
  } catch (e) {
    throw new Error(`The token endpoint of issuer ${issuer.issuer} returned a malformed response.`);
  }
  const validatedResponse = validateTokenEndpointResponse(response, dpopKey !== void 0);
  const { webId } = await getWebidFromTokenPayload(validatedResponse.id_token, issuer.jwksUri, issuer.issuer, client.clientId);
  return {
    accessToken: validatedResponse.access_token,
    idToken: validatedResponse.id_token,
    refreshToken: typeof validatedResponse.refresh_token === "string" ? validatedResponse.refresh_token : void 0,
    webId,
    dpopKey,
    expiresIn: validatedResponse.expires_in
  };
}
function normalizeCallbackUrl(redirectUrl) {
  const cleanedUrl = removeOpenIdParams(redirectUrl);
  cleanedUrl.hash = "";
  if (
    // The trailing slash is present in the original redirect URL
    redirectUrl.includes(`${cleanedUrl.origin}/`)
  ) {
    return cleanedUrl.href;
  }
  return `${cleanedUrl.origin}${cleanedUrl.href.substring(
    // Adds 1 to the origin length to remove the trailing slash
    cleanedUrl.origin.length + 1
  )}`;
}
async function clearOidcPersistentStorage() {
  const client = new import_oidc_client.OidcClient({
    // TODO: We should look at the various interfaces being used for storage,
    //  i.e. between oidc-client-js (WebStorageStoreState), localStorage
    //  (which has an interface Storage), and our own proprietary interface
    //  IStorage - i.e. we should really just be using the browser Web Storage
    //  API, e.g. "stateStore: window.localStorage,".
    // We are instantiating a new instance here, so the only value we need to
    // explicitly provide is the response mode (default otherwise will look
    // for a hash '#' fragment!).
    // eslint-disable-next-line camelcase
    response_mode: "query"
  });
  await client.clearStaleState(new import_oidc_client.WebStorageStateStore({}));
  const myStorage = window.localStorage;
  const itemsToRemove = [];
  for (let i = 0; i <= myStorage.length; i += 1) {
    const key = myStorage.key(i);
    if (key && (key.match(/^oidc\..+$/) || key.match(/^solidClientAuthenticationUser:.+$/))) {
      itemsToRemove.push(key);
    }
  }
  itemsToRemove.forEach((key) => myStorage.removeItem(key));
}
var import_oidc_client, import_oidc_client2, isValidUrl2;
var init_index_es = __esm({
  "node_modules/@inrupt/oidc-client-ext/dist/index.es.js"() {
    import_oidc_client = __toESM(require_oidc_client_min());
    import_oidc_client2 = __toESM(require_oidc_client_min());
    init_dist3();
    isValidUrl2 = (url2) => {
      try {
        new URL(url2);
        return true;
      } catch {
        return false;
      }
    };
  }
});

// node_modules/@inrupt/solid-client-authn-browser/dist/index.mjs
function hasIssuer(options) {
  return typeof options.oidcIssuer === "string";
}
function hasRedirectUrl(options) {
  return typeof options.redirectUrl === "string";
}
function processConfig(config2) {
  const parsedConfig = {};
  Object.keys(config2).forEach((key) => {
    if (issuerConfigKeyMap[key]) {
      parsedConfig[issuerConfigKeyMap[key].toKey] = config2[key];
    }
  });
  if (!Array.isArray(parsedConfig.scopesSupported)) {
    parsedConfig.scopesSupported = ["openid"];
  }
  return parsedConfig;
}
async function clear2(sessionId, storage) {
  await clear(sessionId, storage);
  await clearOidcPersistentStorage();
}
function getClientAuthenticationWithDependencies(dependencies) {
  const inMemoryStorage = new InMemoryStorage();
  const secureStorage = dependencies.secureStorage || inMemoryStorage;
  const insecureStorage = dependencies.insecureStorage || new BrowserStorage();
  const storageUtility = new StorageUtilityBrowser(secureStorage, insecureStorage);
  const issuerConfigFetcher = new IssuerConfigFetcher(storageUtility);
  const clientRegistrar = new ClientRegistrar(storageUtility);
  const sessionInfoManager = new SessionInfoManager(storageUtility);
  const tokenRefresher = new TokenRefresher(storageUtility, issuerConfigFetcher, clientRegistrar);
  const redirector = new Redirector();
  const loginHandler = new OidcLoginHandler(storageUtility, new AuthorizationCodeWithPkceOidcHandler(storageUtility, redirector), issuerConfigFetcher, clientRegistrar);
  const redirectHandler = new AggregateRedirectHandler([
    new ErrorOidcHandler(),
    new AuthCodeRedirectHandler(storageUtility, sessionInfoManager, issuerConfigFetcher, clientRegistrar, tokenRefresher),
    // This catch-all class will always be able to handle the
    // redirect IRI, so it must be registered last.
    new FallbackRedirectHandler()
  ]);
  return new ClientAuthentication2(loginHandler, redirectHandler, new IWaterfallLogoutHandler(sessionInfoManager, redirector), sessionInfoManager, issuerConfigFetcher);
}
async function silentlyAuthenticate(sessionId, clientAuthn, session) {
  const storedSessionInfo = await clientAuthn.validateCurrentSession(sessionId);
  if (storedSessionInfo !== null) {
    window.localStorage.setItem(KEY_CURRENT_URL, window.location.href);
    await clientAuthn.login({
      sessionId,
      prompt: "none",
      oidcIssuer: storedSessionInfo.issuer,
      redirectUrl: storedSessionInfo.redirectUrl,
      clientId: storedSessionInfo.clientAppId,
      clientSecret: storedSessionInfo.clientAppSecret,
      tokenType: storedSessionInfo.tokenType ?? "DPoP"
    }, session.events);
    return true;
  }
  return false;
}
function isLoggedIn(sessionInfo) {
  return !!sessionInfo?.isLoggedIn;
}
function getDefaultSession() {
  if (typeof defaultSession === "undefined") {
    defaultSession = new Session();
  }
  return defaultSession;
}
var import_events, StorageUtilityBrowser, ClientAuthentication2, OidcLoginHandler, AuthorizationCodeWithPkceOidcHandler, WELL_KNOWN_OPENID_CONFIG, issuerConfigKeyMap, IssuerConfigFetcher, SessionInfoManager, FallbackRedirectHandler, AuthCodeRedirectHandler, AggregateRedirectHandler, BrowserStorage, Redirector, ClientRegistrar, ErrorOidcHandler, TokenRefresher, KEY_CURRENT_SESSION, KEY_CURRENT_URL, Session, defaultSession;
var init_dist4 = __esm({
  "node_modules/@inrupt/solid-client-authn-browser/dist/index.mjs"() {
    init_dist3();
    init_dist3();
    init_esm_browser();
    import_events = __toESM(require_events(), 1);
    init_index_es();
    StorageUtilityBrowser = class extends StorageUtility {
      constructor(secureStorage, insecureStorage) {
        super(secureStorage, insecureStorage);
      }
    };
    ClientAuthentication2 = class extends ClientAuthentication {
      // Define these functions as properties so that they don't get accidentally re-bound.
      // Isn't Javascript fun?
      login = async (options, eventEmitter) => {
        if (options.prompt !== "none") {
          await this.sessionInfoManager.clear(options.sessionId);
        }
        const redirectUrl = options.redirectUrl ?? normalizeCallbackUrl(window.location.href);
        if (!isValidRedirectUrl(redirectUrl)) {
          throw new Error(`${redirectUrl} is not a valid redirect URL, it is either a malformed IRI, includes a hash fragment, or reserved query parameters ('code' or 'state').`);
        }
        await this.loginHandler.handle({
          ...options,
          redirectUrl,
          // If no clientName is provided, the clientId may be used instead.
          clientName: options.clientName ?? options.clientId,
          eventEmitter
        });
      };
      // Collects session information from storage, and returns them. Returns null
      // if the expected information cannot be found.
      // Note that the ID token is not stored, which means the session information
      // cannot be validated at this point.
      validateCurrentSession = async (currentSessionId) => {
        const sessionInfo = await this.sessionInfoManager.get(currentSessionId);
        if (sessionInfo === void 0 || sessionInfo.clientAppId === void 0 || sessionInfo.issuer === void 0) {
          return null;
        }
        return sessionInfo;
      };
      handleIncomingRedirect = async (url2, eventEmitter) => {
        try {
          const redirectInfo = await this.redirectHandler.handle(url2, eventEmitter, void 0);
          this.fetch = redirectInfo.fetch.bind(window);
          this.boundLogout = redirectInfo.getLogoutUrl;
          await this.cleanUrlAfterRedirect(url2);
          return {
            isLoggedIn: redirectInfo.isLoggedIn,
            webId: redirectInfo.webId,
            sessionId: redirectInfo.sessionId,
            expirationDate: redirectInfo.expirationDate,
            clientAppId: redirectInfo.clientAppId
          };
        } catch (err) {
          await this.cleanUrlAfterRedirect(url2);
          eventEmitter.emit(EVENTS.ERROR, "redirect", err);
          return void 0;
        }
      };
      async cleanUrlAfterRedirect(url2) {
        const cleanedUpUrl = removeOpenIdParams(url2).href;
        window.history.replaceState(null, "", cleanedUpUrl);
        while (window.location.href !== cleanedUpUrl) {
          await new Promise((resolve) => {
            setTimeout(() => resolve(), 1);
          });
        }
      }
    };
    OidcLoginHandler = class {
      storageUtility;
      oidcHandler;
      issuerConfigFetcher;
      clientRegistrar;
      constructor(storageUtility, oidcHandler, issuerConfigFetcher, clientRegistrar) {
        this.storageUtility = storageUtility;
        this.oidcHandler = oidcHandler;
        this.issuerConfigFetcher = issuerConfigFetcher;
        this.clientRegistrar = clientRegistrar;
        this.storageUtility = storageUtility;
        this.oidcHandler = oidcHandler;
        this.issuerConfigFetcher = issuerConfigFetcher;
        this.clientRegistrar = clientRegistrar;
      }
      async canHandle(options) {
        return hasIssuer(options) && hasRedirectUrl(options);
      }
      async handle(options) {
        if (!hasIssuer(options)) {
          throw new ConfigurationError(`OidcLoginHandler requires an OIDC issuer: missing property 'oidcIssuer' in ${JSON.stringify(options)}`);
        }
        if (!hasRedirectUrl(options)) {
          throw new ConfigurationError(`OidcLoginHandler requires a redirect URL: missing property 'redirectUrl' in ${JSON.stringify(options)}`);
        }
        const issuerConfig = await this.issuerConfigFetcher.fetchConfig(options.oidcIssuer);
        const clientRegistration = await handleRegistration(options, issuerConfig, this.storageUtility, this.clientRegistrar);
        const OidcOptions = {
          // Note that here, the issuer is not the one from the received options, but
          // from the issuer's config. This enforces the canonical URL is used and stored,
          // which is also the one present in the ID token, so storing a technically
          // valid, but different issuer URL (e.g. using a trailing slash or not) now
          // could prevent from validating the ID token later.
          issuer: issuerConfig.issuer,
          // TODO: differentiate if DPoP should be true
          dpop: options.tokenType.toLowerCase() === "dpop",
          ...options,
          issuerConfiguration: issuerConfig,
          client: clientRegistration,
          scopes: normalizeScopes(options.customScopes)
        };
        return this.oidcHandler.handle(OidcOptions);
      }
    };
    AuthorizationCodeWithPkceOidcHandler = class extends AuthorizationCodeWithPkceOidcHandlerBase {
      async handle(oidcLoginOptions) {
        const oidcOptions = {
          authority: oidcLoginOptions.issuer.toString(),
          client_id: oidcLoginOptions.client.clientId,
          client_secret: oidcLoginOptions.client.clientSecret,
          redirect_uri: oidcLoginOptions.redirectUrl,
          response_type: "code",
          scope: oidcLoginOptions.scopes.join(" "),
          filterProtocolClaims: true,
          // The userinfo endpoint on NSS fails, so disable this for now
          // Note that in Solid, information should be retrieved from the
          // profile referenced by the WebId.
          loadUserInfo: false,
          code_verifier: true,
          prompt: oidcLoginOptions.prompt ?? "consent"
        };
        const oidcClientLibrary = new import_oidc_client2.OidcClient(oidcOptions);
        try {
          const signingRequest = await oidcClientLibrary.createSigninRequest();
          return await this.setupRedirectHandler({
            oidcLoginOptions,
            // eslint-disable-next-line no-underscore-dangle
            state: signingRequest.state._id,
            // eslint-disable-next-line no-underscore-dangle
            codeVerifier: signingRequest.state._code_verifier,
            targetUrl: signingRequest.url.toString()
          });
        } catch (err) {
          console.error(err);
        }
        return void 0;
      }
    };
    WELL_KNOWN_OPENID_CONFIG = ".well-known/openid-configuration";
    issuerConfigKeyMap = {
      issuer: {
        toKey: "issuer",
        convertToUrl: true
      },
      authorization_endpoint: {
        toKey: "authorizationEndpoint",
        convertToUrl: true
      },
      token_endpoint: {
        toKey: "tokenEndpoint",
        convertToUrl: true
      },
      userinfo_endpoint: {
        toKey: "userinfoEndpoint",
        convertToUrl: true
      },
      jwks_uri: {
        toKey: "jwksUri",
        convertToUrl: true
      },
      registration_endpoint: {
        toKey: "registrationEndpoint",
        convertToUrl: true
      },
      end_session_endpoint: {
        toKey: "endSessionEndpoint",
        convertToUrl: true
      },
      scopes_supported: { toKey: "scopesSupported" },
      response_types_supported: { toKey: "responseTypesSupported" },
      response_modes_supported: { toKey: "responseModesSupported" },
      grant_types_supported: { toKey: "grantTypesSupported" },
      acr_values_supported: { toKey: "acrValuesSupported" },
      subject_types_supported: { toKey: "subjectTypesSupported" },
      id_token_signing_alg_values_supported: {
        toKey: "idTokenSigningAlgValuesSupported"
      },
      id_token_encryption_alg_values_supported: {
        toKey: "idTokenEncryptionAlgValuesSupported"
      },
      id_token_encryption_enc_values_supported: {
        toKey: "idTokenEncryptionEncValuesSupported"
      },
      userinfo_signing_alg_values_supported: {
        toKey: "userinfoSigningAlgValuesSupported"
      },
      userinfo_encryption_alg_values_supported: {
        toKey: "userinfoEncryptionAlgValuesSupported"
      },
      userinfo_encryption_enc_values_supported: {
        toKey: "userinfoEncryptionEncValuesSupported"
      },
      request_object_signing_alg_values_supported: {
        toKey: "requestObjectSigningAlgValuesSupported"
      },
      request_object_encryption_alg_values_supported: {
        toKey: "requestObjectEncryptionAlgValuesSupported"
      },
      request_object_encryption_enc_values_supported: {
        toKey: "requestObjectEncryptionEncValuesSupported"
      },
      token_endpoint_auth_methods_supported: {
        toKey: "tokenEndpointAuthMethodsSupported"
      },
      token_endpoint_auth_signing_alg_values_supported: {
        toKey: "tokenEndpointAuthSigningAlgValuesSupported"
      },
      display_values_supported: { toKey: "displayValuesSupported" },
      claim_types_supported: { toKey: "claimTypesSupported" },
      claims_supported: { toKey: "claimsSupported" },
      service_documentation: { toKey: "serviceDocumentation" },
      claims_locales_supported: { toKey: "claimsLocalesSupported" },
      ui_locales_supported: { toKey: "uiLocalesSupported" },
      claims_parameter_supported: { toKey: "claimsParameterSupported" },
      request_parameter_supported: { toKey: "requestParameterSupported" },
      request_uri_parameter_supported: { toKey: "requestUriParameterSupported" },
      require_request_uri_registration: { toKey: "requireRequestUriRegistration" },
      op_policy_uri: {
        toKey: "opPolicyUri",
        convertToUrl: true
      },
      op_tos_uri: {
        toKey: "opTosUri",
        convertToUrl: true
      }
    };
    IssuerConfigFetcher = class _IssuerConfigFetcher {
      storageUtility;
      constructor(storageUtility) {
        this.storageUtility = storageUtility;
        this.storageUtility = storageUtility;
      }
      // This method needs no state (so can be static), and can be exposed to allow
      // callers to know where this implementation puts state it needs.
      static getLocalStorageKey(issuer) {
        return `issuerConfig:${issuer}`;
      }
      async fetchConfig(issuer) {
        let issuerConfig;
        const openIdConfigUrl = new URL(
          WELL_KNOWN_OPENID_CONFIG,
          // Make sure to append a slash at issuer URL, so that the .well-known URL
          // includes the full issuer path. See https://openid.net/specs/openid-connect-discovery-1_0.html#ProviderConfig.
          issuer.endsWith("/") ? issuer : `${issuer}/`
        ).href;
        const issuerConfigRequestBody = await fetch(openIdConfigUrl);
        try {
          issuerConfig = processConfig(await issuerConfigRequestBody.json());
        } catch (err) {
          throw new ConfigurationError(`[${issuer.toString()}] has an invalid configuration: ${err.message}`);
        }
        await this.storageUtility.set(_IssuerConfigFetcher.getLocalStorageKey(issuer), JSON.stringify(issuerConfig));
        return issuerConfig;
      }
    };
    SessionInfoManager = class extends SessionInfoManagerBase {
      async get(sessionId) {
        const [isLoggedIn2, webId, clientId, clientSecret, redirectUrl, refreshToken, issuer, tokenType] = await Promise.all([
          this.storageUtility.getForUser(sessionId, "isLoggedIn", {
            secure: true
          }),
          this.storageUtility.getForUser(sessionId, "webId", {
            secure: true
          }),
          this.storageUtility.getForUser(sessionId, "clientId", {
            secure: false
          }),
          this.storageUtility.getForUser(sessionId, "clientSecret", {
            secure: false
          }),
          this.storageUtility.getForUser(sessionId, "redirectUrl", {
            secure: false
          }),
          this.storageUtility.getForUser(sessionId, "refreshToken", {
            secure: true
          }),
          this.storageUtility.getForUser(sessionId, "issuer", {
            secure: false
          }),
          this.storageUtility.getForUser(sessionId, "tokenType", {
            secure: false
          })
        ]);
        if (typeof redirectUrl === "string" && !isValidRedirectUrl(redirectUrl)) {
          await Promise.all([
            this.storageUtility.deleteAllUserData(sessionId, { secure: false }),
            this.storageUtility.deleteAllUserData(sessionId, { secure: true })
          ]);
          return void 0;
        }
        if (tokenType !== void 0 && !isSupportedTokenType(tokenType)) {
          throw new Error(`Tokens of type [${tokenType}] are not supported.`);
        }
        if (clientId === void 0 && isLoggedIn2 === void 0 && webId === void 0 && refreshToken === void 0) {
          return void 0;
        }
        return {
          sessionId,
          webId,
          isLoggedIn: isLoggedIn2 === "true",
          redirectUrl,
          refreshToken,
          issuer,
          clientAppId: clientId,
          clientAppSecret: clientSecret,
          // Default the token type to DPoP if unspecified.
          tokenType: tokenType ?? "DPoP"
        };
      }
      /**
       * This function removes all session-related information from storage.
       * @param sessionId the session identifier
       * @param storage the storage where session info is stored
       * @hidden
       */
      async clear(sessionId) {
        return clear2(sessionId, this.storageUtility);
      }
    };
    FallbackRedirectHandler = class {
      async canHandle(redirectUrl) {
        try {
          new URL(redirectUrl);
          return true;
        } catch (e) {
          throw new Error(`[${redirectUrl}] is not a valid URL, and cannot be used as a redirect URL: ${e}`);
        }
      }
      async handle(_redirectUrl) {
        return getUnauthenticatedSession();
      }
    };
    AuthCodeRedirectHandler = class {
      storageUtility;
      sessionInfoManager;
      issuerConfigFetcher;
      clientRegistrar;
      tokerRefresher;
      constructor(storageUtility, sessionInfoManager, issuerConfigFetcher, clientRegistrar, tokerRefresher) {
        this.storageUtility = storageUtility;
        this.sessionInfoManager = sessionInfoManager;
        this.issuerConfigFetcher = issuerConfigFetcher;
        this.clientRegistrar = clientRegistrar;
        this.tokerRefresher = tokerRefresher;
        this.storageUtility = storageUtility;
        this.sessionInfoManager = sessionInfoManager;
        this.issuerConfigFetcher = issuerConfigFetcher;
        this.clientRegistrar = clientRegistrar;
        this.tokerRefresher = tokerRefresher;
      }
      async canHandle(redirectUrl) {
        try {
          const myUrl = new URL(redirectUrl);
          return myUrl.searchParams.get("code") !== null && myUrl.searchParams.get("state") !== null;
        } catch (e) {
          throw new Error(`[${redirectUrl}] is not a valid URL, and cannot be used as a redirect URL: ${e}`);
        }
      }
      async handle(redirectUrl, eventEmitter) {
        if (!await this.canHandle(redirectUrl)) {
          throw new Error(`AuthCodeRedirectHandler cannot handle [${redirectUrl}]: it is missing one of [code, state].`);
        }
        const url2 = new URL(redirectUrl);
        const oauthState = url2.searchParams.get("state");
        const storedSessionId = await this.storageUtility.getForUser(oauthState, "sessionId", {
          errorIfNull: true
        });
        const { issuerConfig, codeVerifier, redirectUrl: storedRedirectIri, dpop: isDpop } = await loadOidcContextFromStorage(storedSessionId, this.storageUtility, this.issuerConfigFetcher);
        const iss = url2.searchParams.get("iss");
        if (typeof iss === "string" && iss !== issuerConfig.issuer) {
          throw new Error(`The value of the iss parameter (${iss}) does not match the issuer identifier of the authorization server (${issuerConfig.issuer}). See [rfc9207](https://www.rfc-editor.org/rfc/rfc9207.html#section-2.3-3.1.1)`);
        }
        if (codeVerifier === void 0) {
          throw new Error(`The code verifier for session ${storedSessionId} is missing from storage.`);
        }
        if (storedRedirectIri === void 0) {
          throw new Error(`The redirect URL for session ${storedSessionId} is missing from storage.`);
        }
        const client = await this.clientRegistrar.getClient({ sessionId: storedSessionId }, issuerConfig);
        const tokenCreatedAt = Date.now();
        const tokens = await getTokens(issuerConfig, client, {
          grantType: "authorization_code",
          // We rely on our 'canHandle' function checking that the OAuth 'code'
          // parameter is present in our query string.
          code: url2.searchParams.get("code"),
          codeVerifier,
          redirectUrl: storedRedirectIri
        }, isDpop);
        window.localStorage.removeItem(`oidc.${oauthState}`);
        let refreshOptions;
        if (tokens.refreshToken !== void 0) {
          refreshOptions = {
            sessionId: storedSessionId,
            refreshToken: tokens.refreshToken,
            tokenRefresher: this.tokerRefresher
          };
        }
        const authFetch = buildAuthenticatedFetch(tokens.accessToken, {
          dpopKey: tokens.dpopKey,
          refreshOptions,
          eventEmitter,
          expiresIn: tokens.expiresIn
        });
        await saveSessionInfoToStorage(this.storageUtility, storedSessionId, tokens.webId, tokens.clientId, "true", void 0, true);
        const sessionInfo = await this.sessionInfoManager.get(storedSessionId);
        if (!sessionInfo) {
          throw new Error(`Could not retrieve session: [${storedSessionId}].`);
        }
        return Object.assign(sessionInfo, {
          fetch: authFetch,
          getLogoutUrl: maybeBuildRpInitiatedLogout({
            idTokenHint: tokens.idToken,
            endSessionEndpoint: issuerConfig.endSessionEndpoint
          }),
          expirationDate: typeof tokens.expiresIn === "number" ? tokenCreatedAt + tokens.expiresIn * 1e3 : void 0
        });
      }
    };
    AggregateRedirectHandler = class extends AggregateHandler {
      constructor(redirectHandlers) {
        super(redirectHandlers);
      }
    };
    BrowserStorage = class {
      get storage() {
        return window.localStorage;
      }
      async get(key) {
        return this.storage.getItem(key) || void 0;
      }
      async set(key, value) {
        this.storage.setItem(key, value);
      }
      async delete(key) {
        this.storage.removeItem(key);
      }
    };
    Redirector = class {
      redirect(redirectUrl, options) {
        if (options && options.handleRedirect) {
          options.handleRedirect(redirectUrl);
        } else if (options && options.redirectByReplacingState) {
          window.history.replaceState({}, "", redirectUrl);
        } else {
          window.location.href = redirectUrl;
        }
      }
    };
    ClientRegistrar = class {
      storageUtility;
      constructor(storageUtility) {
        this.storageUtility = storageUtility;
        this.storageUtility = storageUtility;
      }
      async getClient(options, issuerConfig) {
        const [storedClientId, storedClientSecret, expiresAt, storedClientName, storedClientType] = await Promise.all([
          this.storageUtility.getForUser(options.sessionId, "clientId", {
            secure: false
          }),
          this.storageUtility.getForUser(options.sessionId, "clientSecret", {
            secure: false
          }),
          this.storageUtility.getForUser(options.sessionId, "expiresAt", {
            secure: false
          }),
          this.storageUtility.getForUser(options.sessionId, "clientName", {
            secure: false
          }),
          this.storageUtility.getForUser(options.sessionId, "clientType", {
            secure: false
          })
        ]);
        const expirationDate = expiresAt !== void 0 ? Number.parseInt(expiresAt, 10) : -1;
        const expired = storedClientSecret !== void 0 && expirationDate !== 0 && Math.floor(Date.now() / 1e3) > expirationDate;
        if (storedClientId && isKnownClientType(storedClientType) && !expired) {
          return storedClientSecret !== void 0 ? {
            clientId: storedClientId,
            clientSecret: storedClientSecret,
            clientName: storedClientName,
            // Note: static clients are not applicable in a browser context.
            clientType: "dynamic",
            expiresAt: expirationDate
          } : {
            clientId: storedClientId,
            clientName: storedClientName,
            // Note: static clients are not applicable in a browser context.
            clientType: storedClientType
            // The type assertion is required even though the type should match the declaration.
          };
        }
        try {
          const registeredClient = await registerClient(options, issuerConfig);
          const infoToSave = {
            clientId: registeredClient.clientId,
            clientType: "dynamic"
          };
          if (registeredClient.clientSecret !== void 0) {
            infoToSave.clientSecret = registeredClient.clientSecret;
            infoToSave.expiresAt = String(registeredClient.expiresAt);
          }
          if (registeredClient.idTokenSignedResponseAlg) {
            infoToSave.idTokenSignedResponseAlg = registeredClient.idTokenSignedResponseAlg;
          }
          await this.storageUtility.setForUser(options.sessionId, infoToSave, {
            // FIXME: figure out how to persist secure storage at reload
            // Otherwise, the client info cannot be retrieved from storage, and
            // the lib tries to re-register the client on each fetch
            secure: false
          });
          return registeredClient;
        } catch (error46) {
          throw new Error(`Client registration failed.`, { cause: error46 });
        }
      }
    };
    ErrorOidcHandler = class {
      async canHandle(redirectUrl) {
        try {
          return new URL(redirectUrl).searchParams.has("error");
        } catch (e) {
          throw new Error(`[${redirectUrl}] is not a valid URL, and cannot be used as a redirect URL: ${e}`);
        }
      }
      async handle(redirectUrl, eventEmitter) {
        if (eventEmitter !== void 0) {
          const url2 = new URL(redirectUrl);
          const errorUrl = url2.searchParams.get("error");
          const errorDescriptionUrl = url2.searchParams.get("error_description");
          eventEmitter.emit(EVENTS.ERROR, errorUrl, errorDescriptionUrl);
        }
        return getUnauthenticatedSession();
      }
    };
    TokenRefresher = class {
      storageUtility;
      issuerConfigFetcher;
      clientRegistrar;
      constructor(storageUtility, issuerConfigFetcher, clientRegistrar) {
        this.storageUtility = storageUtility;
        this.issuerConfigFetcher = issuerConfigFetcher;
        this.clientRegistrar = clientRegistrar;
        this.storageUtility = storageUtility;
        this.issuerConfigFetcher = issuerConfigFetcher;
        this.clientRegistrar = clientRegistrar;
      }
      async refresh(sessionId, refreshToken, dpopKey, eventEmitter) {
        const oidcContext = await loadOidcContextFromStorage(sessionId, this.storageUtility, this.issuerConfigFetcher);
        const clientInfo = await this.clientRegistrar.getClient({ sessionId }, oidcContext.issuerConfig);
        if (refreshToken === void 0) {
          throw new Error(`Session [${sessionId}] has no refresh token to allow it to refresh its access token.`);
        }
        if (oidcContext.dpop && dpopKey === void 0) {
          throw new Error(`For session [${sessionId}], the key bound to the DPoP access token must be provided to refresh said access token.`);
        }
        const tokenSet = await refresh(refreshToken, oidcContext.issuerConfig, clientInfo, dpopKey);
        if (tokenSet.refreshToken !== void 0) {
          eventEmitter?.emit(EVENTS.NEW_REFRESH_TOKEN, tokenSet.refreshToken);
        }
        return tokenSet;
      }
    };
    KEY_CURRENT_SESSION = `${SOLID_CLIENT_AUTHN_KEY_PREFIX}currentSession`;
    KEY_CURRENT_URL = `${SOLID_CLIENT_AUTHN_KEY_PREFIX}currentUrl`;
    Session = class {
      /**
       * Information regarding the current session.
       */
      info;
      /**
       * Session attribute exposing the EventEmitter interface, to listen on session
       * events such as login, logout, etc.
       * @since 1.15.0
       */
      events;
      clientAuthentication;
      tokenRequestInProgress = false;
      /**
       * Session object constructor. Typically called as follows:
       *
       * ```typescript
       * const session = new Session();
       * ```
       *
       * See also [getDefaultSession](https://docs.inrupt.com/developer-tools/api/javascript/solid-client-authn-browser/functions.html#getdefaultsession).
       *
       * @param sessionOptions The options enabling the correct instantiation of
       * the session. Either both storages or clientAuthentication are required. For
       * more information, see {@link ISessionOptions}.
       * @param sessionId A string uniquely identifying the session.
       *
       */
      constructor(sessionOptions = {}, sessionId = void 0) {
        this.events = new import_events.default();
        if (sessionOptions.clientAuthentication) {
          this.clientAuthentication = sessionOptions.clientAuthentication;
        } else if (sessionOptions.secureStorage && sessionOptions.insecureStorage) {
          this.clientAuthentication = getClientAuthenticationWithDependencies({
            secureStorage: sessionOptions.secureStorage,
            insecureStorage: sessionOptions.insecureStorage
          });
        } else {
          this.clientAuthentication = getClientAuthenticationWithDependencies({});
        }
        if (sessionOptions.sessionInfo) {
          this.info = {
            sessionId: sessionOptions.sessionInfo.sessionId,
            isLoggedIn: false,
            webId: sessionOptions.sessionInfo.webId,
            clientAppId: sessionOptions.sessionInfo.clientAppId
          };
        } else {
          this.info = {
            sessionId: sessionId ?? v4_default(),
            isLoggedIn: false
          };
        }
        this.events.on(EVENTS.LOGIN, () => window.localStorage.setItem(KEY_CURRENT_SESSION, this.info.sessionId));
        this.events.on(EVENTS.SESSION_EXPIRED, () => this.internalLogout(false));
        this.events.on(EVENTS.ERROR, () => this.internalLogout(false));
      }
      /**
       * Triggers the login process. Note that this method will redirect the user away from your app.
       *
       * @param options Parameter to customize the login behaviour. In particular, two options are mandatory: `options.oidcIssuer`, the user's identity provider, and `options.redirectUrl`, the URL to which the user will be redirected after logging in their identity provider.
       * @returns This method should redirect the user away from the app: it does not return anything. The login process is completed by {@linkcode handleIncomingRedirect}.
       */
      // Define these functions as properties so that they don't get accidentally re-bound.
      // Isn't Javascript fun?
      login = async (options) => {
        await this.clientAuthentication.login({
          sessionId: this.info.sessionId,
          ...options,
          // Defaults the token type to DPoP
          tokenType: options.tokenType ?? "DPoP"
        }, this.events);
        return new Promise(() => {
        });
      };
      /**
       * Fetches data using available login information. If the user is not logged in, this will behave as a regular `fetch`. The signature of this method is identical to the [canonical `fetch`](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API).
       *
       * @param url The URL from which data should be fetched.
       * @param init Optional parameters customizing the request, by specifying an HTTP method, headers, a body, etc. Follows the [WHATWG Fetch Standard](https://fetch.spec.whatwg.org/).
       */
      fetch = (url2, init) => this.clientAuthentication.fetch(url2, init);
      /**
       * An internal logout function, to control whether or not the logout signal
       * should be sent, i.e. if the logout was user-initiated or is the result of
       * an external event.
       *
       * @hidden
       */
      internalLogout = async (emitSignal, options) => {
        window.localStorage.removeItem(KEY_CURRENT_SESSION);
        await this.clientAuthentication.logout(this.info.sessionId, options);
        this.info.isLoggedIn = false;
        if (emitSignal) {
          this.events.emit(EVENTS.LOGOUT);
        }
      };
      /**
       * Logs the user out of the application.
       *
       * There are 2 types of logout supported by this library,
       * `app` logout and `idp` logout.
       *
       * App logout will log the user out within the application
       * by clearing any session data from the browser. It does
       * not log the user out of their Solid identity provider,
       * and should not redirect the user away.
       * App logout can be performed as follows:
       * ```typescript
       * await session.logout({ logoutType: 'app' });
       * ```
       *
       * IDP logout will log the user out of their Solid identity provider,
       * and will redirect the user away from the application to do so. In order
       * for users to be redirected back to `postLogoutUrl` you MUST include the
       * `postLogoutUrl` value in the `post_logout_redirect_uris` field in the
       * [Client ID Document](https://docs.inrupt.com/ess/latest/security/authentication/#client-identifier-client-id).
       * IDP logout can be performed as follows:
       * ```typescript
       * await session.logout({
       *  logoutType: 'idp',
       *  // An optional URL to redirect to after logout has completed;
       *  // this MUST match a logout URL listed in the Client ID Document
       *  // of the application that is logged in.
       *  // If the application is logged in with a Client ID that is not
       *  // a URI dereferencing to a Client ID Document then users will
       *  // not be redirected back to the `postLogoutUrl` after logout.
       *  postLogoutUrl: 'https://example.com/logout',
       *  // An optional value to be included in the query parameters
       *  // when the IDP provider redirects the user to the postLogoutRedirectUrl.
       *  state: "my-state"
       * });
       * ```
       */
      logout = async (options) => this.internalLogout(true, options);
      /**
       * Completes the login process by processing the information provided by the
       * Solid identity provider through redirect.
       *
       * @param options See {@link IHandleIncomingRedirectOptions}.
       */
      handleIncomingRedirect = async (inputOptions = {}) => {
        if (this.info.isLoggedIn) {
          return this.info;
        }
        if (this.tokenRequestInProgress) {
          return void 0;
        }
        const options = typeof inputOptions === "string" ? { url: inputOptions } : inputOptions;
        const url2 = options.url ?? window.location.href;
        this.tokenRequestInProgress = true;
        const sessionInfo = await this.clientAuthentication.handleIncomingRedirect(url2, this.events);
        if (isLoggedIn(sessionInfo)) {
          this.setSessionInfo(sessionInfo);
          const currentUrl = window.localStorage.getItem(KEY_CURRENT_URL);
          if (currentUrl === null) {
            this.events.emit(EVENTS.LOGIN);
          } else {
            window.localStorage.removeItem(KEY_CURRENT_URL);
            this.events.emit(EVENTS.SESSION_RESTORED, currentUrl);
          }
        } else if (options.restorePreviousSession === true) {
          const storedSessionId = window.localStorage.getItem(KEY_CURRENT_SESSION);
          if (storedSessionId !== null) {
            const attemptedSilentAuthentication = await silentlyAuthenticate(storedSessionId, this.clientAuthentication, this);
            if (attemptedSilentAuthentication) {
              return new Promise(() => {
              });
            }
          }
        }
        this.tokenRequestInProgress = false;
        return sessionInfo;
      };
      setSessionInfo(sessionInfo) {
        this.info.isLoggedIn = sessionInfo.isLoggedIn;
        this.info.webId = sessionInfo.webId;
        this.info.sessionId = sessionInfo.sessionId;
        this.info.clientAppId = sessionInfo.clientAppId;
        this.info.expirationDate = sessionInfo.expirationDate;
        this.events.on(EVENTS.SESSION_EXTENDED, (expiresIn) => {
          this.info.expirationDate = Date.now() + expiresIn * 1e3;
        });
      }
    };
  }
});

// src/ts/solid/meraBridge.ts
var meraBridge_exports = {};
__export(meraBridge_exports, {
  BridgeErrorType: () => BridgeErrorType,
  MeraBridge: () => MeraBridge,
  default: () => meraBridge_default
});
var BridgeErrorType, MeraBridge, bridgeInstance, meraBridge_default;
var init_meraBridge = __esm({
  "src/ts/solid/meraBridge.ts"() {
    "use strict";
    init_dist2();
    init_dist4();
    BridgeErrorType = /* @__PURE__ */ ((BridgeErrorType2) => {
      BridgeErrorType2["Authentication"] = "authentication";
      BridgeErrorType2["Network"] = "network";
      BridgeErrorType2["NotFound"] = "not_found";
      BridgeErrorType2["Storage"] = "storage";
      BridgeErrorType2["Validation"] = "validation";
      return BridgeErrorType2;
    })(BridgeErrorType || {});
    MeraBridge = class _MeraBridge {
      constructor() {
        this.session = null;
        this.podUrl = null;
        this.initialized = false;
        this.initializationPromise = null;
      }
      static {
        this.instance = null;
      }
      /**
       * Get singleton instance
       */
      static getInstance() {
        if (!_MeraBridge.instance) {
          _MeraBridge.instance = new _MeraBridge();
        }
        return _MeraBridge.instance;
      }
      // ==========================================================================
      // Initialization & Session Management
      // ==========================================================================
      /**
       * Initialize bridge - ensures session is ready and Pod URL is extracted
       *
       * Called automatically at module load (fire-and-forget pattern).
       *
       * Trusts Solid Client's built-in persistence:
       * - getDefaultSession() auto-restores from localStorage
       * - handleIncomingRedirect() handles both OAuth callbacks AND restoration
       * - No manual timestamp tracking needed
       *
       * @returns Promise<boolean> - true if authenticated, false otherwise
       */
      async initialize() {
        if (this.initializationPromise) {
          return this.initializationPromise;
        }
        this.initializationPromise = this._doInitialize();
        return this.initializationPromise;
      }
      async _doInitialize() {
        console.log("\u{1F309} Mera Bridge initializing...");
        try {
          this.session = getDefaultSession();
          console.log("\u{1F4CD} Step 1: Initial session check:", {
            sessionId: this.session.info.sessionId,
            isLoggedIn: this.session.info.isLoggedIn,
            webId: this.session.info.webId
          });
          const solidKeys = Object.keys(localStorage).filter(
            (k) => k.includes("solid") || k.includes("session") || k.includes("oidc")
          );
          console.log("\u{1F4CD} Step 1.5: localStorage investigation:", {
            hasCurrentSession: localStorage.getItem("solidClientAuthn:currentSession") !== null,
            solidKeyCount: solidKeys.length
          });
          console.log("\u{1F4CD} Step 2: Calling handleIncomingRedirect...");
          console.log("\u{1F4CD} Step 2a: URL:", window.location.href);
          console.log(
            "\u{1F4CD} Step 2b: Has OAuth params:",
            window.location.href.includes("code=")
          );
          await this.session.handleIncomingRedirect({
            url: window.location.href,
            restorePreviousSession: true
          });
          console.log("\u{1F4CD} Step 3: handleIncomingRedirect completed");
          this.session = getDefaultSession();
          console.log("\u{1F4CD} Step 4: Session after handleIncomingRedirect:", {
            sessionId: this.session.info.sessionId,
            isLoggedIn: this.session.info.isLoggedIn,
            webId: this.session.info.webId
          });
          if (this.session.info.isLoggedIn) {
            console.log("\u2705 User authenticated");
            if (this.session.info.sessionId) {
              localStorage.setItem(
                "solidClientAuthn:currentSession",
                this.session.info.sessionId
              );
              console.log("\u{1F4DD} Stored session marker for cross-page detection");
            }
            await this._extractPodUrl();
            this.initialized = true;
            return true;
          } else {
            console.log("\u26A0\uFE0F User not authenticated");
            if (solidKeys.length > 0) {
              console.log(
                "\u{1F504} Found Solid data without active session - triggering re-authentication"
              );
              console.log("\u{1F504} This will redirect you to login...");
              await this.session.login({
                oidcIssuer: "https://solidcommunity.net",
                redirectUrl: window.location.href,
                clientName: "Mera Digital Security Education"
              });
              return new Promise(() => {
              });
            }
            console.log(
              "\u26A0\uFE0F No Solid data found - new user or need to authenticate"
            );
            this.initialized = false;
            return false;
          }
        } catch (error46) {
          console.error("\u274C Bridge initialization failed:", error46);
          this.initialized = false;
          return false;
        }
      }
      /**
       * Extract Pod URL from authenticated session
       */
      async _extractPodUrl() {
        if (!this.session?.info.isLoggedIn) {
          throw new Error("Cannot extract Pod URL: not authenticated");
        }
        const webId = this.session.info.webId;
        if (!webId) {
          throw new Error("WebID not available in session");
        }
        const webIdUrl = new URL(webId);
        this.podUrl = `${webIdUrl.protocol}//${webIdUrl.host}`;
        console.log("\u{1F4E6} Pod URL extracted:", this.podUrl);
      }
      /**
       * Lightweight check for bridge readiness
       *
       * Bootstrap polls this method waiting for initialization to complete.
       * This is synchronous and just checks flags - doesn't trigger initialization.
       *
       * @returns boolean - true if initialized and authenticated
       */
      check() {
        return this.initialized && this.session?.info.isLoggedIn === true;
      }
      /**
       * Get authenticated user's WebID
       * @returns WebID string or null if not authenticated
       */
      getWebId() {
        return this.session?.info?.webId || null;
      }
      /**
       * Logout user
       * Solid Client handles clearing its own localStorage
       */
      async logout() {
        if (this.session) {
          await this.session.logout();
          this.initialized = false;
          console.log("\u{1F6AA} Logged out");
        }
      }
      // ==========================================================================
      // LocalStorage Operations (String-Based)
      // ==========================================================================
      /**
       * Save pre-stringified JSON to localStorage
       *
       * Architecture: Core handles JSON.stringify, bridge just stores bytes.
       * This ensures single serialization point and trivial verification.
       *
       * @param filename - Storage key (will be prefixed with mera_)
       * @param data - Pre-stringified JSON string
       * @returns BridgeResult indicating success/failure
       */
      async localSave(filename, data) {
        try {
          const key = `mera_${filename}`;
          localStorage.setItem(key, data);
          console.log("\u{1F4BE} Saved to localStorage:", filename);
          return { success: true, error: null };
        } catch (error46) {
          console.error("\u274C localStorage save failed:", error46);
          return {
            success: false,
            error: error46 instanceof Error ? error46.message : "Unknown error",
            errorType: "storage" /* Storage */
          };
        }
      }
      /**
       * Load raw JSON string from localStorage
       *
       * Returns the string directly - caller is responsible for parsing.
       * This ensures bridge doesn't need to understand data structure.
       *
       * @param filename - Storage key (mera_ prefix added automatically)
       * @returns BridgeResult<string> with raw JSON string or error
       */
      async localLoad(filename) {
        try {
          const key = `mera_${filename}`;
          const item = localStorage.getItem(key);
          if (!item) {
            return {
              success: false,
              error: "File not found",
              errorType: "not_found" /* NotFound */
            };
          }
          console.log("\u{1F4E5} Loaded from localStorage:", filename);
          return { success: true, data: item, error: null };
        } catch (error46) {
          console.error("\u274C localStorage load failed:", error46);
          return {
            success: false,
            error: error46 instanceof Error ? error46.message : "Unknown error",
            errorType: "storage" /* Storage */
          };
        }
      }
      /**
       * Delete file from localStorage
       *
       * @param filename - Storage key (mera_ prefix added automatically)
       * @returns BridgeResult indicating success/failure
       */
      async localDelete(filename) {
        try {
          const key = `mera_${filename}`;
          localStorage.removeItem(key);
          console.log("\u{1F5D1}\uFE0F Deleted from localStorage:", filename);
          return { success: true, error: null };
        } catch (error46) {
          console.error("\u274C localStorage delete failed:", error46);
          return {
            success: false,
            error: error46 instanceof Error ? error46.message : "Unknown error",
            errorType: "storage" /* Storage */
          };
        }
      }
      /**
       * List files in localStorage with mera_ prefix
       *
       * @param pattern - Optional glob pattern (e.g., "mera.*.*.*.lofp.*.json")
       * @returns BridgeResult<string[]> with matching filenames
       */
      async localList(pattern) {
        try {
          const allKeys = [];
          for (let i = 0; i < localStorage.length; i++) {
            const key = localStorage.key(i);
            if (key) {
              allKeys.push(key);
            }
          }
          const meraKeys = allKeys.filter((key) => key.startsWith("mera_"));
          const filenames = meraKeys.map((key) => key.replace("mera_", ""));
          const matched = pattern ? filenames.filter(
            (filename) => this._matchesPattern(filename, pattern)
          ) : filenames;
          console.log("\u{1F4CB} Listed localStorage files:", matched.length);
          return { success: true, data: matched, error: null };
        } catch (error46) {
          console.error("\u274C localStorage list failed:", error46);
          return {
            success: false,
            error: error46 instanceof Error ? error46.message : "Unknown error",
            errorType: "storage" /* Storage */
          };
        }
      }
      // ==========================================================================
      // Solid Pod Operations (String-Based)
      // ==========================================================================
      /**
       * Save pre-stringified JSON to Solid Pod
       *
       * Architecture: Core handles JSON.stringify, bridge just stores bytes.
       * This ensures single serialization point and trivial verification.
       *
       * Container path: /mera-learn/ (not /mera/ which is old path)
       *
       * @param filename - File name within mera-learn container
       * @param data - Pre-stringified JSON string
       * @returns BridgeResult indicating success/failure
       */
      async solidSave(filename, data) {
        try {
          if (!this.initialized) {
            await this.initialize();
          }
          if (!this.session?.info.isLoggedIn) {
            return {
              success: false,
              error: "Not authenticated",
              errorType: "authentication" /* Authentication */
            };
          }
          if (!this.podUrl) {
            return {
              success: false,
              error: "Pod URL not available",
              errorType: "authentication" /* Authentication */
            };
          }
          const containerUrl = `${this.podUrl}/mera-learn/`;
          try {
            await createContainerAt(containerUrl, { fetch: this.session.fetch });
          } catch {
          }
          const fileUrl = `${containerUrl}${filename}`;
          const blob = new Blob([data], { type: "application/json" });
          await overwriteFile(fileUrl, blob, {
            contentType: "application/json",
            fetch: this.session.fetch
          });
          console.log("\u{1F4BE} Saved to Pod:", filename);
          return { success: true, error: null };
        } catch (error46) {
          const errorType = this._classifyError(error46);
          console.error("\u274C Pod save failed:", error46);
          return {
            success: false,
            error: error46 instanceof Error ? error46.message : "Unknown error",
            errorType
          };
        }
      }
      /**
       * Load raw JSON string from Solid Pod
       *
       * Returns the string directly - caller is responsible for parsing.
       * This ensures bridge doesn't need to understand data structure.
       *
       * Container path: /mera-learn/ (not /mera/ which is old path)
       *
       * @param filename - File name within mera-learn container
       * @returns BridgeResult<string> with raw JSON string or error
       */
      async solidLoad(filename) {
        try {
          if (!this.initialized) {
            await this.initialize();
          }
          if (!this.session?.info.isLoggedIn) {
            return {
              success: false,
              error: "Not authenticated",
              errorType: "authentication" /* Authentication */
            };
          }
          if (!this.podUrl) {
            return {
              success: false,
              error: "Pod URL not available",
              errorType: "authentication" /* Authentication */
            };
          }
          const fileUrl = `${this.podUrl}/mera-learn/${filename}`;
          const file2 = await getFile(fileUrl, { fetch: this.session.fetch });
          const text = await file2.text();
          console.log("\u{1F4E5} Loaded from Pod:", filename);
          return { success: true, data: text, error: null };
        } catch (error46) {
          const errorType = this._classifyError(error46);
          console.error("\u274C Pod load failed:", error46);
          return {
            success: false,
            error: error46 instanceof Error ? error46.message : "Unknown error",
            errorType
          };
        }
      }
      /**
       * Delete file from Solid Pod
       *
       * Container path: /mera-learn/ (not /mera/ which is old path)
       *
       * @param filename - File name within mera-learn container
       * @returns BridgeResult indicating success/failure
       */
      async solidDelete(filename) {
        try {
          if (!this.initialized) {
            await this.initialize();
          }
          if (!this.session?.info.isLoggedIn) {
            return {
              success: false,
              error: "Not authenticated",
              errorType: "authentication" /* Authentication */
            };
          }
          if (!this.podUrl) {
            return {
              success: false,
              error: "Pod URL not available",
              errorType: "authentication" /* Authentication */
            };
          }
          const fileUrl = `${this.podUrl}/mera-learn/${filename}`;
          await deleteFile(fileUrl, { fetch: this.session.fetch });
          console.log("\u{1F5D1}\uFE0F Deleted from Pod:", filename);
          return { success: true, error: null };
        } catch (error46) {
          const errorType = this._classifyError(error46);
          console.error("\u274C Pod delete failed:", error46);
          return {
            success: false,
            error: error46 instanceof Error ? error46.message : "Unknown error",
            errorType
          };
        }
      }
      /**
       * List files in Solid Pod mera-learn container
       *
       * Container path: /mera-learn/ (not /mera/ which is old path)
       *
       * @param pattern - Optional glob pattern (e.g., "mera.*.*.*.sp.*.json")
       * @returns BridgeResult<string[]> with matching filenames
       */
      async solidList(pattern) {
        try {
          if (!this.initialized) {
            await this.initialize();
          }
          if (!this.session?.info.isLoggedIn) {
            return {
              success: false,
              error: "Not authenticated",
              errorType: "authentication" /* Authentication */
            };
          }
          if (!this.podUrl) {
            return {
              success: false,
              error: "Pod URL not available",
              errorType: "authentication" /* Authentication */
            };
          }
          const containerUrl = `${this.podUrl}/mera-learn/`;
          const dataset = await getSolidDataset(containerUrl, {
            fetch: this.session.fetch
          });
          const fileUrls = getContainedResourceUrlAll(dataset);
          const filenames = fileUrls.map((url2) => {
            const parts = url2.split("/");
            return parts[parts.length - 1];
          }).filter((filename) => {
            if (pattern) {
              return this._matchesPattern(filename, pattern);
            }
            return true;
          });
          console.log("\u{1F4CB} Listed Pod files:", filenames.length);
          return { success: true, data: filenames, error: null };
        } catch (error46) {
          const errorType = this._classifyError(error46);
          console.error("\u274C Pod list failed:", error46);
          return {
            success: false,
            error: error46 instanceof Error ? error46.message : "Unknown error",
            errorType
          };
        }
      }
      // ==========================================================================
      // Utility Methods
      // ==========================================================================
      /**
       * Simple glob pattern matcher
       *
       * Supports * wildcard for any characters.
       * Example: "mera.*.json" matches "mera.123.json", "mera.backup.json"
       *
       * @param filename - Filename to test
       * @param pattern - Glob pattern with * wildcards
       * @returns boolean - true if filename matches pattern
       */
      _matchesPattern(filename, pattern) {
        const regexPattern = pattern.replace(/[.+?^${}()|[\]\\]/g, "\\$&").replace(/\*/g, ".*");
        const regex = new RegExp(`^${regexPattern}$`);
        return regex.test(filename);
      }
      /**
       * Classify error into BridgeErrorType
       *
       * Examines error message to categorize the type of failure.
       * This helps callers implement appropriate retry/fallback logic.
       *
       * @param error - Error object or unknown value
       * @returns BridgeErrorType - Categorized error type
       */
      _classifyError(error46) {
        if (!(error46 instanceof Error)) {
          return "network" /* Network */;
        }
        const message2 = error46.message.toLowerCase();
        if (message2.includes("401") || message2.includes("403") || message2.includes("unauthorized")) {
          return "authentication" /* Authentication */;
        }
        if (message2.includes("404") || message2.includes("not found")) {
          return "not_found" /* NotFound */;
        }
        if (message2.includes("quota") || message2.includes("storage")) {
          return "storage" /* Storage */;
        }
        return "network" /* Network */;
      }
      /**
       * Get debug information about bridge state
       *
       * Useful for troubleshooting initialization and authentication issues.
       *
       * @returns Object with bridge status fields
       */
      getDebugInfo() {
        return {
          initialized: this.initialized,
          isLoggedIn: this.session?.info?.isLoggedIn || false,
          webId: this.session?.info?.webId || null,
          sessionId: this.session?.info?.sessionId || null,
          podUrl: this.podUrl
        };
      }
    };
    bridgeInstance = MeraBridge.getInstance();
    window.meraBridge = bridgeInstance;
    window.MeraBridge = MeraBridge;
    bridgeInstance.initialize().catch((err) => {
      console.error("\u274C Bridge initialization failed:", err);
    });
    meraBridge_default = bridgeInstance;
  }
});

// node_modules/zod/v4/core/core.js
// @__NO_SIDE_EFFECTS__
function $constructor(name, initializer3, params) {
  function init(inst, def) {
    var _a;
    Object.defineProperty(inst, "_zod", {
      value: inst._zod ?? {},
      enumerable: false
    });
    (_a = inst._zod).traits ?? (_a.traits = /* @__PURE__ */ new Set());
    inst._zod.traits.add(name);
    initializer3(inst, def);
    for (const k in _.prototype) {
      if (!(k in inst))
        Object.defineProperty(inst, k, { value: _.prototype[k].bind(inst) });
    }
    inst._zod.constr = _;
    inst._zod.def = def;
  }
  const Parent = params?.Parent ?? Object;
  class Definition extends Parent {
  }
  Object.defineProperty(Definition, "name", { value: name });
  function _(def) {
    var _a;
    const inst = params?.Parent ? new Definition() : this;
    init(inst, def);
    (_a = inst._zod).deferred ?? (_a.deferred = []);
    for (const fn of inst._zod.deferred) {
      fn();
    }
    return inst;
  }
  Object.defineProperty(_, "init", { value: init });
  Object.defineProperty(_, Symbol.hasInstance, {
    value: (inst) => {
      if (params?.Parent && inst instanceof params.Parent)
        return true;
      return inst?._zod?.traits?.has(name);
    }
  });
  Object.defineProperty(_, "name", { value: name });
  return _;
}
function config(newConfig) {
  if (newConfig)
    Object.assign(globalConfig, newConfig);
  return globalConfig;
}
var NEVER, $brand, $ZodAsyncError, $ZodEncodeError, globalConfig;
var init_core = __esm({
  "node_modules/zod/v4/core/core.js"() {
    NEVER = Object.freeze({
      status: "aborted"
    });
    $brand = Symbol("zod_brand");
    $ZodAsyncError = class extends Error {
      constructor() {
        super(`Encountered Promise during synchronous parse. Use .parseAsync() instead.`);
      }
    };
    $ZodEncodeError = class extends Error {
      constructor(name) {
        super(`Encountered unidirectional transform during encode: ${name}`);
        this.name = "ZodEncodeError";
      }
    };
    globalConfig = {};
  }
});

// node_modules/zod/v4/core/util.js
var util_exports = {};
__export(util_exports, {
  BIGINT_FORMAT_RANGES: () => BIGINT_FORMAT_RANGES,
  Class: () => Class,
  NUMBER_FORMAT_RANGES: () => NUMBER_FORMAT_RANGES,
  aborted: () => aborted,
  allowsEval: () => allowsEval,
  assert: () => assert,
  assertEqual: () => assertEqual,
  assertIs: () => assertIs,
  assertNever: () => assertNever,
  assertNotEqual: () => assertNotEqual,
  assignProp: () => assignProp,
  base64ToUint8Array: () => base64ToUint8Array,
  base64urlToUint8Array: () => base64urlToUint8Array,
  cached: () => cached,
  captureStackTrace: () => captureStackTrace,
  cleanEnum: () => cleanEnum,
  cleanRegex: () => cleanRegex,
  clone: () => clone2,
  cloneDef: () => cloneDef,
  createTransparentProxy: () => createTransparentProxy,
  defineLazy: () => defineLazy,
  esc: () => esc,
  escapeRegex: () => escapeRegex2,
  extend: () => extend,
  finalizeIssue: () => finalizeIssue,
  floatSafeRemainder: () => floatSafeRemainder,
  getElementAtPath: () => getElementAtPath,
  getEnumValues: () => getEnumValues,
  getLengthableOrigin: () => getLengthableOrigin,
  getParsedType: () => getParsedType,
  getSizableOrigin: () => getSizableOrigin,
  hexToUint8Array: () => hexToUint8Array,
  isObject: () => isObject2,
  isPlainObject: () => isPlainObject,
  issue: () => issue,
  joinValues: () => joinValues,
  jsonStringifyReplacer: () => jsonStringifyReplacer,
  merge: () => merge2,
  mergeDefs: () => mergeDefs,
  normalizeParams: () => normalizeParams,
  nullish: () => nullish,
  numKeys: () => numKeys,
  objectClone: () => objectClone,
  omit: () => omit,
  optionalKeys: () => optionalKeys,
  partial: () => partial,
  pick: () => pick,
  prefixIssues: () => prefixIssues,
  primitiveTypes: () => primitiveTypes,
  promiseAllObject: () => promiseAllObject,
  propertyKeyTypes: () => propertyKeyTypes,
  randomString: () => randomString,
  required: () => required,
  safeExtend: () => safeExtend,
  shallowClone: () => shallowClone,
  stringifyPrimitive: () => stringifyPrimitive,
  uint8ArrayToBase64: () => uint8ArrayToBase64,
  uint8ArrayToBase64url: () => uint8ArrayToBase64url,
  uint8ArrayToHex: () => uint8ArrayToHex,
  unwrapMessage: () => unwrapMessage
});
function assertEqual(val) {
  return val;
}
function assertNotEqual(val) {
  return val;
}
function assertIs(_arg) {
}
function assertNever(_x) {
  throw new Error();
}
function assert(_) {
}
function getEnumValues(entries) {
  const numericValues = Object.values(entries).filter((v) => typeof v === "number");
  const values = Object.entries(entries).filter(([k, _]) => numericValues.indexOf(+k) === -1).map(([_, v]) => v);
  return values;
}
function joinValues(array2, separator = "|") {
  return array2.map((val) => stringifyPrimitive(val)).join(separator);
}
function jsonStringifyReplacer(_, value) {
  if (typeof value === "bigint")
    return value.toString();
  return value;
}
function cached(getter) {
  const set3 = false;
  return {
    get value() {
      if (!set3) {
        const value = getter();
        Object.defineProperty(this, "value", { value });
        return value;
      }
      throw new Error("cached value already set");
    }
  };
}
function nullish(input) {
  return input === null || input === void 0;
}
function cleanRegex(source) {
  const start = source.startsWith("^") ? 1 : 0;
  const end = source.endsWith("$") ? source.length - 1 : source.length;
  return source.slice(start, end);
}
function floatSafeRemainder(val, step) {
  const valDecCount = (val.toString().split(".")[1] || "").length;
  const stepString = step.toString();
  let stepDecCount = (stepString.split(".")[1] || "").length;
  if (stepDecCount === 0 && /\d?e-\d?/.test(stepString)) {
    const match = stepString.match(/\d?e-(\d?)/);
    if (match?.[1]) {
      stepDecCount = Number.parseInt(match[1]);
    }
  }
  const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
  const valInt = Number.parseInt(val.toFixed(decCount).replace(".", ""));
  const stepInt = Number.parseInt(step.toFixed(decCount).replace(".", ""));
  return valInt % stepInt / 10 ** decCount;
}
function defineLazy(object2, key, getter) {
  let value = void 0;
  Object.defineProperty(object2, key, {
    get() {
      if (value === EVALUATING) {
        return void 0;
      }
      if (value === void 0) {
        value = EVALUATING;
        value = getter();
      }
      return value;
    },
    set(v) {
      Object.defineProperty(object2, key, {
        value: v
        // configurable: true,
      });
    },
    configurable: true
  });
}
function objectClone(obj) {
  return Object.create(Object.getPrototypeOf(obj), Object.getOwnPropertyDescriptors(obj));
}
function assignProp(target, prop, value) {
  Object.defineProperty(target, prop, {
    value,
    writable: true,
    enumerable: true,
    configurable: true
  });
}
function mergeDefs(...defs) {
  const mergedDescriptors = {};
  for (const def of defs) {
    const descriptors = Object.getOwnPropertyDescriptors(def);
    Object.assign(mergedDescriptors, descriptors);
  }
  return Object.defineProperties({}, mergedDescriptors);
}
function cloneDef(schema2) {
  return mergeDefs(schema2._zod.def);
}
function getElementAtPath(obj, path) {
  if (!path)
    return obj;
  return path.reduce((acc, key) => acc?.[key], obj);
}
function promiseAllObject(promisesObj) {
  const keys = Object.keys(promisesObj);
  const promises = keys.map((key) => promisesObj[key]);
  return Promise.all(promises).then((results) => {
    const resolvedObj = {};
    for (let i = 0; i < keys.length; i++) {
      resolvedObj[keys[i]] = results[i];
    }
    return resolvedObj;
  });
}
function randomString(length = 10) {
  const chars = "abcdefghijklmnopqrstuvwxyz";
  let str2 = "";
  for (let i = 0; i < length; i++) {
    str2 += chars[Math.floor(Math.random() * chars.length)];
  }
  return str2;
}
function esc(str2) {
  return JSON.stringify(str2);
}
function isObject2(data) {
  return typeof data === "object" && data !== null && !Array.isArray(data);
}
function isPlainObject(o) {
  if (isObject2(o) === false)
    return false;
  const ctor = o.constructor;
  if (ctor === void 0)
    return true;
  const prot = ctor.prototype;
  if (isObject2(prot) === false)
    return false;
  if (Object.prototype.hasOwnProperty.call(prot, "isPrototypeOf") === false) {
    return false;
  }
  return true;
}
function shallowClone(o) {
  if (isPlainObject(o))
    return { ...o };
  if (Array.isArray(o))
    return [...o];
  return o;
}
function numKeys(data) {
  let keyCount = 0;
  for (const key in data) {
    if (Object.prototype.hasOwnProperty.call(data, key)) {
      keyCount++;
    }
  }
  return keyCount;
}
function escapeRegex2(str2) {
  return str2.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}
function clone2(inst, def, params) {
  const cl = new inst._zod.constr(def ?? inst._zod.def);
  if (!def || params?.parent)
    cl._zod.parent = inst;
  return cl;
}
function normalizeParams(_params) {
  const params = _params;
  if (!params)
    return {};
  if (typeof params === "string")
    return { error: () => params };
  if (params?.message !== void 0) {
    if (params?.error !== void 0)
      throw new Error("Cannot specify both `message` and `error` params");
    params.error = params.message;
  }
  delete params.message;
  if (typeof params.error === "string")
    return { ...params, error: () => params.error };
  return params;
}
function createTransparentProxy(getter) {
  let target;
  return new Proxy({}, {
    get(_, prop, receiver) {
      target ?? (target = getter());
      return Reflect.get(target, prop, receiver);
    },
    set(_, prop, value, receiver) {
      target ?? (target = getter());
      return Reflect.set(target, prop, value, receiver);
    },
    has(_, prop) {
      target ?? (target = getter());
      return Reflect.has(target, prop);
    },
    deleteProperty(_, prop) {
      target ?? (target = getter());
      return Reflect.deleteProperty(target, prop);
    },
    ownKeys(_) {
      target ?? (target = getter());
      return Reflect.ownKeys(target);
    },
    getOwnPropertyDescriptor(_, prop) {
      target ?? (target = getter());
      return Reflect.getOwnPropertyDescriptor(target, prop);
    },
    defineProperty(_, prop, descriptor) {
      target ?? (target = getter());
      return Reflect.defineProperty(target, prop, descriptor);
    }
  });
}
function stringifyPrimitive(value) {
  if (typeof value === "bigint")
    return value.toString() + "n";
  if (typeof value === "string")
    return `"${value}"`;
  return `${value}`;
}
function optionalKeys(shape) {
  return Object.keys(shape).filter((k) => {
    return shape[k]._zod.optin === "optional" && shape[k]._zod.optout === "optional";
  });
}
function pick(schema2, mask) {
  const currDef = schema2._zod.def;
  const def = mergeDefs(schema2._zod.def, {
    get shape() {
      const newShape = {};
      for (const key in mask) {
        if (!(key in currDef.shape)) {
          throw new Error(`Unrecognized key: "${key}"`);
        }
        if (!mask[key])
          continue;
        newShape[key] = currDef.shape[key];
      }
      assignProp(this, "shape", newShape);
      return newShape;
    },
    checks: []
  });
  return clone2(schema2, def);
}
function omit(schema2, mask) {
  const currDef = schema2._zod.def;
  const def = mergeDefs(schema2._zod.def, {
    get shape() {
      const newShape = { ...schema2._zod.def.shape };
      for (const key in mask) {
        if (!(key in currDef.shape)) {
          throw new Error(`Unrecognized key: "${key}"`);
        }
        if (!mask[key])
          continue;
        delete newShape[key];
      }
      assignProp(this, "shape", newShape);
      return newShape;
    },
    checks: []
  });
  return clone2(schema2, def);
}
function extend(schema2, shape) {
  if (!isPlainObject(shape)) {
    throw new Error("Invalid input to extend: expected a plain object");
  }
  const checks = schema2._zod.def.checks;
  const hasChecks = checks && checks.length > 0;
  if (hasChecks) {
    throw new Error("Object schemas containing refinements cannot be extended. Use `.safeExtend()` instead.");
  }
  const def = mergeDefs(schema2._zod.def, {
    get shape() {
      const _shape = { ...schema2._zod.def.shape, ...shape };
      assignProp(this, "shape", _shape);
      return _shape;
    },
    checks: []
  });
  return clone2(schema2, def);
}
function safeExtend(schema2, shape) {
  if (!isPlainObject(shape)) {
    throw new Error("Invalid input to safeExtend: expected a plain object");
  }
  const def = {
    ...schema2._zod.def,
    get shape() {
      const _shape = { ...schema2._zod.def.shape, ...shape };
      assignProp(this, "shape", _shape);
      return _shape;
    },
    checks: schema2._zod.def.checks
  };
  return clone2(schema2, def);
}
function merge2(a, b) {
  const def = mergeDefs(a._zod.def, {
    get shape() {
      const _shape = { ...a._zod.def.shape, ...b._zod.def.shape };
      assignProp(this, "shape", _shape);
      return _shape;
    },
    get catchall() {
      return b._zod.def.catchall;
    },
    checks: []
    // delete existing checks
  });
  return clone2(a, def);
}
function partial(Class2, schema2, mask) {
  const def = mergeDefs(schema2._zod.def, {
    get shape() {
      const oldShape = schema2._zod.def.shape;
      const shape = { ...oldShape };
      if (mask) {
        for (const key in mask) {
          if (!(key in oldShape)) {
            throw new Error(`Unrecognized key: "${key}"`);
          }
          if (!mask[key])
            continue;
          shape[key] = Class2 ? new Class2({
            type: "optional",
            innerType: oldShape[key]
          }) : oldShape[key];
        }
      } else {
        for (const key in oldShape) {
          shape[key] = Class2 ? new Class2({
            type: "optional",
            innerType: oldShape[key]
          }) : oldShape[key];
        }
      }
      assignProp(this, "shape", shape);
      return shape;
    },
    checks: []
  });
  return clone2(schema2, def);
}
function required(Class2, schema2, mask) {
  const def = mergeDefs(schema2._zod.def, {
    get shape() {
      const oldShape = schema2._zod.def.shape;
      const shape = { ...oldShape };
      if (mask) {
        for (const key in mask) {
          if (!(key in shape)) {
            throw new Error(`Unrecognized key: "${key}"`);
          }
          if (!mask[key])
            continue;
          shape[key] = new Class2({
            type: "nonoptional",
            innerType: oldShape[key]
          });
        }
      } else {
        for (const key in oldShape) {
          shape[key] = new Class2({
            type: "nonoptional",
            innerType: oldShape[key]
          });
        }
      }
      assignProp(this, "shape", shape);
      return shape;
    },
    checks: []
  });
  return clone2(schema2, def);
}
function aborted(x, startIndex = 0) {
  if (x.aborted === true)
    return true;
  for (let i = startIndex; i < x.issues.length; i++) {
    if (x.issues[i]?.continue !== true) {
      return true;
    }
  }
  return false;
}
function prefixIssues(path, issues) {
  return issues.map((iss) => {
    var _a;
    (_a = iss).path ?? (_a.path = []);
    iss.path.unshift(path);
    return iss;
  });
}
function unwrapMessage(message2) {
  return typeof message2 === "string" ? message2 : message2?.message;
}
function finalizeIssue(iss, ctx, config2) {
  const full = { ...iss, path: iss.path ?? [] };
  if (!iss.message) {
    const message2 = unwrapMessage(iss.inst?._zod.def?.error?.(iss)) ?? unwrapMessage(ctx?.error?.(iss)) ?? unwrapMessage(config2.customError?.(iss)) ?? unwrapMessage(config2.localeError?.(iss)) ?? "Invalid input";
    full.message = message2;
  }
  delete full.inst;
  delete full.continue;
  if (!ctx?.reportInput) {
    delete full.input;
  }
  return full;
}
function getSizableOrigin(input) {
  if (input instanceof Set)
    return "set";
  if (input instanceof Map)
    return "map";
  if (input instanceof File)
    return "file";
  return "unknown";
}
function getLengthableOrigin(input) {
  if (Array.isArray(input))
    return "array";
  if (typeof input === "string")
    return "string";
  return "unknown";
}
function issue(...args) {
  const [iss, input, inst] = args;
  if (typeof iss === "string") {
    return {
      message: iss,
      code: "custom",
      input,
      inst
    };
  }
  return { ...iss };
}
function cleanEnum(obj) {
  return Object.entries(obj).filter(([k, _]) => {
    return Number.isNaN(Number.parseInt(k, 10));
  }).map((el) => el[1]);
}
function base64ToUint8Array(base643) {
  const binaryString = atob(base643);
  const bytes = new Uint8Array(binaryString.length);
  for (let i = 0; i < binaryString.length; i++) {
    bytes[i] = binaryString.charCodeAt(i);
  }
  return bytes;
}
function uint8ArrayToBase64(bytes) {
  let binaryString = "";
  for (let i = 0; i < bytes.length; i++) {
    binaryString += String.fromCharCode(bytes[i]);
  }
  return btoa(binaryString);
}
function base64urlToUint8Array(base64url3) {
  const base643 = base64url3.replace(/-/g, "+").replace(/_/g, "/");
  const padding = "=".repeat((4 - base643.length % 4) % 4);
  return base64ToUint8Array(base643 + padding);
}
function uint8ArrayToBase64url(bytes) {
  return uint8ArrayToBase64(bytes).replace(/\+/g, "-").replace(/\//g, "_").replace(/=/g, "");
}
function hexToUint8Array(hex3) {
  const cleanHex = hex3.replace(/^0x/, "");
  if (cleanHex.length % 2 !== 0) {
    throw new Error("Invalid hex string length");
  }
  const bytes = new Uint8Array(cleanHex.length / 2);
  for (let i = 0; i < cleanHex.length; i += 2) {
    bytes[i / 2] = Number.parseInt(cleanHex.slice(i, i + 2), 16);
  }
  return bytes;
}
function uint8ArrayToHex(bytes) {
  return Array.from(bytes).map((b) => b.toString(16).padStart(2, "0")).join("");
}
var EVALUATING, captureStackTrace, allowsEval, getParsedType, propertyKeyTypes, primitiveTypes, NUMBER_FORMAT_RANGES, BIGINT_FORMAT_RANGES, Class;
var init_util = __esm({
  "node_modules/zod/v4/core/util.js"() {
    EVALUATING = Symbol("evaluating");
    captureStackTrace = "captureStackTrace" in Error ? Error.captureStackTrace : (..._args) => {
    };
    allowsEval = cached(() => {
      if (typeof navigator !== "undefined" && navigator?.userAgent?.includes("Cloudflare")) {
        return false;
      }
      try {
        const F = Function;
        new F("");
        return true;
      } catch (_) {
        return false;
      }
    });
    getParsedType = (data) => {
      const t = typeof data;
      switch (t) {
        case "undefined":
          return "undefined";
        case "string":
          return "string";
        case "number":
          return Number.isNaN(data) ? "nan" : "number";
        case "boolean":
          return "boolean";
        case "function":
          return "function";
        case "bigint":
          return "bigint";
        case "symbol":
          return "symbol";
        case "object":
          if (Array.isArray(data)) {
            return "array";
          }
          if (data === null) {
            return "null";
          }
          if (data.then && typeof data.then === "function" && data.catch && typeof data.catch === "function") {
            return "promise";
          }
          if (typeof Map !== "undefined" && data instanceof Map) {
            return "map";
          }
          if (typeof Set !== "undefined" && data instanceof Set) {
            return "set";
          }
          if (typeof Date !== "undefined" && data instanceof Date) {
            return "date";
          }
          if (typeof File !== "undefined" && data instanceof File) {
            return "file";
          }
          return "object";
        default:
          throw new Error(`Unknown data type: ${t}`);
      }
    };
    propertyKeyTypes = /* @__PURE__ */ new Set(["string", "number", "symbol"]);
    primitiveTypes = /* @__PURE__ */ new Set(["string", "number", "bigint", "boolean", "symbol", "undefined"]);
    NUMBER_FORMAT_RANGES = {
      safeint: [Number.MIN_SAFE_INTEGER, Number.MAX_SAFE_INTEGER],
      int32: [-2147483648, 2147483647],
      uint32: [0, 4294967295],
      float32: [-34028234663852886e22, 34028234663852886e22],
      float64: [-Number.MAX_VALUE, Number.MAX_VALUE]
    };
    BIGINT_FORMAT_RANGES = {
      int64: [/* @__PURE__ */ BigInt("-9223372036854775808"), /* @__PURE__ */ BigInt("9223372036854775807")],
      uint64: [/* @__PURE__ */ BigInt(0), /* @__PURE__ */ BigInt("18446744073709551615")]
    };
    Class = class {
      constructor(..._args) {
      }
    };
  }
});

// node_modules/zod/v4/core/errors.js
function flattenError(error46, mapper = (issue2) => issue2.message) {
  const fieldErrors = {};
  const formErrors = [];
  for (const sub of error46.issues) {
    if (sub.path.length > 0) {
      fieldErrors[sub.path[0]] = fieldErrors[sub.path[0]] || [];
      fieldErrors[sub.path[0]].push(mapper(sub));
    } else {
      formErrors.push(mapper(sub));
    }
  }
  return { formErrors, fieldErrors };
}
function formatError(error46, mapper = (issue2) => issue2.message) {
  const fieldErrors = { _errors: [] };
  const processError = (error47) => {
    for (const issue2 of error47.issues) {
      if (issue2.code === "invalid_union" && issue2.errors.length) {
        issue2.errors.map((issues) => processError({ issues }));
      } else if (issue2.code === "invalid_key") {
        processError({ issues: issue2.issues });
      } else if (issue2.code === "invalid_element") {
        processError({ issues: issue2.issues });
      } else if (issue2.path.length === 0) {
        fieldErrors._errors.push(mapper(issue2));
      } else {
        let curr = fieldErrors;
        let i = 0;
        while (i < issue2.path.length) {
          const el = issue2.path[i];
          const terminal = i === issue2.path.length - 1;
          if (!terminal) {
            curr[el] = curr[el] || { _errors: [] };
          } else {
            curr[el] = curr[el] || { _errors: [] };
            curr[el]._errors.push(mapper(issue2));
          }
          curr = curr[el];
          i++;
        }
      }
    }
  };
  processError(error46);
  return fieldErrors;
}
function treeifyError(error46, mapper = (issue2) => issue2.message) {
  const result = { errors: [] };
  const processError = (error47, path = []) => {
    var _a, _b;
    for (const issue2 of error47.issues) {
      if (issue2.code === "invalid_union" && issue2.errors.length) {
        issue2.errors.map((issues) => processError({ issues }, issue2.path));
      } else if (issue2.code === "invalid_key") {
        processError({ issues: issue2.issues }, issue2.path);
      } else if (issue2.code === "invalid_element") {
        processError({ issues: issue2.issues }, issue2.path);
      } else {
        const fullpath = [...path, ...issue2.path];
        if (fullpath.length === 0) {
          result.errors.push(mapper(issue2));
          continue;
        }
        let curr = result;
        let i = 0;
        while (i < fullpath.length) {
          const el = fullpath[i];
          const terminal = i === fullpath.length - 1;
          if (typeof el === "string") {
            curr.properties ?? (curr.properties = {});
            (_a = curr.properties)[el] ?? (_a[el] = { errors: [] });
            curr = curr.properties[el];
          } else {
            curr.items ?? (curr.items = []);
            (_b = curr.items)[el] ?? (_b[el] = { errors: [] });
            curr = curr.items[el];
          }
          if (terminal) {
            curr.errors.push(mapper(issue2));
          }
          i++;
        }
      }
    }
  };
  processError(error46);
  return result;
}
function toDotPath(_path) {
  const segs = [];
  const path = _path.map((seg) => typeof seg === "object" ? seg.key : seg);
  for (const seg of path) {
    if (typeof seg === "number")
      segs.push(`[${seg}]`);
    else if (typeof seg === "symbol")
      segs.push(`[${JSON.stringify(String(seg))}]`);
    else if (/[^\w$]/.test(seg))
      segs.push(`[${JSON.stringify(seg)}]`);
    else {
      if (segs.length)
        segs.push(".");
      segs.push(seg);
    }
  }
  return segs.join("");
}
function prettifyError(error46) {
  const lines = [];
  const issues = [...error46.issues].sort((a, b) => (a.path ?? []).length - (b.path ?? []).length);
  for (const issue2 of issues) {
    lines.push(`\u2716 ${issue2.message}`);
    if (issue2.path?.length)
      lines.push(`  \u2192 at ${toDotPath(issue2.path)}`);
  }
  return lines.join("\n");
}
var initializer, $ZodError, $ZodRealError;
var init_errors2 = __esm({
  "node_modules/zod/v4/core/errors.js"() {
    init_core();
    init_util();
    initializer = (inst, def) => {
      inst.name = "$ZodError";
      Object.defineProperty(inst, "_zod", {
        value: inst._zod,
        enumerable: false
      });
      Object.defineProperty(inst, "issues", {
        value: def,
        enumerable: false
      });
      inst.message = JSON.stringify(def, jsonStringifyReplacer, 2);
      Object.defineProperty(inst, "toString", {
        value: () => inst.message,
        enumerable: false
      });
    };
    $ZodError = $constructor("$ZodError", initializer);
    $ZodRealError = $constructor("$ZodError", initializer, { Parent: Error });
  }
});

// node_modules/zod/v4/core/parse.js
var _parse, parse2, _parseAsync, parseAsync, _safeParse, safeParse, _safeParseAsync, safeParseAsync, _encode, encode2, _decode, decode2, _encodeAsync, encodeAsync, _decodeAsync, decodeAsync, _safeEncode, safeEncode, _safeDecode, safeDecode, _safeEncodeAsync, safeEncodeAsync, _safeDecodeAsync, safeDecodeAsync;
var init_parse = __esm({
  "node_modules/zod/v4/core/parse.js"() {
    init_core();
    init_errors2();
    init_util();
    _parse = (_Err) => (schema2, value, _ctx, _params) => {
      const ctx = _ctx ? Object.assign(_ctx, { async: false }) : { async: false };
      const result = schema2._zod.run({ value, issues: [] }, ctx);
      if (result instanceof Promise) {
        throw new $ZodAsyncError();
      }
      if (result.issues.length) {
        const e = new (_params?.Err ?? _Err)(result.issues.map((iss) => finalizeIssue(iss, ctx, config())));
        captureStackTrace(e, _params?.callee);
        throw e;
      }
      return result.value;
    };
    parse2 = /* @__PURE__ */ _parse($ZodRealError);
    _parseAsync = (_Err) => async (schema2, value, _ctx, params) => {
      const ctx = _ctx ? Object.assign(_ctx, { async: true }) : { async: true };
      let result = schema2._zod.run({ value, issues: [] }, ctx);
      if (result instanceof Promise)
        result = await result;
      if (result.issues.length) {
        const e = new (params?.Err ?? _Err)(result.issues.map((iss) => finalizeIssue(iss, ctx, config())));
        captureStackTrace(e, params?.callee);
        throw e;
      }
      return result.value;
    };
    parseAsync = /* @__PURE__ */ _parseAsync($ZodRealError);
    _safeParse = (_Err) => (schema2, value, _ctx) => {
      const ctx = _ctx ? { ..._ctx, async: false } : { async: false };
      const result = schema2._zod.run({ value, issues: [] }, ctx);
      if (result instanceof Promise) {
        throw new $ZodAsyncError();
      }
      return result.issues.length ? {
        success: false,
        error: new (_Err ?? $ZodError)(result.issues.map((iss) => finalizeIssue(iss, ctx, config())))
      } : { success: true, data: result.value };
    };
    safeParse = /* @__PURE__ */ _safeParse($ZodRealError);
    _safeParseAsync = (_Err) => async (schema2, value, _ctx) => {
      const ctx = _ctx ? Object.assign(_ctx, { async: true }) : { async: true };
      let result = schema2._zod.run({ value, issues: [] }, ctx);
      if (result instanceof Promise)
        result = await result;
      return result.issues.length ? {
        success: false,
        error: new _Err(result.issues.map((iss) => finalizeIssue(iss, ctx, config())))
      } : { success: true, data: result.value };
    };
    safeParseAsync = /* @__PURE__ */ _safeParseAsync($ZodRealError);
    _encode = (_Err) => (schema2, value, _ctx) => {
      const ctx = _ctx ? Object.assign(_ctx, { direction: "backward" }) : { direction: "backward" };
      return _parse(_Err)(schema2, value, ctx);
    };
    encode2 = /* @__PURE__ */ _encode($ZodRealError);
    _decode = (_Err) => (schema2, value, _ctx) => {
      return _parse(_Err)(schema2, value, _ctx);
    };
    decode2 = /* @__PURE__ */ _decode($ZodRealError);
    _encodeAsync = (_Err) => async (schema2, value, _ctx) => {
      const ctx = _ctx ? Object.assign(_ctx, { direction: "backward" }) : { direction: "backward" };
      return _parseAsync(_Err)(schema2, value, ctx);
    };
    encodeAsync = /* @__PURE__ */ _encodeAsync($ZodRealError);
    _decodeAsync = (_Err) => async (schema2, value, _ctx) => {
      return _parseAsync(_Err)(schema2, value, _ctx);
    };
    decodeAsync = /* @__PURE__ */ _decodeAsync($ZodRealError);
    _safeEncode = (_Err) => (schema2, value, _ctx) => {
      const ctx = _ctx ? Object.assign(_ctx, { direction: "backward" }) : { direction: "backward" };
      return _safeParse(_Err)(schema2, value, ctx);
    };
    safeEncode = /* @__PURE__ */ _safeEncode($ZodRealError);
    _safeDecode = (_Err) => (schema2, value, _ctx) => {
      return _safeParse(_Err)(schema2, value, _ctx);
    };
    safeDecode = /* @__PURE__ */ _safeDecode($ZodRealError);
    _safeEncodeAsync = (_Err) => async (schema2, value, _ctx) => {
      const ctx = _ctx ? Object.assign(_ctx, { direction: "backward" }) : { direction: "backward" };
      return _safeParseAsync(_Err)(schema2, value, ctx);
    };
    safeEncodeAsync = /* @__PURE__ */ _safeEncodeAsync($ZodRealError);
    _safeDecodeAsync = (_Err) => async (schema2, value, _ctx) => {
      return _safeParseAsync(_Err)(schema2, value, _ctx);
    };
    safeDecodeAsync = /* @__PURE__ */ _safeDecodeAsync($ZodRealError);
  }
});

// node_modules/zod/v4/core/regexes.js
var regexes_exports = {};
__export(regexes_exports, {
  base64: () => base64,
  base64url: () => base64url,
  bigint: () => bigint,
  boolean: () => boolean,
  browserEmail: () => browserEmail,
  cidrv4: () => cidrv4,
  cidrv6: () => cidrv6,
  cuid: () => cuid,
  cuid2: () => cuid2,
  date: () => date,
  datetime: () => datetime,
  domain: () => domain,
  duration: () => duration,
  e164: () => e164,
  email: () => email,
  emoji: () => emoji,
  extendedDuration: () => extendedDuration,
  guid: () => guid,
  hex: () => hex,
  hostname: () => hostname,
  html5Email: () => html5Email,
  idnEmail: () => idnEmail,
  integer: () => integer,
  ipv4: () => ipv4,
  ipv6: () => ipv6,
  ksuid: () => ksuid,
  lowercase: () => lowercase,
  md5_base64: () => md5_base64,
  md5_base64url: () => md5_base64url,
  md5_hex: () => md5_hex,
  nanoid: () => nanoid,
  null: () => _null,
  number: () => number,
  rfc5322Email: () => rfc5322Email,
  sha1_base64: () => sha1_base64,
  sha1_base64url: () => sha1_base64url,
  sha1_hex: () => sha1_hex,
  sha256_base64: () => sha256_base64,
  sha256_base64url: () => sha256_base64url,
  sha256_hex: () => sha256_hex,
  sha384_base64: () => sha384_base64,
  sha384_base64url: () => sha384_base64url,
  sha384_hex: () => sha384_hex,
  sha512_base64: () => sha512_base64,
  sha512_base64url: () => sha512_base64url,
  sha512_hex: () => sha512_hex,
  string: () => string,
  time: () => time,
  ulid: () => ulid,
  undefined: () => _undefined,
  unicodeEmail: () => unicodeEmail,
  uppercase: () => uppercase,
  uuid: () => uuid,
  uuid4: () => uuid4,
  uuid6: () => uuid6,
  uuid7: () => uuid7,
  xid: () => xid
});
function emoji() {
  return new RegExp(_emoji, "u");
}
function timeSource(args) {
  const hhmm = `(?:[01]\\d|2[0-3]):[0-5]\\d`;
  const regex = typeof args.precision === "number" ? args.precision === -1 ? `${hhmm}` : args.precision === 0 ? `${hhmm}:[0-5]\\d` : `${hhmm}:[0-5]\\d\\.\\d{${args.precision}}` : `${hhmm}(?::[0-5]\\d(?:\\.\\d+)?)?`;
  return regex;
}
function time(args) {
  return new RegExp(`^${timeSource(args)}$`);
}
function datetime(args) {
  const time3 = timeSource({ precision: args.precision });
  const opts = ["Z"];
  if (args.local)
    opts.push("");
  if (args.offset)
    opts.push(`([+-](?:[01]\\d|2[0-3]):[0-5]\\d)`);
  const timeRegex = `${time3}(?:${opts.join("|")})`;
  return new RegExp(`^${dateSource}T(?:${timeRegex})$`);
}
function fixedBase64(bodyLength, padding) {
  return new RegExp(`^[A-Za-z0-9+/]{${bodyLength}}${padding}$`);
}
function fixedBase64url(length) {
  return new RegExp(`^[A-Za-z0-9_-]{${length}}$`);
}
var cuid, cuid2, ulid, xid, ksuid, nanoid, duration, extendedDuration, guid, uuid, uuid4, uuid6, uuid7, email, html5Email, rfc5322Email, unicodeEmail, idnEmail, browserEmail, _emoji, ipv4, ipv6, cidrv4, cidrv6, base64, base64url, hostname, domain, e164, dateSource, date, string, bigint, integer, number, boolean, _null, _undefined, lowercase, uppercase, hex, md5_hex, md5_base64, md5_base64url, sha1_hex, sha1_base64, sha1_base64url, sha256_hex, sha256_base64, sha256_base64url, sha384_hex, sha384_base64, sha384_base64url, sha512_hex, sha512_base64, sha512_base64url;
var init_regexes = __esm({
  "node_modules/zod/v4/core/regexes.js"() {
    cuid = /^[cC][^\s-]{8,}$/;
    cuid2 = /^[0-9a-z]+$/;
    ulid = /^[0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{26}$/;
    xid = /^[0-9a-vA-V]{20}$/;
    ksuid = /^[A-Za-z0-9]{27}$/;
    nanoid = /^[a-zA-Z0-9_-]{21}$/;
    duration = /^P(?:(\d+W)|(?!.*W)(?=\d|T\d)(\d+Y)?(\d+M)?(\d+D)?(T(?=\d)(\d+H)?(\d+M)?(\d+([.,]\d+)?S)?)?)$/;
    extendedDuration = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/;
    guid = /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12})$/;
    uuid = (version2) => {
      if (!version2)
        return /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-8][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}|00000000-0000-0000-0000-000000000000|ffffffff-ffff-ffff-ffff-ffffffffffff)$/;
      return new RegExp(`^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-${version2}[0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12})$`);
    };
    uuid4 = /* @__PURE__ */ uuid(4);
    uuid6 = /* @__PURE__ */ uuid(6);
    uuid7 = /* @__PURE__ */ uuid(7);
    email = /^(?!\.)(?!.*\.\.)([A-Za-z0-9_'+\-\.]*)[A-Za-z0-9_+-]@([A-Za-z0-9][A-Za-z0-9\-]*\.)+[A-Za-z]{2,}$/;
    html5Email = /^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;
    rfc5322Email = /^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/;
    unicodeEmail = /^[^\s@"]{1,64}@[^\s@]{1,255}$/u;
    idnEmail = unicodeEmail;
    browserEmail = /^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;
    _emoji = `^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$`;
    ipv4 = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/;
    ipv6 = /^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))$/;
    cidrv4 = /^((25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/([0-9]|[1-2][0-9]|3[0-2])$/;
    cidrv6 = /^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|::|([0-9a-fA-F]{1,4})?::([0-9a-fA-F]{1,4}:?){0,6})\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/;
    base64 = /^$|^(?:[0-9a-zA-Z+/]{4})*(?:(?:[0-9a-zA-Z+/]{2}==)|(?:[0-9a-zA-Z+/]{3}=))?$/;
    base64url = /^[A-Za-z0-9_-]*$/;
    hostname = /^(?=.{1,253}\.?$)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[-0-9a-zA-Z]{0,61}[0-9a-zA-Z])?)*\.?$/;
    domain = /^([a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?\.)+[a-zA-Z]{2,}$/;
    e164 = /^\+(?:[0-9]){6,14}[0-9]$/;
    dateSource = `(?:(?:\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-(?:(?:0[13578]|1[02])-(?:0[1-9]|[12]\\d|3[01])|(?:0[469]|11)-(?:0[1-9]|[12]\\d|30)|(?:02)-(?:0[1-9]|1\\d|2[0-8])))`;
    date = /* @__PURE__ */ new RegExp(`^${dateSource}$`);
    string = (params) => {
      const regex = params ? `[\\s\\S]{${params?.minimum ?? 0},${params?.maximum ?? ""}}` : `[\\s\\S]*`;
      return new RegExp(`^${regex}$`);
    };
    bigint = /^-?\d+n?$/;
    integer = /^-?\d+$/;
    number = /^-?\d+(?:\.\d+)?/;
    boolean = /^(?:true|false)$/i;
    _null = /^null$/i;
    _undefined = /^undefined$/i;
    lowercase = /^[^A-Z]*$/;
    uppercase = /^[^a-z]*$/;
    hex = /^[0-9a-fA-F]*$/;
    md5_hex = /^[0-9a-fA-F]{32}$/;
    md5_base64 = /* @__PURE__ */ fixedBase64(22, "==");
    md5_base64url = /* @__PURE__ */ fixedBase64url(22);
    sha1_hex = /^[0-9a-fA-F]{40}$/;
    sha1_base64 = /* @__PURE__ */ fixedBase64(27, "=");
    sha1_base64url = /* @__PURE__ */ fixedBase64url(27);
    sha256_hex = /^[0-9a-fA-F]{64}$/;
    sha256_base64 = /* @__PURE__ */ fixedBase64(43, "=");
    sha256_base64url = /* @__PURE__ */ fixedBase64url(43);
    sha384_hex = /^[0-9a-fA-F]{96}$/;
    sha384_base64 = /* @__PURE__ */ fixedBase64(64, "");
    sha384_base64url = /* @__PURE__ */ fixedBase64url(64);
    sha512_hex = /^[0-9a-fA-F]{128}$/;
    sha512_base64 = /* @__PURE__ */ fixedBase64(86, "==");
    sha512_base64url = /* @__PURE__ */ fixedBase64url(86);
  }
});

// node_modules/zod/v4/core/checks.js
function handleCheckPropertyResult(result, payload, property) {
  if (result.issues.length) {
    payload.issues.push(...prefixIssues(property, result.issues));
  }
}
var $ZodCheck, numericOriginMap, $ZodCheckLessThan, $ZodCheckGreaterThan, $ZodCheckMultipleOf, $ZodCheckNumberFormat, $ZodCheckBigIntFormat, $ZodCheckMaxSize, $ZodCheckMinSize, $ZodCheckSizeEquals, $ZodCheckMaxLength, $ZodCheckMinLength, $ZodCheckLengthEquals, $ZodCheckStringFormat, $ZodCheckRegex, $ZodCheckLowerCase, $ZodCheckUpperCase, $ZodCheckIncludes, $ZodCheckStartsWith, $ZodCheckEndsWith, $ZodCheckProperty, $ZodCheckMimeType, $ZodCheckOverwrite;
var init_checks = __esm({
  "node_modules/zod/v4/core/checks.js"() {
    init_core();
    init_regexes();
    init_util();
    $ZodCheck = /* @__PURE__ */ $constructor("$ZodCheck", (inst, def) => {
      var _a;
      inst._zod ?? (inst._zod = {});
      inst._zod.def = def;
      (_a = inst._zod).onattach ?? (_a.onattach = []);
    });
    numericOriginMap = {
      number: "number",
      bigint: "bigint",
      object: "date"
    };
    $ZodCheckLessThan = /* @__PURE__ */ $constructor("$ZodCheckLessThan", (inst, def) => {
      $ZodCheck.init(inst, def);
      const origin = numericOriginMap[typeof def.value];
      inst._zod.onattach.push((inst2) => {
        const bag = inst2._zod.bag;
        const curr = (def.inclusive ? bag.maximum : bag.exclusiveMaximum) ?? Number.POSITIVE_INFINITY;
        if (def.value < curr) {
          if (def.inclusive)
            bag.maximum = def.value;
          else
            bag.exclusiveMaximum = def.value;
        }
      });
      inst._zod.check = (payload) => {
        if (def.inclusive ? payload.value <= def.value : payload.value < def.value) {
          return;
        }
        payload.issues.push({
          origin,
          code: "too_big",
          maximum: def.value,
          input: payload.value,
          inclusive: def.inclusive,
          inst,
          continue: !def.abort
        });
      };
    });
    $ZodCheckGreaterThan = /* @__PURE__ */ $constructor("$ZodCheckGreaterThan", (inst, def) => {
      $ZodCheck.init(inst, def);
      const origin = numericOriginMap[typeof def.value];
      inst._zod.onattach.push((inst2) => {
        const bag = inst2._zod.bag;
        const curr = (def.inclusive ? bag.minimum : bag.exclusiveMinimum) ?? Number.NEGATIVE_INFINITY;
        if (def.value > curr) {
          if (def.inclusive)
            bag.minimum = def.value;
          else
            bag.exclusiveMinimum = def.value;
        }
      });
      inst._zod.check = (payload) => {
        if (def.inclusive ? payload.value >= def.value : payload.value > def.value) {
          return;
        }
        payload.issues.push({
          origin,
          code: "too_small",
          minimum: def.value,
          input: payload.value,
          inclusive: def.inclusive,
          inst,
          continue: !def.abort
        });
      };
    });
    $ZodCheckMultipleOf = /* @__PURE__ */ $constructor("$ZodCheckMultipleOf", (inst, def) => {
      $ZodCheck.init(inst, def);
      inst._zod.onattach.push((inst2) => {
        var _a;
        (_a = inst2._zod.bag).multipleOf ?? (_a.multipleOf = def.value);
      });
      inst._zod.check = (payload) => {
        if (typeof payload.value !== typeof def.value)
          throw new Error("Cannot mix number and bigint in multiple_of check.");
        const isMultiple = typeof payload.value === "bigint" ? payload.value % def.value === BigInt(0) : floatSafeRemainder(payload.value, def.value) === 0;
        if (isMultiple)
          return;
        payload.issues.push({
          origin: typeof payload.value,
          code: "not_multiple_of",
          divisor: def.value,
          input: payload.value,
          inst,
          continue: !def.abort
        });
      };
    });
    $ZodCheckNumberFormat = /* @__PURE__ */ $constructor("$ZodCheckNumberFormat", (inst, def) => {
      $ZodCheck.init(inst, def);
      def.format = def.format || "float64";
      const isInt = def.format?.includes("int");
      const origin = isInt ? "int" : "number";
      const [minimum, maximum] = NUMBER_FORMAT_RANGES[def.format];
      inst._zod.onattach.push((inst2) => {
        const bag = inst2._zod.bag;
        bag.format = def.format;
        bag.minimum = minimum;
        bag.maximum = maximum;
        if (isInt)
          bag.pattern = integer;
      });
      inst._zod.check = (payload) => {
        const input = payload.value;
        if (isInt) {
          if (!Number.isInteger(input)) {
            payload.issues.push({
              expected: origin,
              format: def.format,
              code: "invalid_type",
              continue: false,
              input,
              inst
            });
            return;
          }
          if (!Number.isSafeInteger(input)) {
            if (input > 0) {
              payload.issues.push({
                input,
                code: "too_big",
                maximum: Number.MAX_SAFE_INTEGER,
                note: "Integers must be within the safe integer range.",
                inst,
                origin,
                continue: !def.abort
              });
            } else {
              payload.issues.push({
                input,
                code: "too_small",
                minimum: Number.MIN_SAFE_INTEGER,
                note: "Integers must be within the safe integer range.",
                inst,
                origin,
                continue: !def.abort
              });
            }
            return;
          }
        }
        if (input < minimum) {
          payload.issues.push({
            origin: "number",
            input,
            code: "too_small",
            minimum,
            inclusive: true,
            inst,
            continue: !def.abort
          });
        }
        if (input > maximum) {
          payload.issues.push({
            origin: "number",
            input,
            code: "too_big",
            maximum,
            inst
          });
        }
      };
    });
    $ZodCheckBigIntFormat = /* @__PURE__ */ $constructor("$ZodCheckBigIntFormat", (inst, def) => {
      $ZodCheck.init(inst, def);
      const [minimum, maximum] = BIGINT_FORMAT_RANGES[def.format];
      inst._zod.onattach.push((inst2) => {
        const bag = inst2._zod.bag;
        bag.format = def.format;
        bag.minimum = minimum;
        bag.maximum = maximum;
      });
      inst._zod.check = (payload) => {
        const input = payload.value;
        if (input < minimum) {
          payload.issues.push({
            origin: "bigint",
            input,
            code: "too_small",
            minimum,
            inclusive: true,
            inst,
            continue: !def.abort
          });
        }
        if (input > maximum) {
          payload.issues.push({
            origin: "bigint",
            input,
            code: "too_big",
            maximum,
            inst
          });
        }
      };
    });
    $ZodCheckMaxSize = /* @__PURE__ */ $constructor("$ZodCheckMaxSize", (inst, def) => {
      var _a;
      $ZodCheck.init(inst, def);
      (_a = inst._zod.def).when ?? (_a.when = (payload) => {
        const val = payload.value;
        return !nullish(val) && val.size !== void 0;
      });
      inst._zod.onattach.push((inst2) => {
        const curr = inst2._zod.bag.maximum ?? Number.POSITIVE_INFINITY;
        if (def.maximum < curr)
          inst2._zod.bag.maximum = def.maximum;
      });
      inst._zod.check = (payload) => {
        const input = payload.value;
        const size = input.size;
        if (size <= def.maximum)
          return;
        payload.issues.push({
          origin: getSizableOrigin(input),
          code: "too_big",
          maximum: def.maximum,
          inclusive: true,
          input,
          inst,
          continue: !def.abort
        });
      };
    });
    $ZodCheckMinSize = /* @__PURE__ */ $constructor("$ZodCheckMinSize", (inst, def) => {
      var _a;
      $ZodCheck.init(inst, def);
      (_a = inst._zod.def).when ?? (_a.when = (payload) => {
        const val = payload.value;
        return !nullish(val) && val.size !== void 0;
      });
      inst._zod.onattach.push((inst2) => {
        const curr = inst2._zod.bag.minimum ?? Number.NEGATIVE_INFINITY;
        if (def.minimum > curr)
          inst2._zod.bag.minimum = def.minimum;
      });
      inst._zod.check = (payload) => {
        const input = payload.value;
        const size = input.size;
        if (size >= def.minimum)
          return;
        payload.issues.push({
          origin: getSizableOrigin(input),
          code: "too_small",
          minimum: def.minimum,
          inclusive: true,
          input,
          inst,
          continue: !def.abort
        });
      };
    });
    $ZodCheckSizeEquals = /* @__PURE__ */ $constructor("$ZodCheckSizeEquals", (inst, def) => {
      var _a;
      $ZodCheck.init(inst, def);
      (_a = inst._zod.def).when ?? (_a.when = (payload) => {
        const val = payload.value;
        return !nullish(val) && val.size !== void 0;
      });
      inst._zod.onattach.push((inst2) => {
        const bag = inst2._zod.bag;
        bag.minimum = def.size;
        bag.maximum = def.size;
        bag.size = def.size;
      });
      inst._zod.check = (payload) => {
        const input = payload.value;
        const size = input.size;
        if (size === def.size)
          return;
        const tooBig = size > def.size;
        payload.issues.push({
          origin: getSizableOrigin(input),
          ...tooBig ? { code: "too_big", maximum: def.size } : { code: "too_small", minimum: def.size },
          inclusive: true,
          exact: true,
          input: payload.value,
          inst,
          continue: !def.abort
        });
      };
    });
    $ZodCheckMaxLength = /* @__PURE__ */ $constructor("$ZodCheckMaxLength", (inst, def) => {
      var _a;
      $ZodCheck.init(inst, def);
      (_a = inst._zod.def).when ?? (_a.when = (payload) => {
        const val = payload.value;
        return !nullish(val) && val.length !== void 0;
      });
      inst._zod.onattach.push((inst2) => {
        const curr = inst2._zod.bag.maximum ?? Number.POSITIVE_INFINITY;
        if (def.maximum < curr)
          inst2._zod.bag.maximum = def.maximum;
      });
      inst._zod.check = (payload) => {
        const input = payload.value;
        const length = input.length;
        if (length <= def.maximum)
          return;
        const origin = getLengthableOrigin(input);
        payload.issues.push({
          origin,
          code: "too_big",
          maximum: def.maximum,
          inclusive: true,
          input,
          inst,
          continue: !def.abort
        });
      };
    });
    $ZodCheckMinLength = /* @__PURE__ */ $constructor("$ZodCheckMinLength", (inst, def) => {
      var _a;
      $ZodCheck.init(inst, def);
      (_a = inst._zod.def).when ?? (_a.when = (payload) => {
        const val = payload.value;
        return !nullish(val) && val.length !== void 0;
      });
      inst._zod.onattach.push((inst2) => {
        const curr = inst2._zod.bag.minimum ?? Number.NEGATIVE_INFINITY;
        if (def.minimum > curr)
          inst2._zod.bag.minimum = def.minimum;
      });
      inst._zod.check = (payload) => {
        const input = payload.value;
        const length = input.length;
        if (length >= def.minimum)
          return;
        const origin = getLengthableOrigin(input);
        payload.issues.push({
          origin,
          code: "too_small",
          minimum: def.minimum,
          inclusive: true,
          input,
          inst,
          continue: !def.abort
        });
      };
    });
    $ZodCheckLengthEquals = /* @__PURE__ */ $constructor("$ZodCheckLengthEquals", (inst, def) => {
      var _a;
      $ZodCheck.init(inst, def);
      (_a = inst._zod.def).when ?? (_a.when = (payload) => {
        const val = payload.value;
        return !nullish(val) && val.length !== void 0;
      });
      inst._zod.onattach.push((inst2) => {
        const bag = inst2._zod.bag;
        bag.minimum = def.length;
        bag.maximum = def.length;
        bag.length = def.length;
      });
      inst._zod.check = (payload) => {
        const input = payload.value;
        const length = input.length;
        if (length === def.length)
          return;
        const origin = getLengthableOrigin(input);
        const tooBig = length > def.length;
        payload.issues.push({
          origin,
          ...tooBig ? { code: "too_big", maximum: def.length } : { code: "too_small", minimum: def.length },
          inclusive: true,
          exact: true,
          input: payload.value,
          inst,
          continue: !def.abort
        });
      };
    });
    $ZodCheckStringFormat = /* @__PURE__ */ $constructor("$ZodCheckStringFormat", (inst, def) => {
      var _a, _b;
      $ZodCheck.init(inst, def);
      inst._zod.onattach.push((inst2) => {
        const bag = inst2._zod.bag;
        bag.format = def.format;
        if (def.pattern) {
          bag.patterns ?? (bag.patterns = /* @__PURE__ */ new Set());
          bag.patterns.add(def.pattern);
        }
      });
      if (def.pattern)
        (_a = inst._zod).check ?? (_a.check = (payload) => {
          def.pattern.lastIndex = 0;
          if (def.pattern.test(payload.value))
            return;
          payload.issues.push({
            origin: "string",
            code: "invalid_format",
            format: def.format,
            input: payload.value,
            ...def.pattern ? { pattern: def.pattern.toString() } : {},
            inst,
            continue: !def.abort
          });
        });
      else
        (_b = inst._zod).check ?? (_b.check = () => {
        });
    });
    $ZodCheckRegex = /* @__PURE__ */ $constructor("$ZodCheckRegex", (inst, def) => {
      $ZodCheckStringFormat.init(inst, def);
      inst._zod.check = (payload) => {
        def.pattern.lastIndex = 0;
        if (def.pattern.test(payload.value))
          return;
        payload.issues.push({
          origin: "string",
          code: "invalid_format",
          format: "regex",
          input: payload.value,
          pattern: def.pattern.toString(),
          inst,
          continue: !def.abort
        });
      };
    });
    $ZodCheckLowerCase = /* @__PURE__ */ $constructor("$ZodCheckLowerCase", (inst, def) => {
      def.pattern ?? (def.pattern = lowercase);
      $ZodCheckStringFormat.init(inst, def);
    });
    $ZodCheckUpperCase = /* @__PURE__ */ $constructor("$ZodCheckUpperCase", (inst, def) => {
      def.pattern ?? (def.pattern = uppercase);
      $ZodCheckStringFormat.init(inst, def);
    });
    $ZodCheckIncludes = /* @__PURE__ */ $constructor("$ZodCheckIncludes", (inst, def) => {
      $ZodCheck.init(inst, def);
      const escapedRegex = escapeRegex2(def.includes);
      const pattern = new RegExp(typeof def.position === "number" ? `^.{${def.position}}${escapedRegex}` : escapedRegex);
      def.pattern = pattern;
      inst._zod.onattach.push((inst2) => {
        const bag = inst2._zod.bag;
        bag.patterns ?? (bag.patterns = /* @__PURE__ */ new Set());
        bag.patterns.add(pattern);
      });
      inst._zod.check = (payload) => {
        if (payload.value.includes(def.includes, def.position))
          return;
        payload.issues.push({
          origin: "string",
          code: "invalid_format",
          format: "includes",
          includes: def.includes,
          input: payload.value,
          inst,
          continue: !def.abort
        });
      };
    });
    $ZodCheckStartsWith = /* @__PURE__ */ $constructor("$ZodCheckStartsWith", (inst, def) => {
      $ZodCheck.init(inst, def);
      const pattern = new RegExp(`^${escapeRegex2(def.prefix)}.*`);
      def.pattern ?? (def.pattern = pattern);
      inst._zod.onattach.push((inst2) => {
        const bag = inst2._zod.bag;
        bag.patterns ?? (bag.patterns = /* @__PURE__ */ new Set());
        bag.patterns.add(pattern);
      });
      inst._zod.check = (payload) => {
        if (payload.value.startsWith(def.prefix))
          return;
        payload.issues.push({
          origin: "string",
          code: "invalid_format",
          format: "starts_with",
          prefix: def.prefix,
          input: payload.value,
          inst,
          continue: !def.abort
        });
      };
    });
    $ZodCheckEndsWith = /* @__PURE__ */ $constructor("$ZodCheckEndsWith", (inst, def) => {
      $ZodCheck.init(inst, def);
      const pattern = new RegExp(`.*${escapeRegex2(def.suffix)}$`);
      def.pattern ?? (def.pattern = pattern);
      inst._zod.onattach.push((inst2) => {
        const bag = inst2._zod.bag;
        bag.patterns ?? (bag.patterns = /* @__PURE__ */ new Set());
        bag.patterns.add(pattern);
      });
      inst._zod.check = (payload) => {
        if (payload.value.endsWith(def.suffix))
          return;
        payload.issues.push({
          origin: "string",
          code: "invalid_format",
          format: "ends_with",
          suffix: def.suffix,
          input: payload.value,
          inst,
          continue: !def.abort
        });
      };
    });
    $ZodCheckProperty = /* @__PURE__ */ $constructor("$ZodCheckProperty", (inst, def) => {
      $ZodCheck.init(inst, def);
      inst._zod.check = (payload) => {
        const result = def.schema._zod.run({
          value: payload.value[def.property],
          issues: []
        }, {});
        if (result instanceof Promise) {
          return result.then((result2) => handleCheckPropertyResult(result2, payload, def.property));
        }
        handleCheckPropertyResult(result, payload, def.property);
        return;
      };
    });
    $ZodCheckMimeType = /* @__PURE__ */ $constructor("$ZodCheckMimeType", (inst, def) => {
      $ZodCheck.init(inst, def);
      const mimeSet = new Set(def.mime);
      inst._zod.onattach.push((inst2) => {
        inst2._zod.bag.mime = def.mime;
      });
      inst._zod.check = (payload) => {
        if (mimeSet.has(payload.value.type))
          return;
        payload.issues.push({
          code: "invalid_value",
          values: def.mime,
          input: payload.value.type,
          inst,
          continue: !def.abort
        });
      };
    });
    $ZodCheckOverwrite = /* @__PURE__ */ $constructor("$ZodCheckOverwrite", (inst, def) => {
      $ZodCheck.init(inst, def);
      inst._zod.check = (payload) => {
        payload.value = def.tx(payload.value);
      };
    });
  }
});

// node_modules/zod/v4/core/doc.js
var Doc;
var init_doc = __esm({
  "node_modules/zod/v4/core/doc.js"() {
    Doc = class {
      constructor(args = []) {
        this.content = [];
        this.indent = 0;
        if (this)
          this.args = args;
      }
      indented(fn) {
        this.indent += 1;
        fn(this);
        this.indent -= 1;
      }
      write(arg) {
        if (typeof arg === "function") {
          arg(this, { execution: "sync" });
          arg(this, { execution: "async" });
          return;
        }
        const content = arg;
        const lines = content.split("\n").filter((x) => x);
        const minIndent = Math.min(...lines.map((x) => x.length - x.trimStart().length));
        const dedented = lines.map((x) => x.slice(minIndent)).map((x) => " ".repeat(this.indent * 2) + x);
        for (const line of dedented) {
          this.content.push(line);
        }
      }
      compile() {
        const F = Function;
        const args = this?.args;
        const content = this?.content ?? [``];
        const lines = [...content.map((x) => `  ${x}`)];
        return new F(...args, lines.join("\n"));
      }
    };
  }
});

// node_modules/zod/v4/core/versions.js
var version;
var init_versions = __esm({
  "node_modules/zod/v4/core/versions.js"() {
    version = {
      major: 4,
      minor: 1,
      patch: 12
    };
  }
});

// node_modules/zod/v4/core/schemas.js
function isValidBase64(data) {
  if (data === "")
    return true;
  if (data.length % 4 !== 0)
    return false;
  try {
    atob(data);
    return true;
  } catch {
    return false;
  }
}
function isValidBase64URL(data) {
  if (!base64url.test(data))
    return false;
  const base643 = data.replace(/[-_]/g, (c) => c === "-" ? "+" : "/");
  const padded = base643.padEnd(Math.ceil(base643.length / 4) * 4, "=");
  return isValidBase64(padded);
}
function isValidJWT(token, algorithm = null) {
  try {
    const tokensParts = token.split(".");
    if (tokensParts.length !== 3)
      return false;
    const [header] = tokensParts;
    if (!header)
      return false;
    const parsedHeader = JSON.parse(atob(header));
    if ("typ" in parsedHeader && parsedHeader?.typ !== "JWT")
      return false;
    if (!parsedHeader.alg)
      return false;
    if (algorithm && (!("alg" in parsedHeader) || parsedHeader.alg !== algorithm))
      return false;
    return true;
  } catch {
    return false;
  }
}
function handleArrayResult(result, final, index) {
  if (result.issues.length) {
    final.issues.push(...prefixIssues(index, result.issues));
  }
  final.value[index] = result.value;
}
function handlePropertyResult(result, final, key, input) {
  if (result.issues.length) {
    final.issues.push(...prefixIssues(key, result.issues));
  }
  if (result.value === void 0) {
    if (key in input) {
      final.value[key] = void 0;
    }
  } else {
    final.value[key] = result.value;
  }
}
function normalizeDef(def) {
  const keys = Object.keys(def.shape);
  for (const k of keys) {
    if (!def.shape?.[k]?._zod?.traits?.has("$ZodType")) {
      throw new Error(`Invalid element at key "${k}": expected a Zod schema`);
    }
  }
  const okeys = optionalKeys(def.shape);
  return {
    ...def,
    keys,
    keySet: new Set(keys),
    numKeys: keys.length,
    optionalKeys: new Set(okeys)
  };
}
function handleCatchall(proms, input, payload, ctx, def, inst) {
  const unrecognized = [];
  const keySet = def.keySet;
  const _catchall = def.catchall._zod;
  const t = _catchall.def.type;
  for (const key of Object.keys(input)) {
    if (keySet.has(key))
      continue;
    if (t === "never") {
      unrecognized.push(key);
      continue;
    }
    const r = _catchall.run({ value: input[key], issues: [] }, ctx);
    if (r instanceof Promise) {
      proms.push(r.then((r2) => handlePropertyResult(r2, payload, key, input)));
    } else {
      handlePropertyResult(r, payload, key, input);
    }
  }
  if (unrecognized.length) {
    payload.issues.push({
      code: "unrecognized_keys",
      keys: unrecognized,
      input,
      inst
    });
  }
  if (!proms.length)
    return payload;
  return Promise.all(proms).then(() => {
    return payload;
  });
}
function handleUnionResults(results, final, inst, ctx) {
  for (const result of results) {
    if (result.issues.length === 0) {
      final.value = result.value;
      return final;
    }
  }
  const nonaborted = results.filter((r) => !aborted(r));
  if (nonaborted.length === 1) {
    final.value = nonaborted[0].value;
    return nonaborted[0];
  }
  final.issues.push({
    code: "invalid_union",
    input: final.value,
    inst,
    errors: results.map((result) => result.issues.map((iss) => finalizeIssue(iss, ctx, config())))
  });
  return final;
}
function mergeValues(a, b) {
  if (a === b) {
    return { valid: true, data: a };
  }
  if (a instanceof Date && b instanceof Date && +a === +b) {
    return { valid: true, data: a };
  }
  if (isPlainObject(a) && isPlainObject(b)) {
    const bKeys = Object.keys(b);
    const sharedKeys = Object.keys(a).filter((key) => bKeys.indexOf(key) !== -1);
    const newObj = { ...a, ...b };
    for (const key of sharedKeys) {
      const sharedValue = mergeValues(a[key], b[key]);
      if (!sharedValue.valid) {
        return {
          valid: false,
          mergeErrorPath: [key, ...sharedValue.mergeErrorPath]
        };
      }
      newObj[key] = sharedValue.data;
    }
    return { valid: true, data: newObj };
  }
  if (Array.isArray(a) && Array.isArray(b)) {
    if (a.length !== b.length) {
      return { valid: false, mergeErrorPath: [] };
    }
    const newArray = [];
    for (let index = 0; index < a.length; index++) {
      const itemA = a[index];
      const itemB = b[index];
      const sharedValue = mergeValues(itemA, itemB);
      if (!sharedValue.valid) {
        return {
          valid: false,
          mergeErrorPath: [index, ...sharedValue.mergeErrorPath]
        };
      }
      newArray.push(sharedValue.data);
    }
    return { valid: true, data: newArray };
  }
  return { valid: false, mergeErrorPath: [] };
}
function handleIntersectionResults(result, left, right) {
  if (left.issues.length) {
    result.issues.push(...left.issues);
  }
  if (right.issues.length) {
    result.issues.push(...right.issues);
  }
  if (aborted(result))
    return result;
  const merged = mergeValues(left.value, right.value);
  if (!merged.valid) {
    throw new Error(`Unmergable intersection. Error path: ${JSON.stringify(merged.mergeErrorPath)}`);
  }
  result.value = merged.data;
  return result;
}
function handleTupleResult(result, final, index) {
  if (result.issues.length) {
    final.issues.push(...prefixIssues(index, result.issues));
  }
  final.value[index] = result.value;
}
function handleMapResult(keyResult, valueResult, final, key, input, inst, ctx) {
  if (keyResult.issues.length) {
    if (propertyKeyTypes.has(typeof key)) {
      final.issues.push(...prefixIssues(key, keyResult.issues));
    } else {
      final.issues.push({
        code: "invalid_key",
        origin: "map",
        input,
        inst,
        issues: keyResult.issues.map((iss) => finalizeIssue(iss, ctx, config()))
      });
    }
  }
  if (valueResult.issues.length) {
    if (propertyKeyTypes.has(typeof key)) {
      final.issues.push(...prefixIssues(key, valueResult.issues));
    } else {
      final.issues.push({
        origin: "map",
        code: "invalid_element",
        input,
        inst,
        key,
        issues: valueResult.issues.map((iss) => finalizeIssue(iss, ctx, config()))
      });
    }
  }
  final.value.set(keyResult.value, valueResult.value);
}
function handleSetResult(result, final) {
  if (result.issues.length) {
    final.issues.push(...result.issues);
  }
  final.value.add(result.value);
}
function handleOptionalResult(result, input) {
  if (result.issues.length && input === void 0) {
    return { issues: [], value: void 0 };
  }
  return result;
}
function handleDefaultResult(payload, def) {
  if (payload.value === void 0) {
    payload.value = def.defaultValue;
  }
  return payload;
}
function handleNonOptionalResult(payload, inst) {
  if (!payload.issues.length && payload.value === void 0) {
    payload.issues.push({
      code: "invalid_type",
      expected: "nonoptional",
      input: payload.value,
      inst
    });
  }
  return payload;
}
function handlePipeResult(left, next, ctx) {
  if (left.issues.length) {
    left.aborted = true;
    return left;
  }
  return next._zod.run({ value: left.value, issues: left.issues }, ctx);
}
function handleCodecAResult(result, def, ctx) {
  if (result.issues.length) {
    result.aborted = true;
    return result;
  }
  const direction = ctx.direction || "forward";
  if (direction === "forward") {
    const transformed = def.transform(result.value, result);
    if (transformed instanceof Promise) {
      return transformed.then((value) => handleCodecTxResult(result, value, def.out, ctx));
    }
    return handleCodecTxResult(result, transformed, def.out, ctx);
  } else {
    const transformed = def.reverseTransform(result.value, result);
    if (transformed instanceof Promise) {
      return transformed.then((value) => handleCodecTxResult(result, value, def.in, ctx));
    }
    return handleCodecTxResult(result, transformed, def.in, ctx);
  }
}
function handleCodecTxResult(left, value, nextSchema, ctx) {
  if (left.issues.length) {
    left.aborted = true;
    return left;
  }
  return nextSchema._zod.run({ value, issues: left.issues }, ctx);
}
function handleReadonlyResult(payload) {
  payload.value = Object.freeze(payload.value);
  return payload;
}
function handleRefineResult(result, payload, input, inst) {
  if (!result) {
    const _iss = {
      code: "custom",
      input,
      inst,
      // incorporates params.error into issue reporting
      path: [...inst._zod.def.path ?? []],
      // incorporates params.error into issue reporting
      continue: !inst._zod.def.abort
      // params: inst._zod.def.params,
    };
    if (inst._zod.def.params)
      _iss.params = inst._zod.def.params;
    payload.issues.push(issue(_iss));
  }
}
var $ZodType, $ZodString, $ZodStringFormat, $ZodGUID, $ZodUUID, $ZodEmail, $ZodURL, $ZodEmoji, $ZodNanoID, $ZodCUID, $ZodCUID2, $ZodULID, $ZodXID, $ZodKSUID, $ZodISODateTime, $ZodISODate, $ZodISOTime, $ZodISODuration, $ZodIPv4, $ZodIPv6, $ZodCIDRv4, $ZodCIDRv6, $ZodBase64, $ZodBase64URL, $ZodE164, $ZodJWT, $ZodCustomStringFormat, $ZodNumber, $ZodNumberFormat, $ZodBoolean, $ZodBigInt, $ZodBigIntFormat, $ZodSymbol, $ZodUndefined, $ZodNull, $ZodAny, $ZodUnknown, $ZodNever, $ZodVoid, $ZodDate, $ZodArray, $ZodObject, $ZodObjectJIT, $ZodUnion, $ZodDiscriminatedUnion, $ZodIntersection, $ZodTuple, $ZodRecord, $ZodMap, $ZodSet, $ZodEnum, $ZodLiteral, $ZodFile, $ZodTransform, $ZodOptional, $ZodNullable, $ZodDefault, $ZodPrefault, $ZodNonOptional, $ZodSuccess, $ZodCatch, $ZodNaN, $ZodPipe, $ZodCodec, $ZodReadonly, $ZodTemplateLiteral, $ZodFunction, $ZodPromise, $ZodLazy, $ZodCustom;
var init_schemas = __esm({
  "node_modules/zod/v4/core/schemas.js"() {
    init_checks();
    init_core();
    init_doc();
    init_parse();
    init_regexes();
    init_util();
    init_versions();
    init_util();
    $ZodType = /* @__PURE__ */ $constructor("$ZodType", (inst, def) => {
      var _a;
      inst ?? (inst = {});
      inst._zod.def = def;
      inst._zod.bag = inst._zod.bag || {};
      inst._zod.version = version;
      const checks = [...inst._zod.def.checks ?? []];
      if (inst._zod.traits.has("$ZodCheck")) {
        checks.unshift(inst);
      }
      for (const ch of checks) {
        for (const fn of ch._zod.onattach) {
          fn(inst);
        }
      }
      if (checks.length === 0) {
        (_a = inst._zod).deferred ?? (_a.deferred = []);
        inst._zod.deferred?.push(() => {
          inst._zod.run = inst._zod.parse;
        });
      } else {
        const runChecks = (payload, checks2, ctx) => {
          let isAborted = aborted(payload);
          let asyncResult;
          for (const ch of checks2) {
            if (ch._zod.def.when) {
              const shouldRun = ch._zod.def.when(payload);
              if (!shouldRun)
                continue;
            } else if (isAborted) {
              continue;
            }
            const currLen = payload.issues.length;
            const _ = ch._zod.check(payload);
            if (_ instanceof Promise && ctx?.async === false) {
              throw new $ZodAsyncError();
            }
            if (asyncResult || _ instanceof Promise) {
              asyncResult = (asyncResult ?? Promise.resolve()).then(async () => {
                await _;
                const nextLen = payload.issues.length;
                if (nextLen === currLen)
                  return;
                if (!isAborted)
                  isAborted = aborted(payload, currLen);
              });
            } else {
              const nextLen = payload.issues.length;
              if (nextLen === currLen)
                continue;
              if (!isAborted)
                isAborted = aborted(payload, currLen);
            }
          }
          if (asyncResult) {
            return asyncResult.then(() => {
              return payload;
            });
          }
          return payload;
        };
        const handleCanaryResult = (canary, payload, ctx) => {
          if (aborted(canary)) {
            canary.aborted = true;
            return canary;
          }
          const checkResult = runChecks(payload, checks, ctx);
          if (checkResult instanceof Promise) {
            if (ctx.async === false)
              throw new $ZodAsyncError();
            return checkResult.then((checkResult2) => inst._zod.parse(checkResult2, ctx));
          }
          return inst._zod.parse(checkResult, ctx);
        };
        inst._zod.run = (payload, ctx) => {
          if (ctx.skipChecks) {
            return inst._zod.parse(payload, ctx);
          }
          if (ctx.direction === "backward") {
            const canary = inst._zod.parse({ value: payload.value, issues: [] }, { ...ctx, skipChecks: true });
            if (canary instanceof Promise) {
              return canary.then((canary2) => {
                return handleCanaryResult(canary2, payload, ctx);
              });
            }
            return handleCanaryResult(canary, payload, ctx);
          }
          const result = inst._zod.parse(payload, ctx);
          if (result instanceof Promise) {
            if (ctx.async === false)
              throw new $ZodAsyncError();
            return result.then((result2) => runChecks(result2, checks, ctx));
          }
          return runChecks(result, checks, ctx);
        };
      }
      inst["~standard"] = {
        validate: (value) => {
          try {
            const r = safeParse(inst, value);
            return r.success ? { value: r.data } : { issues: r.error?.issues };
          } catch (_) {
            return safeParseAsync(inst, value).then((r) => r.success ? { value: r.data } : { issues: r.error?.issues });
          }
        },
        vendor: "zod",
        version: 1
      };
    });
    $ZodString = /* @__PURE__ */ $constructor("$ZodString", (inst, def) => {
      $ZodType.init(inst, def);
      inst._zod.pattern = [...inst?._zod.bag?.patterns ?? []].pop() ?? string(inst._zod.bag);
      inst._zod.parse = (payload, _) => {
        if (def.coerce)
          try {
            payload.value = String(payload.value);
          } catch (_2) {
          }
        if (typeof payload.value === "string")
          return payload;
        payload.issues.push({
          expected: "string",
          code: "invalid_type",
          input: payload.value,
          inst
        });
        return payload;
      };
    });
    $ZodStringFormat = /* @__PURE__ */ $constructor("$ZodStringFormat", (inst, def) => {
      $ZodCheckStringFormat.init(inst, def);
      $ZodString.init(inst, def);
    });
    $ZodGUID = /* @__PURE__ */ $constructor("$ZodGUID", (inst, def) => {
      def.pattern ?? (def.pattern = guid);
      $ZodStringFormat.init(inst, def);
    });
    $ZodUUID = /* @__PURE__ */ $constructor("$ZodUUID", (inst, def) => {
      if (def.version) {
        const versionMap = {
          v1: 1,
          v2: 2,
          v3: 3,
          v4: 4,
          v5: 5,
          v6: 6,
          v7: 7,
          v8: 8
        };
        const v = versionMap[def.version];
        if (v === void 0)
          throw new Error(`Invalid UUID version: "${def.version}"`);
        def.pattern ?? (def.pattern = uuid(v));
      } else
        def.pattern ?? (def.pattern = uuid());
      $ZodStringFormat.init(inst, def);
    });
    $ZodEmail = /* @__PURE__ */ $constructor("$ZodEmail", (inst, def) => {
      def.pattern ?? (def.pattern = email);
      $ZodStringFormat.init(inst, def);
    });
    $ZodURL = /* @__PURE__ */ $constructor("$ZodURL", (inst, def) => {
      $ZodStringFormat.init(inst, def);
      inst._zod.check = (payload) => {
        try {
          const trimmed = payload.value.trim();
          const url2 = new URL(trimmed);
          if (def.hostname) {
            def.hostname.lastIndex = 0;
            if (!def.hostname.test(url2.hostname)) {
              payload.issues.push({
                code: "invalid_format",
                format: "url",
                note: "Invalid hostname",
                pattern: hostname.source,
                input: payload.value,
                inst,
                continue: !def.abort
              });
            }
          }
          if (def.protocol) {
            def.protocol.lastIndex = 0;
            if (!def.protocol.test(url2.protocol.endsWith(":") ? url2.protocol.slice(0, -1) : url2.protocol)) {
              payload.issues.push({
                code: "invalid_format",
                format: "url",
                note: "Invalid protocol",
                pattern: def.protocol.source,
                input: payload.value,
                inst,
                continue: !def.abort
              });
            }
          }
          if (def.normalize) {
            payload.value = url2.href;
          } else {
            payload.value = trimmed;
          }
          return;
        } catch (_) {
          payload.issues.push({
            code: "invalid_format",
            format: "url",
            input: payload.value,
            inst,
            continue: !def.abort
          });
        }
      };
    });
    $ZodEmoji = /* @__PURE__ */ $constructor("$ZodEmoji", (inst, def) => {
      def.pattern ?? (def.pattern = emoji());
      $ZodStringFormat.init(inst, def);
    });
    $ZodNanoID = /* @__PURE__ */ $constructor("$ZodNanoID", (inst, def) => {
      def.pattern ?? (def.pattern = nanoid);
      $ZodStringFormat.init(inst, def);
    });
    $ZodCUID = /* @__PURE__ */ $constructor("$ZodCUID", (inst, def) => {
      def.pattern ?? (def.pattern = cuid);
      $ZodStringFormat.init(inst, def);
    });
    $ZodCUID2 = /* @__PURE__ */ $constructor("$ZodCUID2", (inst, def) => {
      def.pattern ?? (def.pattern = cuid2);
      $ZodStringFormat.init(inst, def);
    });
    $ZodULID = /* @__PURE__ */ $constructor("$ZodULID", (inst, def) => {
      def.pattern ?? (def.pattern = ulid);
      $ZodStringFormat.init(inst, def);
    });
    $ZodXID = /* @__PURE__ */ $constructor("$ZodXID", (inst, def) => {
      def.pattern ?? (def.pattern = xid);
      $ZodStringFormat.init(inst, def);
    });
    $ZodKSUID = /* @__PURE__ */ $constructor("$ZodKSUID", (inst, def) => {
      def.pattern ?? (def.pattern = ksuid);
      $ZodStringFormat.init(inst, def);
    });
    $ZodISODateTime = /* @__PURE__ */ $constructor("$ZodISODateTime", (inst, def) => {
      def.pattern ?? (def.pattern = datetime(def));
      $ZodStringFormat.init(inst, def);
    });
    $ZodISODate = /* @__PURE__ */ $constructor("$ZodISODate", (inst, def) => {
      def.pattern ?? (def.pattern = date);
      $ZodStringFormat.init(inst, def);
    });
    $ZodISOTime = /* @__PURE__ */ $constructor("$ZodISOTime", (inst, def) => {
      def.pattern ?? (def.pattern = time(def));
      $ZodStringFormat.init(inst, def);
    });
    $ZodISODuration = /* @__PURE__ */ $constructor("$ZodISODuration", (inst, def) => {
      def.pattern ?? (def.pattern = duration);
      $ZodStringFormat.init(inst, def);
    });
    $ZodIPv4 = /* @__PURE__ */ $constructor("$ZodIPv4", (inst, def) => {
      def.pattern ?? (def.pattern = ipv4);
      $ZodStringFormat.init(inst, def);
      inst._zod.onattach.push((inst2) => {
        const bag = inst2._zod.bag;
        bag.format = `ipv4`;
      });
    });
    $ZodIPv6 = /* @__PURE__ */ $constructor("$ZodIPv6", (inst, def) => {
      def.pattern ?? (def.pattern = ipv6);
      $ZodStringFormat.init(inst, def);
      inst._zod.onattach.push((inst2) => {
        const bag = inst2._zod.bag;
        bag.format = `ipv6`;
      });
      inst._zod.check = (payload) => {
        try {
          new URL(`http://[${payload.value}]`);
        } catch {
          payload.issues.push({
            code: "invalid_format",
            format: "ipv6",
            input: payload.value,
            inst,
            continue: !def.abort
          });
        }
      };
    });
    $ZodCIDRv4 = /* @__PURE__ */ $constructor("$ZodCIDRv4", (inst, def) => {
      def.pattern ?? (def.pattern = cidrv4);
      $ZodStringFormat.init(inst, def);
    });
    $ZodCIDRv6 = /* @__PURE__ */ $constructor("$ZodCIDRv6", (inst, def) => {
      def.pattern ?? (def.pattern = cidrv6);
      $ZodStringFormat.init(inst, def);
      inst._zod.check = (payload) => {
        const parts = payload.value.split("/");
        try {
          if (parts.length !== 2)
            throw new Error();
          const [address, prefix] = parts;
          if (!prefix)
            throw new Error();
          const prefixNum = Number(prefix);
          if (`${prefixNum}` !== prefix)
            throw new Error();
          if (prefixNum < 0 || prefixNum > 128)
            throw new Error();
          new URL(`http://[${address}]`);
        } catch {
          payload.issues.push({
            code: "invalid_format",
            format: "cidrv6",
            input: payload.value,
            inst,
            continue: !def.abort
          });
        }
      };
    });
    $ZodBase64 = /* @__PURE__ */ $constructor("$ZodBase64", (inst, def) => {
      def.pattern ?? (def.pattern = base64);
      $ZodStringFormat.init(inst, def);
      inst._zod.onattach.push((inst2) => {
        inst2._zod.bag.contentEncoding = "base64";
      });
      inst._zod.check = (payload) => {
        if (isValidBase64(payload.value))
          return;
        payload.issues.push({
          code: "invalid_format",
          format: "base64",
          input: payload.value,
          inst,
          continue: !def.abort
        });
      };
    });
    $ZodBase64URL = /* @__PURE__ */ $constructor("$ZodBase64URL", (inst, def) => {
      def.pattern ?? (def.pattern = base64url);
      $ZodStringFormat.init(inst, def);
      inst._zod.onattach.push((inst2) => {
        inst2._zod.bag.contentEncoding = "base64url";
      });
      inst._zod.check = (payload) => {
        if (isValidBase64URL(payload.value))
          return;
        payload.issues.push({
          code: "invalid_format",
          format: "base64url",
          input: payload.value,
          inst,
          continue: !def.abort
        });
      };
    });
    $ZodE164 = /* @__PURE__ */ $constructor("$ZodE164", (inst, def) => {
      def.pattern ?? (def.pattern = e164);
      $ZodStringFormat.init(inst, def);
    });
    $ZodJWT = /* @__PURE__ */ $constructor("$ZodJWT", (inst, def) => {
      $ZodStringFormat.init(inst, def);
      inst._zod.check = (payload) => {
        if (isValidJWT(payload.value, def.alg))
          return;
        payload.issues.push({
          code: "invalid_format",
          format: "jwt",
          input: payload.value,
          inst,
          continue: !def.abort
        });
      };
    });
    $ZodCustomStringFormat = /* @__PURE__ */ $constructor("$ZodCustomStringFormat", (inst, def) => {
      $ZodStringFormat.init(inst, def);
      inst._zod.check = (payload) => {
        if (def.fn(payload.value))
          return;
        payload.issues.push({
          code: "invalid_format",
          format: def.format,
          input: payload.value,
          inst,
          continue: !def.abort
        });
      };
    });
    $ZodNumber = /* @__PURE__ */ $constructor("$ZodNumber", (inst, def) => {
      $ZodType.init(inst, def);
      inst._zod.pattern = inst._zod.bag.pattern ?? number;
      inst._zod.parse = (payload, _ctx) => {
        if (def.coerce)
          try {
            payload.value = Number(payload.value);
          } catch (_) {
          }
        const input = payload.value;
        if (typeof input === "number" && !Number.isNaN(input) && Number.isFinite(input)) {
          return payload;
        }
        const received = typeof input === "number" ? Number.isNaN(input) ? "NaN" : !Number.isFinite(input) ? "Infinity" : void 0 : void 0;
        payload.issues.push({
          expected: "number",
          code: "invalid_type",
          input,
          inst,
          ...received ? { received } : {}
        });
        return payload;
      };
    });
    $ZodNumberFormat = /* @__PURE__ */ $constructor("$ZodNumber", (inst, def) => {
      $ZodCheckNumberFormat.init(inst, def);
      $ZodNumber.init(inst, def);
    });
    $ZodBoolean = /* @__PURE__ */ $constructor("$ZodBoolean", (inst, def) => {
      $ZodType.init(inst, def);
      inst._zod.pattern = boolean;
      inst._zod.parse = (payload, _ctx) => {
        if (def.coerce)
          try {
            payload.value = Boolean(payload.value);
          } catch (_) {
          }
        const input = payload.value;
        if (typeof input === "boolean")
          return payload;
        payload.issues.push({
          expected: "boolean",
          code: "invalid_type",
          input,
          inst
        });
        return payload;
      };
    });
    $ZodBigInt = /* @__PURE__ */ $constructor("$ZodBigInt", (inst, def) => {
      $ZodType.init(inst, def);
      inst._zod.pattern = bigint;
      inst._zod.parse = (payload, _ctx) => {
        if (def.coerce)
          try {
            payload.value = BigInt(payload.value);
          } catch (_) {
          }
        if (typeof payload.value === "bigint")
          return payload;
        payload.issues.push({
          expected: "bigint",
          code: "invalid_type",
          input: payload.value,
          inst
        });
        return payload;
      };
    });
    $ZodBigIntFormat = /* @__PURE__ */ $constructor("$ZodBigInt", (inst, def) => {
      $ZodCheckBigIntFormat.init(inst, def);
      $ZodBigInt.init(inst, def);
    });
    $ZodSymbol = /* @__PURE__ */ $constructor("$ZodSymbol", (inst, def) => {
      $ZodType.init(inst, def);
      inst._zod.parse = (payload, _ctx) => {
        const input = payload.value;
        if (typeof input === "symbol")
          return payload;
        payload.issues.push({
          expected: "symbol",
          code: "invalid_type",
          input,
          inst
        });
        return payload;
      };
    });
    $ZodUndefined = /* @__PURE__ */ $constructor("$ZodUndefined", (inst, def) => {
      $ZodType.init(inst, def);
      inst._zod.pattern = _undefined;
      inst._zod.values = /* @__PURE__ */ new Set([void 0]);
      inst._zod.optin = "optional";
      inst._zod.optout = "optional";
      inst._zod.parse = (payload, _ctx) => {
        const input = payload.value;
        if (typeof input === "undefined")
          return payload;
        payload.issues.push({
          expected: "undefined",
          code: "invalid_type",
          input,
          inst
        });
        return payload;
      };
    });
    $ZodNull = /* @__PURE__ */ $constructor("$ZodNull", (inst, def) => {
      $ZodType.init(inst, def);
      inst._zod.pattern = _null;
      inst._zod.values = /* @__PURE__ */ new Set([null]);
      inst._zod.parse = (payload, _ctx) => {
        const input = payload.value;
        if (input === null)
          return payload;
        payload.issues.push({
          expected: "null",
          code: "invalid_type",
          input,
          inst
        });
        return payload;
      };
    });
    $ZodAny = /* @__PURE__ */ $constructor("$ZodAny", (inst, def) => {
      $ZodType.init(inst, def);
      inst._zod.parse = (payload) => payload;
    });
    $ZodUnknown = /* @__PURE__ */ $constructor("$ZodUnknown", (inst, def) => {
      $ZodType.init(inst, def);
      inst._zod.parse = (payload) => payload;
    });
    $ZodNever = /* @__PURE__ */ $constructor("$ZodNever", (inst, def) => {
      $ZodType.init(inst, def);
      inst._zod.parse = (payload, _ctx) => {
        payload.issues.push({
          expected: "never",
          code: "invalid_type",
          input: payload.value,
          inst
        });
        return payload;
      };
    });
    $ZodVoid = /* @__PURE__ */ $constructor("$ZodVoid", (inst, def) => {
      $ZodType.init(inst, def);
      inst._zod.parse = (payload, _ctx) => {
        const input = payload.value;
        if (typeof input === "undefined")
          return payload;
        payload.issues.push({
          expected: "void",
          code: "invalid_type",
          input,
          inst
        });
        return payload;
      };
    });
    $ZodDate = /* @__PURE__ */ $constructor("$ZodDate", (inst, def) => {
      $ZodType.init(inst, def);
      inst._zod.parse = (payload, _ctx) => {
        if (def.coerce) {
          try {
            payload.value = new Date(payload.value);
          } catch (_err) {
          }
        }
        const input = payload.value;
        const isDate = input instanceof Date;
        const isValidDate = isDate && !Number.isNaN(input.getTime());
        if (isValidDate)
          return payload;
        payload.issues.push({
          expected: "date",
          code: "invalid_type",
          input,
          ...isDate ? { received: "Invalid Date" } : {},
          inst
        });
        return payload;
      };
    });
    $ZodArray = /* @__PURE__ */ $constructor("$ZodArray", (inst, def) => {
      $ZodType.init(inst, def);
      inst._zod.parse = (payload, ctx) => {
        const input = payload.value;
        if (!Array.isArray(input)) {
          payload.issues.push({
            expected: "array",
            code: "invalid_type",
            input,
            inst
          });
          return payload;
        }
        payload.value = Array(input.length);
        const proms = [];
        for (let i = 0; i < input.length; i++) {
          const item = input[i];
          const result = def.element._zod.run({
            value: item,
            issues: []
          }, ctx);
          if (result instanceof Promise) {
            proms.push(result.then((result2) => handleArrayResult(result2, payload, i)));
          } else {
            handleArrayResult(result, payload, i);
          }
        }
        if (proms.length) {
          return Promise.all(proms).then(() => payload);
        }
        return payload;
      };
    });
    $ZodObject = /* @__PURE__ */ $constructor("$ZodObject", (inst, def) => {
      $ZodType.init(inst, def);
      const desc = Object.getOwnPropertyDescriptor(def, "shape");
      if (!desc?.get) {
        const sh = def.shape;
        Object.defineProperty(def, "shape", {
          get: () => {
            const newSh = { ...sh };
            Object.defineProperty(def, "shape", {
              value: newSh
            });
            return newSh;
          }
        });
      }
      const _normalized = cached(() => normalizeDef(def));
      defineLazy(inst._zod, "propValues", () => {
        const shape = def.shape;
        const propValues = {};
        for (const key in shape) {
          const field = shape[key]._zod;
          if (field.values) {
            propValues[key] ?? (propValues[key] = /* @__PURE__ */ new Set());
            for (const v of field.values)
              propValues[key].add(v);
          }
        }
        return propValues;
      });
      const isObject4 = isObject2;
      const catchall = def.catchall;
      let value;
      inst._zod.parse = (payload, ctx) => {
        value ?? (value = _normalized.value);
        const input = payload.value;
        if (!isObject4(input)) {
          payload.issues.push({
            expected: "object",
            code: "invalid_type",
            input,
            inst
          });
          return payload;
        }
        payload.value = {};
        const proms = [];
        const shape = value.shape;
        for (const key of value.keys) {
          const el = shape[key];
          const r = el._zod.run({ value: input[key], issues: [] }, ctx);
          if (r instanceof Promise) {
            proms.push(r.then((r2) => handlePropertyResult(r2, payload, key, input)));
          } else {
            handlePropertyResult(r, payload, key, input);
          }
        }
        if (!catchall) {
          return proms.length ? Promise.all(proms).then(() => payload) : payload;
        }
        return handleCatchall(proms, input, payload, ctx, _normalized.value, inst);
      };
    });
    $ZodObjectJIT = /* @__PURE__ */ $constructor("$ZodObjectJIT", (inst, def) => {
      $ZodObject.init(inst, def);
      const superParse = inst._zod.parse;
      const _normalized = cached(() => normalizeDef(def));
      const generateFastpass = (shape) => {
        const doc = new Doc(["shape", "payload", "ctx"]);
        const normalized = _normalized.value;
        const parseStr = (key) => {
          const k = esc(key);
          return `shape[${k}]._zod.run({ value: input[${k}], issues: [] }, ctx)`;
        };
        doc.write(`const input = payload.value;`);
        const ids = /* @__PURE__ */ Object.create(null);
        let counter = 0;
        for (const key of normalized.keys) {
          ids[key] = `key_${counter++}`;
        }
        doc.write(`const newResult = {};`);
        for (const key of normalized.keys) {
          const id = ids[key];
          const k = esc(key);
          doc.write(`const ${id} = ${parseStr(key)};`);
          doc.write(`
        if (${id}.issues.length) {
          payload.issues = payload.issues.concat(${id}.issues.map(iss => ({
            ...iss,
            path: iss.path ? [${k}, ...iss.path] : [${k}]
          })));
        }
        
        
        if (${id}.value === undefined) {
          if (${k} in input) {
            newResult[${k}] = undefined;
          }
        } else {
          newResult[${k}] = ${id}.value;
        }
        
      `);
        }
        doc.write(`payload.value = newResult;`);
        doc.write(`return payload;`);
        const fn = doc.compile();
        return (payload, ctx) => fn(shape, payload, ctx);
      };
      let fastpass;
      const isObject4 = isObject2;
      const jit = !globalConfig.jitless;
      const allowsEval2 = allowsEval;
      const fastEnabled = jit && allowsEval2.value;
      const catchall = def.catchall;
      let value;
      inst._zod.parse = (payload, ctx) => {
        value ?? (value = _normalized.value);
        const input = payload.value;
        if (!isObject4(input)) {
          payload.issues.push({
            expected: "object",
            code: "invalid_type",
            input,
            inst
          });
          return payload;
        }
        if (jit && fastEnabled && ctx?.async === false && ctx.jitless !== true) {
          if (!fastpass)
            fastpass = generateFastpass(def.shape);
          payload = fastpass(payload, ctx);
          if (!catchall)
            return payload;
          return handleCatchall([], input, payload, ctx, value, inst);
        }
        return superParse(payload, ctx);
      };
    });
    $ZodUnion = /* @__PURE__ */ $constructor("$ZodUnion", (inst, def) => {
      $ZodType.init(inst, def);
      defineLazy(inst._zod, "optin", () => def.options.some((o) => o._zod.optin === "optional") ? "optional" : void 0);
      defineLazy(inst._zod, "optout", () => def.options.some((o) => o._zod.optout === "optional") ? "optional" : void 0);
      defineLazy(inst._zod, "values", () => {
        if (def.options.every((o) => o._zod.values)) {
          return new Set(def.options.flatMap((option) => Array.from(option._zod.values)));
        }
        return void 0;
      });
      defineLazy(inst._zod, "pattern", () => {
        if (def.options.every((o) => o._zod.pattern)) {
          const patterns = def.options.map((o) => o._zod.pattern);
          return new RegExp(`^(${patterns.map((p) => cleanRegex(p.source)).join("|")})$`);
        }
        return void 0;
      });
      const single = def.options.length === 1;
      const first = def.options[0]._zod.run;
      inst._zod.parse = (payload, ctx) => {
        if (single) {
          return first(payload, ctx);
        }
        let async = false;
        const results = [];
        for (const option of def.options) {
          const result = option._zod.run({
            value: payload.value,
            issues: []
          }, ctx);
          if (result instanceof Promise) {
            results.push(result);
            async = true;
          } else {
            if (result.issues.length === 0)
              return result;
            results.push(result);
          }
        }
        if (!async)
          return handleUnionResults(results, payload, inst, ctx);
        return Promise.all(results).then((results2) => {
          return handleUnionResults(results2, payload, inst, ctx);
        });
      };
    });
    $ZodDiscriminatedUnion = /* @__PURE__ */ $constructor("$ZodDiscriminatedUnion", (inst, def) => {
      $ZodUnion.init(inst, def);
      const _super = inst._zod.parse;
      defineLazy(inst._zod, "propValues", () => {
        const propValues = {};
        for (const option of def.options) {
          const pv = option._zod.propValues;
          if (!pv || Object.keys(pv).length === 0)
            throw new Error(`Invalid discriminated union option at index "${def.options.indexOf(option)}"`);
          for (const [k, v] of Object.entries(pv)) {
            if (!propValues[k])
              propValues[k] = /* @__PURE__ */ new Set();
            for (const val of v) {
              propValues[k].add(val);
            }
          }
        }
        return propValues;
      });
      const disc = cached(() => {
        const opts = def.options;
        const map3 = /* @__PURE__ */ new Map();
        for (const o of opts) {
          const values = o._zod.propValues?.[def.discriminator];
          if (!values || values.size === 0)
            throw new Error(`Invalid discriminated union option at index "${def.options.indexOf(o)}"`);
          for (const v of values) {
            if (map3.has(v)) {
              throw new Error(`Duplicate discriminator value "${String(v)}"`);
            }
            map3.set(v, o);
          }
        }
        return map3;
      });
      inst._zod.parse = (payload, ctx) => {
        const input = payload.value;
        if (!isObject2(input)) {
          payload.issues.push({
            code: "invalid_type",
            expected: "object",
            input,
            inst
          });
          return payload;
        }
        const opt = disc.value.get(input?.[def.discriminator]);
        if (opt) {
          return opt._zod.run(payload, ctx);
        }
        if (def.unionFallback) {
          return _super(payload, ctx);
        }
        payload.issues.push({
          code: "invalid_union",
          errors: [],
          note: "No matching discriminator",
          discriminator: def.discriminator,
          input,
          path: [def.discriminator],
          inst
        });
        return payload;
      };
    });
    $ZodIntersection = /* @__PURE__ */ $constructor("$ZodIntersection", (inst, def) => {
      $ZodType.init(inst, def);
      inst._zod.parse = (payload, ctx) => {
        const input = payload.value;
        const left = def.left._zod.run({ value: input, issues: [] }, ctx);
        const right = def.right._zod.run({ value: input, issues: [] }, ctx);
        const async = left instanceof Promise || right instanceof Promise;
        if (async) {
          return Promise.all([left, right]).then(([left2, right2]) => {
            return handleIntersectionResults(payload, left2, right2);
          });
        }
        return handleIntersectionResults(payload, left, right);
      };
    });
    $ZodTuple = /* @__PURE__ */ $constructor("$ZodTuple", (inst, def) => {
      $ZodType.init(inst, def);
      const items = def.items;
      const optStart = items.length - [...items].reverse().findIndex((item) => item._zod.optin !== "optional");
      inst._zod.parse = (payload, ctx) => {
        const input = payload.value;
        if (!Array.isArray(input)) {
          payload.issues.push({
            input,
            inst,
            expected: "tuple",
            code: "invalid_type"
          });
          return payload;
        }
        payload.value = [];
        const proms = [];
        if (!def.rest) {
          const tooBig = input.length > items.length;
          const tooSmall = input.length < optStart - 1;
          if (tooBig || tooSmall) {
            payload.issues.push({
              ...tooBig ? { code: "too_big", maximum: items.length } : { code: "too_small", minimum: items.length },
              input,
              inst,
              origin: "array"
            });
            return payload;
          }
        }
        let i = -1;
        for (const item of items) {
          i++;
          if (i >= input.length) {
            if (i >= optStart)
              continue;
          }
          const result = item._zod.run({
            value: input[i],
            issues: []
          }, ctx);
          if (result instanceof Promise) {
            proms.push(result.then((result2) => handleTupleResult(result2, payload, i)));
          } else {
            handleTupleResult(result, payload, i);
          }
        }
        if (def.rest) {
          const rest = input.slice(items.length);
          for (const el of rest) {
            i++;
            const result = def.rest._zod.run({
              value: el,
              issues: []
            }, ctx);
            if (result instanceof Promise) {
              proms.push(result.then((result2) => handleTupleResult(result2, payload, i)));
            } else {
              handleTupleResult(result, payload, i);
            }
          }
        }
        if (proms.length)
          return Promise.all(proms).then(() => payload);
        return payload;
      };
    });
    $ZodRecord = /* @__PURE__ */ $constructor("$ZodRecord", (inst, def) => {
      $ZodType.init(inst, def);
      inst._zod.parse = (payload, ctx) => {
        const input = payload.value;
        if (!isPlainObject(input)) {
          payload.issues.push({
            expected: "record",
            code: "invalid_type",
            input,
            inst
          });
          return payload;
        }
        const proms = [];
        if (def.keyType._zod.values) {
          const values = def.keyType._zod.values;
          payload.value = {};
          for (const key of values) {
            if (typeof key === "string" || typeof key === "number" || typeof key === "symbol") {
              const result = def.valueType._zod.run({ value: input[key], issues: [] }, ctx);
              if (result instanceof Promise) {
                proms.push(result.then((result2) => {
                  if (result2.issues.length) {
                    payload.issues.push(...prefixIssues(key, result2.issues));
                  }
                  payload.value[key] = result2.value;
                }));
              } else {
                if (result.issues.length) {
                  payload.issues.push(...prefixIssues(key, result.issues));
                }
                payload.value[key] = result.value;
              }
            }
          }
          let unrecognized;
          for (const key in input) {
            if (!values.has(key)) {
              unrecognized = unrecognized ?? [];
              unrecognized.push(key);
            }
          }
          if (unrecognized && unrecognized.length > 0) {
            payload.issues.push({
              code: "unrecognized_keys",
              input,
              inst,
              keys: unrecognized
            });
          }
        } else {
          payload.value = {};
          for (const key of Reflect.ownKeys(input)) {
            if (key === "__proto__")
              continue;
            const keyResult = def.keyType._zod.run({ value: key, issues: [] }, ctx);
            if (keyResult instanceof Promise) {
              throw new Error("Async schemas not supported in object keys currently");
            }
            if (keyResult.issues.length) {
              payload.issues.push({
                code: "invalid_key",
                origin: "record",
                issues: keyResult.issues.map((iss) => finalizeIssue(iss, ctx, config())),
                input: key,
                path: [key],
                inst
              });
              payload.value[keyResult.value] = keyResult.value;
              continue;
            }
            const result = def.valueType._zod.run({ value: input[key], issues: [] }, ctx);
            if (result instanceof Promise) {
              proms.push(result.then((result2) => {
                if (result2.issues.length) {
                  payload.issues.push(...prefixIssues(key, result2.issues));
                }
                payload.value[keyResult.value] = result2.value;
              }));
            } else {
              if (result.issues.length) {
                payload.issues.push(...prefixIssues(key, result.issues));
              }
              payload.value[keyResult.value] = result.value;
            }
          }
        }
        if (proms.length) {
          return Promise.all(proms).then(() => payload);
        }
        return payload;
      };
    });
    $ZodMap = /* @__PURE__ */ $constructor("$ZodMap", (inst, def) => {
      $ZodType.init(inst, def);
      inst._zod.parse = (payload, ctx) => {
        const input = payload.value;
        if (!(input instanceof Map)) {
          payload.issues.push({
            expected: "map",
            code: "invalid_type",
            input,
            inst
          });
          return payload;
        }
        const proms = [];
        payload.value = /* @__PURE__ */ new Map();
        for (const [key, value] of input) {
          const keyResult = def.keyType._zod.run({ value: key, issues: [] }, ctx);
          const valueResult = def.valueType._zod.run({ value, issues: [] }, ctx);
          if (keyResult instanceof Promise || valueResult instanceof Promise) {
            proms.push(Promise.all([keyResult, valueResult]).then(([keyResult2, valueResult2]) => {
              handleMapResult(keyResult2, valueResult2, payload, key, input, inst, ctx);
            }));
          } else {
            handleMapResult(keyResult, valueResult, payload, key, input, inst, ctx);
          }
        }
        if (proms.length)
          return Promise.all(proms).then(() => payload);
        return payload;
      };
    });
    $ZodSet = /* @__PURE__ */ $constructor("$ZodSet", (inst, def) => {
      $ZodType.init(inst, def);
      inst._zod.parse = (payload, ctx) => {
        const input = payload.value;
        if (!(input instanceof Set)) {
          payload.issues.push({
            input,
            inst,
            expected: "set",
            code: "invalid_type"
          });
          return payload;
        }
        const proms = [];
        payload.value = /* @__PURE__ */ new Set();
        for (const item of input) {
          const result = def.valueType._zod.run({ value: item, issues: [] }, ctx);
          if (result instanceof Promise) {
            proms.push(result.then((result2) => handleSetResult(result2, payload)));
          } else
            handleSetResult(result, payload);
        }
        if (proms.length)
          return Promise.all(proms).then(() => payload);
        return payload;
      };
    });
    $ZodEnum = /* @__PURE__ */ $constructor("$ZodEnum", (inst, def) => {
      $ZodType.init(inst, def);
      const values = getEnumValues(def.entries);
      const valuesSet = new Set(values);
      inst._zod.values = valuesSet;
      inst._zod.pattern = new RegExp(`^(${values.filter((k) => propertyKeyTypes.has(typeof k)).map((o) => typeof o === "string" ? escapeRegex2(o) : o.toString()).join("|")})$`);
      inst._zod.parse = (payload, _ctx) => {
        const input = payload.value;
        if (valuesSet.has(input)) {
          return payload;
        }
        payload.issues.push({
          code: "invalid_value",
          values,
          input,
          inst
        });
        return payload;
      };
    });
    $ZodLiteral = /* @__PURE__ */ $constructor("$ZodLiteral", (inst, def) => {
      $ZodType.init(inst, def);
      if (def.values.length === 0) {
        throw new Error("Cannot create literal schema with no valid values");
      }
      inst._zod.values = new Set(def.values);
      inst._zod.pattern = new RegExp(`^(${def.values.map((o) => typeof o === "string" ? escapeRegex2(o) : o ? escapeRegex2(o.toString()) : String(o)).join("|")})$`);
      inst._zod.parse = (payload, _ctx) => {
        const input = payload.value;
        if (inst._zod.values.has(input)) {
          return payload;
        }
        payload.issues.push({
          code: "invalid_value",
          values: def.values,
          input,
          inst
        });
        return payload;
      };
    });
    $ZodFile = /* @__PURE__ */ $constructor("$ZodFile", (inst, def) => {
      $ZodType.init(inst, def);
      inst._zod.parse = (payload, _ctx) => {
        const input = payload.value;
        if (input instanceof File)
          return payload;
        payload.issues.push({
          expected: "file",
          code: "invalid_type",
          input,
          inst
        });
        return payload;
      };
    });
    $ZodTransform = /* @__PURE__ */ $constructor("$ZodTransform", (inst, def) => {
      $ZodType.init(inst, def);
      inst._zod.parse = (payload, ctx) => {
        if (ctx.direction === "backward") {
          throw new $ZodEncodeError(inst.constructor.name);
        }
        const _out = def.transform(payload.value, payload);
        if (ctx.async) {
          const output = _out instanceof Promise ? _out : Promise.resolve(_out);
          return output.then((output2) => {
            payload.value = output2;
            return payload;
          });
        }
        if (_out instanceof Promise) {
          throw new $ZodAsyncError();
        }
        payload.value = _out;
        return payload;
      };
    });
    $ZodOptional = /* @__PURE__ */ $constructor("$ZodOptional", (inst, def) => {
      $ZodType.init(inst, def);
      inst._zod.optin = "optional";
      inst._zod.optout = "optional";
      defineLazy(inst._zod, "values", () => {
        return def.innerType._zod.values ? /* @__PURE__ */ new Set([...def.innerType._zod.values, void 0]) : void 0;
      });
      defineLazy(inst._zod, "pattern", () => {
        const pattern = def.innerType._zod.pattern;
        return pattern ? new RegExp(`^(${cleanRegex(pattern.source)})?$`) : void 0;
      });
      inst._zod.parse = (payload, ctx) => {
        if (def.innerType._zod.optin === "optional") {
          const result = def.innerType._zod.run(payload, ctx);
          if (result instanceof Promise)
            return result.then((r) => handleOptionalResult(r, payload.value));
          return handleOptionalResult(result, payload.value);
        }
        if (payload.value === void 0) {
          return payload;
        }
        return def.innerType._zod.run(payload, ctx);
      };
    });
    $ZodNullable = /* @__PURE__ */ $constructor("$ZodNullable", (inst, def) => {
      $ZodType.init(inst, def);
      defineLazy(inst._zod, "optin", () => def.innerType._zod.optin);
      defineLazy(inst._zod, "optout", () => def.innerType._zod.optout);
      defineLazy(inst._zod, "pattern", () => {
        const pattern = def.innerType._zod.pattern;
        return pattern ? new RegExp(`^(${cleanRegex(pattern.source)}|null)$`) : void 0;
      });
      defineLazy(inst._zod, "values", () => {
        return def.innerType._zod.values ? /* @__PURE__ */ new Set([...def.innerType._zod.values, null]) : void 0;
      });
      inst._zod.parse = (payload, ctx) => {
        if (payload.value === null)
          return payload;
        return def.innerType._zod.run(payload, ctx);
      };
    });
    $ZodDefault = /* @__PURE__ */ $constructor("$ZodDefault", (inst, def) => {
      $ZodType.init(inst, def);
      inst._zod.optin = "optional";
      defineLazy(inst._zod, "values", () => def.innerType._zod.values);
      inst._zod.parse = (payload, ctx) => {
        if (ctx.direction === "backward") {
          return def.innerType._zod.run(payload, ctx);
        }
        if (payload.value === void 0) {
          payload.value = def.defaultValue;
          return payload;
        }
        const result = def.innerType._zod.run(payload, ctx);
        if (result instanceof Promise) {
          return result.then((result2) => handleDefaultResult(result2, def));
        }
        return handleDefaultResult(result, def);
      };
    });
    $ZodPrefault = /* @__PURE__ */ $constructor("$ZodPrefault", (inst, def) => {
      $ZodType.init(inst, def);
      inst._zod.optin = "optional";
      defineLazy(inst._zod, "values", () => def.innerType._zod.values);
      inst._zod.parse = (payload, ctx) => {
        if (ctx.direction === "backward") {
          return def.innerType._zod.run(payload, ctx);
        }
        if (payload.value === void 0) {
          payload.value = def.defaultValue;
        }
        return def.innerType._zod.run(payload, ctx);
      };
    });
    $ZodNonOptional = /* @__PURE__ */ $constructor("$ZodNonOptional", (inst, def) => {
      $ZodType.init(inst, def);
      defineLazy(inst._zod, "values", () => {
        const v = def.innerType._zod.values;
        return v ? new Set([...v].filter((x) => x !== void 0)) : void 0;
      });
      inst._zod.parse = (payload, ctx) => {
        const result = def.innerType._zod.run(payload, ctx);
        if (result instanceof Promise) {
          return result.then((result2) => handleNonOptionalResult(result2, inst));
        }
        return handleNonOptionalResult(result, inst);
      };
    });
    $ZodSuccess = /* @__PURE__ */ $constructor("$ZodSuccess", (inst, def) => {
      $ZodType.init(inst, def);
      inst._zod.parse = (payload, ctx) => {
        if (ctx.direction === "backward") {
          throw new $ZodEncodeError("ZodSuccess");
        }
        const result = def.innerType._zod.run(payload, ctx);
        if (result instanceof Promise) {
          return result.then((result2) => {
            payload.value = result2.issues.length === 0;
            return payload;
          });
        }
        payload.value = result.issues.length === 0;
        return payload;
      };
    });
    $ZodCatch = /* @__PURE__ */ $constructor("$ZodCatch", (inst, def) => {
      $ZodType.init(inst, def);
      defineLazy(inst._zod, "optin", () => def.innerType._zod.optin);
      defineLazy(inst._zod, "optout", () => def.innerType._zod.optout);
      defineLazy(inst._zod, "values", () => def.innerType._zod.values);
      inst._zod.parse = (payload, ctx) => {
        if (ctx.direction === "backward") {
          return def.innerType._zod.run(payload, ctx);
        }
        const result = def.innerType._zod.run(payload, ctx);
        if (result instanceof Promise) {
          return result.then((result2) => {
            payload.value = result2.value;
            if (result2.issues.length) {
              payload.value = def.catchValue({
                ...payload,
                error: {
                  issues: result2.issues.map((iss) => finalizeIssue(iss, ctx, config()))
                },
                input: payload.value
              });
              payload.issues = [];
            }
            return payload;
          });
        }
        payload.value = result.value;
        if (result.issues.length) {
          payload.value = def.catchValue({
            ...payload,
            error: {
              issues: result.issues.map((iss) => finalizeIssue(iss, ctx, config()))
            },
            input: payload.value
          });
          payload.issues = [];
        }
        return payload;
      };
    });
    $ZodNaN = /* @__PURE__ */ $constructor("$ZodNaN", (inst, def) => {
      $ZodType.init(inst, def);
      inst._zod.parse = (payload, _ctx) => {
        if (typeof payload.value !== "number" || !Number.isNaN(payload.value)) {
          payload.issues.push({
            input: payload.value,
            inst,
            expected: "nan",
            code: "invalid_type"
          });
          return payload;
        }
        return payload;
      };
    });
    $ZodPipe = /* @__PURE__ */ $constructor("$ZodPipe", (inst, def) => {
      $ZodType.init(inst, def);
      defineLazy(inst._zod, "values", () => def.in._zod.values);
      defineLazy(inst._zod, "optin", () => def.in._zod.optin);
      defineLazy(inst._zod, "optout", () => def.out._zod.optout);
      defineLazy(inst._zod, "propValues", () => def.in._zod.propValues);
      inst._zod.parse = (payload, ctx) => {
        if (ctx.direction === "backward") {
          const right = def.out._zod.run(payload, ctx);
          if (right instanceof Promise) {
            return right.then((right2) => handlePipeResult(right2, def.in, ctx));
          }
          return handlePipeResult(right, def.in, ctx);
        }
        const left = def.in._zod.run(payload, ctx);
        if (left instanceof Promise) {
          return left.then((left2) => handlePipeResult(left2, def.out, ctx));
        }
        return handlePipeResult(left, def.out, ctx);
      };
    });
    $ZodCodec = /* @__PURE__ */ $constructor("$ZodCodec", (inst, def) => {
      $ZodType.init(inst, def);
      defineLazy(inst._zod, "values", () => def.in._zod.values);
      defineLazy(inst._zod, "optin", () => def.in._zod.optin);
      defineLazy(inst._zod, "optout", () => def.out._zod.optout);
      defineLazy(inst._zod, "propValues", () => def.in._zod.propValues);
      inst._zod.parse = (payload, ctx) => {
        const direction = ctx.direction || "forward";
        if (direction === "forward") {
          const left = def.in._zod.run(payload, ctx);
          if (left instanceof Promise) {
            return left.then((left2) => handleCodecAResult(left2, def, ctx));
          }
          return handleCodecAResult(left, def, ctx);
        } else {
          const right = def.out._zod.run(payload, ctx);
          if (right instanceof Promise) {
            return right.then((right2) => handleCodecAResult(right2, def, ctx));
          }
          return handleCodecAResult(right, def, ctx);
        }
      };
    });
    $ZodReadonly = /* @__PURE__ */ $constructor("$ZodReadonly", (inst, def) => {
      $ZodType.init(inst, def);
      defineLazy(inst._zod, "propValues", () => def.innerType._zod.propValues);
      defineLazy(inst._zod, "values", () => def.innerType._zod.values);
      defineLazy(inst._zod, "optin", () => def.innerType._zod.optin);
      defineLazy(inst._zod, "optout", () => def.innerType._zod.optout);
      inst._zod.parse = (payload, ctx) => {
        if (ctx.direction === "backward") {
          return def.innerType._zod.run(payload, ctx);
        }
        const result = def.innerType._zod.run(payload, ctx);
        if (result instanceof Promise) {
          return result.then(handleReadonlyResult);
        }
        return handleReadonlyResult(result);
      };
    });
    $ZodTemplateLiteral = /* @__PURE__ */ $constructor("$ZodTemplateLiteral", (inst, def) => {
      $ZodType.init(inst, def);
      const regexParts = [];
      for (const part of def.parts) {
        if (typeof part === "object" && part !== null) {
          if (!part._zod.pattern) {
            throw new Error(`Invalid template literal part, no pattern found: ${[...part._zod.traits].shift()}`);
          }
          const source = part._zod.pattern instanceof RegExp ? part._zod.pattern.source : part._zod.pattern;
          if (!source)
            throw new Error(`Invalid template literal part: ${part._zod.traits}`);
          const start = source.startsWith("^") ? 1 : 0;
          const end = source.endsWith("$") ? source.length - 1 : source.length;
          regexParts.push(source.slice(start, end));
        } else if (part === null || primitiveTypes.has(typeof part)) {
          regexParts.push(escapeRegex2(`${part}`));
        } else {
          throw new Error(`Invalid template literal part: ${part}`);
        }
      }
      inst._zod.pattern = new RegExp(`^${regexParts.join("")}$`);
      inst._zod.parse = (payload, _ctx) => {
        if (typeof payload.value !== "string") {
          payload.issues.push({
            input: payload.value,
            inst,
            expected: "template_literal",
            code: "invalid_type"
          });
          return payload;
        }
        inst._zod.pattern.lastIndex = 0;
        if (!inst._zod.pattern.test(payload.value)) {
          payload.issues.push({
            input: payload.value,
            inst,
            code: "invalid_format",
            format: def.format ?? "template_literal",
            pattern: inst._zod.pattern.source
          });
          return payload;
        }
        return payload;
      };
    });
    $ZodFunction = /* @__PURE__ */ $constructor("$ZodFunction", (inst, def) => {
      $ZodType.init(inst, def);
      inst._def = def;
      inst._zod.def = def;
      inst.implement = (func) => {
        if (typeof func !== "function") {
          throw new Error("implement() must be called with a function");
        }
        return function(...args) {
          const parsedArgs = inst._def.input ? parse2(inst._def.input, args) : args;
          const result = Reflect.apply(func, this, parsedArgs);
          if (inst._def.output) {
            return parse2(inst._def.output, result);
          }
          return result;
        };
      };
      inst.implementAsync = (func) => {
        if (typeof func !== "function") {
          throw new Error("implementAsync() must be called with a function");
        }
        return async function(...args) {
          const parsedArgs = inst._def.input ? await parseAsync(inst._def.input, args) : args;
          const result = await Reflect.apply(func, this, parsedArgs);
          if (inst._def.output) {
            return await parseAsync(inst._def.output, result);
          }
          return result;
        };
      };
      inst._zod.parse = (payload, _ctx) => {
        if (typeof payload.value !== "function") {
          payload.issues.push({
            code: "invalid_type",
            expected: "function",
            input: payload.value,
            inst
          });
          return payload;
        }
        const hasPromiseOutput = inst._def.output && inst._def.output._zod.def.type === "promise";
        if (hasPromiseOutput) {
          payload.value = inst.implementAsync(payload.value);
        } else {
          payload.value = inst.implement(payload.value);
        }
        return payload;
      };
      inst.input = (...args) => {
        const F = inst.constructor;
        if (Array.isArray(args[0])) {
          return new F({
            type: "function",
            input: new $ZodTuple({
              type: "tuple",
              items: args[0],
              rest: args[1]
            }),
            output: inst._def.output
          });
        }
        return new F({
          type: "function",
          input: args[0],
          output: inst._def.output
        });
      };
      inst.output = (output) => {
        const F = inst.constructor;
        return new F({
          type: "function",
          input: inst._def.input,
          output
        });
      };
      return inst;
    });
    $ZodPromise = /* @__PURE__ */ $constructor("$ZodPromise", (inst, def) => {
      $ZodType.init(inst, def);
      inst._zod.parse = (payload, ctx) => {
        return Promise.resolve(payload.value).then((inner) => def.innerType._zod.run({ value: inner, issues: [] }, ctx));
      };
    });
    $ZodLazy = /* @__PURE__ */ $constructor("$ZodLazy", (inst, def) => {
      $ZodType.init(inst, def);
      defineLazy(inst._zod, "innerType", () => def.getter());
      defineLazy(inst._zod, "pattern", () => inst._zod.innerType._zod.pattern);
      defineLazy(inst._zod, "propValues", () => inst._zod.innerType._zod.propValues);
      defineLazy(inst._zod, "optin", () => inst._zod.innerType._zod.optin ?? void 0);
      defineLazy(inst._zod, "optout", () => inst._zod.innerType._zod.optout ?? void 0);
      inst._zod.parse = (payload, ctx) => {
        const inner = inst._zod.innerType;
        return inner._zod.run(payload, ctx);
      };
    });
    $ZodCustom = /* @__PURE__ */ $constructor("$ZodCustom", (inst, def) => {
      $ZodCheck.init(inst, def);
      $ZodType.init(inst, def);
      inst._zod.parse = (payload, _) => {
        return payload;
      };
      inst._zod.check = (payload) => {
        const input = payload.value;
        const r = def.fn(input);
        if (r instanceof Promise) {
          return r.then((r2) => handleRefineResult(r2, payload, input, inst));
        }
        handleRefineResult(r, payload, input, inst);
        return;
      };
    });
  }
});

// node_modules/zod/v4/locales/ar.js
function ar_default() {
  return {
    localeError: error()
  };
}
var error;
var init_ar = __esm({
  "node_modules/zod/v4/locales/ar.js"() {
    init_util();
    error = () => {
      const Sizable = {
        string: { unit: "\u062D\u0631\u0641", verb: "\u0623\u0646 \u064A\u062D\u0648\u064A" },
        file: { unit: "\u0628\u0627\u064A\u062A", verb: "\u0623\u0646 \u064A\u062D\u0648\u064A" },
        array: { unit: "\u0639\u0646\u0635\u0631", verb: "\u0623\u0646 \u064A\u062D\u0648\u064A" },
        set: { unit: "\u0639\u0646\u0635\u0631", verb: "\u0623\u0646 \u064A\u062D\u0648\u064A" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const parsedType8 = (data) => {
        const t = typeof data;
        switch (t) {
          case "number": {
            return Number.isNaN(data) ? "NaN" : "number";
          }
          case "object": {
            if (Array.isArray(data)) {
              return "array";
            }
            if (data === null) {
              return "null";
            }
            if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
              return data.constructor.name;
            }
          }
        }
        return t;
      };
      const Nouns = {
        regex: "\u0645\u062F\u062E\u0644",
        email: "\u0628\u0631\u064A\u062F \u0625\u0644\u0643\u062A\u0631\u0648\u0646\u064A",
        url: "\u0631\u0627\u0628\u0637",
        emoji: "\u0625\u064A\u0645\u0648\u062C\u064A",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "\u062A\u0627\u0631\u064A\u062E \u0648\u0648\u0642\u062A \u0628\u0645\u0639\u064A\u0627\u0631 ISO",
        date: "\u062A\u0627\u0631\u064A\u062E \u0628\u0645\u0639\u064A\u0627\u0631 ISO",
        time: "\u0648\u0642\u062A \u0628\u0645\u0639\u064A\u0627\u0631 ISO",
        duration: "\u0645\u062F\u0629 \u0628\u0645\u0639\u064A\u0627\u0631 ISO",
        ipv4: "\u0639\u0646\u0648\u0627\u0646 IPv4",
        ipv6: "\u0639\u0646\u0648\u0627\u0646 IPv6",
        cidrv4: "\u0645\u062F\u0649 \u0639\u0646\u0627\u0648\u064A\u0646 \u0628\u0635\u064A\u063A\u0629 IPv4",
        cidrv6: "\u0645\u062F\u0649 \u0639\u0646\u0627\u0648\u064A\u0646 \u0628\u0635\u064A\u063A\u0629 IPv6",
        base64: "\u0646\u064E\u0635 \u0628\u062A\u0631\u0645\u064A\u0632 base64-encoded",
        base64url: "\u0646\u064E\u0635 \u0628\u062A\u0631\u0645\u064A\u0632 base64url-encoded",
        json_string: "\u0646\u064E\u0635 \u0639\u0644\u0649 \u0647\u064A\u0626\u0629 JSON",
        e164: "\u0631\u0642\u0645 \u0647\u0627\u062A\u0641 \u0628\u0645\u0639\u064A\u0627\u0631 E.164",
        jwt: "JWT",
        template_literal: "\u0645\u062F\u062E\u0644"
      };
      return (issue2) => {
        switch (issue2.code) {
          case "invalid_type":
            return `\u0645\u062F\u062E\u0644\u0627\u062A \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644\u0629: \u064A\u0641\u062A\u0631\u0636 \u0625\u062F\u062E\u0627\u0644 ${issue2.expected}\u060C \u0648\u0644\u0643\u0646 \u062A\u0645 \u0625\u062F\u062E\u0627\u0644 ${parsedType8(issue2.input)}`;
          case "invalid_value":
            if (issue2.values.length === 1)
              return `\u0645\u062F\u062E\u0644\u0627\u062A \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644\u0629: \u064A\u0641\u062A\u0631\u0636 \u0625\u062F\u062E\u0627\u0644 ${stringifyPrimitive(issue2.values[0])}`;
            return `\u0627\u062E\u062A\u064A\u0627\u0631 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644: \u064A\u062A\u0648\u0642\u0639 \u0627\u0646\u062A\u0642\u0627\u0621 \u0623\u062D\u062F \u0647\u0630\u0647 \u0627\u0644\u062E\u064A\u0627\u0631\u0627\u062A: ${joinValues(issue2.values, "|")}`;
          case "too_big": {
            const adj = issue2.inclusive ? "<=" : "<";
            const sizing = getSizing(issue2.origin);
            if (sizing)
              return ` \u0623\u0643\u0628\u0631 \u0645\u0646 \u0627\u0644\u0644\u0627\u0632\u0645: \u064A\u0641\u062A\u0631\u0636 \u0623\u0646 \u062A\u0643\u0648\u0646 ${issue2.origin ?? "\u0627\u0644\u0642\u064A\u0645\u0629"} ${adj} ${issue2.maximum.toString()} ${sizing.unit ?? "\u0639\u0646\u0635\u0631"}`;
            return `\u0623\u0643\u0628\u0631 \u0645\u0646 \u0627\u0644\u0644\u0627\u0632\u0645: \u064A\u0641\u062A\u0631\u0636 \u0623\u0646 \u062A\u0643\u0648\u0646 ${issue2.origin ?? "\u0627\u0644\u0642\u064A\u0645\u0629"} ${adj} ${issue2.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue2.inclusive ? ">=" : ">";
            const sizing = getSizing(issue2.origin);
            if (sizing) {
              return `\u0623\u0635\u063A\u0631 \u0645\u0646 \u0627\u0644\u0644\u0627\u0632\u0645: \u064A\u0641\u062A\u0631\u0636 \u0644\u0640 ${issue2.origin} \u0623\u0646 \u064A\u0643\u0648\u0646 ${adj} ${issue2.minimum.toString()} ${sizing.unit}`;
            }
            return `\u0623\u0635\u063A\u0631 \u0645\u0646 \u0627\u0644\u0644\u0627\u0632\u0645: \u064A\u0641\u062A\u0631\u0636 \u0644\u0640 ${issue2.origin} \u0623\u0646 \u064A\u0643\u0648\u0646 ${adj} ${issue2.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue2;
            if (_issue.format === "starts_with")
              return `\u0646\u064E\u0635 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644: \u064A\u062C\u0628 \u0623\u0646 \u064A\u0628\u062F\u0623 \u0628\u0640 "${issue2.prefix}"`;
            if (_issue.format === "ends_with")
              return `\u0646\u064E\u0635 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644: \u064A\u062C\u0628 \u0623\u0646 \u064A\u0646\u062A\u0647\u064A \u0628\u0640 "${_issue.suffix}"`;
            if (_issue.format === "includes")
              return `\u0646\u064E\u0635 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644: \u064A\u062C\u0628 \u0623\u0646 \u064A\u062A\u0636\u0645\u0651\u064E\u0646 "${_issue.includes}"`;
            if (_issue.format === "regex")
              return `\u0646\u064E\u0635 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644: \u064A\u062C\u0628 \u0623\u0646 \u064A\u0637\u0627\u0628\u0642 \u0627\u0644\u0646\u0645\u0637 ${_issue.pattern}`;
            return `${Nouns[_issue.format] ?? issue2.format} \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644`;
          }
          case "not_multiple_of":
            return `\u0631\u0642\u0645 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644: \u064A\u062C\u0628 \u0623\u0646 \u064A\u0643\u0648\u0646 \u0645\u0646 \u0645\u0636\u0627\u0639\u0641\u0627\u062A ${issue2.divisor}`;
          case "unrecognized_keys":
            return `\u0645\u0639\u0631\u0641${issue2.keys.length > 1 ? "\u0627\u062A" : ""} \u063A\u0631\u064A\u0628${issue2.keys.length > 1 ? "\u0629" : ""}: ${joinValues(issue2.keys, "\u060C ")}`;
          case "invalid_key":
            return `\u0645\u0639\u0631\u0641 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644 \u0641\u064A ${issue2.origin}`;
          case "invalid_union":
            return "\u0645\u062F\u062E\u0644 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644";
          case "invalid_element":
            return `\u0645\u062F\u062E\u0644 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644 \u0641\u064A ${issue2.origin}`;
          default:
            return "\u0645\u062F\u062E\u0644 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644";
        }
      };
    };
  }
});

// node_modules/zod/v4/locales/az.js
function az_default() {
  return {
    localeError: error2()
  };
}
var error2;
var init_az = __esm({
  "node_modules/zod/v4/locales/az.js"() {
    init_util();
    error2 = () => {
      const Sizable = {
        string: { unit: "simvol", verb: "olmal\u0131d\u0131r" },
        file: { unit: "bayt", verb: "olmal\u0131d\u0131r" },
        array: { unit: "element", verb: "olmal\u0131d\u0131r" },
        set: { unit: "element", verb: "olmal\u0131d\u0131r" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const parsedType8 = (data) => {
        const t = typeof data;
        switch (t) {
          case "number": {
            return Number.isNaN(data) ? "NaN" : "number";
          }
          case "object": {
            if (Array.isArray(data)) {
              return "array";
            }
            if (data === null) {
              return "null";
            }
            if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
              return data.constructor.name;
            }
          }
        }
        return t;
      };
      const Nouns = {
        regex: "input",
        email: "email address",
        url: "URL",
        emoji: "emoji",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "ISO datetime",
        date: "ISO date",
        time: "ISO time",
        duration: "ISO duration",
        ipv4: "IPv4 address",
        ipv6: "IPv6 address",
        cidrv4: "IPv4 range",
        cidrv6: "IPv6 range",
        base64: "base64-encoded string",
        base64url: "base64url-encoded string",
        json_string: "JSON string",
        e164: "E.164 number",
        jwt: "JWT",
        template_literal: "input"
      };
      return (issue2) => {
        switch (issue2.code) {
          case "invalid_type":
            return `Yanl\u0131\u015F d\u0259y\u0259r: g\xF6zl\u0259nil\u0259n ${issue2.expected}, daxil olan ${parsedType8(issue2.input)}`;
          case "invalid_value":
            if (issue2.values.length === 1)
              return `Yanl\u0131\u015F d\u0259y\u0259r: g\xF6zl\u0259nil\u0259n ${stringifyPrimitive(issue2.values[0])}`;
            return `Yanl\u0131\u015F se\xE7im: a\u015Fa\u011F\u0131dak\u0131lardan biri olmal\u0131d\u0131r: ${joinValues(issue2.values, "|")}`;
          case "too_big": {
            const adj = issue2.inclusive ? "<=" : "<";
            const sizing = getSizing(issue2.origin);
            if (sizing)
              return `\xC7ox b\xF6y\xFCk: g\xF6zl\u0259nil\u0259n ${issue2.origin ?? "d\u0259y\u0259r"} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "element"}`;
            return `\xC7ox b\xF6y\xFCk: g\xF6zl\u0259nil\u0259n ${issue2.origin ?? "d\u0259y\u0259r"} ${adj}${issue2.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue2.inclusive ? ">=" : ">";
            const sizing = getSizing(issue2.origin);
            if (sizing)
              return `\xC7ox ki\xE7ik: g\xF6zl\u0259nil\u0259n ${issue2.origin} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
            return `\xC7ox ki\xE7ik: g\xF6zl\u0259nil\u0259n ${issue2.origin} ${adj}${issue2.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue2;
            if (_issue.format === "starts_with")
              return `Yanl\u0131\u015F m\u0259tn: "${_issue.prefix}" il\u0259 ba\u015Flamal\u0131d\u0131r`;
            if (_issue.format === "ends_with")
              return `Yanl\u0131\u015F m\u0259tn: "${_issue.suffix}" il\u0259 bitm\u0259lidir`;
            if (_issue.format === "includes")
              return `Yanl\u0131\u015F m\u0259tn: "${_issue.includes}" daxil olmal\u0131d\u0131r`;
            if (_issue.format === "regex")
              return `Yanl\u0131\u015F m\u0259tn: ${_issue.pattern} \u015Fablonuna uy\u011Fun olmal\u0131d\u0131r`;
            return `Yanl\u0131\u015F ${Nouns[_issue.format] ?? issue2.format}`;
          }
          case "not_multiple_of":
            return `Yanl\u0131\u015F \u0259d\u0259d: ${issue2.divisor} il\u0259 b\xF6l\xFCn\u0259 bil\u0259n olmal\u0131d\u0131r`;
          case "unrecognized_keys":
            return `Tan\u0131nmayan a\xE7ar${issue2.keys.length > 1 ? "lar" : ""}: ${joinValues(issue2.keys, ", ")}`;
          case "invalid_key":
            return `${issue2.origin} daxilind\u0259 yanl\u0131\u015F a\xE7ar`;
          case "invalid_union":
            return "Yanl\u0131\u015F d\u0259y\u0259r";
          case "invalid_element":
            return `${issue2.origin} daxilind\u0259 yanl\u0131\u015F d\u0259y\u0259r`;
          default:
            return `Yanl\u0131\u015F d\u0259y\u0259r`;
        }
      };
    };
  }
});

// node_modules/zod/v4/locales/be.js
function getBelarusianPlural(count, one, few, many) {
  const absCount = Math.abs(count);
  const lastDigit = absCount % 10;
  const lastTwoDigits = absCount % 100;
  if (lastTwoDigits >= 11 && lastTwoDigits <= 19) {
    return many;
  }
  if (lastDigit === 1) {
    return one;
  }
  if (lastDigit >= 2 && lastDigit <= 4) {
    return few;
  }
  return many;
}
function be_default() {
  return {
    localeError: error3()
  };
}
var error3;
var init_be = __esm({
  "node_modules/zod/v4/locales/be.js"() {
    init_util();
    error3 = () => {
      const Sizable = {
        string: {
          unit: {
            one: "\u0441\u0456\u043C\u0432\u0430\u043B",
            few: "\u0441\u0456\u043C\u0432\u0430\u043B\u044B",
            many: "\u0441\u0456\u043C\u0432\u0430\u043B\u0430\u045E"
          },
          verb: "\u043C\u0435\u0446\u044C"
        },
        array: {
          unit: {
            one: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442",
            few: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442\u044B",
            many: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442\u0430\u045E"
          },
          verb: "\u043C\u0435\u0446\u044C"
        },
        set: {
          unit: {
            one: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442",
            few: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442\u044B",
            many: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442\u0430\u045E"
          },
          verb: "\u043C\u0435\u0446\u044C"
        },
        file: {
          unit: {
            one: "\u0431\u0430\u0439\u0442",
            few: "\u0431\u0430\u0439\u0442\u044B",
            many: "\u0431\u0430\u0439\u0442\u0430\u045E"
          },
          verb: "\u043C\u0435\u0446\u044C"
        }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const parsedType8 = (data) => {
        const t = typeof data;
        switch (t) {
          case "number": {
            return Number.isNaN(data) ? "NaN" : "\u043B\u0456\u043A";
          }
          case "object": {
            if (Array.isArray(data)) {
              return "\u043C\u0430\u0441\u0456\u045E";
            }
            if (data === null) {
              return "null";
            }
            if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
              return data.constructor.name;
            }
          }
        }
        return t;
      };
      const Nouns = {
        regex: "\u0443\u0432\u043E\u0434",
        email: "email \u0430\u0434\u0440\u0430\u0441",
        url: "URL",
        emoji: "\u044D\u043C\u043E\u0434\u0437\u0456",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "ISO \u0434\u0430\u0442\u0430 \u0456 \u0447\u0430\u0441",
        date: "ISO \u0434\u0430\u0442\u0430",
        time: "ISO \u0447\u0430\u0441",
        duration: "ISO \u043F\u0440\u0430\u0446\u044F\u0433\u043B\u0430\u0441\u0446\u044C",
        ipv4: "IPv4 \u0430\u0434\u0440\u0430\u0441",
        ipv6: "IPv6 \u0430\u0434\u0440\u0430\u0441",
        cidrv4: "IPv4 \u0434\u044B\u044F\u043F\u0430\u0437\u043E\u043D",
        cidrv6: "IPv6 \u0434\u044B\u044F\u043F\u0430\u0437\u043E\u043D",
        base64: "\u0440\u0430\u0434\u043E\u043A \u0443 \u0444\u0430\u0440\u043C\u0430\u0446\u0435 base64",
        base64url: "\u0440\u0430\u0434\u043E\u043A \u0443 \u0444\u0430\u0440\u043C\u0430\u0446\u0435 base64url",
        json_string: "JSON \u0440\u0430\u0434\u043E\u043A",
        e164: "\u043D\u0443\u043C\u0430\u0440 E.164",
        jwt: "JWT",
        template_literal: "\u0443\u0432\u043E\u0434"
      };
      return (issue2) => {
        switch (issue2.code) {
          case "invalid_type":
            return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u045E\u0432\u043E\u0434: \u0447\u0430\u043A\u0430\u045E\u0441\u044F ${issue2.expected}, \u0430\u0442\u0440\u044B\u043C\u0430\u043D\u0430 ${parsedType8(issue2.input)}`;
          case "invalid_value":
            if (issue2.values.length === 1)
              return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u045E\u0432\u043E\u0434: \u0447\u0430\u043A\u0430\u043B\u0430\u0441\u044F ${stringifyPrimitive(issue2.values[0])}`;
            return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u0432\u0430\u0440\u044B\u044F\u043D\u0442: \u0447\u0430\u043A\u0430\u045E\u0441\u044F \u0430\u0434\u0437\u0456\u043D \u0437 ${joinValues(issue2.values, "|")}`;
          case "too_big": {
            const adj = issue2.inclusive ? "<=" : "<";
            const sizing = getSizing(issue2.origin);
            if (sizing) {
              const maxValue = Number(issue2.maximum);
              const unit = getBelarusianPlural(maxValue, sizing.unit.one, sizing.unit.few, sizing.unit.many);
              return `\u0417\u0430\u043D\u0430\u0434\u0442\u0430 \u0432\u044F\u043B\u0456\u043A\u0456: \u0447\u0430\u043A\u0430\u043B\u0430\u0441\u044F, \u0448\u0442\u043E ${issue2.origin ?? "\u0437\u043D\u0430\u0447\u044D\u043D\u043D\u0435"} \u043F\u0430\u0432\u0456\u043D\u043D\u0430 ${sizing.verb} ${adj}${issue2.maximum.toString()} ${unit}`;
            }
            return `\u0417\u0430\u043D\u0430\u0434\u0442\u0430 \u0432\u044F\u043B\u0456\u043A\u0456: \u0447\u0430\u043A\u0430\u043B\u0430\u0441\u044F, \u0448\u0442\u043E ${issue2.origin ?? "\u0437\u043D\u0430\u0447\u044D\u043D\u043D\u0435"} \u043F\u0430\u0432\u0456\u043D\u043D\u0430 \u0431\u044B\u0446\u044C ${adj}${issue2.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue2.inclusive ? ">=" : ">";
            const sizing = getSizing(issue2.origin);
            if (sizing) {
              const minValue = Number(issue2.minimum);
              const unit = getBelarusianPlural(minValue, sizing.unit.one, sizing.unit.few, sizing.unit.many);
              return `\u0417\u0430\u043D\u0430\u0434\u0442\u0430 \u043C\u0430\u043B\u044B: \u0447\u0430\u043A\u0430\u043B\u0430\u0441\u044F, \u0448\u0442\u043E ${issue2.origin} \u043F\u0430\u0432\u0456\u043D\u043D\u0430 ${sizing.verb} ${adj}${issue2.minimum.toString()} ${unit}`;
            }
            return `\u0417\u0430\u043D\u0430\u0434\u0442\u0430 \u043C\u0430\u043B\u044B: \u0447\u0430\u043A\u0430\u043B\u0430\u0441\u044F, \u0448\u0442\u043E ${issue2.origin} \u043F\u0430\u0432\u0456\u043D\u043D\u0430 \u0431\u044B\u0446\u044C ${adj}${issue2.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue2;
            if (_issue.format === "starts_with")
              return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u0440\u0430\u0434\u043E\u043A: \u043F\u0430\u0432\u0456\u043D\u0435\u043D \u043F\u0430\u0447\u044B\u043D\u0430\u0446\u0446\u0430 \u0437 "${_issue.prefix}"`;
            if (_issue.format === "ends_with")
              return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u0440\u0430\u0434\u043E\u043A: \u043F\u0430\u0432\u0456\u043D\u0435\u043D \u0437\u0430\u043A\u0430\u043D\u0447\u0432\u0430\u0446\u0446\u0430 \u043D\u0430 "${_issue.suffix}"`;
            if (_issue.format === "includes")
              return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u0440\u0430\u0434\u043E\u043A: \u043F\u0430\u0432\u0456\u043D\u0435\u043D \u0437\u043C\u044F\u0448\u0447\u0430\u0446\u044C "${_issue.includes}"`;
            if (_issue.format === "regex")
              return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u0440\u0430\u0434\u043E\u043A: \u043F\u0430\u0432\u0456\u043D\u0435\u043D \u0430\u0434\u043F\u0430\u0432\u044F\u0434\u0430\u0446\u044C \u0448\u0430\u0431\u043B\u043E\u043D\u0443 ${_issue.pattern}`;
            return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B ${Nouns[_issue.format] ?? issue2.format}`;
          }
          case "not_multiple_of":
            return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u043B\u0456\u043A: \u043F\u0430\u0432\u0456\u043D\u0435\u043D \u0431\u044B\u0446\u044C \u043A\u0440\u0430\u0442\u043D\u044B\u043C ${issue2.divisor}`;
          case "unrecognized_keys":
            return `\u041D\u0435\u0440\u0430\u0441\u043F\u0430\u0437\u043D\u0430\u043D\u044B ${issue2.keys.length > 1 ? "\u043A\u043B\u044E\u0447\u044B" : "\u043A\u043B\u044E\u0447"}: ${joinValues(issue2.keys, ", ")}`;
          case "invalid_key":
            return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u043A\u043B\u044E\u0447 \u0443 ${issue2.origin}`;
          case "invalid_union":
            return "\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u045E\u0432\u043E\u0434";
          case "invalid_element":
            return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u0430\u0435 \u0437\u043D\u0430\u0447\u044D\u043D\u043D\u0435 \u045E ${issue2.origin}`;
          default:
            return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u045E\u0432\u043E\u0434`;
        }
      };
    };
  }
});

// node_modules/zod/v4/locales/bg.js
function bg_default() {
  return {
    localeError: error4()
  };
}
var parsedType, error4;
var init_bg = __esm({
  "node_modules/zod/v4/locales/bg.js"() {
    init_util();
    parsedType = (data) => {
      const t = typeof data;
      switch (t) {
        case "number": {
          return Number.isNaN(data) ? "NaN" : "\u0447\u0438\u0441\u043B\u043E";
        }
        case "object": {
          if (Array.isArray(data)) {
            return "\u043C\u0430\u0441\u0438\u0432";
          }
          if (data === null) {
            return "null";
          }
          if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
            return data.constructor.name;
          }
        }
      }
      return t;
    };
    error4 = () => {
      const Sizable = {
        string: { unit: "\u0441\u0438\u043C\u0432\u043E\u043B\u0430", verb: "\u0434\u0430 \u0441\u044A\u0434\u044A\u0440\u0436\u0430" },
        file: { unit: "\u0431\u0430\u0439\u0442\u0430", verb: "\u0434\u0430 \u0441\u044A\u0434\u044A\u0440\u0436\u0430" },
        array: { unit: "\u0435\u043B\u0435\u043C\u0435\u043D\u0442\u0430", verb: "\u0434\u0430 \u0441\u044A\u0434\u044A\u0440\u0436\u0430" },
        set: { unit: "\u0435\u043B\u0435\u043C\u0435\u043D\u0442\u0430", verb: "\u0434\u0430 \u0441\u044A\u0434\u044A\u0440\u0436\u0430" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const Nouns = {
        regex: "\u0432\u0445\u043E\u0434",
        email: "\u0438\u043C\u0435\u0439\u043B \u0430\u0434\u0440\u0435\u0441",
        url: "URL",
        emoji: "\u0435\u043C\u043E\u0434\u0436\u0438",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "ISO \u0432\u0440\u0435\u043C\u0435",
        date: "ISO \u0434\u0430\u0442\u0430",
        time: "ISO \u0432\u0440\u0435\u043C\u0435",
        duration: "ISO \u043F\u0440\u043E\u0434\u044A\u043B\u0436\u0438\u0442\u0435\u043B\u043D\u043E\u0441\u0442",
        ipv4: "IPv4 \u0430\u0434\u0440\u0435\u0441",
        ipv6: "IPv6 \u0430\u0434\u0440\u0435\u0441",
        cidrv4: "IPv4 \u0434\u0438\u0430\u043F\u0430\u0437\u043E\u043D",
        cidrv6: "IPv6 \u0434\u0438\u0430\u043F\u0430\u0437\u043E\u043D",
        base64: "base64-\u043A\u043E\u0434\u0438\u0440\u0430\u043D \u043D\u0438\u0437",
        base64url: "base64url-\u043A\u043E\u0434\u0438\u0440\u0430\u043D \u043D\u0438\u0437",
        json_string: "JSON \u043D\u0438\u0437",
        e164: "E.164 \u043D\u043E\u043C\u0435\u0440",
        jwt: "JWT",
        template_literal: "\u0432\u0445\u043E\u0434"
      };
      return (issue2) => {
        switch (issue2.code) {
          case "invalid_type":
            return `\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u0435\u043D \u0432\u0445\u043E\u0434: \u043E\u0447\u0430\u043A\u0432\u0430\u043D ${issue2.expected}, \u043F\u043E\u043B\u0443\u0447\u0435\u043D ${parsedType(issue2.input)}`;
          case "invalid_value":
            if (issue2.values.length === 1)
              return `\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u0435\u043D \u0432\u0445\u043E\u0434: \u043E\u0447\u0430\u043A\u0432\u0430\u043D ${stringifyPrimitive(issue2.values[0])}`;
            return `\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u043D\u0430 \u043E\u043F\u0446\u0438\u044F: \u043E\u0447\u0430\u043A\u0432\u0430\u043D\u043E \u0435\u0434\u043D\u043E \u043E\u0442 ${joinValues(issue2.values, "|")}`;
          case "too_big": {
            const adj = issue2.inclusive ? "<=" : "<";
            const sizing = getSizing(issue2.origin);
            if (sizing)
              return `\u0422\u0432\u044A\u0440\u0434\u0435 \u0433\u043E\u043B\u044F\u043C\u043E: \u043E\u0447\u0430\u043A\u0432\u0430 \u0441\u0435 ${issue2.origin ?? "\u0441\u0442\u043E\u0439\u043D\u043E\u0441\u0442"} \u0434\u0430 \u0441\u044A\u0434\u044A\u0440\u0436\u0430 ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "\u0435\u043B\u0435\u043C\u0435\u043D\u0442\u0430"}`;
            return `\u0422\u0432\u044A\u0440\u0434\u0435 \u0433\u043E\u043B\u044F\u043C\u043E: \u043E\u0447\u0430\u043A\u0432\u0430 \u0441\u0435 ${issue2.origin ?? "\u0441\u0442\u043E\u0439\u043D\u043E\u0441\u0442"} \u0434\u0430 \u0431\u044A\u0434\u0435 ${adj}${issue2.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue2.inclusive ? ">=" : ">";
            const sizing = getSizing(issue2.origin);
            if (sizing) {
              return `\u0422\u0432\u044A\u0440\u0434\u0435 \u043C\u0430\u043B\u043A\u043E: \u043E\u0447\u0430\u043A\u0432\u0430 \u0441\u0435 ${issue2.origin} \u0434\u0430 \u0441\u044A\u0434\u044A\u0440\u0436\u0430 ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
            }
            return `\u0422\u0432\u044A\u0440\u0434\u0435 \u043C\u0430\u043B\u043A\u043E: \u043E\u0447\u0430\u043A\u0432\u0430 \u0441\u0435 ${issue2.origin} \u0434\u0430 \u0431\u044A\u0434\u0435 ${adj}${issue2.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue2;
            if (_issue.format === "starts_with") {
              return `\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u0435\u043D \u043D\u0438\u0437: \u0442\u0440\u044F\u0431\u0432\u0430 \u0434\u0430 \u0437\u0430\u043F\u043E\u0447\u0432\u0430 \u0441 "${_issue.prefix}"`;
            }
            if (_issue.format === "ends_with")
              return `\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u0435\u043D \u043D\u0438\u0437: \u0442\u0440\u044F\u0431\u0432\u0430 \u0434\u0430 \u0437\u0430\u0432\u044A\u0440\u0448\u0432\u0430 \u0441 "${_issue.suffix}"`;
            if (_issue.format === "includes")
              return `\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u0435\u043D \u043D\u0438\u0437: \u0442\u0440\u044F\u0431\u0432\u0430 \u0434\u0430 \u0432\u043A\u043B\u044E\u0447\u0432\u0430 "${_issue.includes}"`;
            if (_issue.format === "regex")
              return `\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u0435\u043D \u043D\u0438\u0437: \u0442\u0440\u044F\u0431\u0432\u0430 \u0434\u0430 \u0441\u044A\u0432\u043F\u0430\u0434\u0430 \u0441 ${_issue.pattern}`;
            let invalid_adj = "\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u0435\u043D";
            if (_issue.format === "emoji")
              invalid_adj = "\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u043D\u043E";
            if (_issue.format === "datetime")
              invalid_adj = "\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u043D\u043E";
            if (_issue.format === "date")
              invalid_adj = "\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u043D\u0430";
            if (_issue.format === "time")
              invalid_adj = "\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u043D\u043E";
            if (_issue.format === "duration")
              invalid_adj = "\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u043D\u0430";
            return `${invalid_adj} ${Nouns[_issue.format] ?? issue2.format}`;
          }
          case "not_multiple_of":
            return `\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u043D\u043E \u0447\u0438\u0441\u043B\u043E: \u0442\u0440\u044F\u0431\u0432\u0430 \u0434\u0430 \u0431\u044A\u0434\u0435 \u043A\u0440\u0430\u0442\u043D\u043E \u043D\u0430 ${issue2.divisor}`;
          case "unrecognized_keys":
            return `\u041D\u0435\u0440\u0430\u0437\u043F\u043E\u0437\u043D\u0430\u0442${issue2.keys.length > 1 ? "\u0438" : ""} \u043A\u043B\u044E\u0447${issue2.keys.length > 1 ? "\u043E\u0432\u0435" : ""}: ${joinValues(issue2.keys, ", ")}`;
          case "invalid_key":
            return `\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u0435\u043D \u043A\u043B\u044E\u0447 \u0432 ${issue2.origin}`;
          case "invalid_union":
            return "\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u0435\u043D \u0432\u0445\u043E\u0434";
          case "invalid_element":
            return `\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u043D\u0430 \u0441\u0442\u043E\u0439\u043D\u043E\u0441\u0442 \u0432 ${issue2.origin}`;
          default:
            return `\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u0435\u043D \u0432\u0445\u043E\u0434`;
        }
      };
    };
  }
});

// node_modules/zod/v4/locales/ca.js
function ca_default() {
  return {
    localeError: error5()
  };
}
var error5;
var init_ca = __esm({
  "node_modules/zod/v4/locales/ca.js"() {
    init_util();
    error5 = () => {
      const Sizable = {
        string: { unit: "car\xE0cters", verb: "contenir" },
        file: { unit: "bytes", verb: "contenir" },
        array: { unit: "elements", verb: "contenir" },
        set: { unit: "elements", verb: "contenir" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const parsedType8 = (data) => {
        const t = typeof data;
        switch (t) {
          case "number": {
            return Number.isNaN(data) ? "NaN" : "number";
          }
          case "object": {
            if (Array.isArray(data)) {
              return "array";
            }
            if (data === null) {
              return "null";
            }
            if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
              return data.constructor.name;
            }
          }
        }
        return t;
      };
      const Nouns = {
        regex: "entrada",
        email: "adre\xE7a electr\xF2nica",
        url: "URL",
        emoji: "emoji",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "data i hora ISO",
        date: "data ISO",
        time: "hora ISO",
        duration: "durada ISO",
        ipv4: "adre\xE7a IPv4",
        ipv6: "adre\xE7a IPv6",
        cidrv4: "rang IPv4",
        cidrv6: "rang IPv6",
        base64: "cadena codificada en base64",
        base64url: "cadena codificada en base64url",
        json_string: "cadena JSON",
        e164: "n\xFAmero E.164",
        jwt: "JWT",
        template_literal: "entrada"
      };
      return (issue2) => {
        switch (issue2.code) {
          case "invalid_type":
            return `Tipus inv\xE0lid: s'esperava ${issue2.expected}, s'ha rebut ${parsedType8(issue2.input)}`;
          // return `Tipus invlid: s'esperava ${issue.expected}, s'ha rebut ${util.getParsedType(issue.input)}`;
          case "invalid_value":
            if (issue2.values.length === 1)
              return `Valor inv\xE0lid: s'esperava ${stringifyPrimitive(issue2.values[0])}`;
            return `Opci\xF3 inv\xE0lida: s'esperava una de ${joinValues(issue2.values, " o ")}`;
          case "too_big": {
            const adj = issue2.inclusive ? "com a m\xE0xim" : "menys de";
            const sizing = getSizing(issue2.origin);
            if (sizing)
              return `Massa gran: s'esperava que ${issue2.origin ?? "el valor"} contingu\xE9s ${adj} ${issue2.maximum.toString()} ${sizing.unit ?? "elements"}`;
            return `Massa gran: s'esperava que ${issue2.origin ?? "el valor"} fos ${adj} ${issue2.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue2.inclusive ? "com a m\xEDnim" : "m\xE9s de";
            const sizing = getSizing(issue2.origin);
            if (sizing) {
              return `Massa petit: s'esperava que ${issue2.origin} contingu\xE9s ${adj} ${issue2.minimum.toString()} ${sizing.unit}`;
            }
            return `Massa petit: s'esperava que ${issue2.origin} fos ${adj} ${issue2.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue2;
            if (_issue.format === "starts_with") {
              return `Format inv\xE0lid: ha de comen\xE7ar amb "${_issue.prefix}"`;
            }
            if (_issue.format === "ends_with")
              return `Format inv\xE0lid: ha d'acabar amb "${_issue.suffix}"`;
            if (_issue.format === "includes")
              return `Format inv\xE0lid: ha d'incloure "${_issue.includes}"`;
            if (_issue.format === "regex")
              return `Format inv\xE0lid: ha de coincidir amb el patr\xF3 ${_issue.pattern}`;
            return `Format inv\xE0lid per a ${Nouns[_issue.format] ?? issue2.format}`;
          }
          case "not_multiple_of":
            return `N\xFAmero inv\xE0lid: ha de ser m\xFAltiple de ${issue2.divisor}`;
          case "unrecognized_keys":
            return `Clau${issue2.keys.length > 1 ? "s" : ""} no reconeguda${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
          case "invalid_key":
            return `Clau inv\xE0lida a ${issue2.origin}`;
          case "invalid_union":
            return "Entrada inv\xE0lida";
          // Could also be "Tipus d'uni invlid" but "Entrada invlida" is more general
          case "invalid_element":
            return `Element inv\xE0lid a ${issue2.origin}`;
          default:
            return `Entrada inv\xE0lida`;
        }
      };
    };
  }
});

// node_modules/zod/v4/locales/cs.js
function cs_default() {
  return {
    localeError: error6()
  };
}
var error6;
var init_cs = __esm({
  "node_modules/zod/v4/locales/cs.js"() {
    init_util();
    error6 = () => {
      const Sizable = {
        string: { unit: "znak\u016F", verb: "m\xEDt" },
        file: { unit: "bajt\u016F", verb: "m\xEDt" },
        array: { unit: "prvk\u016F", verb: "m\xEDt" },
        set: { unit: "prvk\u016F", verb: "m\xEDt" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const parsedType8 = (data) => {
        const t = typeof data;
        switch (t) {
          case "number": {
            return Number.isNaN(data) ? "NaN" : "\u010D\xEDslo";
          }
          case "string": {
            return "\u0159et\u011Bzec";
          }
          case "boolean": {
            return "boolean";
          }
          case "bigint": {
            return "bigint";
          }
          case "function": {
            return "funkce";
          }
          case "symbol": {
            return "symbol";
          }
          case "undefined": {
            return "undefined";
          }
          case "object": {
            if (Array.isArray(data)) {
              return "pole";
            }
            if (data === null) {
              return "null";
            }
            if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
              return data.constructor.name;
            }
          }
        }
        return t;
      };
      const Nouns = {
        regex: "regul\xE1rn\xED v\xFDraz",
        email: "e-mailov\xE1 adresa",
        url: "URL",
        emoji: "emoji",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "datum a \u010Das ve form\xE1tu ISO",
        date: "datum ve form\xE1tu ISO",
        time: "\u010Das ve form\xE1tu ISO",
        duration: "doba trv\xE1n\xED ISO",
        ipv4: "IPv4 adresa",
        ipv6: "IPv6 adresa",
        cidrv4: "rozsah IPv4",
        cidrv6: "rozsah IPv6",
        base64: "\u0159et\u011Bzec zak\xF3dovan\xFD ve form\xE1tu base64",
        base64url: "\u0159et\u011Bzec zak\xF3dovan\xFD ve form\xE1tu base64url",
        json_string: "\u0159et\u011Bzec ve form\xE1tu JSON",
        e164: "\u010D\xEDslo E.164",
        jwt: "JWT",
        template_literal: "vstup"
      };
      return (issue2) => {
        switch (issue2.code) {
          case "invalid_type":
            return `Neplatn\xFD vstup: o\u010Dek\xE1v\xE1no ${issue2.expected}, obdr\u017Eeno ${parsedType8(issue2.input)}`;
          case "invalid_value":
            if (issue2.values.length === 1)
              return `Neplatn\xFD vstup: o\u010Dek\xE1v\xE1no ${stringifyPrimitive(issue2.values[0])}`;
            return `Neplatn\xE1 mo\u017Enost: o\u010Dek\xE1v\xE1na jedna z hodnot ${joinValues(issue2.values, "|")}`;
          case "too_big": {
            const adj = issue2.inclusive ? "<=" : "<";
            const sizing = getSizing(issue2.origin);
            if (sizing) {
              return `Hodnota je p\u0159\xEDli\u0161 velk\xE1: ${issue2.origin ?? "hodnota"} mus\xED m\xEDt ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "prvk\u016F"}`;
            }
            return `Hodnota je p\u0159\xEDli\u0161 velk\xE1: ${issue2.origin ?? "hodnota"} mus\xED b\xFDt ${adj}${issue2.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue2.inclusive ? ">=" : ">";
            const sizing = getSizing(issue2.origin);
            if (sizing) {
              return `Hodnota je p\u0159\xEDli\u0161 mal\xE1: ${issue2.origin ?? "hodnota"} mus\xED m\xEDt ${adj}${issue2.minimum.toString()} ${sizing.unit ?? "prvk\u016F"}`;
            }
            return `Hodnota je p\u0159\xEDli\u0161 mal\xE1: ${issue2.origin ?? "hodnota"} mus\xED b\xFDt ${adj}${issue2.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue2;
            if (_issue.format === "starts_with")
              return `Neplatn\xFD \u0159et\u011Bzec: mus\xED za\u010D\xEDnat na "${_issue.prefix}"`;
            if (_issue.format === "ends_with")
              return `Neplatn\xFD \u0159et\u011Bzec: mus\xED kon\u010Dit na "${_issue.suffix}"`;
            if (_issue.format === "includes")
              return `Neplatn\xFD \u0159et\u011Bzec: mus\xED obsahovat "${_issue.includes}"`;
            if (_issue.format === "regex")
              return `Neplatn\xFD \u0159et\u011Bzec: mus\xED odpov\xEDdat vzoru ${_issue.pattern}`;
            return `Neplatn\xFD form\xE1t ${Nouns[_issue.format] ?? issue2.format}`;
          }
          case "not_multiple_of":
            return `Neplatn\xE9 \u010D\xEDslo: mus\xED b\xFDt n\xE1sobkem ${issue2.divisor}`;
          case "unrecognized_keys":
            return `Nezn\xE1m\xE9 kl\xED\u010De: ${joinValues(issue2.keys, ", ")}`;
          case "invalid_key":
            return `Neplatn\xFD kl\xED\u010D v ${issue2.origin}`;
          case "invalid_union":
            return "Neplatn\xFD vstup";
          case "invalid_element":
            return `Neplatn\xE1 hodnota v ${issue2.origin}`;
          default:
            return `Neplatn\xFD vstup`;
        }
      };
    };
  }
});

// node_modules/zod/v4/locales/da.js
function da_default() {
  return {
    localeError: error7()
  };
}
var error7;
var init_da = __esm({
  "node_modules/zod/v4/locales/da.js"() {
    init_util();
    error7 = () => {
      const Sizable = {
        string: { unit: "tegn", verb: "havde" },
        file: { unit: "bytes", verb: "havde" },
        array: { unit: "elementer", verb: "indeholdt" },
        set: { unit: "elementer", verb: "indeholdt" }
      };
      const TypeNames = {
        string: "streng",
        number: "tal",
        boolean: "boolean",
        array: "liste",
        object: "objekt",
        set: "s\xE6t",
        file: "fil"
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      function getTypeName(type2) {
        return TypeNames[type2] ?? type2;
      }
      const parsedType8 = (data) => {
        const t = typeof data;
        switch (t) {
          case "number": {
            return Number.isNaN(data) ? "NaN" : "tal";
          }
          case "object": {
            if (Array.isArray(data)) {
              return "liste";
            }
            if (data === null) {
              return "null";
            }
            if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
              return data.constructor.name;
            }
            return "objekt";
          }
        }
        return t;
      };
      const Nouns = {
        regex: "input",
        email: "e-mailadresse",
        url: "URL",
        emoji: "emoji",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "ISO dato- og klokkesl\xE6t",
        date: "ISO-dato",
        time: "ISO-klokkesl\xE6t",
        duration: "ISO-varighed",
        ipv4: "IPv4-omr\xE5de",
        ipv6: "IPv6-omr\xE5de",
        cidrv4: "IPv4-spektrum",
        cidrv6: "IPv6-spektrum",
        base64: "base64-kodet streng",
        base64url: "base64url-kodet streng",
        json_string: "JSON-streng",
        e164: "E.164-nummer",
        jwt: "JWT",
        template_literal: "input"
      };
      return (issue2) => {
        switch (issue2.code) {
          case "invalid_type":
            return `Ugyldigt input: forventede ${getTypeName(issue2.expected)}, fik ${getTypeName(parsedType8(issue2.input))}`;
          case "invalid_value":
            if (issue2.values.length === 1)
              return `Ugyldig v\xE6rdi: forventede ${stringifyPrimitive(issue2.values[0])}`;
            return `Ugyldigt valg: forventede en af f\xF8lgende ${joinValues(issue2.values, "|")}`;
          case "too_big": {
            const adj = issue2.inclusive ? "<=" : "<";
            const sizing = getSizing(issue2.origin);
            const origin = getTypeName(issue2.origin);
            if (sizing)
              return `For stor: forventede ${origin ?? "value"} ${sizing.verb} ${adj} ${issue2.maximum.toString()} ${sizing.unit ?? "elementer"}`;
            return `For stor: forventede ${origin ?? "value"} havde ${adj} ${issue2.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue2.inclusive ? ">=" : ">";
            const sizing = getSizing(issue2.origin);
            const origin = getTypeName(issue2.origin);
            if (sizing) {
              return `For lille: forventede ${origin} ${sizing.verb} ${adj} ${issue2.minimum.toString()} ${sizing.unit}`;
            }
            return `For lille: forventede ${origin} havde ${adj} ${issue2.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue2;
            if (_issue.format === "starts_with")
              return `Ugyldig streng: skal starte med "${_issue.prefix}"`;
            if (_issue.format === "ends_with")
              return `Ugyldig streng: skal ende med "${_issue.suffix}"`;
            if (_issue.format === "includes")
              return `Ugyldig streng: skal indeholde "${_issue.includes}"`;
            if (_issue.format === "regex")
              return `Ugyldig streng: skal matche m\xF8nsteret ${_issue.pattern}`;
            return `Ugyldig ${Nouns[_issue.format] ?? issue2.format}`;
          }
          case "not_multiple_of":
            return `Ugyldigt tal: skal v\xE6re deleligt med ${issue2.divisor}`;
          case "unrecognized_keys":
            return `${issue2.keys.length > 1 ? "Ukendte n\xF8gler" : "Ukendt n\xF8gle"}: ${joinValues(issue2.keys, ", ")}`;
          case "invalid_key":
            return `Ugyldig n\xF8gle i ${issue2.origin}`;
          case "invalid_union":
            return "Ugyldigt input: matcher ingen af de tilladte typer";
          case "invalid_element":
            return `Ugyldig v\xE6rdi i ${issue2.origin}`;
          default:
            return `Ugyldigt input`;
        }
      };
    };
  }
});

// node_modules/zod/v4/locales/de.js
function de_default() {
  return {
    localeError: error8()
  };
}
var error8;
var init_de = __esm({
  "node_modules/zod/v4/locales/de.js"() {
    init_util();
    error8 = () => {
      const Sizable = {
        string: { unit: "Zeichen", verb: "zu haben" },
        file: { unit: "Bytes", verb: "zu haben" },
        array: { unit: "Elemente", verb: "zu haben" },
        set: { unit: "Elemente", verb: "zu haben" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const parsedType8 = (data) => {
        const t = typeof data;
        switch (t) {
          case "number": {
            return Number.isNaN(data) ? "NaN" : "Zahl";
          }
          case "object": {
            if (Array.isArray(data)) {
              return "Array";
            }
            if (data === null) {
              return "null";
            }
            if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
              return data.constructor.name;
            }
          }
        }
        return t;
      };
      const Nouns = {
        regex: "Eingabe",
        email: "E-Mail-Adresse",
        url: "URL",
        emoji: "Emoji",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "ISO-Datum und -Uhrzeit",
        date: "ISO-Datum",
        time: "ISO-Uhrzeit",
        duration: "ISO-Dauer",
        ipv4: "IPv4-Adresse",
        ipv6: "IPv6-Adresse",
        cidrv4: "IPv4-Bereich",
        cidrv6: "IPv6-Bereich",
        base64: "Base64-codierter String",
        base64url: "Base64-URL-codierter String",
        json_string: "JSON-String",
        e164: "E.164-Nummer",
        jwt: "JWT",
        template_literal: "Eingabe"
      };
      return (issue2) => {
        switch (issue2.code) {
          case "invalid_type":
            return `Ung\xFCltige Eingabe: erwartet ${issue2.expected}, erhalten ${parsedType8(issue2.input)}`;
          case "invalid_value":
            if (issue2.values.length === 1)
              return `Ung\xFCltige Eingabe: erwartet ${stringifyPrimitive(issue2.values[0])}`;
            return `Ung\xFCltige Option: erwartet eine von ${joinValues(issue2.values, "|")}`;
          case "too_big": {
            const adj = issue2.inclusive ? "<=" : "<";
            const sizing = getSizing(issue2.origin);
            if (sizing)
              return `Zu gro\xDF: erwartet, dass ${issue2.origin ?? "Wert"} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "Elemente"} hat`;
            return `Zu gro\xDF: erwartet, dass ${issue2.origin ?? "Wert"} ${adj}${issue2.maximum.toString()} ist`;
          }
          case "too_small": {
            const adj = issue2.inclusive ? ">=" : ">";
            const sizing = getSizing(issue2.origin);
            if (sizing) {
              return `Zu klein: erwartet, dass ${issue2.origin} ${adj}${issue2.minimum.toString()} ${sizing.unit} hat`;
            }
            return `Zu klein: erwartet, dass ${issue2.origin} ${adj}${issue2.minimum.toString()} ist`;
          }
          case "invalid_format": {
            const _issue = issue2;
            if (_issue.format === "starts_with")
              return `Ung\xFCltiger String: muss mit "${_issue.prefix}" beginnen`;
            if (_issue.format === "ends_with")
              return `Ung\xFCltiger String: muss mit "${_issue.suffix}" enden`;
            if (_issue.format === "includes")
              return `Ung\xFCltiger String: muss "${_issue.includes}" enthalten`;
            if (_issue.format === "regex")
              return `Ung\xFCltiger String: muss dem Muster ${_issue.pattern} entsprechen`;
            return `Ung\xFCltig: ${Nouns[_issue.format] ?? issue2.format}`;
          }
          case "not_multiple_of":
            return `Ung\xFCltige Zahl: muss ein Vielfaches von ${issue2.divisor} sein`;
          case "unrecognized_keys":
            return `${issue2.keys.length > 1 ? "Unbekannte Schl\xFCssel" : "Unbekannter Schl\xFCssel"}: ${joinValues(issue2.keys, ", ")}`;
          case "invalid_key":
            return `Ung\xFCltiger Schl\xFCssel in ${issue2.origin}`;
          case "invalid_union":
            return "Ung\xFCltige Eingabe";
          case "invalid_element":
            return `Ung\xFCltiger Wert in ${issue2.origin}`;
          default:
            return `Ung\xFCltige Eingabe`;
        }
      };
    };
  }
});

// node_modules/zod/v4/locales/en.js
function en_default() {
  return {
    localeError: error9()
  };
}
var parsedType2, error9;
var init_en = __esm({
  "node_modules/zod/v4/locales/en.js"() {
    init_util();
    parsedType2 = (data) => {
      const t = typeof data;
      switch (t) {
        case "number": {
          return Number.isNaN(data) ? "NaN" : "number";
        }
        case "object": {
          if (Array.isArray(data)) {
            return "array";
          }
          if (data === null) {
            return "null";
          }
          if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
            return data.constructor.name;
          }
        }
      }
      return t;
    };
    error9 = () => {
      const Sizable = {
        string: { unit: "characters", verb: "to have" },
        file: { unit: "bytes", verb: "to have" },
        array: { unit: "items", verb: "to have" },
        set: { unit: "items", verb: "to have" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const Nouns = {
        regex: "input",
        email: "email address",
        url: "URL",
        emoji: "emoji",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "ISO datetime",
        date: "ISO date",
        time: "ISO time",
        duration: "ISO duration",
        ipv4: "IPv4 address",
        ipv6: "IPv6 address",
        cidrv4: "IPv4 range",
        cidrv6: "IPv6 range",
        base64: "base64-encoded string",
        base64url: "base64url-encoded string",
        json_string: "JSON string",
        e164: "E.164 number",
        jwt: "JWT",
        template_literal: "input"
      };
      return (issue2) => {
        switch (issue2.code) {
          case "invalid_type":
            return `Invalid input: expected ${issue2.expected}, received ${parsedType2(issue2.input)}`;
          case "invalid_value":
            if (issue2.values.length === 1)
              return `Invalid input: expected ${stringifyPrimitive(issue2.values[0])}`;
            return `Invalid option: expected one of ${joinValues(issue2.values, "|")}`;
          case "too_big": {
            const adj = issue2.inclusive ? "<=" : "<";
            const sizing = getSizing(issue2.origin);
            if (sizing)
              return `Too big: expected ${issue2.origin ?? "value"} to have ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elements"}`;
            return `Too big: expected ${issue2.origin ?? "value"} to be ${adj}${issue2.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue2.inclusive ? ">=" : ">";
            const sizing = getSizing(issue2.origin);
            if (sizing) {
              return `Too small: expected ${issue2.origin} to have ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
            }
            return `Too small: expected ${issue2.origin} to be ${adj}${issue2.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue2;
            if (_issue.format === "starts_with") {
              return `Invalid string: must start with "${_issue.prefix}"`;
            }
            if (_issue.format === "ends_with")
              return `Invalid string: must end with "${_issue.suffix}"`;
            if (_issue.format === "includes")
              return `Invalid string: must include "${_issue.includes}"`;
            if (_issue.format === "regex")
              return `Invalid string: must match pattern ${_issue.pattern}`;
            return `Invalid ${Nouns[_issue.format] ?? issue2.format}`;
          }
          case "not_multiple_of":
            return `Invalid number: must be a multiple of ${issue2.divisor}`;
          case "unrecognized_keys":
            return `Unrecognized key${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
          case "invalid_key":
            return `Invalid key in ${issue2.origin}`;
          case "invalid_union":
            return "Invalid input";
          case "invalid_element":
            return `Invalid value in ${issue2.origin}`;
          default:
            return `Invalid input`;
        }
      };
    };
  }
});

// node_modules/zod/v4/locales/eo.js
function eo_default() {
  return {
    localeError: error10()
  };
}
var parsedType3, error10;
var init_eo = __esm({
  "node_modules/zod/v4/locales/eo.js"() {
    init_util();
    parsedType3 = (data) => {
      const t = typeof data;
      switch (t) {
        case "number": {
          return Number.isNaN(data) ? "NaN" : "nombro";
        }
        case "object": {
          if (Array.isArray(data)) {
            return "tabelo";
          }
          if (data === null) {
            return "senvalora";
          }
          if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
            return data.constructor.name;
          }
        }
      }
      return t;
    };
    error10 = () => {
      const Sizable = {
        string: { unit: "karaktrojn", verb: "havi" },
        file: { unit: "bajtojn", verb: "havi" },
        array: { unit: "elementojn", verb: "havi" },
        set: { unit: "elementojn", verb: "havi" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const Nouns = {
        regex: "enigo",
        email: "retadreso",
        url: "URL",
        emoji: "emo\u011Dio",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "ISO-datotempo",
        date: "ISO-dato",
        time: "ISO-tempo",
        duration: "ISO-da\u016Dro",
        ipv4: "IPv4-adreso",
        ipv6: "IPv6-adreso",
        cidrv4: "IPv4-rango",
        cidrv6: "IPv6-rango",
        base64: "64-ume kodita karaktraro",
        base64url: "URL-64-ume kodita karaktraro",
        json_string: "JSON-karaktraro",
        e164: "E.164-nombro",
        jwt: "JWT",
        template_literal: "enigo"
      };
      return (issue2) => {
        switch (issue2.code) {
          case "invalid_type":
            return `Nevalida enigo: atendi\u011Dis ${issue2.expected}, ricevi\u011Dis ${parsedType3(issue2.input)}`;
          case "invalid_value":
            if (issue2.values.length === 1)
              return `Nevalida enigo: atendi\u011Dis ${stringifyPrimitive(issue2.values[0])}`;
            return `Nevalida opcio: atendi\u011Dis unu el ${joinValues(issue2.values, "|")}`;
          case "too_big": {
            const adj = issue2.inclusive ? "<=" : "<";
            const sizing = getSizing(issue2.origin);
            if (sizing)
              return `Tro granda: atendi\u011Dis ke ${issue2.origin ?? "valoro"} havu ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elementojn"}`;
            return `Tro granda: atendi\u011Dis ke ${issue2.origin ?? "valoro"} havu ${adj}${issue2.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue2.inclusive ? ">=" : ">";
            const sizing = getSizing(issue2.origin);
            if (sizing) {
              return `Tro malgranda: atendi\u011Dis ke ${issue2.origin} havu ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
            }
            return `Tro malgranda: atendi\u011Dis ke ${issue2.origin} estu ${adj}${issue2.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue2;
            if (_issue.format === "starts_with")
              return `Nevalida karaktraro: devas komenci\u011Di per "${_issue.prefix}"`;
            if (_issue.format === "ends_with")
              return `Nevalida karaktraro: devas fini\u011Di per "${_issue.suffix}"`;
            if (_issue.format === "includes")
              return `Nevalida karaktraro: devas inkluzivi "${_issue.includes}"`;
            if (_issue.format === "regex")
              return `Nevalida karaktraro: devas kongrui kun la modelo ${_issue.pattern}`;
            return `Nevalida ${Nouns[_issue.format] ?? issue2.format}`;
          }
          case "not_multiple_of":
            return `Nevalida nombro: devas esti oblo de ${issue2.divisor}`;
          case "unrecognized_keys":
            return `Nekonata${issue2.keys.length > 1 ? "j" : ""} \u015Dlosilo${issue2.keys.length > 1 ? "j" : ""}: ${joinValues(issue2.keys, ", ")}`;
          case "invalid_key":
            return `Nevalida \u015Dlosilo en ${issue2.origin}`;
          case "invalid_union":
            return "Nevalida enigo";
          case "invalid_element":
            return `Nevalida valoro en ${issue2.origin}`;
          default:
            return `Nevalida enigo`;
        }
      };
    };
  }
});

// node_modules/zod/v4/locales/es.js
function es_default() {
  return {
    localeError: error11()
  };
}
var error11;
var init_es = __esm({
  "node_modules/zod/v4/locales/es.js"() {
    init_util();
    error11 = () => {
      const Sizable = {
        string: { unit: "caracteres", verb: "tener" },
        file: { unit: "bytes", verb: "tener" },
        array: { unit: "elementos", verb: "tener" },
        set: { unit: "elementos", verb: "tener" }
      };
      const TypeNames = {
        string: "texto",
        number: "n\xFAmero",
        boolean: "booleano",
        array: "arreglo",
        object: "objeto",
        set: "conjunto",
        file: "archivo",
        date: "fecha",
        bigint: "n\xFAmero grande",
        symbol: "s\xEDmbolo",
        undefined: "indefinido",
        null: "nulo",
        function: "funci\xF3n",
        map: "mapa",
        record: "registro",
        tuple: "tupla",
        enum: "enumeraci\xF3n",
        union: "uni\xF3n",
        literal: "literal",
        promise: "promesa",
        void: "vac\xEDo",
        never: "nunca",
        unknown: "desconocido",
        any: "cualquiera"
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      function getTypeName(type2) {
        return TypeNames[type2] ?? type2;
      }
      const parsedType8 = (data) => {
        const t = typeof data;
        switch (t) {
          case "number": {
            return Number.isNaN(data) ? "NaN" : "number";
          }
          case "object": {
            if (Array.isArray(data)) {
              return "array";
            }
            if (data === null) {
              return "null";
            }
            if (Object.getPrototypeOf(data) !== Object.prototype) {
              return data.constructor.name;
            }
            return "object";
          }
        }
        return t;
      };
      const Nouns = {
        regex: "entrada",
        email: "direcci\xF3n de correo electr\xF3nico",
        url: "URL",
        emoji: "emoji",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "fecha y hora ISO",
        date: "fecha ISO",
        time: "hora ISO",
        duration: "duraci\xF3n ISO",
        ipv4: "direcci\xF3n IPv4",
        ipv6: "direcci\xF3n IPv6",
        cidrv4: "rango IPv4",
        cidrv6: "rango IPv6",
        base64: "cadena codificada en base64",
        base64url: "URL codificada en base64",
        json_string: "cadena JSON",
        e164: "n\xFAmero E.164",
        jwt: "JWT",
        template_literal: "entrada"
      };
      return (issue2) => {
        switch (issue2.code) {
          case "invalid_type":
            return `Entrada inv\xE1lida: se esperaba ${getTypeName(issue2.expected)}, recibido ${getTypeName(parsedType8(issue2.input))}`;
          // return `Entrada invlida: se esperaba ${issue.expected}, recibido ${util.getParsedType(issue.input)}`;
          case "invalid_value":
            if (issue2.values.length === 1)
              return `Entrada inv\xE1lida: se esperaba ${stringifyPrimitive(issue2.values[0])}`;
            return `Opci\xF3n inv\xE1lida: se esperaba una de ${joinValues(issue2.values, "|")}`;
          case "too_big": {
            const adj = issue2.inclusive ? "<=" : "<";
            const sizing = getSizing(issue2.origin);
            const origin = getTypeName(issue2.origin);
            if (sizing)
              return `Demasiado grande: se esperaba que ${origin ?? "valor"} tuviera ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elementos"}`;
            return `Demasiado grande: se esperaba que ${origin ?? "valor"} fuera ${adj}${issue2.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue2.inclusive ? ">=" : ">";
            const sizing = getSizing(issue2.origin);
            const origin = getTypeName(issue2.origin);
            if (sizing) {
              return `Demasiado peque\xF1o: se esperaba que ${origin} tuviera ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
            }
            return `Demasiado peque\xF1o: se esperaba que ${origin} fuera ${adj}${issue2.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue2;
            if (_issue.format === "starts_with")
              return `Cadena inv\xE1lida: debe comenzar con "${_issue.prefix}"`;
            if (_issue.format === "ends_with")
              return `Cadena inv\xE1lida: debe terminar en "${_issue.suffix}"`;
            if (_issue.format === "includes")
              return `Cadena inv\xE1lida: debe incluir "${_issue.includes}"`;
            if (_issue.format === "regex")
              return `Cadena inv\xE1lida: debe coincidir con el patr\xF3n ${_issue.pattern}`;
            return `Inv\xE1lido ${Nouns[_issue.format] ?? issue2.format}`;
          }
          case "not_multiple_of":
            return `N\xFAmero inv\xE1lido: debe ser m\xFAltiplo de ${issue2.divisor}`;
          case "unrecognized_keys":
            return `Llave${issue2.keys.length > 1 ? "s" : ""} desconocida${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
          case "invalid_key":
            return `Llave inv\xE1lida en ${getTypeName(issue2.origin)}`;
          case "invalid_union":
            return "Entrada inv\xE1lida";
          case "invalid_element":
            return `Valor inv\xE1lido en ${getTypeName(issue2.origin)}`;
          default:
            return `Entrada inv\xE1lida`;
        }
      };
    };
  }
});

// node_modules/zod/v4/locales/fa.js
function fa_default() {
  return {
    localeError: error12()
  };
}
var error12;
var init_fa = __esm({
  "node_modules/zod/v4/locales/fa.js"() {
    init_util();
    error12 = () => {
      const Sizable = {
        string: { unit: "\u06A9\u0627\u0631\u0627\u06A9\u062A\u0631", verb: "\u062F\u0627\u0634\u062A\u0647 \u0628\u0627\u0634\u062F" },
        file: { unit: "\u0628\u0627\u06CC\u062A", verb: "\u062F\u0627\u0634\u062A\u0647 \u0628\u0627\u0634\u062F" },
        array: { unit: "\u0622\u06CC\u062A\u0645", verb: "\u062F\u0627\u0634\u062A\u0647 \u0628\u0627\u0634\u062F" },
        set: { unit: "\u0622\u06CC\u062A\u0645", verb: "\u062F\u0627\u0634\u062A\u0647 \u0628\u0627\u0634\u062F" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const parsedType8 = (data) => {
        const t = typeof data;
        switch (t) {
          case "number": {
            return Number.isNaN(data) ? "NaN" : "\u0639\u062F\u062F";
          }
          case "object": {
            if (Array.isArray(data)) {
              return "\u0622\u0631\u0627\u06CC\u0647";
            }
            if (data === null) {
              return "null";
            }
            if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
              return data.constructor.name;
            }
          }
        }
        return t;
      };
      const Nouns = {
        regex: "\u0648\u0631\u0648\u062F\u06CC",
        email: "\u0622\u062F\u0631\u0633 \u0627\u06CC\u0645\u06CC\u0644",
        url: "URL",
        emoji: "\u0627\u06CC\u0645\u0648\u062C\u06CC",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "\u062A\u0627\u0631\u06CC\u062E \u0648 \u0632\u0645\u0627\u0646 \u0627\u06CC\u0632\u0648",
        date: "\u062A\u0627\u0631\u06CC\u062E \u0627\u06CC\u0632\u0648",
        time: "\u0632\u0645\u0627\u0646 \u0627\u06CC\u0632\u0648",
        duration: "\u0645\u062F\u062A \u0632\u0645\u0627\u0646 \u0627\u06CC\u0632\u0648",
        ipv4: "IPv4 \u0622\u062F\u0631\u0633",
        ipv6: "IPv6 \u0622\u062F\u0631\u0633",
        cidrv4: "IPv4 \u062F\u0627\u0645\u0646\u0647",
        cidrv6: "IPv6 \u062F\u0627\u0645\u0646\u0647",
        base64: "base64-encoded \u0631\u0634\u062A\u0647",
        base64url: "base64url-encoded \u0631\u0634\u062A\u0647",
        json_string: "JSON \u0631\u0634\u062A\u0647",
        e164: "E.164 \u0639\u062F\u062F",
        jwt: "JWT",
        template_literal: "\u0648\u0631\u0648\u062F\u06CC"
      };
      return (issue2) => {
        switch (issue2.code) {
          case "invalid_type":
            return `\u0648\u0631\u0648\u062F\u06CC \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0645\u06CC\u200C\u0628\u0627\u06CC\u0633\u062A ${issue2.expected} \u0645\u06CC\u200C\u0628\u0648\u062F\u060C ${parsedType8(issue2.input)} \u062F\u0631\u06CC\u0627\u0641\u062A \u0634\u062F`;
          case "invalid_value":
            if (issue2.values.length === 1) {
              return `\u0648\u0631\u0648\u062F\u06CC \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0645\u06CC\u200C\u0628\u0627\u06CC\u0633\u062A ${stringifyPrimitive(issue2.values[0])} \u0645\u06CC\u200C\u0628\u0648\u062F`;
            }
            return `\u06AF\u0632\u06CC\u0646\u0647 \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0645\u06CC\u200C\u0628\u0627\u06CC\u0633\u062A \u06CC\u06A9\u06CC \u0627\u0632 ${joinValues(issue2.values, "|")} \u0645\u06CC\u200C\u0628\u0648\u062F`;
          case "too_big": {
            const adj = issue2.inclusive ? "<=" : "<";
            const sizing = getSizing(issue2.origin);
            if (sizing) {
              return `\u062E\u06CC\u0644\u06CC \u0628\u0632\u0631\u06AF: ${issue2.origin ?? "\u0645\u0642\u062F\u0627\u0631"} \u0628\u0627\u06CC\u062F ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "\u0639\u0646\u0635\u0631"} \u0628\u0627\u0634\u062F`;
            }
            return `\u062E\u06CC\u0644\u06CC \u0628\u0632\u0631\u06AF: ${issue2.origin ?? "\u0645\u0642\u062F\u0627\u0631"} \u0628\u0627\u06CC\u062F ${adj}${issue2.maximum.toString()} \u0628\u0627\u0634\u062F`;
          }
          case "too_small": {
            const adj = issue2.inclusive ? ">=" : ">";
            const sizing = getSizing(issue2.origin);
            if (sizing) {
              return `\u062E\u06CC\u0644\u06CC \u06A9\u0648\u0686\u06A9: ${issue2.origin} \u0628\u0627\u06CC\u062F ${adj}${issue2.minimum.toString()} ${sizing.unit} \u0628\u0627\u0634\u062F`;
            }
            return `\u062E\u06CC\u0644\u06CC \u06A9\u0648\u0686\u06A9: ${issue2.origin} \u0628\u0627\u06CC\u062F ${adj}${issue2.minimum.toString()} \u0628\u0627\u0634\u062F`;
          }
          case "invalid_format": {
            const _issue = issue2;
            if (_issue.format === "starts_with") {
              return `\u0631\u0634\u062A\u0647 \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0628\u0627\u06CC\u062F \u0628\u0627 "${_issue.prefix}" \u0634\u0631\u0648\u0639 \u0634\u0648\u062F`;
            }
            if (_issue.format === "ends_with") {
              return `\u0631\u0634\u062A\u0647 \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0628\u0627\u06CC\u062F \u0628\u0627 "${_issue.suffix}" \u062A\u0645\u0627\u0645 \u0634\u0648\u062F`;
            }
            if (_issue.format === "includes") {
              return `\u0631\u0634\u062A\u0647 \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0628\u0627\u06CC\u062F \u0634\u0627\u0645\u0644 "${_issue.includes}" \u0628\u0627\u0634\u062F`;
            }
            if (_issue.format === "regex") {
              return `\u0631\u0634\u062A\u0647 \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0628\u0627\u06CC\u062F \u0628\u0627 \u0627\u0644\u06AF\u0648\u06CC ${_issue.pattern} \u0645\u0637\u0627\u0628\u0642\u062A \u062F\u0627\u0634\u062A\u0647 \u0628\u0627\u0634\u062F`;
            }
            return `${Nouns[_issue.format] ?? issue2.format} \u0646\u0627\u0645\u0639\u062A\u0628\u0631`;
          }
          case "not_multiple_of":
            return `\u0639\u062F\u062F \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0628\u0627\u06CC\u062F \u0645\u0636\u0631\u0628 ${issue2.divisor} \u0628\u0627\u0634\u062F`;
          case "unrecognized_keys":
            return `\u06A9\u0644\u06CC\u062F${issue2.keys.length > 1 ? "\u0647\u0627\u06CC" : ""} \u0646\u0627\u0634\u0646\u0627\u0633: ${joinValues(issue2.keys, ", ")}`;
          case "invalid_key":
            return `\u06A9\u0644\u06CC\u062F \u0646\u0627\u0634\u0646\u0627\u0633 \u062F\u0631 ${issue2.origin}`;
          case "invalid_union":
            return `\u0648\u0631\u0648\u062F\u06CC \u0646\u0627\u0645\u0639\u062A\u0628\u0631`;
          case "invalid_element":
            return `\u0645\u0642\u062F\u0627\u0631 \u0646\u0627\u0645\u0639\u062A\u0628\u0631 \u062F\u0631 ${issue2.origin}`;
          default:
            return `\u0648\u0631\u0648\u062F\u06CC \u0646\u0627\u0645\u0639\u062A\u0628\u0631`;
        }
      };
    };
  }
});

// node_modules/zod/v4/locales/fi.js
function fi_default() {
  return {
    localeError: error13()
  };
}
var error13;
var init_fi = __esm({
  "node_modules/zod/v4/locales/fi.js"() {
    init_util();
    error13 = () => {
      const Sizable = {
        string: { unit: "merkki\xE4", subject: "merkkijonon" },
        file: { unit: "tavua", subject: "tiedoston" },
        array: { unit: "alkiota", subject: "listan" },
        set: { unit: "alkiota", subject: "joukon" },
        number: { unit: "", subject: "luvun" },
        bigint: { unit: "", subject: "suuren kokonaisluvun" },
        int: { unit: "", subject: "kokonaisluvun" },
        date: { unit: "", subject: "p\xE4iv\xE4m\xE4\xE4r\xE4n" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const parsedType8 = (data) => {
        const t = typeof data;
        switch (t) {
          case "number": {
            return Number.isNaN(data) ? "NaN" : "number";
          }
          case "object": {
            if (Array.isArray(data)) {
              return "array";
            }
            if (data === null) {
              return "null";
            }
            if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
              return data.constructor.name;
            }
          }
        }
        return t;
      };
      const Nouns = {
        regex: "s\xE4\xE4nn\xF6llinen lauseke",
        email: "s\xE4hk\xF6postiosoite",
        url: "URL-osoite",
        emoji: "emoji",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "ISO-aikaleima",
        date: "ISO-p\xE4iv\xE4m\xE4\xE4r\xE4",
        time: "ISO-aika",
        duration: "ISO-kesto",
        ipv4: "IPv4-osoite",
        ipv6: "IPv6-osoite",
        cidrv4: "IPv4-alue",
        cidrv6: "IPv6-alue",
        base64: "base64-koodattu merkkijono",
        base64url: "base64url-koodattu merkkijono",
        json_string: "JSON-merkkijono",
        e164: "E.164-luku",
        jwt: "JWT",
        template_literal: "templaattimerkkijono"
      };
      return (issue2) => {
        switch (issue2.code) {
          case "invalid_type":
            return `Virheellinen tyyppi: odotettiin ${issue2.expected}, oli ${parsedType8(issue2.input)}`;
          case "invalid_value":
            if (issue2.values.length === 1)
              return `Virheellinen sy\xF6te: t\xE4ytyy olla ${stringifyPrimitive(issue2.values[0])}`;
            return `Virheellinen valinta: t\xE4ytyy olla yksi seuraavista: ${joinValues(issue2.values, "|")}`;
          case "too_big": {
            const adj = issue2.inclusive ? "<=" : "<";
            const sizing = getSizing(issue2.origin);
            if (sizing) {
              return `Liian suuri: ${sizing.subject} t\xE4ytyy olla ${adj}${issue2.maximum.toString()} ${sizing.unit}`.trim();
            }
            return `Liian suuri: arvon t\xE4ytyy olla ${adj}${issue2.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue2.inclusive ? ">=" : ">";
            const sizing = getSizing(issue2.origin);
            if (sizing) {
              return `Liian pieni: ${sizing.subject} t\xE4ytyy olla ${adj}${issue2.minimum.toString()} ${sizing.unit}`.trim();
            }
            return `Liian pieni: arvon t\xE4ytyy olla ${adj}${issue2.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue2;
            if (_issue.format === "starts_with")
              return `Virheellinen sy\xF6te: t\xE4ytyy alkaa "${_issue.prefix}"`;
            if (_issue.format === "ends_with")
              return `Virheellinen sy\xF6te: t\xE4ytyy loppua "${_issue.suffix}"`;
            if (_issue.format === "includes")
              return `Virheellinen sy\xF6te: t\xE4ytyy sis\xE4lt\xE4\xE4 "${_issue.includes}"`;
            if (_issue.format === "regex") {
              return `Virheellinen sy\xF6te: t\xE4ytyy vastata s\xE4\xE4nn\xF6llist\xE4 lauseketta ${_issue.pattern}`;
            }
            return `Virheellinen ${Nouns[_issue.format] ?? issue2.format}`;
          }
          case "not_multiple_of":
            return `Virheellinen luku: t\xE4ytyy olla luvun ${issue2.divisor} monikerta`;
          case "unrecognized_keys":
            return `${issue2.keys.length > 1 ? "Tuntemattomat avaimet" : "Tuntematon avain"}: ${joinValues(issue2.keys, ", ")}`;
          case "invalid_key":
            return "Virheellinen avain tietueessa";
          case "invalid_union":
            return "Virheellinen unioni";
          case "invalid_element":
            return "Virheellinen arvo joukossa";
          default:
            return `Virheellinen sy\xF6te`;
        }
      };
    };
  }
});

// node_modules/zod/v4/locales/fr.js
function fr_default() {
  return {
    localeError: error14()
  };
}
var error14;
var init_fr = __esm({
  "node_modules/zod/v4/locales/fr.js"() {
    init_util();
    error14 = () => {
      const Sizable = {
        string: { unit: "caract\xE8res", verb: "avoir" },
        file: { unit: "octets", verb: "avoir" },
        array: { unit: "\xE9l\xE9ments", verb: "avoir" },
        set: { unit: "\xE9l\xE9ments", verb: "avoir" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const parsedType8 = (data) => {
        const t = typeof data;
        switch (t) {
          case "number": {
            return Number.isNaN(data) ? "NaN" : "nombre";
          }
          case "object": {
            if (Array.isArray(data)) {
              return "tableau";
            }
            if (data === null) {
              return "null";
            }
            if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
              return data.constructor.name;
            }
          }
        }
        return t;
      };
      const Nouns = {
        regex: "entr\xE9e",
        email: "adresse e-mail",
        url: "URL",
        emoji: "emoji",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "date et heure ISO",
        date: "date ISO",
        time: "heure ISO",
        duration: "dur\xE9e ISO",
        ipv4: "adresse IPv4",
        ipv6: "adresse IPv6",
        cidrv4: "plage IPv4",
        cidrv6: "plage IPv6",
        base64: "cha\xEEne encod\xE9e en base64",
        base64url: "cha\xEEne encod\xE9e en base64url",
        json_string: "cha\xEEne JSON",
        e164: "num\xE9ro E.164",
        jwt: "JWT",
        template_literal: "entr\xE9e"
      };
      return (issue2) => {
        switch (issue2.code) {
          case "invalid_type":
            return `Entr\xE9e invalide : ${issue2.expected} attendu, ${parsedType8(issue2.input)} re\xE7u`;
          case "invalid_value":
            if (issue2.values.length === 1)
              return `Entr\xE9e invalide : ${stringifyPrimitive(issue2.values[0])} attendu`;
            return `Option invalide : une valeur parmi ${joinValues(issue2.values, "|")} attendue`;
          case "too_big": {
            const adj = issue2.inclusive ? "<=" : "<";
            const sizing = getSizing(issue2.origin);
            if (sizing)
              return `Trop grand : ${issue2.origin ?? "valeur"} doit ${sizing.verb} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "\xE9l\xE9ment(s)"}`;
            return `Trop grand : ${issue2.origin ?? "valeur"} doit \xEAtre ${adj}${issue2.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue2.inclusive ? ">=" : ">";
            const sizing = getSizing(issue2.origin);
            if (sizing) {
              return `Trop petit : ${issue2.origin} doit ${sizing.verb} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
            }
            return `Trop petit : ${issue2.origin} doit \xEAtre ${adj}${issue2.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue2;
            if (_issue.format === "starts_with")
              return `Cha\xEEne invalide : doit commencer par "${_issue.prefix}"`;
            if (_issue.format === "ends_with")
              return `Cha\xEEne invalide : doit se terminer par "${_issue.suffix}"`;
            if (_issue.format === "includes")
              return `Cha\xEEne invalide : doit inclure "${_issue.includes}"`;
            if (_issue.format === "regex")
              return `Cha\xEEne invalide : doit correspondre au mod\xE8le ${_issue.pattern}`;
            return `${Nouns[_issue.format] ?? issue2.format} invalide`;
          }
          case "not_multiple_of":
            return `Nombre invalide : doit \xEAtre un multiple de ${issue2.divisor}`;
          case "unrecognized_keys":
            return `Cl\xE9${issue2.keys.length > 1 ? "s" : ""} non reconnue${issue2.keys.length > 1 ? "s" : ""} : ${joinValues(issue2.keys, ", ")}`;
          case "invalid_key":
            return `Cl\xE9 invalide dans ${issue2.origin}`;
          case "invalid_union":
            return "Entr\xE9e invalide";
          case "invalid_element":
            return `Valeur invalide dans ${issue2.origin}`;
          default:
            return `Entr\xE9e invalide`;
        }
      };
    };
  }
});

// node_modules/zod/v4/locales/fr-CA.js
function fr_CA_default() {
  return {
    localeError: error15()
  };
}
var error15;
var init_fr_CA = __esm({
  "node_modules/zod/v4/locales/fr-CA.js"() {
    init_util();
    error15 = () => {
      const Sizable = {
        string: { unit: "caract\xE8res", verb: "avoir" },
        file: { unit: "octets", verb: "avoir" },
        array: { unit: "\xE9l\xE9ments", verb: "avoir" },
        set: { unit: "\xE9l\xE9ments", verb: "avoir" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const parsedType8 = (data) => {
        const t = typeof data;
        switch (t) {
          case "number": {
            return Number.isNaN(data) ? "NaN" : "number";
          }
          case "object": {
            if (Array.isArray(data)) {
              return "array";
            }
            if (data === null) {
              return "null";
            }
            if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
              return data.constructor.name;
            }
          }
        }
        return t;
      };
      const Nouns = {
        regex: "entr\xE9e",
        email: "adresse courriel",
        url: "URL",
        emoji: "emoji",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "date-heure ISO",
        date: "date ISO",
        time: "heure ISO",
        duration: "dur\xE9e ISO",
        ipv4: "adresse IPv4",
        ipv6: "adresse IPv6",
        cidrv4: "plage IPv4",
        cidrv6: "plage IPv6",
        base64: "cha\xEEne encod\xE9e en base64",
        base64url: "cha\xEEne encod\xE9e en base64url",
        json_string: "cha\xEEne JSON",
        e164: "num\xE9ro E.164",
        jwt: "JWT",
        template_literal: "entr\xE9e"
      };
      return (issue2) => {
        switch (issue2.code) {
          case "invalid_type":
            return `Entr\xE9e invalide : attendu ${issue2.expected}, re\xE7u ${parsedType8(issue2.input)}`;
          case "invalid_value":
            if (issue2.values.length === 1)
              return `Entr\xE9e invalide : attendu ${stringifyPrimitive(issue2.values[0])}`;
            return `Option invalide : attendu l'une des valeurs suivantes ${joinValues(issue2.values, "|")}`;
          case "too_big": {
            const adj = issue2.inclusive ? "\u2264" : "<";
            const sizing = getSizing(issue2.origin);
            if (sizing)
              return `Trop grand : attendu que ${issue2.origin ?? "la valeur"} ait ${adj}${issue2.maximum.toString()} ${sizing.unit}`;
            return `Trop grand : attendu que ${issue2.origin ?? "la valeur"} soit ${adj}${issue2.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue2.inclusive ? "\u2265" : ">";
            const sizing = getSizing(issue2.origin);
            if (sizing) {
              return `Trop petit : attendu que ${issue2.origin} ait ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
            }
            return `Trop petit : attendu que ${issue2.origin} soit ${adj}${issue2.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue2;
            if (_issue.format === "starts_with") {
              return `Cha\xEEne invalide : doit commencer par "${_issue.prefix}"`;
            }
            if (_issue.format === "ends_with")
              return `Cha\xEEne invalide : doit se terminer par "${_issue.suffix}"`;
            if (_issue.format === "includes")
              return `Cha\xEEne invalide : doit inclure "${_issue.includes}"`;
            if (_issue.format === "regex")
              return `Cha\xEEne invalide : doit correspondre au motif ${_issue.pattern}`;
            return `${Nouns[_issue.format] ?? issue2.format} invalide`;
          }
          case "not_multiple_of":
            return `Nombre invalide : doit \xEAtre un multiple de ${issue2.divisor}`;
          case "unrecognized_keys":
            return `Cl\xE9${issue2.keys.length > 1 ? "s" : ""} non reconnue${issue2.keys.length > 1 ? "s" : ""} : ${joinValues(issue2.keys, ", ")}`;
          case "invalid_key":
            return `Cl\xE9 invalide dans ${issue2.origin}`;
          case "invalid_union":
            return "Entr\xE9e invalide";
          case "invalid_element":
            return `Valeur invalide dans ${issue2.origin}`;
          default:
            return `Entr\xE9e invalide`;
        }
      };
    };
  }
});

// node_modules/zod/v4/locales/he.js
function he_default() {
  return {
    localeError: error16()
  };
}
var error16;
var init_he = __esm({
  "node_modules/zod/v4/locales/he.js"() {
    init_util();
    error16 = () => {
      const Sizable = {
        string: { unit: "\u05D0\u05D5\u05EA\u05D9\u05D5\u05EA", verb: "\u05DC\u05DB\u05DC\u05D5\u05DC" },
        file: { unit: "\u05D1\u05D9\u05D9\u05D8\u05D9\u05DD", verb: "\u05DC\u05DB\u05DC\u05D5\u05DC" },
        array: { unit: "\u05E4\u05E8\u05D9\u05D8\u05D9\u05DD", verb: "\u05DC\u05DB\u05DC\u05D5\u05DC" },
        set: { unit: "\u05E4\u05E8\u05D9\u05D8\u05D9\u05DD", verb: "\u05DC\u05DB\u05DC\u05D5\u05DC" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const parsedType8 = (data) => {
        const t = typeof data;
        switch (t) {
          case "number": {
            return Number.isNaN(data) ? "NaN" : "number";
          }
          case "object": {
            if (Array.isArray(data)) {
              return "array";
            }
            if (data === null) {
              return "null";
            }
            if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
              return data.constructor.name;
            }
          }
        }
        return t;
      };
      const Nouns = {
        regex: "\u05E7\u05DC\u05D8",
        email: "\u05DB\u05EA\u05D5\u05D1\u05EA \u05D0\u05D9\u05DE\u05D9\u05D9\u05DC",
        url: "\u05DB\u05EA\u05D5\u05D1\u05EA \u05E8\u05E9\u05EA",
        emoji: "\u05D0\u05D9\u05DE\u05D5\u05D2'\u05D9",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "\u05EA\u05D0\u05E8\u05D9\u05DA \u05D5\u05D6\u05DE\u05DF ISO",
        date: "\u05EA\u05D0\u05E8\u05D9\u05DA ISO",
        time: "\u05D6\u05DE\u05DF ISO",
        duration: "\u05DE\u05E9\u05DA \u05D6\u05DE\u05DF ISO",
        ipv4: "\u05DB\u05EA\u05D5\u05D1\u05EA IPv4",
        ipv6: "\u05DB\u05EA\u05D5\u05D1\u05EA IPv6",
        cidrv4: "\u05D8\u05D5\u05D5\u05D7 IPv4",
        cidrv6: "\u05D8\u05D5\u05D5\u05D7 IPv6",
        base64: "\u05DE\u05D7\u05E8\u05D5\u05D6\u05EA \u05D1\u05D1\u05E1\u05D9\u05E1 64",
        base64url: "\u05DE\u05D7\u05E8\u05D5\u05D6\u05EA \u05D1\u05D1\u05E1\u05D9\u05E1 64 \u05DC\u05DB\u05EA\u05D5\u05D1\u05D5\u05EA \u05E8\u05E9\u05EA",
        json_string: "\u05DE\u05D7\u05E8\u05D5\u05D6\u05EA JSON",
        e164: "\u05DE\u05E1\u05E4\u05E8 E.164",
        jwt: "JWT",
        template_literal: "\u05E7\u05DC\u05D8"
      };
      return (issue2) => {
        switch (issue2.code) {
          case "invalid_type":
            return `\u05E7\u05DC\u05D8 \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF: \u05E6\u05E8\u05D9\u05DA ${issue2.expected}, \u05D4\u05EA\u05E7\u05D1\u05DC ${parsedType8(issue2.input)}`;
          // return `Invalid input: expected ${issue.expected}, received ${util.getParsedType(issue.input)}`;
          case "invalid_value":
            if (issue2.values.length === 1)
              return `\u05E7\u05DC\u05D8 \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF: \u05E6\u05E8\u05D9\u05DA ${stringifyPrimitive(issue2.values[0])}`;
            return `\u05E7\u05DC\u05D8 \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF: \u05E6\u05E8\u05D9\u05DA \u05D0\u05D7\u05EA \u05DE\u05D4\u05D0\u05E4\u05E9\u05E8\u05D5\u05D9\u05D5\u05EA  ${joinValues(issue2.values, "|")}`;
          case "too_big": {
            const adj = issue2.inclusive ? "<=" : "<";
            const sizing = getSizing(issue2.origin);
            if (sizing)
              return `\u05D2\u05D3\u05D5\u05DC \u05DE\u05D3\u05D9: ${issue2.origin ?? "value"} \u05E6\u05E8\u05D9\u05DA \u05DC\u05D4\u05D9\u05D5\u05EA ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elements"}`;
            return `\u05D2\u05D3\u05D5\u05DC \u05DE\u05D3\u05D9: ${issue2.origin ?? "value"} \u05E6\u05E8\u05D9\u05DA \u05DC\u05D4\u05D9\u05D5\u05EA ${adj}${issue2.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue2.inclusive ? ">=" : ">";
            const sizing = getSizing(issue2.origin);
            if (sizing) {
              return `\u05E7\u05D8\u05DF \u05DE\u05D3\u05D9: ${issue2.origin} \u05E6\u05E8\u05D9\u05DA \u05DC\u05D4\u05D9\u05D5\u05EA ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
            }
            return `\u05E7\u05D8\u05DF \u05DE\u05D3\u05D9: ${issue2.origin} \u05E6\u05E8\u05D9\u05DA \u05DC\u05D4\u05D9\u05D5\u05EA ${adj}${issue2.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue2;
            if (_issue.format === "starts_with")
              return `\u05DE\u05D7\u05E8\u05D5\u05D6\u05EA \u05DC\u05D0 \u05EA\u05E7\u05D9\u05E0\u05D4: \u05D7\u05D9\u05D9\u05D1\u05EA \u05DC\u05D4\u05EA\u05D7\u05D9\u05DC \u05D1"${_issue.prefix}"`;
            if (_issue.format === "ends_with")
              return `\u05DE\u05D7\u05E8\u05D5\u05D6\u05EA \u05DC\u05D0 \u05EA\u05E7\u05D9\u05E0\u05D4: \u05D7\u05D9\u05D9\u05D1\u05EA \u05DC\u05D4\u05E1\u05EA\u05D9\u05D9\u05DD \u05D1 "${_issue.suffix}"`;
            if (_issue.format === "includes")
              return `\u05DE\u05D7\u05E8\u05D5\u05D6\u05EA \u05DC\u05D0 \u05EA\u05E7\u05D9\u05E0\u05D4: \u05D7\u05D9\u05D9\u05D1\u05EA \u05DC\u05DB\u05DC\u05D5\u05DC "${_issue.includes}"`;
            if (_issue.format === "regex")
              return `\u05DE\u05D7\u05E8\u05D5\u05D6\u05EA \u05DC\u05D0 \u05EA\u05E7\u05D9\u05E0\u05D4: \u05D7\u05D9\u05D9\u05D1\u05EA \u05DC\u05D4\u05EA\u05D0\u05D9\u05DD \u05DC\u05EA\u05D1\u05E0\u05D9\u05EA ${_issue.pattern}`;
            return `${Nouns[_issue.format] ?? issue2.format} \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF`;
          }
          case "not_multiple_of":
            return `\u05DE\u05E1\u05E4\u05E8 \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF: \u05D7\u05D9\u05D9\u05D1 \u05DC\u05D4\u05D9\u05D5\u05EA \u05DE\u05DB\u05E4\u05DC\u05D4 \u05E9\u05DC ${issue2.divisor}`;
          case "unrecognized_keys":
            return `\u05DE\u05E4\u05EA\u05D7${issue2.keys.length > 1 ? "\u05D5\u05EA" : ""} \u05DC\u05D0 \u05DE\u05D6\u05D5\u05D4${issue2.keys.length > 1 ? "\u05D9\u05DD" : "\u05D4"}: ${joinValues(issue2.keys, ", ")}`;
          case "invalid_key":
            return `\u05DE\u05E4\u05EA\u05D7 \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF \u05D1${issue2.origin}`;
          case "invalid_union":
            return "\u05E7\u05DC\u05D8 \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF";
          case "invalid_element":
            return `\u05E2\u05E8\u05DA \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF \u05D1${issue2.origin}`;
          default:
            return `\u05E7\u05DC\u05D8 \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF`;
        }
      };
    };
  }
});

// node_modules/zod/v4/locales/hu.js
function hu_default() {
  return {
    localeError: error17()
  };
}
var error17;
var init_hu = __esm({
  "node_modules/zod/v4/locales/hu.js"() {
    init_util();
    error17 = () => {
      const Sizable = {
        string: { unit: "karakter", verb: "legyen" },
        file: { unit: "byte", verb: "legyen" },
        array: { unit: "elem", verb: "legyen" },
        set: { unit: "elem", verb: "legyen" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const parsedType8 = (data) => {
        const t = typeof data;
        switch (t) {
          case "number": {
            return Number.isNaN(data) ? "NaN" : "sz\xE1m";
          }
          case "object": {
            if (Array.isArray(data)) {
              return "t\xF6mb";
            }
            if (data === null) {
              return "null";
            }
            if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
              return data.constructor.name;
            }
          }
        }
        return t;
      };
      const Nouns = {
        regex: "bemenet",
        email: "email c\xEDm",
        url: "URL",
        emoji: "emoji",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "ISO id\u0151b\xE9lyeg",
        date: "ISO d\xE1tum",
        time: "ISO id\u0151",
        duration: "ISO id\u0151intervallum",
        ipv4: "IPv4 c\xEDm",
        ipv6: "IPv6 c\xEDm",
        cidrv4: "IPv4 tartom\xE1ny",
        cidrv6: "IPv6 tartom\xE1ny",
        base64: "base64-k\xF3dolt string",
        base64url: "base64url-k\xF3dolt string",
        json_string: "JSON string",
        e164: "E.164 sz\xE1m",
        jwt: "JWT",
        template_literal: "bemenet"
      };
      return (issue2) => {
        switch (issue2.code) {
          case "invalid_type":
            return `\xC9rv\xE9nytelen bemenet: a v\xE1rt \xE9rt\xE9k ${issue2.expected}, a kapott \xE9rt\xE9k ${parsedType8(issue2.input)}`;
          // return `Invalid input: expected ${issue.expected}, received ${util.getParsedType(issue.input)}`;
          case "invalid_value":
            if (issue2.values.length === 1)
              return `\xC9rv\xE9nytelen bemenet: a v\xE1rt \xE9rt\xE9k ${stringifyPrimitive(issue2.values[0])}`;
            return `\xC9rv\xE9nytelen opci\xF3: valamelyik \xE9rt\xE9k v\xE1rt ${joinValues(issue2.values, "|")}`;
          case "too_big": {
            const adj = issue2.inclusive ? "<=" : "<";
            const sizing = getSizing(issue2.origin);
            if (sizing)
              return `T\xFAl nagy: ${issue2.origin ?? "\xE9rt\xE9k"} m\xE9rete t\xFAl nagy ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elem"}`;
            return `T\xFAl nagy: a bemeneti \xE9rt\xE9k ${issue2.origin ?? "\xE9rt\xE9k"} t\xFAl nagy: ${adj}${issue2.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue2.inclusive ? ">=" : ">";
            const sizing = getSizing(issue2.origin);
            if (sizing) {
              return `T\xFAl kicsi: a bemeneti \xE9rt\xE9k ${issue2.origin} m\xE9rete t\xFAl kicsi ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
            }
            return `T\xFAl kicsi: a bemeneti \xE9rt\xE9k ${issue2.origin} t\xFAl kicsi ${adj}${issue2.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue2;
            if (_issue.format === "starts_with")
              return `\xC9rv\xE9nytelen string: "${_issue.prefix}" \xE9rt\xE9kkel kell kezd\u0151dnie`;
            if (_issue.format === "ends_with")
              return `\xC9rv\xE9nytelen string: "${_issue.suffix}" \xE9rt\xE9kkel kell v\xE9gz\u0151dnie`;
            if (_issue.format === "includes")
              return `\xC9rv\xE9nytelen string: "${_issue.includes}" \xE9rt\xE9ket kell tartalmaznia`;
            if (_issue.format === "regex")
              return `\xC9rv\xE9nytelen string: ${_issue.pattern} mint\xE1nak kell megfelelnie`;
            return `\xC9rv\xE9nytelen ${Nouns[_issue.format] ?? issue2.format}`;
          }
          case "not_multiple_of":
            return `\xC9rv\xE9nytelen sz\xE1m: ${issue2.divisor} t\xF6bbsz\xF6r\xF6s\xE9nek kell lennie`;
          case "unrecognized_keys":
            return `Ismeretlen kulcs${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
          case "invalid_key":
            return `\xC9rv\xE9nytelen kulcs ${issue2.origin}`;
          case "invalid_union":
            return "\xC9rv\xE9nytelen bemenet";
          case "invalid_element":
            return `\xC9rv\xE9nytelen \xE9rt\xE9k: ${issue2.origin}`;
          default:
            return `\xC9rv\xE9nytelen bemenet`;
        }
      };
    };
  }
});

// node_modules/zod/v4/locales/id.js
function id_default() {
  return {
    localeError: error18()
  };
}
var error18;
var init_id = __esm({
  "node_modules/zod/v4/locales/id.js"() {
    init_util();
    error18 = () => {
      const Sizable = {
        string: { unit: "karakter", verb: "memiliki" },
        file: { unit: "byte", verb: "memiliki" },
        array: { unit: "item", verb: "memiliki" },
        set: { unit: "item", verb: "memiliki" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const parsedType8 = (data) => {
        const t = typeof data;
        switch (t) {
          case "number": {
            return Number.isNaN(data) ? "NaN" : "number";
          }
          case "object": {
            if (Array.isArray(data)) {
              return "array";
            }
            if (data === null) {
              return "null";
            }
            if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
              return data.constructor.name;
            }
          }
        }
        return t;
      };
      const Nouns = {
        regex: "input",
        email: "alamat email",
        url: "URL",
        emoji: "emoji",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "tanggal dan waktu format ISO",
        date: "tanggal format ISO",
        time: "jam format ISO",
        duration: "durasi format ISO",
        ipv4: "alamat IPv4",
        ipv6: "alamat IPv6",
        cidrv4: "rentang alamat IPv4",
        cidrv6: "rentang alamat IPv6",
        base64: "string dengan enkode base64",
        base64url: "string dengan enkode base64url",
        json_string: "string JSON",
        e164: "angka E.164",
        jwt: "JWT",
        template_literal: "input"
      };
      return (issue2) => {
        switch (issue2.code) {
          case "invalid_type":
            return `Input tidak valid: diharapkan ${issue2.expected}, diterima ${parsedType8(issue2.input)}`;
          case "invalid_value":
            if (issue2.values.length === 1)
              return `Input tidak valid: diharapkan ${stringifyPrimitive(issue2.values[0])}`;
            return `Pilihan tidak valid: diharapkan salah satu dari ${joinValues(issue2.values, "|")}`;
          case "too_big": {
            const adj = issue2.inclusive ? "<=" : "<";
            const sizing = getSizing(issue2.origin);
            if (sizing)
              return `Terlalu besar: diharapkan ${issue2.origin ?? "value"} memiliki ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elemen"}`;
            return `Terlalu besar: diharapkan ${issue2.origin ?? "value"} menjadi ${adj}${issue2.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue2.inclusive ? ">=" : ">";
            const sizing = getSizing(issue2.origin);
            if (sizing) {
              return `Terlalu kecil: diharapkan ${issue2.origin} memiliki ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
            }
            return `Terlalu kecil: diharapkan ${issue2.origin} menjadi ${adj}${issue2.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue2;
            if (_issue.format === "starts_with")
              return `String tidak valid: harus dimulai dengan "${_issue.prefix}"`;
            if (_issue.format === "ends_with")
              return `String tidak valid: harus berakhir dengan "${_issue.suffix}"`;
            if (_issue.format === "includes")
              return `String tidak valid: harus menyertakan "${_issue.includes}"`;
            if (_issue.format === "regex")
              return `String tidak valid: harus sesuai pola ${_issue.pattern}`;
            return `${Nouns[_issue.format] ?? issue2.format} tidak valid`;
          }
          case "not_multiple_of":
            return `Angka tidak valid: harus kelipatan dari ${issue2.divisor}`;
          case "unrecognized_keys":
            return `Kunci tidak dikenali ${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
          case "invalid_key":
            return `Kunci tidak valid di ${issue2.origin}`;
          case "invalid_union":
            return "Input tidak valid";
          case "invalid_element":
            return `Nilai tidak valid di ${issue2.origin}`;
          default:
            return `Input tidak valid`;
        }
      };
    };
  }
});

// node_modules/zod/v4/locales/is.js
function is_default() {
  return {
    localeError: error19()
  };
}
var parsedType4, error19;
var init_is = __esm({
  "node_modules/zod/v4/locales/is.js"() {
    init_util();
    parsedType4 = (data) => {
      const t = typeof data;
      switch (t) {
        case "number": {
          return Number.isNaN(data) ? "NaN" : "n\xFAmer";
        }
        case "object": {
          if (Array.isArray(data)) {
            return "fylki";
          }
          if (data === null) {
            return "null";
          }
          if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
            return data.constructor.name;
          }
        }
      }
      return t;
    };
    error19 = () => {
      const Sizable = {
        string: { unit: "stafi", verb: "a\xF0 hafa" },
        file: { unit: "b\xE6ti", verb: "a\xF0 hafa" },
        array: { unit: "hluti", verb: "a\xF0 hafa" },
        set: { unit: "hluti", verb: "a\xF0 hafa" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const Nouns = {
        regex: "gildi",
        email: "netfang",
        url: "vefsl\xF3\xF0",
        emoji: "emoji",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "ISO dagsetning og t\xEDmi",
        date: "ISO dagsetning",
        time: "ISO t\xEDmi",
        duration: "ISO t\xEDmalengd",
        ipv4: "IPv4 address",
        ipv6: "IPv6 address",
        cidrv4: "IPv4 range",
        cidrv6: "IPv6 range",
        base64: "base64-encoded strengur",
        base64url: "base64url-encoded strengur",
        json_string: "JSON strengur",
        e164: "E.164 t\xF6lugildi",
        jwt: "JWT",
        template_literal: "gildi"
      };
      return (issue2) => {
        switch (issue2.code) {
          case "invalid_type":
            return `Rangt gildi: \xDE\xFA sl\xF3st inn ${parsedType4(issue2.input)} \xFEar sem \xE1 a\xF0 vera ${issue2.expected}`;
          case "invalid_value":
            if (issue2.values.length === 1)
              return `Rangt gildi: gert r\xE1\xF0 fyrir ${stringifyPrimitive(issue2.values[0])}`;
            return `\xD3gilt val: m\xE1 vera eitt af eftirfarandi ${joinValues(issue2.values, "|")}`;
          case "too_big": {
            const adj = issue2.inclusive ? "<=" : "<";
            const sizing = getSizing(issue2.origin);
            if (sizing)
              return `Of st\xF3rt: gert er r\xE1\xF0 fyrir a\xF0 ${issue2.origin ?? "gildi"} hafi ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "hluti"}`;
            return `Of st\xF3rt: gert er r\xE1\xF0 fyrir a\xF0 ${issue2.origin ?? "gildi"} s\xE9 ${adj}${issue2.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue2.inclusive ? ">=" : ">";
            const sizing = getSizing(issue2.origin);
            if (sizing) {
              return `Of l\xEDti\xF0: gert er r\xE1\xF0 fyrir a\xF0 ${issue2.origin} hafi ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
            }
            return `Of l\xEDti\xF0: gert er r\xE1\xF0 fyrir a\xF0 ${issue2.origin} s\xE9 ${adj}${issue2.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue2;
            if (_issue.format === "starts_with") {
              return `\xD3gildur strengur: ver\xF0ur a\xF0 byrja \xE1 "${_issue.prefix}"`;
            }
            if (_issue.format === "ends_with")
              return `\xD3gildur strengur: ver\xF0ur a\xF0 enda \xE1 "${_issue.suffix}"`;
            if (_issue.format === "includes")
              return `\xD3gildur strengur: ver\xF0ur a\xF0 innihalda "${_issue.includes}"`;
            if (_issue.format === "regex")
              return `\xD3gildur strengur: ver\xF0ur a\xF0 fylgja mynstri ${_issue.pattern}`;
            return `Rangt ${Nouns[_issue.format] ?? issue2.format}`;
          }
          case "not_multiple_of":
            return `R\xF6ng tala: ver\xF0ur a\xF0 vera margfeldi af ${issue2.divisor}`;
          case "unrecognized_keys":
            return `\xD3\xFEekkt ${issue2.keys.length > 1 ? "ir lyklar" : "ur lykill"}: ${joinValues(issue2.keys, ", ")}`;
          case "invalid_key":
            return `Rangur lykill \xED ${issue2.origin}`;
          case "invalid_union":
            return "Rangt gildi";
          case "invalid_element":
            return `Rangt gildi \xED ${issue2.origin}`;
          default:
            return `Rangt gildi`;
        }
      };
    };
  }
});

// node_modules/zod/v4/locales/it.js
function it_default() {
  return {
    localeError: error20()
  };
}
var error20;
var init_it = __esm({
  "node_modules/zod/v4/locales/it.js"() {
    init_util();
    error20 = () => {
      const Sizable = {
        string: { unit: "caratteri", verb: "avere" },
        file: { unit: "byte", verb: "avere" },
        array: { unit: "elementi", verb: "avere" },
        set: { unit: "elementi", verb: "avere" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const parsedType8 = (data) => {
        const t = typeof data;
        switch (t) {
          case "number": {
            return Number.isNaN(data) ? "NaN" : "numero";
          }
          case "object": {
            if (Array.isArray(data)) {
              return "vettore";
            }
            if (data === null) {
              return "null";
            }
            if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
              return data.constructor.name;
            }
          }
        }
        return t;
      };
      const Nouns = {
        regex: "input",
        email: "indirizzo email",
        url: "URL",
        emoji: "emoji",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "data e ora ISO",
        date: "data ISO",
        time: "ora ISO",
        duration: "durata ISO",
        ipv4: "indirizzo IPv4",
        ipv6: "indirizzo IPv6",
        cidrv4: "intervallo IPv4",
        cidrv6: "intervallo IPv6",
        base64: "stringa codificata in base64",
        base64url: "URL codificata in base64",
        json_string: "stringa JSON",
        e164: "numero E.164",
        jwt: "JWT",
        template_literal: "input"
      };
      return (issue2) => {
        switch (issue2.code) {
          case "invalid_type":
            return `Input non valido: atteso ${issue2.expected}, ricevuto ${parsedType8(issue2.input)}`;
          // return `Input non valido: atteso ${issue.expected}, ricevuto ${util.getParsedType(issue.input)}`;
          case "invalid_value":
            if (issue2.values.length === 1)
              return `Input non valido: atteso ${stringifyPrimitive(issue2.values[0])}`;
            return `Opzione non valida: atteso uno tra ${joinValues(issue2.values, "|")}`;
          case "too_big": {
            const adj = issue2.inclusive ? "<=" : "<";
            const sizing = getSizing(issue2.origin);
            if (sizing)
              return `Troppo grande: ${issue2.origin ?? "valore"} deve avere ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elementi"}`;
            return `Troppo grande: ${issue2.origin ?? "valore"} deve essere ${adj}${issue2.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue2.inclusive ? ">=" : ">";
            const sizing = getSizing(issue2.origin);
            if (sizing) {
              return `Troppo piccolo: ${issue2.origin} deve avere ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
            }
            return `Troppo piccolo: ${issue2.origin} deve essere ${adj}${issue2.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue2;
            if (_issue.format === "starts_with")
              return `Stringa non valida: deve iniziare con "${_issue.prefix}"`;
            if (_issue.format === "ends_with")
              return `Stringa non valida: deve terminare con "${_issue.suffix}"`;
            if (_issue.format === "includes")
              return `Stringa non valida: deve includere "${_issue.includes}"`;
            if (_issue.format === "regex")
              return `Stringa non valida: deve corrispondere al pattern ${_issue.pattern}`;
            return `Invalid ${Nouns[_issue.format] ?? issue2.format}`;
          }
          case "not_multiple_of":
            return `Numero non valido: deve essere un multiplo di ${issue2.divisor}`;
          case "unrecognized_keys":
            return `Chiav${issue2.keys.length > 1 ? "i" : "e"} non riconosciut${issue2.keys.length > 1 ? "e" : "a"}: ${joinValues(issue2.keys, ", ")}`;
          case "invalid_key":
            return `Chiave non valida in ${issue2.origin}`;
          case "invalid_union":
            return "Input non valido";
          case "invalid_element":
            return `Valore non valido in ${issue2.origin}`;
          default:
            return `Input non valido`;
        }
      };
    };
  }
});

// node_modules/zod/v4/locales/ja.js
function ja_default() {
  return {
    localeError: error21()
  };
}
var error21;
var init_ja = __esm({
  "node_modules/zod/v4/locales/ja.js"() {
    init_util();
    error21 = () => {
      const Sizable = {
        string: { unit: "\u6587\u5B57", verb: "\u3067\u3042\u308B" },
        file: { unit: "\u30D0\u30A4\u30C8", verb: "\u3067\u3042\u308B" },
        array: { unit: "\u8981\u7D20", verb: "\u3067\u3042\u308B" },
        set: { unit: "\u8981\u7D20", verb: "\u3067\u3042\u308B" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const parsedType8 = (data) => {
        const t = typeof data;
        switch (t) {
          case "number": {
            return Number.isNaN(data) ? "NaN" : "\u6570\u5024";
          }
          case "object": {
            if (Array.isArray(data)) {
              return "\u914D\u5217";
            }
            if (data === null) {
              return "null";
            }
            if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
              return data.constructor.name;
            }
          }
        }
        return t;
      };
      const Nouns = {
        regex: "\u5165\u529B\u5024",
        email: "\u30E1\u30FC\u30EB\u30A2\u30C9\u30EC\u30B9",
        url: "URL",
        emoji: "\u7D75\u6587\u5B57",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "ISO\u65E5\u6642",
        date: "ISO\u65E5\u4ED8",
        time: "ISO\u6642\u523B",
        duration: "ISO\u671F\u9593",
        ipv4: "IPv4\u30A2\u30C9\u30EC\u30B9",
        ipv6: "IPv6\u30A2\u30C9\u30EC\u30B9",
        cidrv4: "IPv4\u7BC4\u56F2",
        cidrv6: "IPv6\u7BC4\u56F2",
        base64: "base64\u30A8\u30F3\u30B3\u30FC\u30C9\u6587\u5B57\u5217",
        base64url: "base64url\u30A8\u30F3\u30B3\u30FC\u30C9\u6587\u5B57\u5217",
        json_string: "JSON\u6587\u5B57\u5217",
        e164: "E.164\u756A\u53F7",
        jwt: "JWT",
        template_literal: "\u5165\u529B\u5024"
      };
      return (issue2) => {
        switch (issue2.code) {
          case "invalid_type":
            return `\u7121\u52B9\u306A\u5165\u529B: ${issue2.expected}\u304C\u671F\u5F85\u3055\u308C\u307E\u3057\u305F\u304C\u3001${parsedType8(issue2.input)}\u304C\u5165\u529B\u3055\u308C\u307E\u3057\u305F`;
          case "invalid_value":
            if (issue2.values.length === 1)
              return `\u7121\u52B9\u306A\u5165\u529B: ${stringifyPrimitive(issue2.values[0])}\u304C\u671F\u5F85\u3055\u308C\u307E\u3057\u305F`;
            return `\u7121\u52B9\u306A\u9078\u629E: ${joinValues(issue2.values, "\u3001")}\u306E\u3044\u305A\u308C\u304B\u3067\u3042\u308B\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
          case "too_big": {
            const adj = issue2.inclusive ? "\u4EE5\u4E0B\u3067\u3042\u308B" : "\u3088\u308A\u5C0F\u3055\u3044";
            const sizing = getSizing(issue2.origin);
            if (sizing)
              return `\u5927\u304D\u3059\u304E\u308B\u5024: ${issue2.origin ?? "\u5024"}\u306F${issue2.maximum.toString()}${sizing.unit ?? "\u8981\u7D20"}${adj}\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
            return `\u5927\u304D\u3059\u304E\u308B\u5024: ${issue2.origin ?? "\u5024"}\u306F${issue2.maximum.toString()}${adj}\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
          }
          case "too_small": {
            const adj = issue2.inclusive ? "\u4EE5\u4E0A\u3067\u3042\u308B" : "\u3088\u308A\u5927\u304D\u3044";
            const sizing = getSizing(issue2.origin);
            if (sizing)
              return `\u5C0F\u3055\u3059\u304E\u308B\u5024: ${issue2.origin}\u306F${issue2.minimum.toString()}${sizing.unit}${adj}\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
            return `\u5C0F\u3055\u3059\u304E\u308B\u5024: ${issue2.origin}\u306F${issue2.minimum.toString()}${adj}\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
          }
          case "invalid_format": {
            const _issue = issue2;
            if (_issue.format === "starts_with")
              return `\u7121\u52B9\u306A\u6587\u5B57\u5217: "${_issue.prefix}"\u3067\u59CB\u307E\u308B\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
            if (_issue.format === "ends_with")
              return `\u7121\u52B9\u306A\u6587\u5B57\u5217: "${_issue.suffix}"\u3067\u7D42\u308F\u308B\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
            if (_issue.format === "includes")
              return `\u7121\u52B9\u306A\u6587\u5B57\u5217: "${_issue.includes}"\u3092\u542B\u3080\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
            if (_issue.format === "regex")
              return `\u7121\u52B9\u306A\u6587\u5B57\u5217: \u30D1\u30BF\u30FC\u30F3${_issue.pattern}\u306B\u4E00\u81F4\u3059\u308B\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
            return `\u7121\u52B9\u306A${Nouns[_issue.format] ?? issue2.format}`;
          }
          case "not_multiple_of":
            return `\u7121\u52B9\u306A\u6570\u5024: ${issue2.divisor}\u306E\u500D\u6570\u3067\u3042\u308B\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
          case "unrecognized_keys":
            return `\u8A8D\u8B58\u3055\u308C\u3066\u3044\u306A\u3044\u30AD\u30FC${issue2.keys.length > 1 ? "\u7FA4" : ""}: ${joinValues(issue2.keys, "\u3001")}`;
          case "invalid_key":
            return `${issue2.origin}\u5185\u306E\u7121\u52B9\u306A\u30AD\u30FC`;
          case "invalid_union":
            return "\u7121\u52B9\u306A\u5165\u529B";
          case "invalid_element":
            return `${issue2.origin}\u5185\u306E\u7121\u52B9\u306A\u5024`;
          default:
            return `\u7121\u52B9\u306A\u5165\u529B`;
        }
      };
    };
  }
});

// node_modules/zod/v4/locales/ka.js
function ka_default() {
  return {
    localeError: error22()
  };
}
var parsedType5, error22;
var init_ka = __esm({
  "node_modules/zod/v4/locales/ka.js"() {
    init_util();
    parsedType5 = (data) => {
      const t = typeof data;
      switch (t) {
        case "number": {
          return Number.isNaN(data) ? "NaN" : "\u10E0\u10D8\u10EA\u10EE\u10D5\u10D8";
        }
        case "object": {
          if (Array.isArray(data)) {
            return "\u10DB\u10D0\u10E1\u10D8\u10D5\u10D8";
          }
          if (data === null) {
            return "null";
          }
          if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
            return data.constructor.name;
          }
        }
      }
      const typeMap = {
        string: "\u10E1\u10E2\u10E0\u10D8\u10DC\u10D2\u10D8",
        boolean: "\u10D1\u10E3\u10DA\u10D4\u10D0\u10DC\u10D8",
        undefined: "undefined",
        bigint: "bigint",
        symbol: "symbol",
        function: "\u10E4\u10E3\u10DC\u10E5\u10EA\u10D8\u10D0"
      };
      return typeMap[t] ?? t;
    };
    error22 = () => {
      const Sizable = {
        string: { unit: "\u10E1\u10D8\u10DB\u10D1\u10DD\u10DA\u10DD", verb: "\u10E3\u10DC\u10D3\u10D0 \u10E8\u10D4\u10D8\u10EA\u10D0\u10D5\u10D3\u10D4\u10E1" },
        file: { unit: "\u10D1\u10D0\u10D8\u10E2\u10D8", verb: "\u10E3\u10DC\u10D3\u10D0 \u10E8\u10D4\u10D8\u10EA\u10D0\u10D5\u10D3\u10D4\u10E1" },
        array: { unit: "\u10D4\u10DA\u10D4\u10DB\u10D4\u10DC\u10E2\u10D8", verb: "\u10E3\u10DC\u10D3\u10D0 \u10E8\u10D4\u10D8\u10EA\u10D0\u10D5\u10D3\u10D4\u10E1" },
        set: { unit: "\u10D4\u10DA\u10D4\u10DB\u10D4\u10DC\u10E2\u10D8", verb: "\u10E3\u10DC\u10D3\u10D0 \u10E8\u10D4\u10D8\u10EA\u10D0\u10D5\u10D3\u10D4\u10E1" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const Nouns = {
        regex: "\u10E8\u10D4\u10E7\u10D5\u10D0\u10DC\u10D0",
        email: "\u10D4\u10DA-\u10E4\u10DD\u10E1\u10E2\u10D8\u10E1 \u10DB\u10D8\u10E1\u10D0\u10DB\u10D0\u10E0\u10D7\u10D8",
        url: "URL",
        emoji: "\u10D4\u10DB\u10DD\u10EF\u10D8",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "\u10D7\u10D0\u10E0\u10D8\u10E6\u10D8-\u10D3\u10E0\u10DD",
        date: "\u10D7\u10D0\u10E0\u10D8\u10E6\u10D8",
        time: "\u10D3\u10E0\u10DD",
        duration: "\u10EE\u10D0\u10DC\u10D2\u10E0\u10EB\u10DA\u10D8\u10D5\u10DD\u10D1\u10D0",
        ipv4: "IPv4 \u10DB\u10D8\u10E1\u10D0\u10DB\u10D0\u10E0\u10D7\u10D8",
        ipv6: "IPv6 \u10DB\u10D8\u10E1\u10D0\u10DB\u10D0\u10E0\u10D7\u10D8",
        cidrv4: "IPv4 \u10D3\u10D8\u10D0\u10DE\u10D0\u10D6\u10DD\u10DC\u10D8",
        cidrv6: "IPv6 \u10D3\u10D8\u10D0\u10DE\u10D0\u10D6\u10DD\u10DC\u10D8",
        base64: "base64-\u10D9\u10DD\u10D3\u10D8\u10E0\u10D4\u10D1\u10E3\u10DA\u10D8 \u10E1\u10E2\u10E0\u10D8\u10DC\u10D2\u10D8",
        base64url: "base64url-\u10D9\u10DD\u10D3\u10D8\u10E0\u10D4\u10D1\u10E3\u10DA\u10D8 \u10E1\u10E2\u10E0\u10D8\u10DC\u10D2\u10D8",
        json_string: "JSON \u10E1\u10E2\u10E0\u10D8\u10DC\u10D2\u10D8",
        e164: "E.164 \u10DC\u10DD\u10DB\u10D4\u10E0\u10D8",
        jwt: "JWT",
        template_literal: "\u10E8\u10D4\u10E7\u10D5\u10D0\u10DC\u10D0"
      };
      return (issue2) => {
        switch (issue2.code) {
          case "invalid_type":
            return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10E8\u10D4\u10E7\u10D5\u10D0\u10DC\u10D0: \u10DB\u10DD\u10E1\u10D0\u10DA\u10DD\u10D3\u10DC\u10D4\u10DA\u10D8 ${issue2.expected}, \u10DB\u10D8\u10E6\u10D4\u10D1\u10E3\u10DA\u10D8 ${parsedType5(issue2.input)}`;
          case "invalid_value":
            if (issue2.values.length === 1)
              return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10E8\u10D4\u10E7\u10D5\u10D0\u10DC\u10D0: \u10DB\u10DD\u10E1\u10D0\u10DA\u10DD\u10D3\u10DC\u10D4\u10DA\u10D8 ${stringifyPrimitive(issue2.values[0])}`;
            return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10D5\u10D0\u10E0\u10D8\u10D0\u10DC\u10E2\u10D8: \u10DB\u10DD\u10E1\u10D0\u10DA\u10DD\u10D3\u10DC\u10D4\u10DA\u10D8\u10D0 \u10D4\u10E0\u10D7-\u10D4\u10E0\u10D7\u10D8 ${joinValues(issue2.values, "|")}-\u10D3\u10D0\u10DC`;
          case "too_big": {
            const adj = issue2.inclusive ? "<=" : "<";
            const sizing = getSizing(issue2.origin);
            if (sizing)
              return `\u10D6\u10D4\u10D3\u10DB\u10D4\u10E2\u10D0\u10D3 \u10D3\u10D8\u10D3\u10D8: \u10DB\u10DD\u10E1\u10D0\u10DA\u10DD\u10D3\u10DC\u10D4\u10DA\u10D8 ${issue2.origin ?? "\u10DB\u10DC\u10D8\u10E8\u10D5\u10DC\u10D4\u10DA\u10DD\u10D1\u10D0"} ${sizing.verb} ${adj}${issue2.maximum.toString()} ${sizing.unit}`;
            return `\u10D6\u10D4\u10D3\u10DB\u10D4\u10E2\u10D0\u10D3 \u10D3\u10D8\u10D3\u10D8: \u10DB\u10DD\u10E1\u10D0\u10DA\u10DD\u10D3\u10DC\u10D4\u10DA\u10D8 ${issue2.origin ?? "\u10DB\u10DC\u10D8\u10E8\u10D5\u10DC\u10D4\u10DA\u10DD\u10D1\u10D0"} \u10D8\u10E7\u10DD\u10E1 ${adj}${issue2.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue2.inclusive ? ">=" : ">";
            const sizing = getSizing(issue2.origin);
            if (sizing) {
              return `\u10D6\u10D4\u10D3\u10DB\u10D4\u10E2\u10D0\u10D3 \u10DE\u10D0\u10E2\u10D0\u10E0\u10D0: \u10DB\u10DD\u10E1\u10D0\u10DA\u10DD\u10D3\u10DC\u10D4\u10DA\u10D8 ${issue2.origin} ${sizing.verb} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
            }
            return `\u10D6\u10D4\u10D3\u10DB\u10D4\u10E2\u10D0\u10D3 \u10DE\u10D0\u10E2\u10D0\u10E0\u10D0: \u10DB\u10DD\u10E1\u10D0\u10DA\u10DD\u10D3\u10DC\u10D4\u10DA\u10D8 ${issue2.origin} \u10D8\u10E7\u10DD\u10E1 ${adj}${issue2.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue2;
            if (_issue.format === "starts_with") {
              return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10E1\u10E2\u10E0\u10D8\u10DC\u10D2\u10D8: \u10E3\u10DC\u10D3\u10D0 \u10D8\u10EC\u10E7\u10D4\u10D1\u10DD\u10D3\u10D4\u10E1 "${_issue.prefix}"-\u10D8\u10D7`;
            }
            if (_issue.format === "ends_with")
              return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10E1\u10E2\u10E0\u10D8\u10DC\u10D2\u10D8: \u10E3\u10DC\u10D3\u10D0 \u10DB\u10D7\u10D0\u10D5\u10E0\u10D3\u10D4\u10D1\u10DD\u10D3\u10D4\u10E1 "${_issue.suffix}"-\u10D8\u10D7`;
            if (_issue.format === "includes")
              return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10E1\u10E2\u10E0\u10D8\u10DC\u10D2\u10D8: \u10E3\u10DC\u10D3\u10D0 \u10E8\u10D4\u10D8\u10EA\u10D0\u10D5\u10D3\u10D4\u10E1 "${_issue.includes}"-\u10E1`;
            if (_issue.format === "regex")
              return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10E1\u10E2\u10E0\u10D8\u10DC\u10D2\u10D8: \u10E3\u10DC\u10D3\u10D0 \u10E8\u10D4\u10D4\u10E1\u10D0\u10D1\u10D0\u10DB\u10D4\u10D1\u10DD\u10D3\u10D4\u10E1 \u10E8\u10D0\u10D1\u10DA\u10DD\u10DC\u10E1 ${_issue.pattern}`;
            return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 ${Nouns[_issue.format] ?? issue2.format}`;
          }
          case "not_multiple_of":
            return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10E0\u10D8\u10EA\u10EE\u10D5\u10D8: \u10E3\u10DC\u10D3\u10D0 \u10D8\u10E7\u10DD\u10E1 ${issue2.divisor}-\u10D8\u10E1 \u10EF\u10D4\u10E0\u10D0\u10D3\u10D8`;
          case "unrecognized_keys":
            return `\u10E3\u10EA\u10DC\u10DD\u10D1\u10D8 \u10D2\u10D0\u10E1\u10D0\u10E6\u10D4\u10D1${issue2.keys.length > 1 ? "\u10D4\u10D1\u10D8" : "\u10D8"}: ${joinValues(issue2.keys, ", ")}`;
          case "invalid_key":
            return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10D2\u10D0\u10E1\u10D0\u10E6\u10D4\u10D1\u10D8 ${issue2.origin}-\u10E8\u10D8`;
          case "invalid_union":
            return "\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10E8\u10D4\u10E7\u10D5\u10D0\u10DC\u10D0";
          case "invalid_element":
            return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10DB\u10DC\u10D8\u10E8\u10D5\u10DC\u10D4\u10DA\u10DD\u10D1\u10D0 ${issue2.origin}-\u10E8\u10D8`;
          default:
            return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10E8\u10D4\u10E7\u10D5\u10D0\u10DC\u10D0`;
        }
      };
    };
  }
});

// node_modules/zod/v4/locales/km.js
function km_default() {
  return {
    localeError: error23()
  };
}
var error23;
var init_km = __esm({
  "node_modules/zod/v4/locales/km.js"() {
    init_util();
    error23 = () => {
      const Sizable = {
        string: { unit: "\u178F\u17BD\u17A2\u1780\u17D2\u179F\u179A", verb: "\u1782\u17BD\u179A\u1798\u17B6\u1793" },
        file: { unit: "\u1794\u17C3", verb: "\u1782\u17BD\u179A\u1798\u17B6\u1793" },
        array: { unit: "\u1792\u17B6\u178F\u17BB", verb: "\u1782\u17BD\u179A\u1798\u17B6\u1793" },
        set: { unit: "\u1792\u17B6\u178F\u17BB", verb: "\u1782\u17BD\u179A\u1798\u17B6\u1793" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const parsedType8 = (data) => {
        const t = typeof data;
        switch (t) {
          case "number": {
            return Number.isNaN(data) ? "\u1798\u17B7\u1793\u1798\u17C2\u1793\u1787\u17B6\u179B\u17C1\u1781 (NaN)" : "\u179B\u17C1\u1781";
          }
          case "object": {
            if (Array.isArray(data)) {
              return "\u17A2\u17B6\u179A\u17C1 (Array)";
            }
            if (data === null) {
              return "\u1782\u17D2\u1798\u17B6\u1793\u178F\u1798\u17D2\u179B\u17C3 (null)";
            }
            if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
              return data.constructor.name;
            }
          }
        }
        return t;
      };
      const Nouns = {
        regex: "\u1791\u17B7\u1793\u17D2\u1793\u1793\u17D0\u1799\u1794\u1789\u17D2\u1785\u17BC\u179B",
        email: "\u17A2\u17B6\u179F\u1799\u178A\u17D2\u178B\u17B6\u1793\u17A2\u17CA\u17B8\u1798\u17C2\u179B",
        url: "URL",
        emoji: "\u179F\u1789\u17D2\u1789\u17B6\u17A2\u17B6\u179A\u1798\u17D2\u1798\u178E\u17CD",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "\u1780\u17B6\u179B\u1794\u179A\u17B7\u1785\u17D2\u1786\u17C1\u1791 \u1793\u17B7\u1784\u1798\u17C9\u17C4\u1784 ISO",
        date: "\u1780\u17B6\u179B\u1794\u179A\u17B7\u1785\u17D2\u1786\u17C1\u1791 ISO",
        time: "\u1798\u17C9\u17C4\u1784 ISO",
        duration: "\u179A\u1799\u17C8\u1796\u17C1\u179B ISO",
        ipv4: "\u17A2\u17B6\u179F\u1799\u178A\u17D2\u178B\u17B6\u1793 IPv4",
        ipv6: "\u17A2\u17B6\u179F\u1799\u178A\u17D2\u178B\u17B6\u1793 IPv6",
        cidrv4: "\u178A\u17C2\u1793\u17A2\u17B6\u179F\u1799\u178A\u17D2\u178B\u17B6\u1793 IPv4",
        cidrv6: "\u178A\u17C2\u1793\u17A2\u17B6\u179F\u1799\u178A\u17D2\u178B\u17B6\u1793 IPv6",
        base64: "\u1781\u17D2\u179F\u17C2\u17A2\u1780\u17D2\u179F\u179A\u17A2\u17CA\u17B7\u1780\u17BC\u178A base64",
        base64url: "\u1781\u17D2\u179F\u17C2\u17A2\u1780\u17D2\u179F\u179A\u17A2\u17CA\u17B7\u1780\u17BC\u178A base64url",
        json_string: "\u1781\u17D2\u179F\u17C2\u17A2\u1780\u17D2\u179F\u179A JSON",
        e164: "\u179B\u17C1\u1781 E.164",
        jwt: "JWT",
        template_literal: "\u1791\u17B7\u1793\u17D2\u1793\u1793\u17D0\u1799\u1794\u1789\u17D2\u1785\u17BC\u179B"
      };
      return (issue2) => {
        switch (issue2.code) {
          case "invalid_type":
            return `\u1791\u17B7\u1793\u17D2\u1793\u1793\u17D0\u1799\u1794\u1789\u17D2\u1785\u17BC\u179B\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1780\u17B6\u179A ${issue2.expected} \u1794\u17C9\u17BB\u1793\u17D2\u178F\u17C2\u1791\u1791\u17BD\u179B\u1794\u17B6\u1793 ${parsedType8(issue2.input)}`;
          case "invalid_value":
            if (issue2.values.length === 1)
              return `\u1791\u17B7\u1793\u17D2\u1793\u1793\u17D0\u1799\u1794\u1789\u17D2\u1785\u17BC\u179B\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1780\u17B6\u179A ${stringifyPrimitive(issue2.values[0])}`;
            return `\u1787\u1798\u17D2\u179A\u17BE\u179F\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1787\u17B6\u1798\u17BD\u1799\u1780\u17D2\u1793\u17BB\u1784\u1785\u17C6\u178E\u17C4\u1798 ${joinValues(issue2.values, "|")}`;
          case "too_big": {
            const adj = issue2.inclusive ? "<=" : "<";
            const sizing = getSizing(issue2.origin);
            if (sizing)
              return `\u1792\u17C6\u1796\u17C1\u1780\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1780\u17B6\u179A ${issue2.origin ?? "\u178F\u1798\u17D2\u179B\u17C3"} ${adj} ${issue2.maximum.toString()} ${sizing.unit ?? "\u1792\u17B6\u178F\u17BB"}`;
            return `\u1792\u17C6\u1796\u17C1\u1780\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1780\u17B6\u179A ${issue2.origin ?? "\u178F\u1798\u17D2\u179B\u17C3"} ${adj} ${issue2.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue2.inclusive ? ">=" : ">";
            const sizing = getSizing(issue2.origin);
            if (sizing) {
              return `\u178F\u17BC\u1785\u1796\u17C1\u1780\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1780\u17B6\u179A ${issue2.origin} ${adj} ${issue2.minimum.toString()} ${sizing.unit}`;
            }
            return `\u178F\u17BC\u1785\u1796\u17C1\u1780\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1780\u17B6\u179A ${issue2.origin} ${adj} ${issue2.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue2;
            if (_issue.format === "starts_with") {
              return `\u1781\u17D2\u179F\u17C2\u17A2\u1780\u17D2\u179F\u179A\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1785\u17B6\u1794\u17CB\u1795\u17D2\u178F\u17BE\u1798\u178A\u17C4\u1799 "${_issue.prefix}"`;
            }
            if (_issue.format === "ends_with")
              return `\u1781\u17D2\u179F\u17C2\u17A2\u1780\u17D2\u179F\u179A\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1794\u1789\u17D2\u1785\u1794\u17CB\u178A\u17C4\u1799 "${_issue.suffix}"`;
            if (_issue.format === "includes")
              return `\u1781\u17D2\u179F\u17C2\u17A2\u1780\u17D2\u179F\u179A\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1798\u17B6\u1793 "${_issue.includes}"`;
            if (_issue.format === "regex")
              return `\u1781\u17D2\u179F\u17C2\u17A2\u1780\u17D2\u179F\u179A\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u178F\u17C2\u1795\u17D2\u1782\u17BC\u1795\u17D2\u1782\u1784\u1793\u17B9\u1784\u1791\u1798\u17D2\u179A\u1784\u17CB\u178A\u17C2\u179B\u1794\u17B6\u1793\u1780\u17C6\u178E\u178F\u17CB ${_issue.pattern}`;
            return `\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 ${Nouns[_issue.format] ?? issue2.format}`;
          }
          case "not_multiple_of":
            return `\u179B\u17C1\u1781\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u178F\u17C2\u1787\u17B6\u1796\u17A0\u17BB\u1782\u17BB\u178E\u1793\u17C3 ${issue2.divisor}`;
          case "unrecognized_keys":
            return `\u179A\u1780\u1783\u17BE\u1789\u179F\u17C4\u1798\u17B7\u1793\u179F\u17D2\u1782\u17B6\u179B\u17CB\u17D6 ${joinValues(issue2.keys, ", ")}`;
          case "invalid_key":
            return `\u179F\u17C4\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u1793\u17C5\u1780\u17D2\u1793\u17BB\u1784 ${issue2.origin}`;
          case "invalid_union":
            return `\u1791\u17B7\u1793\u17D2\u1793\u1793\u17D0\u1799\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C`;
          case "invalid_element":
            return `\u1791\u17B7\u1793\u17D2\u1793\u1793\u17D0\u1799\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u1793\u17C5\u1780\u17D2\u1793\u17BB\u1784 ${issue2.origin}`;
          default:
            return `\u1791\u17B7\u1793\u17D2\u1793\u1793\u17D0\u1799\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C`;
        }
      };
    };
  }
});

// node_modules/zod/v4/locales/kh.js
function kh_default() {
  return km_default();
}
var init_kh = __esm({
  "node_modules/zod/v4/locales/kh.js"() {
    init_km();
  }
});

// node_modules/zod/v4/locales/ko.js
function ko_default() {
  return {
    localeError: error24()
  };
}
var error24;
var init_ko = __esm({
  "node_modules/zod/v4/locales/ko.js"() {
    init_util();
    error24 = () => {
      const Sizable = {
        string: { unit: "\uBB38\uC790", verb: "to have" },
        file: { unit: "\uBC14\uC774\uD2B8", verb: "to have" },
        array: { unit: "\uAC1C", verb: "to have" },
        set: { unit: "\uAC1C", verb: "to have" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const parsedType8 = (data) => {
        const t = typeof data;
        switch (t) {
          case "number": {
            return Number.isNaN(data) ? "NaN" : "number";
          }
          case "object": {
            if (Array.isArray(data)) {
              return "array";
            }
            if (data === null) {
              return "null";
            }
            if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
              return data.constructor.name;
            }
          }
        }
        return t;
      };
      const Nouns = {
        regex: "\uC785\uB825",
        email: "\uC774\uBA54\uC77C \uC8FC\uC18C",
        url: "URL",
        emoji: "\uC774\uBAA8\uC9C0",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "ISO \uB0A0\uC9DC\uC2DC\uAC04",
        date: "ISO \uB0A0\uC9DC",
        time: "ISO \uC2DC\uAC04",
        duration: "ISO \uAE30\uAC04",
        ipv4: "IPv4 \uC8FC\uC18C",
        ipv6: "IPv6 \uC8FC\uC18C",
        cidrv4: "IPv4 \uBC94\uC704",
        cidrv6: "IPv6 \uBC94\uC704",
        base64: "base64 \uC778\uCF54\uB529 \uBB38\uC790\uC5F4",
        base64url: "base64url \uC778\uCF54\uB529 \uBB38\uC790\uC5F4",
        json_string: "JSON \uBB38\uC790\uC5F4",
        e164: "E.164 \uBC88\uD638",
        jwt: "JWT",
        template_literal: "\uC785\uB825"
      };
      return (issue2) => {
        switch (issue2.code) {
          case "invalid_type":
            return `\uC798\uBABB\uB41C \uC785\uB825: \uC608\uC0C1 \uD0C0\uC785\uC740 ${issue2.expected}, \uBC1B\uC740 \uD0C0\uC785\uC740 ${parsedType8(issue2.input)}\uC785\uB2C8\uB2E4`;
          case "invalid_value":
            if (issue2.values.length === 1)
              return `\uC798\uBABB\uB41C \uC785\uB825: \uAC12\uC740 ${stringifyPrimitive(issue2.values[0])} \uC774\uC5B4\uC57C \uD569\uB2C8\uB2E4`;
            return `\uC798\uBABB\uB41C \uC635\uC158: ${joinValues(issue2.values, "\uB610\uB294 ")} \uC911 \uD558\uB098\uC5EC\uC57C \uD569\uB2C8\uB2E4`;
          case "too_big": {
            const adj = issue2.inclusive ? "\uC774\uD558" : "\uBBF8\uB9CC";
            const suffix = adj === "\uBBF8\uB9CC" ? "\uC774\uC5B4\uC57C \uD569\uB2C8\uB2E4" : "\uC5EC\uC57C \uD569\uB2C8\uB2E4";
            const sizing = getSizing(issue2.origin);
            const unit = sizing?.unit ?? "\uC694\uC18C";
            if (sizing)
              return `${issue2.origin ?? "\uAC12"}\uC774 \uB108\uBB34 \uD07D\uB2C8\uB2E4: ${issue2.maximum.toString()}${unit} ${adj}${suffix}`;
            return `${issue2.origin ?? "\uAC12"}\uC774 \uB108\uBB34 \uD07D\uB2C8\uB2E4: ${issue2.maximum.toString()} ${adj}${suffix}`;
          }
          case "too_small": {
            const adj = issue2.inclusive ? "\uC774\uC0C1" : "\uCD08\uACFC";
            const suffix = adj === "\uC774\uC0C1" ? "\uC774\uC5B4\uC57C \uD569\uB2C8\uB2E4" : "\uC5EC\uC57C \uD569\uB2C8\uB2E4";
            const sizing = getSizing(issue2.origin);
            const unit = sizing?.unit ?? "\uC694\uC18C";
            if (sizing) {
              return `${issue2.origin ?? "\uAC12"}\uC774 \uB108\uBB34 \uC791\uC2B5\uB2C8\uB2E4: ${issue2.minimum.toString()}${unit} ${adj}${suffix}`;
            }
            return `${issue2.origin ?? "\uAC12"}\uC774 \uB108\uBB34 \uC791\uC2B5\uB2C8\uB2E4: ${issue2.minimum.toString()} ${adj}${suffix}`;
          }
          case "invalid_format": {
            const _issue = issue2;
            if (_issue.format === "starts_with") {
              return `\uC798\uBABB\uB41C \uBB38\uC790\uC5F4: "${_issue.prefix}"(\uC73C)\uB85C \uC2DC\uC791\uD574\uC57C \uD569\uB2C8\uB2E4`;
            }
            if (_issue.format === "ends_with")
              return `\uC798\uBABB\uB41C \uBB38\uC790\uC5F4: "${_issue.suffix}"(\uC73C)\uB85C \uB05D\uB098\uC57C \uD569\uB2C8\uB2E4`;
            if (_issue.format === "includes")
              return `\uC798\uBABB\uB41C \uBB38\uC790\uC5F4: "${_issue.includes}"\uC744(\uB97C) \uD3EC\uD568\uD574\uC57C \uD569\uB2C8\uB2E4`;
            if (_issue.format === "regex")
              return `\uC798\uBABB\uB41C \uBB38\uC790\uC5F4: \uC815\uADDC\uC2DD ${_issue.pattern} \uD328\uD134\uACFC \uC77C\uCE58\uD574\uC57C \uD569\uB2C8\uB2E4`;
            return `\uC798\uBABB\uB41C ${Nouns[_issue.format] ?? issue2.format}`;
          }
          case "not_multiple_of":
            return `\uC798\uBABB\uB41C \uC22B\uC790: ${issue2.divisor}\uC758 \uBC30\uC218\uC5EC\uC57C \uD569\uB2C8\uB2E4`;
          case "unrecognized_keys":
            return `\uC778\uC2DD\uD560 \uC218 \uC5C6\uB294 \uD0A4: ${joinValues(issue2.keys, ", ")}`;
          case "invalid_key":
            return `\uC798\uBABB\uB41C \uD0A4: ${issue2.origin}`;
          case "invalid_union":
            return `\uC798\uBABB\uB41C \uC785\uB825`;
          case "invalid_element":
            return `\uC798\uBABB\uB41C \uAC12: ${issue2.origin}`;
          default:
            return `\uC798\uBABB\uB41C \uC785\uB825`;
        }
      };
    };
  }
});

// node_modules/zod/v4/locales/lt.js
function getUnitTypeFromNumber(number4) {
  const abs = Math.abs(number4);
  const last = abs % 10;
  const last2 = abs % 100;
  if (last2 >= 11 && last2 <= 19 || last === 0)
    return "many";
  if (last === 1)
    return "one";
  return "few";
}
function lt_default() {
  return {
    localeError: error25()
  };
}
var parsedType6, parsedTypeFromType, capitalizeFirstCharacter, error25;
var init_lt = __esm({
  "node_modules/zod/v4/locales/lt.js"() {
    init_util();
    parsedType6 = (data) => {
      const t = typeof data;
      return parsedTypeFromType(t, data);
    };
    parsedTypeFromType = (t, data = void 0) => {
      switch (t) {
        case "number": {
          return Number.isNaN(data) ? "NaN" : "skai\u010Dius";
        }
        case "bigint": {
          return "sveikasis skai\u010Dius";
        }
        case "string": {
          return "eilut\u0117";
        }
        case "boolean": {
          return "login\u0117 reik\u0161m\u0117";
        }
        case "undefined":
        case "void": {
          return "neapibr\u0117\u017Eta reik\u0161m\u0117";
        }
        case "function": {
          return "funkcija";
        }
        case "symbol": {
          return "simbolis";
        }
        case "object": {
          if (data === void 0)
            return "ne\u017Einomas objektas";
          if (data === null)
            return "nulin\u0117 reik\u0161m\u0117";
          if (Array.isArray(data))
            return "masyvas";
          if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
            return data.constructor.name;
          }
          return "objektas";
        }
        //Zod types below
        case "null": {
          return "nulin\u0117 reik\u0161m\u0117";
        }
      }
      return t;
    };
    capitalizeFirstCharacter = (text) => {
      return text.charAt(0).toUpperCase() + text.slice(1);
    };
    error25 = () => {
      const Sizable = {
        string: {
          unit: {
            one: "simbolis",
            few: "simboliai",
            many: "simboli\u0173"
          },
          verb: {
            smaller: {
              inclusive: "turi b\u016Bti ne ilgesn\u0117 kaip",
              notInclusive: "turi b\u016Bti trumpesn\u0117 kaip"
            },
            bigger: {
              inclusive: "turi b\u016Bti ne trumpesn\u0117 kaip",
              notInclusive: "turi b\u016Bti ilgesn\u0117 kaip"
            }
          }
        },
        file: {
          unit: {
            one: "baitas",
            few: "baitai",
            many: "bait\u0173"
          },
          verb: {
            smaller: {
              inclusive: "turi b\u016Bti ne didesnis kaip",
              notInclusive: "turi b\u016Bti ma\u017Eesnis kaip"
            },
            bigger: {
              inclusive: "turi b\u016Bti ne ma\u017Eesnis kaip",
              notInclusive: "turi b\u016Bti didesnis kaip"
            }
          }
        },
        array: {
          unit: {
            one: "element\u0105",
            few: "elementus",
            many: "element\u0173"
          },
          verb: {
            smaller: {
              inclusive: "turi tur\u0117ti ne daugiau kaip",
              notInclusive: "turi tur\u0117ti ma\u017Eiau kaip"
            },
            bigger: {
              inclusive: "turi tur\u0117ti ne ma\u017Eiau kaip",
              notInclusive: "turi tur\u0117ti daugiau kaip"
            }
          }
        },
        set: {
          unit: {
            one: "element\u0105",
            few: "elementus",
            many: "element\u0173"
          },
          verb: {
            smaller: {
              inclusive: "turi tur\u0117ti ne daugiau kaip",
              notInclusive: "turi tur\u0117ti ma\u017Eiau kaip"
            },
            bigger: {
              inclusive: "turi tur\u0117ti ne ma\u017Eiau kaip",
              notInclusive: "turi tur\u0117ti daugiau kaip"
            }
          }
        }
      };
      function getSizing(origin, unitType, inclusive, targetShouldBe) {
        const result = Sizable[origin] ?? null;
        if (result === null)
          return result;
        return {
          unit: result.unit[unitType],
          verb: result.verb[targetShouldBe][inclusive ? "inclusive" : "notInclusive"]
        };
      }
      const Nouns = {
        regex: "\u012Fvestis",
        email: "el. pa\u0161to adresas",
        url: "URL",
        emoji: "jaustukas",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "ISO data ir laikas",
        date: "ISO data",
        time: "ISO laikas",
        duration: "ISO trukm\u0117",
        ipv4: "IPv4 adresas",
        ipv6: "IPv6 adresas",
        cidrv4: "IPv4 tinklo prefiksas (CIDR)",
        cidrv6: "IPv6 tinklo prefiksas (CIDR)",
        base64: "base64 u\u017Ekoduota eilut\u0117",
        base64url: "base64url u\u017Ekoduota eilut\u0117",
        json_string: "JSON eilut\u0117",
        e164: "E.164 numeris",
        jwt: "JWT",
        template_literal: "\u012Fvestis"
      };
      return (issue2) => {
        switch (issue2.code) {
          case "invalid_type":
            return `Gautas tipas ${parsedType6(issue2.input)}, o tik\u0117tasi - ${parsedTypeFromType(issue2.expected)}`;
          case "invalid_value":
            if (issue2.values.length === 1)
              return `Privalo b\u016Bti ${stringifyPrimitive(issue2.values[0])}`;
            return `Privalo b\u016Bti vienas i\u0161 ${joinValues(issue2.values, "|")} pasirinkim\u0173`;
          case "too_big": {
            const origin = parsedTypeFromType(issue2.origin);
            const sizing = getSizing(issue2.origin, getUnitTypeFromNumber(Number(issue2.maximum)), issue2.inclusive ?? false, "smaller");
            if (sizing?.verb)
              return `${capitalizeFirstCharacter(origin ?? issue2.origin ?? "reik\u0161m\u0117")} ${sizing.verb} ${issue2.maximum.toString()} ${sizing.unit ?? "element\u0173"}`;
            const adj = issue2.inclusive ? "ne didesnis kaip" : "ma\u017Eesnis kaip";
            return `${capitalizeFirstCharacter(origin ?? issue2.origin ?? "reik\u0161m\u0117")} turi b\u016Bti ${adj} ${issue2.maximum.toString()} ${sizing?.unit}`;
          }
          case "too_small": {
            const origin = parsedTypeFromType(issue2.origin);
            const sizing = getSizing(issue2.origin, getUnitTypeFromNumber(Number(issue2.minimum)), issue2.inclusive ?? false, "bigger");
            if (sizing?.verb)
              return `${capitalizeFirstCharacter(origin ?? issue2.origin ?? "reik\u0161m\u0117")} ${sizing.verb} ${issue2.minimum.toString()} ${sizing.unit ?? "element\u0173"}`;
            const adj = issue2.inclusive ? "ne ma\u017Eesnis kaip" : "didesnis kaip";
            return `${capitalizeFirstCharacter(origin ?? issue2.origin ?? "reik\u0161m\u0117")} turi b\u016Bti ${adj} ${issue2.minimum.toString()} ${sizing?.unit}`;
          }
          case "invalid_format": {
            const _issue = issue2;
            if (_issue.format === "starts_with") {
              return `Eilut\u0117 privalo prasid\u0117ti "${_issue.prefix}"`;
            }
            if (_issue.format === "ends_with")
              return `Eilut\u0117 privalo pasibaigti "${_issue.suffix}"`;
            if (_issue.format === "includes")
              return `Eilut\u0117 privalo \u012Ftraukti "${_issue.includes}"`;
            if (_issue.format === "regex")
              return `Eilut\u0117 privalo atitikti ${_issue.pattern}`;
            return `Neteisingas ${Nouns[_issue.format] ?? issue2.format}`;
          }
          case "not_multiple_of":
            return `Skai\u010Dius privalo b\u016Bti ${issue2.divisor} kartotinis.`;
          case "unrecognized_keys":
            return `Neatpa\u017Eint${issue2.keys.length > 1 ? "i" : "as"} rakt${issue2.keys.length > 1 ? "ai" : "as"}: ${joinValues(issue2.keys, ", ")}`;
          case "invalid_key":
            return "Rastas klaidingas raktas";
          case "invalid_union":
            return "Klaidinga \u012Fvestis";
          case "invalid_element": {
            const origin = parsedTypeFromType(issue2.origin);
            return `${capitalizeFirstCharacter(origin ?? issue2.origin ?? "reik\u0161m\u0117")} turi klaiding\u0105 \u012Fvest\u012F`;
          }
          default:
            return "Klaidinga \u012Fvestis";
        }
      };
    };
  }
});

// node_modules/zod/v4/locales/mk.js
function mk_default() {
  return {
    localeError: error26()
  };
}
var error26;
var init_mk = __esm({
  "node_modules/zod/v4/locales/mk.js"() {
    init_util();
    error26 = () => {
      const Sizable = {
        string: { unit: "\u0437\u043D\u0430\u0446\u0438", verb: "\u0434\u0430 \u0438\u043C\u0430\u0430\u0442" },
        file: { unit: "\u0431\u0430\u0458\u0442\u0438", verb: "\u0434\u0430 \u0438\u043C\u0430\u0430\u0442" },
        array: { unit: "\u0441\u0442\u0430\u0432\u043A\u0438", verb: "\u0434\u0430 \u0438\u043C\u0430\u0430\u0442" },
        set: { unit: "\u0441\u0442\u0430\u0432\u043A\u0438", verb: "\u0434\u0430 \u0438\u043C\u0430\u0430\u0442" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const parsedType8 = (data) => {
        const t = typeof data;
        switch (t) {
          case "number": {
            return Number.isNaN(data) ? "NaN" : "\u0431\u0440\u043E\u0458";
          }
          case "object": {
            if (Array.isArray(data)) {
              return "\u043D\u0438\u0437\u0430";
            }
            if (data === null) {
              return "null";
            }
            if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
              return data.constructor.name;
            }
          }
        }
        return t;
      };
      const Nouns = {
        regex: "\u0432\u043D\u0435\u0441",
        email: "\u0430\u0434\u0440\u0435\u0441\u0430 \u043D\u0430 \u0435-\u043F\u043E\u0448\u0442\u0430",
        url: "URL",
        emoji: "\u0435\u043C\u043E\u045F\u0438",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "ISO \u0434\u0430\u0442\u0443\u043C \u0438 \u0432\u0440\u0435\u043C\u0435",
        date: "ISO \u0434\u0430\u0442\u0443\u043C",
        time: "ISO \u0432\u0440\u0435\u043C\u0435",
        duration: "ISO \u0432\u0440\u0435\u043C\u0435\u0442\u0440\u0430\u0435\u045A\u0435",
        ipv4: "IPv4 \u0430\u0434\u0440\u0435\u0441\u0430",
        ipv6: "IPv6 \u0430\u0434\u0440\u0435\u0441\u0430",
        cidrv4: "IPv4 \u043E\u043F\u0441\u0435\u0433",
        cidrv6: "IPv6 \u043E\u043F\u0441\u0435\u0433",
        base64: "base64-\u0435\u043D\u043A\u043E\u0434\u0438\u0440\u0430\u043D\u0430 \u043D\u0438\u0437\u0430",
        base64url: "base64url-\u0435\u043D\u043A\u043E\u0434\u0438\u0440\u0430\u043D\u0430 \u043D\u0438\u0437\u0430",
        json_string: "JSON \u043D\u0438\u0437\u0430",
        e164: "E.164 \u0431\u0440\u043E\u0458",
        jwt: "JWT",
        template_literal: "\u0432\u043D\u0435\u0441"
      };
      return (issue2) => {
        switch (issue2.code) {
          case "invalid_type":
            return `\u0413\u0440\u0435\u0448\u0435\u043D \u0432\u043D\u0435\u0441: \u0441\u0435 \u043E\u0447\u0435\u043A\u0443\u0432\u0430 ${issue2.expected}, \u043F\u0440\u0438\u043C\u0435\u043D\u043E ${parsedType8(issue2.input)}`;
          // return `Invalid input: expected ${issue.expected}, received ${util.getParsedType(issue.input)}`;
          case "invalid_value":
            if (issue2.values.length === 1)
              return `Invalid input: expected ${stringifyPrimitive(issue2.values[0])}`;
            return `\u0413\u0440\u0435\u0448\u0430\u043D\u0430 \u043E\u043F\u0446\u0438\u0458\u0430: \u0441\u0435 \u043E\u0447\u0435\u043A\u0443\u0432\u0430 \u0435\u0434\u043D\u0430 ${joinValues(issue2.values, "|")}`;
          case "too_big": {
            const adj = issue2.inclusive ? "<=" : "<";
            const sizing = getSizing(issue2.origin);
            if (sizing)
              return `\u041F\u0440\u0435\u043C\u043D\u043E\u0433\u0443 \u0433\u043E\u043B\u0435\u043C: \u0441\u0435 \u043E\u0447\u0435\u043A\u0443\u0432\u0430 ${issue2.origin ?? "\u0432\u0440\u0435\u0434\u043D\u043E\u0441\u0442\u0430"} \u0434\u0430 \u0438\u043C\u0430 ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "\u0435\u043B\u0435\u043C\u0435\u043D\u0442\u0438"}`;
            return `\u041F\u0440\u0435\u043C\u043D\u043E\u0433\u0443 \u0433\u043E\u043B\u0435\u043C: \u0441\u0435 \u043E\u0447\u0435\u043A\u0443\u0432\u0430 ${issue2.origin ?? "\u0432\u0440\u0435\u0434\u043D\u043E\u0441\u0442\u0430"} \u0434\u0430 \u0431\u0438\u0434\u0435 ${adj}${issue2.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue2.inclusive ? ">=" : ">";
            const sizing = getSizing(issue2.origin);
            if (sizing) {
              return `\u041F\u0440\u0435\u043C\u043D\u043E\u0433\u0443 \u043C\u0430\u043B: \u0441\u0435 \u043E\u0447\u0435\u043A\u0443\u0432\u0430 ${issue2.origin} \u0434\u0430 \u0438\u043C\u0430 ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
            }
            return `\u041F\u0440\u0435\u043C\u043D\u043E\u0433\u0443 \u043C\u0430\u043B: \u0441\u0435 \u043E\u0447\u0435\u043A\u0443\u0432\u0430 ${issue2.origin} \u0434\u0430 \u0431\u0438\u0434\u0435 ${adj}${issue2.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue2;
            if (_issue.format === "starts_with") {
              return `\u041D\u0435\u0432\u0430\u0436\u0435\u0447\u043A\u0430 \u043D\u0438\u0437\u0430: \u043C\u043E\u0440\u0430 \u0434\u0430 \u0437\u0430\u043F\u043E\u0447\u043D\u0443\u0432\u0430 \u0441\u043E "${_issue.prefix}"`;
            }
            if (_issue.format === "ends_with")
              return `\u041D\u0435\u0432\u0430\u0436\u0435\u0447\u043A\u0430 \u043D\u0438\u0437\u0430: \u043C\u043E\u0440\u0430 \u0434\u0430 \u0437\u0430\u0432\u0440\u0448\u0443\u0432\u0430 \u0441\u043E "${_issue.suffix}"`;
            if (_issue.format === "includes")
              return `\u041D\u0435\u0432\u0430\u0436\u0435\u0447\u043A\u0430 \u043D\u0438\u0437\u0430: \u043C\u043E\u0440\u0430 \u0434\u0430 \u0432\u043A\u043B\u0443\u0447\u0443\u0432\u0430 "${_issue.includes}"`;
            if (_issue.format === "regex")
              return `\u041D\u0435\u0432\u0430\u0436\u0435\u0447\u043A\u0430 \u043D\u0438\u0437\u0430: \u043C\u043E\u0440\u0430 \u0434\u0430 \u043E\u0434\u0433\u043E\u0430\u0440\u0430 \u043D\u0430 \u043F\u0430\u0442\u0435\u0440\u043D\u043E\u0442 ${_issue.pattern}`;
            return `Invalid ${Nouns[_issue.format] ?? issue2.format}`;
          }
          case "not_multiple_of":
            return `\u0413\u0440\u0435\u0448\u0435\u043D \u0431\u0440\u043E\u0458: \u043C\u043E\u0440\u0430 \u0434\u0430 \u0431\u0438\u0434\u0435 \u0434\u0435\u043B\u0438\u0432 \u0441\u043E ${issue2.divisor}`;
          case "unrecognized_keys":
            return `${issue2.keys.length > 1 ? "\u041D\u0435\u043F\u0440\u0435\u043F\u043E\u0437\u043D\u0430\u0435\u043D\u0438 \u043A\u043B\u0443\u0447\u0435\u0432\u0438" : "\u041D\u0435\u043F\u0440\u0435\u043F\u043E\u0437\u043D\u0430\u0435\u043D \u043A\u043B\u0443\u0447"}: ${joinValues(issue2.keys, ", ")}`;
          case "invalid_key":
            return `\u0413\u0440\u0435\u0448\u0435\u043D \u043A\u043B\u0443\u0447 \u0432\u043E ${issue2.origin}`;
          case "invalid_union":
            return "\u0413\u0440\u0435\u0448\u0435\u043D \u0432\u043D\u0435\u0441";
          case "invalid_element":
            return `\u0413\u0440\u0435\u0448\u043D\u0430 \u0432\u0440\u0435\u0434\u043D\u043E\u0441\u0442 \u0432\u043E ${issue2.origin}`;
          default:
            return `\u0413\u0440\u0435\u0448\u0435\u043D \u0432\u043D\u0435\u0441`;
        }
      };
    };
  }
});

// node_modules/zod/v4/locales/ms.js
function ms_default() {
  return {
    localeError: error27()
  };
}
var error27;
var init_ms = __esm({
  "node_modules/zod/v4/locales/ms.js"() {
    init_util();
    error27 = () => {
      const Sizable = {
        string: { unit: "aksara", verb: "mempunyai" },
        file: { unit: "bait", verb: "mempunyai" },
        array: { unit: "elemen", verb: "mempunyai" },
        set: { unit: "elemen", verb: "mempunyai" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const parsedType8 = (data) => {
        const t = typeof data;
        switch (t) {
          case "number": {
            return Number.isNaN(data) ? "NaN" : "nombor";
          }
          case "object": {
            if (Array.isArray(data)) {
              return "array";
            }
            if (data === null) {
              return "null";
            }
            if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
              return data.constructor.name;
            }
          }
        }
        return t;
      };
      const Nouns = {
        regex: "input",
        email: "alamat e-mel",
        url: "URL",
        emoji: "emoji",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "tarikh masa ISO",
        date: "tarikh ISO",
        time: "masa ISO",
        duration: "tempoh ISO",
        ipv4: "alamat IPv4",
        ipv6: "alamat IPv6",
        cidrv4: "julat IPv4",
        cidrv6: "julat IPv6",
        base64: "string dikodkan base64",
        base64url: "string dikodkan base64url",
        json_string: "string JSON",
        e164: "nombor E.164",
        jwt: "JWT",
        template_literal: "input"
      };
      return (issue2) => {
        switch (issue2.code) {
          case "invalid_type":
            return `Input tidak sah: dijangka ${issue2.expected}, diterima ${parsedType8(issue2.input)}`;
          case "invalid_value":
            if (issue2.values.length === 1)
              return `Input tidak sah: dijangka ${stringifyPrimitive(issue2.values[0])}`;
            return `Pilihan tidak sah: dijangka salah satu daripada ${joinValues(issue2.values, "|")}`;
          case "too_big": {
            const adj = issue2.inclusive ? "<=" : "<";
            const sizing = getSizing(issue2.origin);
            if (sizing)
              return `Terlalu besar: dijangka ${issue2.origin ?? "nilai"} ${sizing.verb} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elemen"}`;
            return `Terlalu besar: dijangka ${issue2.origin ?? "nilai"} adalah ${adj}${issue2.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue2.inclusive ? ">=" : ">";
            const sizing = getSizing(issue2.origin);
            if (sizing) {
              return `Terlalu kecil: dijangka ${issue2.origin} ${sizing.verb} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
            }
            return `Terlalu kecil: dijangka ${issue2.origin} adalah ${adj}${issue2.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue2;
            if (_issue.format === "starts_with")
              return `String tidak sah: mesti bermula dengan "${_issue.prefix}"`;
            if (_issue.format === "ends_with")
              return `String tidak sah: mesti berakhir dengan "${_issue.suffix}"`;
            if (_issue.format === "includes")
              return `String tidak sah: mesti mengandungi "${_issue.includes}"`;
            if (_issue.format === "regex")
              return `String tidak sah: mesti sepadan dengan corak ${_issue.pattern}`;
            return `${Nouns[_issue.format] ?? issue2.format} tidak sah`;
          }
          case "not_multiple_of":
            return `Nombor tidak sah: perlu gandaan ${issue2.divisor}`;
          case "unrecognized_keys":
            return `Kunci tidak dikenali: ${joinValues(issue2.keys, ", ")}`;
          case "invalid_key":
            return `Kunci tidak sah dalam ${issue2.origin}`;
          case "invalid_union":
            return "Input tidak sah";
          case "invalid_element":
            return `Nilai tidak sah dalam ${issue2.origin}`;
          default:
            return `Input tidak sah`;
        }
      };
    };
  }
});

// node_modules/zod/v4/locales/nl.js
function nl_default() {
  return {
    localeError: error28()
  };
}
var error28;
var init_nl = __esm({
  "node_modules/zod/v4/locales/nl.js"() {
    init_util();
    error28 = () => {
      const Sizable = {
        string: { unit: "tekens" },
        file: { unit: "bytes" },
        array: { unit: "elementen" },
        set: { unit: "elementen" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const parsedType8 = (data) => {
        const t = typeof data;
        switch (t) {
          case "number": {
            return Number.isNaN(data) ? "NaN" : "getal";
          }
          case "object": {
            if (Array.isArray(data)) {
              return "array";
            }
            if (data === null) {
              return "null";
            }
            if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
              return data.constructor.name;
            }
          }
        }
        return t;
      };
      const Nouns = {
        regex: "invoer",
        email: "emailadres",
        url: "URL",
        emoji: "emoji",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "ISO datum en tijd",
        date: "ISO datum",
        time: "ISO tijd",
        duration: "ISO duur",
        ipv4: "IPv4-adres",
        ipv6: "IPv6-adres",
        cidrv4: "IPv4-bereik",
        cidrv6: "IPv6-bereik",
        base64: "base64-gecodeerde tekst",
        base64url: "base64 URL-gecodeerde tekst",
        json_string: "JSON string",
        e164: "E.164-nummer",
        jwt: "JWT",
        template_literal: "invoer"
      };
      return (issue2) => {
        switch (issue2.code) {
          case "invalid_type":
            return `Ongeldige invoer: verwacht ${issue2.expected}, ontving ${parsedType8(issue2.input)}`;
          case "invalid_value":
            if (issue2.values.length === 1)
              return `Ongeldige invoer: verwacht ${stringifyPrimitive(issue2.values[0])}`;
            return `Ongeldige optie: verwacht \xE9\xE9n van ${joinValues(issue2.values, "|")}`;
          case "too_big": {
            const adj = issue2.inclusive ? "<=" : "<";
            const sizing = getSizing(issue2.origin);
            if (sizing)
              return `Te lang: verwacht dat ${issue2.origin ?? "waarde"} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elementen"} bevat`;
            return `Te lang: verwacht dat ${issue2.origin ?? "waarde"} ${adj}${issue2.maximum.toString()} is`;
          }
          case "too_small": {
            const adj = issue2.inclusive ? ">=" : ">";
            const sizing = getSizing(issue2.origin);
            if (sizing) {
              return `Te kort: verwacht dat ${issue2.origin} ${adj}${issue2.minimum.toString()} ${sizing.unit} bevat`;
            }
            return `Te kort: verwacht dat ${issue2.origin} ${adj}${issue2.minimum.toString()} is`;
          }
          case "invalid_format": {
            const _issue = issue2;
            if (_issue.format === "starts_with") {
              return `Ongeldige tekst: moet met "${_issue.prefix}" beginnen`;
            }
            if (_issue.format === "ends_with")
              return `Ongeldige tekst: moet op "${_issue.suffix}" eindigen`;
            if (_issue.format === "includes")
              return `Ongeldige tekst: moet "${_issue.includes}" bevatten`;
            if (_issue.format === "regex")
              return `Ongeldige tekst: moet overeenkomen met patroon ${_issue.pattern}`;
            return `Ongeldig: ${Nouns[_issue.format] ?? issue2.format}`;
          }
          case "not_multiple_of":
            return `Ongeldig getal: moet een veelvoud van ${issue2.divisor} zijn`;
          case "unrecognized_keys":
            return `Onbekende key${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
          case "invalid_key":
            return `Ongeldige key in ${issue2.origin}`;
          case "invalid_union":
            return "Ongeldige invoer";
          case "invalid_element":
            return `Ongeldige waarde in ${issue2.origin}`;
          default:
            return `Ongeldige invoer`;
        }
      };
    };
  }
});

// node_modules/zod/v4/locales/no.js
function no_default() {
  return {
    localeError: error29()
  };
}
var error29;
var init_no = __esm({
  "node_modules/zod/v4/locales/no.js"() {
    init_util();
    error29 = () => {
      const Sizable = {
        string: { unit: "tegn", verb: "\xE5 ha" },
        file: { unit: "bytes", verb: "\xE5 ha" },
        array: { unit: "elementer", verb: "\xE5 inneholde" },
        set: { unit: "elementer", verb: "\xE5 inneholde" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const parsedType8 = (data) => {
        const t = typeof data;
        switch (t) {
          case "number": {
            return Number.isNaN(data) ? "NaN" : "tall";
          }
          case "object": {
            if (Array.isArray(data)) {
              return "liste";
            }
            if (data === null) {
              return "null";
            }
            if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
              return data.constructor.name;
            }
          }
        }
        return t;
      };
      const Nouns = {
        regex: "input",
        email: "e-postadresse",
        url: "URL",
        emoji: "emoji",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "ISO dato- og klokkeslett",
        date: "ISO-dato",
        time: "ISO-klokkeslett",
        duration: "ISO-varighet",
        ipv4: "IPv4-omr\xE5de",
        ipv6: "IPv6-omr\xE5de",
        cidrv4: "IPv4-spekter",
        cidrv6: "IPv6-spekter",
        base64: "base64-enkodet streng",
        base64url: "base64url-enkodet streng",
        json_string: "JSON-streng",
        e164: "E.164-nummer",
        jwt: "JWT",
        template_literal: "input"
      };
      return (issue2) => {
        switch (issue2.code) {
          case "invalid_type":
            return `Ugyldig input: forventet ${issue2.expected}, fikk ${parsedType8(issue2.input)}`;
          case "invalid_value":
            if (issue2.values.length === 1)
              return `Ugyldig verdi: forventet ${stringifyPrimitive(issue2.values[0])}`;
            return `Ugyldig valg: forventet en av ${joinValues(issue2.values, "|")}`;
          case "too_big": {
            const adj = issue2.inclusive ? "<=" : "<";
            const sizing = getSizing(issue2.origin);
            if (sizing)
              return `For stor(t): forventet ${issue2.origin ?? "value"} til \xE5 ha ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elementer"}`;
            return `For stor(t): forventet ${issue2.origin ?? "value"} til \xE5 ha ${adj}${issue2.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue2.inclusive ? ">=" : ">";
            const sizing = getSizing(issue2.origin);
            if (sizing) {
              return `For lite(n): forventet ${issue2.origin} til \xE5 ha ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
            }
            return `For lite(n): forventet ${issue2.origin} til \xE5 ha ${adj}${issue2.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue2;
            if (_issue.format === "starts_with")
              return `Ugyldig streng: m\xE5 starte med "${_issue.prefix}"`;
            if (_issue.format === "ends_with")
              return `Ugyldig streng: m\xE5 ende med "${_issue.suffix}"`;
            if (_issue.format === "includes")
              return `Ugyldig streng: m\xE5 inneholde "${_issue.includes}"`;
            if (_issue.format === "regex")
              return `Ugyldig streng: m\xE5 matche m\xF8nsteret ${_issue.pattern}`;
            return `Ugyldig ${Nouns[_issue.format] ?? issue2.format}`;
          }
          case "not_multiple_of":
            return `Ugyldig tall: m\xE5 v\xE6re et multiplum av ${issue2.divisor}`;
          case "unrecognized_keys":
            return `${issue2.keys.length > 1 ? "Ukjente n\xF8kler" : "Ukjent n\xF8kkel"}: ${joinValues(issue2.keys, ", ")}`;
          case "invalid_key":
            return `Ugyldig n\xF8kkel i ${issue2.origin}`;
          case "invalid_union":
            return "Ugyldig input";
          case "invalid_element":
            return `Ugyldig verdi i ${issue2.origin}`;
          default:
            return `Ugyldig input`;
        }
      };
    };
  }
});

// node_modules/zod/v4/locales/ota.js
function ota_default() {
  return {
    localeError: error30()
  };
}
var error30;
var init_ota = __esm({
  "node_modules/zod/v4/locales/ota.js"() {
    init_util();
    error30 = () => {
      const Sizable = {
        string: { unit: "harf", verb: "olmal\u0131d\u0131r" },
        file: { unit: "bayt", verb: "olmal\u0131d\u0131r" },
        array: { unit: "unsur", verb: "olmal\u0131d\u0131r" },
        set: { unit: "unsur", verb: "olmal\u0131d\u0131r" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const parsedType8 = (data) => {
        const t = typeof data;
        switch (t) {
          case "number": {
            return Number.isNaN(data) ? "NaN" : "numara";
          }
          case "object": {
            if (Array.isArray(data)) {
              return "saf";
            }
            if (data === null) {
              return "gayb";
            }
            if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
              return data.constructor.name;
            }
          }
        }
        return t;
      };
      const Nouns = {
        regex: "giren",
        email: "epostag\xE2h",
        url: "URL",
        emoji: "emoji",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "ISO heng\xE2m\u0131",
        date: "ISO tarihi",
        time: "ISO zaman\u0131",
        duration: "ISO m\xFCddeti",
        ipv4: "IPv4 ni\u015F\xE2n\u0131",
        ipv6: "IPv6 ni\u015F\xE2n\u0131",
        cidrv4: "IPv4 menzili",
        cidrv6: "IPv6 menzili",
        base64: "base64-\u015Fifreli metin",
        base64url: "base64url-\u015Fifreli metin",
        json_string: "JSON metin",
        e164: "E.164 say\u0131s\u0131",
        jwt: "JWT",
        template_literal: "giren"
      };
      return (issue2) => {
        switch (issue2.code) {
          case "invalid_type":
            return `F\xE2sit giren: umulan ${issue2.expected}, al\u0131nan ${parsedType8(issue2.input)}`;
          // return `Fsit giren: umulan ${issue.expected}, alnan ${util.getParsedType(issue.input)}`;
          case "invalid_value":
            if (issue2.values.length === 1)
              return `F\xE2sit giren: umulan ${stringifyPrimitive(issue2.values[0])}`;
            return `F\xE2sit tercih: m\xFBteberler ${joinValues(issue2.values, "|")}`;
          case "too_big": {
            const adj = issue2.inclusive ? "<=" : "<";
            const sizing = getSizing(issue2.origin);
            if (sizing)
              return `Fazla b\xFCy\xFCk: ${issue2.origin ?? "value"}, ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elements"} sahip olmal\u0131yd\u0131.`;
            return `Fazla b\xFCy\xFCk: ${issue2.origin ?? "value"}, ${adj}${issue2.maximum.toString()} olmal\u0131yd\u0131.`;
          }
          case "too_small": {
            const adj = issue2.inclusive ? ">=" : ">";
            const sizing = getSizing(issue2.origin);
            if (sizing) {
              return `Fazla k\xFC\xE7\xFCk: ${issue2.origin}, ${adj}${issue2.minimum.toString()} ${sizing.unit} sahip olmal\u0131yd\u0131.`;
            }
            return `Fazla k\xFC\xE7\xFCk: ${issue2.origin}, ${adj}${issue2.minimum.toString()} olmal\u0131yd\u0131.`;
          }
          case "invalid_format": {
            const _issue = issue2;
            if (_issue.format === "starts_with")
              return `F\xE2sit metin: "${_issue.prefix}" ile ba\u015Flamal\u0131.`;
            if (_issue.format === "ends_with")
              return `F\xE2sit metin: "${_issue.suffix}" ile bitmeli.`;
            if (_issue.format === "includes")
              return `F\xE2sit metin: "${_issue.includes}" ihtiv\xE2 etmeli.`;
            if (_issue.format === "regex")
              return `F\xE2sit metin: ${_issue.pattern} nak\u015F\u0131na uymal\u0131.`;
            return `F\xE2sit ${Nouns[_issue.format] ?? issue2.format}`;
          }
          case "not_multiple_of":
            return `F\xE2sit say\u0131: ${issue2.divisor} kat\u0131 olmal\u0131yd\u0131.`;
          case "unrecognized_keys":
            return `Tan\u0131nmayan anahtar ${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
          case "invalid_key":
            return `${issue2.origin} i\xE7in tan\u0131nmayan anahtar var.`;
          case "invalid_union":
            return "Giren tan\u0131namad\u0131.";
          case "invalid_element":
            return `${issue2.origin} i\xE7in tan\u0131nmayan k\u0131ymet var.`;
          default:
            return `K\u0131ymet tan\u0131namad\u0131.`;
        }
      };
    };
  }
});

// node_modules/zod/v4/locales/ps.js
function ps_default() {
  return {
    localeError: error31()
  };
}
var error31;
var init_ps = __esm({
  "node_modules/zod/v4/locales/ps.js"() {
    init_util();
    error31 = () => {
      const Sizable = {
        string: { unit: "\u062A\u0648\u06A9\u064A", verb: "\u0648\u0644\u0631\u064A" },
        file: { unit: "\u0628\u0627\u06CC\u067C\u0633", verb: "\u0648\u0644\u0631\u064A" },
        array: { unit: "\u062A\u0648\u06A9\u064A", verb: "\u0648\u0644\u0631\u064A" },
        set: { unit: "\u062A\u0648\u06A9\u064A", verb: "\u0648\u0644\u0631\u064A" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const parsedType8 = (data) => {
        const t = typeof data;
        switch (t) {
          case "number": {
            return Number.isNaN(data) ? "NaN" : "\u0639\u062F\u062F";
          }
          case "object": {
            if (Array.isArray(data)) {
              return "\u0627\u0631\u06D0";
            }
            if (data === null) {
              return "null";
            }
            if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
              return data.constructor.name;
            }
          }
        }
        return t;
      };
      const Nouns = {
        regex: "\u0648\u0631\u0648\u062F\u064A",
        email: "\u0628\u0631\u06CC\u069A\u0646\u0627\u0644\u06CC\u06A9",
        url: "\u06CC\u0648 \u0622\u0631 \u0627\u0644",
        emoji: "\u0627\u06CC\u0645\u0648\u062C\u064A",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "\u0646\u06CC\u067C\u0647 \u0627\u0648 \u0648\u062E\u062A",
        date: "\u0646\u06D0\u067C\u0647",
        time: "\u0648\u062E\u062A",
        duration: "\u0645\u0648\u062F\u0647",
        ipv4: "\u062F IPv4 \u067E\u062A\u0647",
        ipv6: "\u062F IPv6 \u067E\u062A\u0647",
        cidrv4: "\u062F IPv4 \u0633\u0627\u062D\u0647",
        cidrv6: "\u062F IPv6 \u0633\u0627\u062D\u0647",
        base64: "base64-encoded \u0645\u062A\u0646",
        base64url: "base64url-encoded \u0645\u062A\u0646",
        json_string: "JSON \u0645\u062A\u0646",
        e164: "\u062F E.164 \u0634\u0645\u06D0\u0631\u0647",
        jwt: "JWT",
        template_literal: "\u0648\u0631\u0648\u062F\u064A"
      };
      return (issue2) => {
        switch (issue2.code) {
          case "invalid_type":
            return `\u0646\u0627\u0633\u0645 \u0648\u0631\u0648\u062F\u064A: \u0628\u0627\u06CC\u062F ${issue2.expected} \u0648\u0627\u06CC, \u0645\u06AB\u0631 ${parsedType8(issue2.input)} \u062A\u0631\u0644\u0627\u0633\u0647 \u0634\u0648`;
          case "invalid_value":
            if (issue2.values.length === 1) {
              return `\u0646\u0627\u0633\u0645 \u0648\u0631\u0648\u062F\u064A: \u0628\u0627\u06CC\u062F ${stringifyPrimitive(issue2.values[0])} \u0648\u0627\u06CC`;
            }
            return `\u0646\u0627\u0633\u0645 \u0627\u0646\u062A\u062E\u0627\u0628: \u0628\u0627\u06CC\u062F \u06CC\u0648 \u0644\u0647 ${joinValues(issue2.values, "|")} \u0685\u062E\u0647 \u0648\u0627\u06CC`;
          case "too_big": {
            const adj = issue2.inclusive ? "<=" : "<";
            const sizing = getSizing(issue2.origin);
            if (sizing) {
              return `\u0689\u06CC\u0631 \u0644\u0648\u06CC: ${issue2.origin ?? "\u0627\u0631\u0632\u069A\u062A"} \u0628\u0627\u06CC\u062F ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "\u0639\u0646\u0635\u0631\u0648\u0646\u0647"} \u0648\u0644\u0631\u064A`;
            }
            return `\u0689\u06CC\u0631 \u0644\u0648\u06CC: ${issue2.origin ?? "\u0627\u0631\u0632\u069A\u062A"} \u0628\u0627\u06CC\u062F ${adj}${issue2.maximum.toString()} \u0648\u064A`;
          }
          case "too_small": {
            const adj = issue2.inclusive ? ">=" : ">";
            const sizing = getSizing(issue2.origin);
            if (sizing) {
              return `\u0689\u06CC\u0631 \u06A9\u0648\u0686\u0646\u06CC: ${issue2.origin} \u0628\u0627\u06CC\u062F ${adj}${issue2.minimum.toString()} ${sizing.unit} \u0648\u0644\u0631\u064A`;
            }
            return `\u0689\u06CC\u0631 \u06A9\u0648\u0686\u0646\u06CC: ${issue2.origin} \u0628\u0627\u06CC\u062F ${adj}${issue2.minimum.toString()} \u0648\u064A`;
          }
          case "invalid_format": {
            const _issue = issue2;
            if (_issue.format === "starts_with") {
              return `\u0646\u0627\u0633\u0645 \u0645\u062A\u0646: \u0628\u0627\u06CC\u062F \u062F "${_issue.prefix}" \u0633\u0631\u0647 \u067E\u06CC\u0644 \u0634\u064A`;
            }
            if (_issue.format === "ends_with") {
              return `\u0646\u0627\u0633\u0645 \u0645\u062A\u0646: \u0628\u0627\u06CC\u062F \u062F "${_issue.suffix}" \u0633\u0631\u0647 \u067E\u0627\u06CC \u062A\u0647 \u0648\u0631\u0633\u064A\u0696\u064A`;
            }
            if (_issue.format === "includes") {
              return `\u0646\u0627\u0633\u0645 \u0645\u062A\u0646: \u0628\u0627\u06CC\u062F "${_issue.includes}" \u0648\u0644\u0631\u064A`;
            }
            if (_issue.format === "regex") {
              return `\u0646\u0627\u0633\u0645 \u0645\u062A\u0646: \u0628\u0627\u06CC\u062F \u062F ${_issue.pattern} \u0633\u0631\u0647 \u0645\u0637\u0627\u0628\u0642\u062A \u0648\u0644\u0631\u064A`;
            }
            return `${Nouns[_issue.format] ?? issue2.format} \u0646\u0627\u0633\u0645 \u062F\u06CC`;
          }
          case "not_multiple_of":
            return `\u0646\u0627\u0633\u0645 \u0639\u062F\u062F: \u0628\u0627\u06CC\u062F \u062F ${issue2.divisor} \u0645\u0636\u0631\u0628 \u0648\u064A`;
          case "unrecognized_keys":
            return `\u0646\u0627\u0633\u0645 ${issue2.keys.length > 1 ? "\u06A9\u0644\u06CC\u0689\u0648\u0646\u0647" : "\u06A9\u0644\u06CC\u0689"}: ${joinValues(issue2.keys, ", ")}`;
          case "invalid_key":
            return `\u0646\u0627\u0633\u0645 \u06A9\u0644\u06CC\u0689 \u067E\u0647 ${issue2.origin} \u06A9\u06D0`;
          case "invalid_union":
            return `\u0646\u0627\u0633\u0645\u0647 \u0648\u0631\u0648\u062F\u064A`;
          case "invalid_element":
            return `\u0646\u0627\u0633\u0645 \u0639\u0646\u0635\u0631 \u067E\u0647 ${issue2.origin} \u06A9\u06D0`;
          default:
            return `\u0646\u0627\u0633\u0645\u0647 \u0648\u0631\u0648\u062F\u064A`;
        }
      };
    };
  }
});

// node_modules/zod/v4/locales/pl.js
function pl_default() {
  return {
    localeError: error32()
  };
}
var error32;
var init_pl = __esm({
  "node_modules/zod/v4/locales/pl.js"() {
    init_util();
    error32 = () => {
      const Sizable = {
        string: { unit: "znak\xF3w", verb: "mie\u0107" },
        file: { unit: "bajt\xF3w", verb: "mie\u0107" },
        array: { unit: "element\xF3w", verb: "mie\u0107" },
        set: { unit: "element\xF3w", verb: "mie\u0107" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const parsedType8 = (data) => {
        const t = typeof data;
        switch (t) {
          case "number": {
            return Number.isNaN(data) ? "NaN" : "liczba";
          }
          case "object": {
            if (Array.isArray(data)) {
              return "tablica";
            }
            if (data === null) {
              return "null";
            }
            if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
              return data.constructor.name;
            }
          }
        }
        return t;
      };
      const Nouns = {
        regex: "wyra\u017Cenie",
        email: "adres email",
        url: "URL",
        emoji: "emoji",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "data i godzina w formacie ISO",
        date: "data w formacie ISO",
        time: "godzina w formacie ISO",
        duration: "czas trwania ISO",
        ipv4: "adres IPv4",
        ipv6: "adres IPv6",
        cidrv4: "zakres IPv4",
        cidrv6: "zakres IPv6",
        base64: "ci\u0105g znak\xF3w zakodowany w formacie base64",
        base64url: "ci\u0105g znak\xF3w zakodowany w formacie base64url",
        json_string: "ci\u0105g znak\xF3w w formacie JSON",
        e164: "liczba E.164",
        jwt: "JWT",
        template_literal: "wej\u015Bcie"
      };
      return (issue2) => {
        switch (issue2.code) {
          case "invalid_type":
            return `Nieprawid\u0142owe dane wej\u015Bciowe: oczekiwano ${issue2.expected}, otrzymano ${parsedType8(issue2.input)}`;
          case "invalid_value":
            if (issue2.values.length === 1)
              return `Nieprawid\u0142owe dane wej\u015Bciowe: oczekiwano ${stringifyPrimitive(issue2.values[0])}`;
            return `Nieprawid\u0142owa opcja: oczekiwano jednej z warto\u015Bci ${joinValues(issue2.values, "|")}`;
          case "too_big": {
            const adj = issue2.inclusive ? "<=" : "<";
            const sizing = getSizing(issue2.origin);
            if (sizing) {
              return `Za du\u017Ca warto\u015B\u0107: oczekiwano, \u017Ce ${issue2.origin ?? "warto\u015B\u0107"} b\u0119dzie mie\u0107 ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "element\xF3w"}`;
            }
            return `Zbyt du\u017C(y/a/e): oczekiwano, \u017Ce ${issue2.origin ?? "warto\u015B\u0107"} b\u0119dzie wynosi\u0107 ${adj}${issue2.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue2.inclusive ? ">=" : ">";
            const sizing = getSizing(issue2.origin);
            if (sizing) {
              return `Za ma\u0142a warto\u015B\u0107: oczekiwano, \u017Ce ${issue2.origin ?? "warto\u015B\u0107"} b\u0119dzie mie\u0107 ${adj}${issue2.minimum.toString()} ${sizing.unit ?? "element\xF3w"}`;
            }
            return `Zbyt ma\u0142(y/a/e): oczekiwano, \u017Ce ${issue2.origin ?? "warto\u015B\u0107"} b\u0119dzie wynosi\u0107 ${adj}${issue2.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue2;
            if (_issue.format === "starts_with")
              return `Nieprawid\u0142owy ci\u0105g znak\xF3w: musi zaczyna\u0107 si\u0119 od "${_issue.prefix}"`;
            if (_issue.format === "ends_with")
              return `Nieprawid\u0142owy ci\u0105g znak\xF3w: musi ko\u0144czy\u0107 si\u0119 na "${_issue.suffix}"`;
            if (_issue.format === "includes")
              return `Nieprawid\u0142owy ci\u0105g znak\xF3w: musi zawiera\u0107 "${_issue.includes}"`;
            if (_issue.format === "regex")
              return `Nieprawid\u0142owy ci\u0105g znak\xF3w: musi odpowiada\u0107 wzorcowi ${_issue.pattern}`;
            return `Nieprawid\u0142ow(y/a/e) ${Nouns[_issue.format] ?? issue2.format}`;
          }
          case "not_multiple_of":
            return `Nieprawid\u0142owa liczba: musi by\u0107 wielokrotno\u015Bci\u0105 ${issue2.divisor}`;
          case "unrecognized_keys":
            return `Nierozpoznane klucze${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
          case "invalid_key":
            return `Nieprawid\u0142owy klucz w ${issue2.origin}`;
          case "invalid_union":
            return "Nieprawid\u0142owe dane wej\u015Bciowe";
          case "invalid_element":
            return `Nieprawid\u0142owa warto\u015B\u0107 w ${issue2.origin}`;
          default:
            return `Nieprawid\u0142owe dane wej\u015Bciowe`;
        }
      };
    };
  }
});

// node_modules/zod/v4/locales/pt.js
function pt_default() {
  return {
    localeError: error33()
  };
}
var error33;
var init_pt = __esm({
  "node_modules/zod/v4/locales/pt.js"() {
    init_util();
    error33 = () => {
      const Sizable = {
        string: { unit: "caracteres", verb: "ter" },
        file: { unit: "bytes", verb: "ter" },
        array: { unit: "itens", verb: "ter" },
        set: { unit: "itens", verb: "ter" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const parsedType8 = (data) => {
        const t = typeof data;
        switch (t) {
          case "number": {
            return Number.isNaN(data) ? "NaN" : "n\xFAmero";
          }
          case "object": {
            if (Array.isArray(data)) {
              return "array";
            }
            if (data === null) {
              return "nulo";
            }
            if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
              return data.constructor.name;
            }
          }
        }
        return t;
      };
      const Nouns = {
        regex: "padr\xE3o",
        email: "endere\xE7o de e-mail",
        url: "URL",
        emoji: "emoji",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "data e hora ISO",
        date: "data ISO",
        time: "hora ISO",
        duration: "dura\xE7\xE3o ISO",
        ipv4: "endere\xE7o IPv4",
        ipv6: "endere\xE7o IPv6",
        cidrv4: "faixa de IPv4",
        cidrv6: "faixa de IPv6",
        base64: "texto codificado em base64",
        base64url: "URL codificada em base64",
        json_string: "texto JSON",
        e164: "n\xFAmero E.164",
        jwt: "JWT",
        template_literal: "entrada"
      };
      return (issue2) => {
        switch (issue2.code) {
          case "invalid_type":
            return `Tipo inv\xE1lido: esperado ${issue2.expected}, recebido ${parsedType8(issue2.input)}`;
          case "invalid_value":
            if (issue2.values.length === 1)
              return `Entrada inv\xE1lida: esperado ${stringifyPrimitive(issue2.values[0])}`;
            return `Op\xE7\xE3o inv\xE1lida: esperada uma das ${joinValues(issue2.values, "|")}`;
          case "too_big": {
            const adj = issue2.inclusive ? "<=" : "<";
            const sizing = getSizing(issue2.origin);
            if (sizing)
              return `Muito grande: esperado que ${issue2.origin ?? "valor"} tivesse ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elementos"}`;
            return `Muito grande: esperado que ${issue2.origin ?? "valor"} fosse ${adj}${issue2.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue2.inclusive ? ">=" : ">";
            const sizing = getSizing(issue2.origin);
            if (sizing) {
              return `Muito pequeno: esperado que ${issue2.origin} tivesse ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
            }
            return `Muito pequeno: esperado que ${issue2.origin} fosse ${adj}${issue2.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue2;
            if (_issue.format === "starts_with")
              return `Texto inv\xE1lido: deve come\xE7ar com "${_issue.prefix}"`;
            if (_issue.format === "ends_with")
              return `Texto inv\xE1lido: deve terminar com "${_issue.suffix}"`;
            if (_issue.format === "includes")
              return `Texto inv\xE1lido: deve incluir "${_issue.includes}"`;
            if (_issue.format === "regex")
              return `Texto inv\xE1lido: deve corresponder ao padr\xE3o ${_issue.pattern}`;
            return `${Nouns[_issue.format] ?? issue2.format} inv\xE1lido`;
          }
          case "not_multiple_of":
            return `N\xFAmero inv\xE1lido: deve ser m\xFAltiplo de ${issue2.divisor}`;
          case "unrecognized_keys":
            return `Chave${issue2.keys.length > 1 ? "s" : ""} desconhecida${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
          case "invalid_key":
            return `Chave inv\xE1lida em ${issue2.origin}`;
          case "invalid_union":
            return "Entrada inv\xE1lida";
          case "invalid_element":
            return `Valor inv\xE1lido em ${issue2.origin}`;
          default:
            return `Campo inv\xE1lido`;
        }
      };
    };
  }
});

// node_modules/zod/v4/locales/ru.js
function getRussianPlural(count, one, few, many) {
  const absCount = Math.abs(count);
  const lastDigit = absCount % 10;
  const lastTwoDigits = absCount % 100;
  if (lastTwoDigits >= 11 && lastTwoDigits <= 19) {
    return many;
  }
  if (lastDigit === 1) {
    return one;
  }
  if (lastDigit >= 2 && lastDigit <= 4) {
    return few;
  }
  return many;
}
function ru_default() {
  return {
    localeError: error34()
  };
}
var error34;
var init_ru = __esm({
  "node_modules/zod/v4/locales/ru.js"() {
    init_util();
    error34 = () => {
      const Sizable = {
        string: {
          unit: {
            one: "\u0441\u0438\u043C\u0432\u043E\u043B",
            few: "\u0441\u0438\u043C\u0432\u043E\u043B\u0430",
            many: "\u0441\u0438\u043C\u0432\u043E\u043B\u043E\u0432"
          },
          verb: "\u0438\u043C\u0435\u0442\u044C"
        },
        file: {
          unit: {
            one: "\u0431\u0430\u0439\u0442",
            few: "\u0431\u0430\u0439\u0442\u0430",
            many: "\u0431\u0430\u0439\u0442"
          },
          verb: "\u0438\u043C\u0435\u0442\u044C"
        },
        array: {
          unit: {
            one: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442",
            few: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442\u0430",
            many: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442\u043E\u0432"
          },
          verb: "\u0438\u043C\u0435\u0442\u044C"
        },
        set: {
          unit: {
            one: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442",
            few: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442\u0430",
            many: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442\u043E\u0432"
          },
          verb: "\u0438\u043C\u0435\u0442\u044C"
        }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const parsedType8 = (data) => {
        const t = typeof data;
        switch (t) {
          case "number": {
            return Number.isNaN(data) ? "NaN" : "\u0447\u0438\u0441\u043B\u043E";
          }
          case "object": {
            if (Array.isArray(data)) {
              return "\u043C\u0430\u0441\u0441\u0438\u0432";
            }
            if (data === null) {
              return "null";
            }
            if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
              return data.constructor.name;
            }
          }
        }
        return t;
      };
      const Nouns = {
        regex: "\u0432\u0432\u043E\u0434",
        email: "email \u0430\u0434\u0440\u0435\u0441",
        url: "URL",
        emoji: "\u044D\u043C\u043E\u0434\u0437\u0438",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "ISO \u0434\u0430\u0442\u0430 \u0438 \u0432\u0440\u0435\u043C\u044F",
        date: "ISO \u0434\u0430\u0442\u0430",
        time: "ISO \u0432\u0440\u0435\u043C\u044F",
        duration: "ISO \u0434\u043B\u0438\u0442\u0435\u043B\u044C\u043D\u043E\u0441\u0442\u044C",
        ipv4: "IPv4 \u0430\u0434\u0440\u0435\u0441",
        ipv6: "IPv6 \u0430\u0434\u0440\u0435\u0441",
        cidrv4: "IPv4 \u0434\u0438\u0430\u043F\u0430\u0437\u043E\u043D",
        cidrv6: "IPv6 \u0434\u0438\u0430\u043F\u0430\u0437\u043E\u043D",
        base64: "\u0441\u0442\u0440\u043E\u043A\u0430 \u0432 \u0444\u043E\u0440\u043C\u0430\u0442\u0435 base64",
        base64url: "\u0441\u0442\u0440\u043E\u043A\u0430 \u0432 \u0444\u043E\u0440\u043C\u0430\u0442\u0435 base64url",
        json_string: "JSON \u0441\u0442\u0440\u043E\u043A\u0430",
        e164: "\u043D\u043E\u043C\u0435\u0440 E.164",
        jwt: "JWT",
        template_literal: "\u0432\u0432\u043E\u0434"
      };
      return (issue2) => {
        switch (issue2.code) {
          case "invalid_type":
            return `\u041D\u0435\u0432\u0435\u0440\u043D\u044B\u0439 \u0432\u0432\u043E\u0434: \u043E\u0436\u0438\u0434\u0430\u043B\u043E\u0441\u044C ${issue2.expected}, \u043F\u043E\u043B\u0443\u0447\u0435\u043D\u043E ${parsedType8(issue2.input)}`;
          case "invalid_value":
            if (issue2.values.length === 1)
              return `\u041D\u0435\u0432\u0435\u0440\u043D\u044B\u0439 \u0432\u0432\u043E\u0434: \u043E\u0436\u0438\u0434\u0430\u043B\u043E\u0441\u044C ${stringifyPrimitive(issue2.values[0])}`;
            return `\u041D\u0435\u0432\u0435\u0440\u043D\u044B\u0439 \u0432\u0430\u0440\u0438\u0430\u043D\u0442: \u043E\u0436\u0438\u0434\u0430\u043B\u043E\u0441\u044C \u043E\u0434\u043D\u043E \u0438\u0437 ${joinValues(issue2.values, "|")}`;
          case "too_big": {
            const adj = issue2.inclusive ? "<=" : "<";
            const sizing = getSizing(issue2.origin);
            if (sizing) {
              const maxValue = Number(issue2.maximum);
              const unit = getRussianPlural(maxValue, sizing.unit.one, sizing.unit.few, sizing.unit.many);
              return `\u0421\u043B\u0438\u0448\u043A\u043E\u043C \u0431\u043E\u043B\u044C\u0448\u043E\u0435 \u0437\u043D\u0430\u0447\u0435\u043D\u0438\u0435: \u043E\u0436\u0438\u0434\u0430\u043B\u043E\u0441\u044C, \u0447\u0442\u043E ${issue2.origin ?? "\u0437\u043D\u0430\u0447\u0435\u043D\u0438\u0435"} \u0431\u0443\u0434\u0435\u0442 \u0438\u043C\u0435\u0442\u044C ${adj}${issue2.maximum.toString()} ${unit}`;
            }
            return `\u0421\u043B\u0438\u0448\u043A\u043E\u043C \u0431\u043E\u043B\u044C\u0448\u043E\u0435 \u0437\u043D\u0430\u0447\u0435\u043D\u0438\u0435: \u043E\u0436\u0438\u0434\u0430\u043B\u043E\u0441\u044C, \u0447\u0442\u043E ${issue2.origin ?? "\u0437\u043D\u0430\u0447\u0435\u043D\u0438\u0435"} \u0431\u0443\u0434\u0435\u0442 ${adj}${issue2.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue2.inclusive ? ">=" : ">";
            const sizing = getSizing(issue2.origin);
            if (sizing) {
              const minValue = Number(issue2.minimum);
              const unit = getRussianPlural(minValue, sizing.unit.one, sizing.unit.few, sizing.unit.many);
              return `\u0421\u043B\u0438\u0448\u043A\u043E\u043C \u043C\u0430\u043B\u0435\u043D\u044C\u043A\u043E\u0435 \u0437\u043D\u0430\u0447\u0435\u043D\u0438\u0435: \u043E\u0436\u0438\u0434\u0430\u043B\u043E\u0441\u044C, \u0447\u0442\u043E ${issue2.origin} \u0431\u0443\u0434\u0435\u0442 \u0438\u043C\u0435\u0442\u044C ${adj}${issue2.minimum.toString()} ${unit}`;
            }
            return `\u0421\u043B\u0438\u0448\u043A\u043E\u043C \u043C\u0430\u043B\u0435\u043D\u044C\u043A\u043E\u0435 \u0437\u043D\u0430\u0447\u0435\u043D\u0438\u0435: \u043E\u0436\u0438\u0434\u0430\u043B\u043E\u0441\u044C, \u0447\u0442\u043E ${issue2.origin} \u0431\u0443\u0434\u0435\u0442 ${adj}${issue2.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue2;
            if (_issue.format === "starts_with")
              return `\u041D\u0435\u0432\u0435\u0440\u043D\u0430\u044F \u0441\u0442\u0440\u043E\u043A\u0430: \u0434\u043E\u043B\u0436\u043D\u0430 \u043D\u0430\u0447\u0438\u043D\u0430\u0442\u044C\u0441\u044F \u0441 "${_issue.prefix}"`;
            if (_issue.format === "ends_with")
              return `\u041D\u0435\u0432\u0435\u0440\u043D\u0430\u044F \u0441\u0442\u0440\u043E\u043A\u0430: \u0434\u043E\u043B\u0436\u043D\u0430 \u0437\u0430\u043A\u0430\u043D\u0447\u0438\u0432\u0430\u0442\u044C\u0441\u044F \u043D\u0430 "${_issue.suffix}"`;
            if (_issue.format === "includes")
              return `\u041D\u0435\u0432\u0435\u0440\u043D\u0430\u044F \u0441\u0442\u0440\u043E\u043A\u0430: \u0434\u043E\u043B\u0436\u043D\u0430 \u0441\u043E\u0434\u0435\u0440\u0436\u0430\u0442\u044C "${_issue.includes}"`;
            if (_issue.format === "regex")
              return `\u041D\u0435\u0432\u0435\u0440\u043D\u0430\u044F \u0441\u0442\u0440\u043E\u043A\u0430: \u0434\u043E\u043B\u0436\u043D\u0430 \u0441\u043E\u043E\u0442\u0432\u0435\u0442\u0441\u0442\u0432\u043E\u0432\u0430\u0442\u044C \u0448\u0430\u0431\u043B\u043E\u043D\u0443 ${_issue.pattern}`;
            return `\u041D\u0435\u0432\u0435\u0440\u043D\u044B\u0439 ${Nouns[_issue.format] ?? issue2.format}`;
          }
          case "not_multiple_of":
            return `\u041D\u0435\u0432\u0435\u0440\u043D\u043E\u0435 \u0447\u0438\u0441\u043B\u043E: \u0434\u043E\u043B\u0436\u043D\u043E \u0431\u044B\u0442\u044C \u043A\u0440\u0430\u0442\u043D\u044B\u043C ${issue2.divisor}`;
          case "unrecognized_keys":
            return `\u041D\u0435\u0440\u0430\u0441\u043F\u043E\u0437\u043D\u0430\u043D\u043D${issue2.keys.length > 1 ? "\u044B\u0435" : "\u044B\u0439"} \u043A\u043B\u044E\u0447${issue2.keys.length > 1 ? "\u0438" : ""}: ${joinValues(issue2.keys, ", ")}`;
          case "invalid_key":
            return `\u041D\u0435\u0432\u0435\u0440\u043D\u044B\u0439 \u043A\u043B\u044E\u0447 \u0432 ${issue2.origin}`;
          case "invalid_union":
            return "\u041D\u0435\u0432\u0435\u0440\u043D\u044B\u0435 \u0432\u0445\u043E\u0434\u043D\u044B\u0435 \u0434\u0430\u043D\u043D\u044B\u0435";
          case "invalid_element":
            return `\u041D\u0435\u0432\u0435\u0440\u043D\u043E\u0435 \u0437\u043D\u0430\u0447\u0435\u043D\u0438\u0435 \u0432 ${issue2.origin}`;
          default:
            return `\u041D\u0435\u0432\u0435\u0440\u043D\u044B\u0435 \u0432\u0445\u043E\u0434\u043D\u044B\u0435 \u0434\u0430\u043D\u043D\u044B\u0435`;
        }
      };
    };
  }
});

// node_modules/zod/v4/locales/sl.js
function sl_default() {
  return {
    localeError: error35()
  };
}
var error35;
var init_sl = __esm({
  "node_modules/zod/v4/locales/sl.js"() {
    init_util();
    error35 = () => {
      const Sizable = {
        string: { unit: "znakov", verb: "imeti" },
        file: { unit: "bajtov", verb: "imeti" },
        array: { unit: "elementov", verb: "imeti" },
        set: { unit: "elementov", verb: "imeti" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const parsedType8 = (data) => {
        const t = typeof data;
        switch (t) {
          case "number": {
            return Number.isNaN(data) ? "NaN" : "\u0161tevilo";
          }
          case "object": {
            if (Array.isArray(data)) {
              return "tabela";
            }
            if (data === null) {
              return "null";
            }
            if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
              return data.constructor.name;
            }
          }
        }
        return t;
      };
      const Nouns = {
        regex: "vnos",
        email: "e-po\u0161tni naslov",
        url: "URL",
        emoji: "emoji",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "ISO datum in \u010Das",
        date: "ISO datum",
        time: "ISO \u010Das",
        duration: "ISO trajanje",
        ipv4: "IPv4 naslov",
        ipv6: "IPv6 naslov",
        cidrv4: "obseg IPv4",
        cidrv6: "obseg IPv6",
        base64: "base64 kodiran niz",
        base64url: "base64url kodiran niz",
        json_string: "JSON niz",
        e164: "E.164 \u0161tevilka",
        jwt: "JWT",
        template_literal: "vnos"
      };
      return (issue2) => {
        switch (issue2.code) {
          case "invalid_type":
            return `Neveljaven vnos: pri\u010Dakovano ${issue2.expected}, prejeto ${parsedType8(issue2.input)}`;
          case "invalid_value":
            if (issue2.values.length === 1)
              return `Neveljaven vnos: pri\u010Dakovano ${stringifyPrimitive(issue2.values[0])}`;
            return `Neveljavna mo\u017Enost: pri\u010Dakovano eno izmed ${joinValues(issue2.values, "|")}`;
          case "too_big": {
            const adj = issue2.inclusive ? "<=" : "<";
            const sizing = getSizing(issue2.origin);
            if (sizing)
              return `Preveliko: pri\u010Dakovano, da bo ${issue2.origin ?? "vrednost"} imelo ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elementov"}`;
            return `Preveliko: pri\u010Dakovano, da bo ${issue2.origin ?? "vrednost"} ${adj}${issue2.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue2.inclusive ? ">=" : ">";
            const sizing = getSizing(issue2.origin);
            if (sizing) {
              return `Premajhno: pri\u010Dakovano, da bo ${issue2.origin} imelo ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
            }
            return `Premajhno: pri\u010Dakovano, da bo ${issue2.origin} ${adj}${issue2.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue2;
            if (_issue.format === "starts_with") {
              return `Neveljaven niz: mora se za\u010Deti z "${_issue.prefix}"`;
            }
            if (_issue.format === "ends_with")
              return `Neveljaven niz: mora se kon\u010Dati z "${_issue.suffix}"`;
            if (_issue.format === "includes")
              return `Neveljaven niz: mora vsebovati "${_issue.includes}"`;
            if (_issue.format === "regex")
              return `Neveljaven niz: mora ustrezati vzorcu ${_issue.pattern}`;
            return `Neveljaven ${Nouns[_issue.format] ?? issue2.format}`;
          }
          case "not_multiple_of":
            return `Neveljavno \u0161tevilo: mora biti ve\u010Dkratnik ${issue2.divisor}`;
          case "unrecognized_keys":
            return `Neprepoznan${issue2.keys.length > 1 ? "i klju\u010Di" : " klju\u010D"}: ${joinValues(issue2.keys, ", ")}`;
          case "invalid_key":
            return `Neveljaven klju\u010D v ${issue2.origin}`;
          case "invalid_union":
            return "Neveljaven vnos";
          case "invalid_element":
            return `Neveljavna vrednost v ${issue2.origin}`;
          default:
            return "Neveljaven vnos";
        }
      };
    };
  }
});

// node_modules/zod/v4/locales/sv.js
function sv_default() {
  return {
    localeError: error36()
  };
}
var error36;
var init_sv = __esm({
  "node_modules/zod/v4/locales/sv.js"() {
    init_util();
    error36 = () => {
      const Sizable = {
        string: { unit: "tecken", verb: "att ha" },
        file: { unit: "bytes", verb: "att ha" },
        array: { unit: "objekt", verb: "att inneh\xE5lla" },
        set: { unit: "objekt", verb: "att inneh\xE5lla" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const parsedType8 = (data) => {
        const t = typeof data;
        switch (t) {
          case "number": {
            return Number.isNaN(data) ? "NaN" : "antal";
          }
          case "object": {
            if (Array.isArray(data)) {
              return "lista";
            }
            if (data === null) {
              return "null";
            }
            if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
              return data.constructor.name;
            }
          }
        }
        return t;
      };
      const Nouns = {
        regex: "regulj\xE4rt uttryck",
        email: "e-postadress",
        url: "URL",
        emoji: "emoji",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "ISO-datum och tid",
        date: "ISO-datum",
        time: "ISO-tid",
        duration: "ISO-varaktighet",
        ipv4: "IPv4-intervall",
        ipv6: "IPv6-intervall",
        cidrv4: "IPv4-spektrum",
        cidrv6: "IPv6-spektrum",
        base64: "base64-kodad str\xE4ng",
        base64url: "base64url-kodad str\xE4ng",
        json_string: "JSON-str\xE4ng",
        e164: "E.164-nummer",
        jwt: "JWT",
        template_literal: "mall-literal"
      };
      return (issue2) => {
        switch (issue2.code) {
          case "invalid_type":
            return `Ogiltig inmatning: f\xF6rv\xE4ntat ${issue2.expected}, fick ${parsedType8(issue2.input)}`;
          case "invalid_value":
            if (issue2.values.length === 1)
              return `Ogiltig inmatning: f\xF6rv\xE4ntat ${stringifyPrimitive(issue2.values[0])}`;
            return `Ogiltigt val: f\xF6rv\xE4ntade en av ${joinValues(issue2.values, "|")}`;
          case "too_big": {
            const adj = issue2.inclusive ? "<=" : "<";
            const sizing = getSizing(issue2.origin);
            if (sizing) {
              return `F\xF6r stor(t): f\xF6rv\xE4ntade ${issue2.origin ?? "v\xE4rdet"} att ha ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "element"}`;
            }
            return `F\xF6r stor(t): f\xF6rv\xE4ntat ${issue2.origin ?? "v\xE4rdet"} att ha ${adj}${issue2.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue2.inclusive ? ">=" : ">";
            const sizing = getSizing(issue2.origin);
            if (sizing) {
              return `F\xF6r lite(t): f\xF6rv\xE4ntade ${issue2.origin ?? "v\xE4rdet"} att ha ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
            }
            return `F\xF6r lite(t): f\xF6rv\xE4ntade ${issue2.origin ?? "v\xE4rdet"} att ha ${adj}${issue2.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue2;
            if (_issue.format === "starts_with") {
              return `Ogiltig str\xE4ng: m\xE5ste b\xF6rja med "${_issue.prefix}"`;
            }
            if (_issue.format === "ends_with")
              return `Ogiltig str\xE4ng: m\xE5ste sluta med "${_issue.suffix}"`;
            if (_issue.format === "includes")
              return `Ogiltig str\xE4ng: m\xE5ste inneh\xE5lla "${_issue.includes}"`;
            if (_issue.format === "regex")
              return `Ogiltig str\xE4ng: m\xE5ste matcha m\xF6nstret "${_issue.pattern}"`;
            return `Ogiltig(t) ${Nouns[_issue.format] ?? issue2.format}`;
          }
          case "not_multiple_of":
            return `Ogiltigt tal: m\xE5ste vara en multipel av ${issue2.divisor}`;
          case "unrecognized_keys":
            return `${issue2.keys.length > 1 ? "Ok\xE4nda nycklar" : "Ok\xE4nd nyckel"}: ${joinValues(issue2.keys, ", ")}`;
          case "invalid_key":
            return `Ogiltig nyckel i ${issue2.origin ?? "v\xE4rdet"}`;
          case "invalid_union":
            return "Ogiltig input";
          case "invalid_element":
            return `Ogiltigt v\xE4rde i ${issue2.origin ?? "v\xE4rdet"}`;
          default:
            return `Ogiltig input`;
        }
      };
    };
  }
});

// node_modules/zod/v4/locales/ta.js
function ta_default() {
  return {
    localeError: error37()
  };
}
var error37;
var init_ta = __esm({
  "node_modules/zod/v4/locales/ta.js"() {
    init_util();
    error37 = () => {
      const Sizable = {
        string: { unit: "\u0B8E\u0BB4\u0BC1\u0BA4\u0BCD\u0BA4\u0BC1\u0B95\u0BCD\u0B95\u0BB3\u0BCD", verb: "\u0B95\u0BCA\u0BA3\u0BCD\u0B9F\u0BBF\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD" },
        file: { unit: "\u0BAA\u0BC8\u0B9F\u0BCD\u0B9F\u0BC1\u0B95\u0BB3\u0BCD", verb: "\u0B95\u0BCA\u0BA3\u0BCD\u0B9F\u0BBF\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD" },
        array: { unit: "\u0B89\u0BB1\u0BC1\u0BAA\u0BCD\u0BAA\u0BC1\u0B95\u0BB3\u0BCD", verb: "\u0B95\u0BCA\u0BA3\u0BCD\u0B9F\u0BBF\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD" },
        set: { unit: "\u0B89\u0BB1\u0BC1\u0BAA\u0BCD\u0BAA\u0BC1\u0B95\u0BB3\u0BCD", verb: "\u0B95\u0BCA\u0BA3\u0BCD\u0B9F\u0BBF\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const parsedType8 = (data) => {
        const t = typeof data;
        switch (t) {
          case "number": {
            return Number.isNaN(data) ? "\u0B8E\u0BA3\u0BCD \u0B85\u0BB2\u0BCD\u0BB2\u0BBE\u0BA4\u0BA4\u0BC1" : "\u0B8E\u0BA3\u0BCD";
          }
          case "object": {
            if (Array.isArray(data)) {
              return "\u0B85\u0BA3\u0BBF";
            }
            if (data === null) {
              return "\u0BB5\u0BC6\u0BB1\u0BC1\u0BAE\u0BC8";
            }
            if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
              return data.constructor.name;
            }
          }
        }
        return t;
      };
      const Nouns = {
        regex: "\u0B89\u0BB3\u0BCD\u0BB3\u0BC0\u0B9F\u0BC1",
        email: "\u0BAE\u0BBF\u0BA9\u0BCD\u0BA9\u0B9E\u0BCD\u0B9A\u0BB2\u0BCD \u0BAE\u0BC1\u0B95\u0BB5\u0BB0\u0BBF",
        url: "URL",
        emoji: "emoji",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "ISO \u0BA4\u0BC7\u0BA4\u0BBF \u0BA8\u0BC7\u0BB0\u0BAE\u0BCD",
        date: "ISO \u0BA4\u0BC7\u0BA4\u0BBF",
        time: "ISO \u0BA8\u0BC7\u0BB0\u0BAE\u0BCD",
        duration: "ISO \u0B95\u0BBE\u0BB2 \u0B85\u0BB3\u0BB5\u0BC1",
        ipv4: "IPv4 \u0BAE\u0BC1\u0B95\u0BB5\u0BB0\u0BBF",
        ipv6: "IPv6 \u0BAE\u0BC1\u0B95\u0BB5\u0BB0\u0BBF",
        cidrv4: "IPv4 \u0BB5\u0BB0\u0BAE\u0BCD\u0BAA\u0BC1",
        cidrv6: "IPv6 \u0BB5\u0BB0\u0BAE\u0BCD\u0BAA\u0BC1",
        base64: "base64-encoded \u0B9A\u0BB0\u0BAE\u0BCD",
        base64url: "base64url-encoded \u0B9A\u0BB0\u0BAE\u0BCD",
        json_string: "JSON \u0B9A\u0BB0\u0BAE\u0BCD",
        e164: "E.164 \u0B8E\u0BA3\u0BCD",
        jwt: "JWT",
        template_literal: "input"
      };
      return (issue2) => {
        switch (issue2.code) {
          case "invalid_type":
            return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B89\u0BB3\u0BCD\u0BB3\u0BC0\u0B9F\u0BC1: \u0B8E\u0BA4\u0BBF\u0BB0\u0BCD\u0BAA\u0BBE\u0BB0\u0BCD\u0B95\u0BCD\u0B95\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${issue2.expected}, \u0BAA\u0BC6\u0BB1\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${parsedType8(issue2.input)}`;
          case "invalid_value":
            if (issue2.values.length === 1)
              return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B89\u0BB3\u0BCD\u0BB3\u0BC0\u0B9F\u0BC1: \u0B8E\u0BA4\u0BBF\u0BB0\u0BCD\u0BAA\u0BBE\u0BB0\u0BCD\u0B95\u0BCD\u0B95\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${stringifyPrimitive(issue2.values[0])}`;
            return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0BB5\u0BBF\u0BB0\u0BC1\u0BAA\u0BCD\u0BAA\u0BAE\u0BCD: \u0B8E\u0BA4\u0BBF\u0BB0\u0BCD\u0BAA\u0BBE\u0BB0\u0BCD\u0B95\u0BCD\u0B95\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${joinValues(issue2.values, "|")} \u0B87\u0BB2\u0BCD \u0B92\u0BA9\u0BCD\u0BB1\u0BC1`;
          case "too_big": {
            const adj = issue2.inclusive ? "<=" : "<";
            const sizing = getSizing(issue2.origin);
            if (sizing) {
              return `\u0BAE\u0BBF\u0B95 \u0BAA\u0BC6\u0BB0\u0BBF\u0BAF\u0BA4\u0BC1: \u0B8E\u0BA4\u0BBF\u0BB0\u0BCD\u0BAA\u0BBE\u0BB0\u0BCD\u0B95\u0BCD\u0B95\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${issue2.origin ?? "\u0BAE\u0BA4\u0BBF\u0BAA\u0BCD\u0BAA\u0BC1"} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "\u0B89\u0BB1\u0BC1\u0BAA\u0BCD\u0BAA\u0BC1\u0B95\u0BB3\u0BCD"} \u0B86\u0B95 \u0B87\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
            }
            return `\u0BAE\u0BBF\u0B95 \u0BAA\u0BC6\u0BB0\u0BBF\u0BAF\u0BA4\u0BC1: \u0B8E\u0BA4\u0BBF\u0BB0\u0BCD\u0BAA\u0BBE\u0BB0\u0BCD\u0B95\u0BCD\u0B95\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${issue2.origin ?? "\u0BAE\u0BA4\u0BBF\u0BAA\u0BCD\u0BAA\u0BC1"} ${adj}${issue2.maximum.toString()} \u0B86\u0B95 \u0B87\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
          }
          case "too_small": {
            const adj = issue2.inclusive ? ">=" : ">";
            const sizing = getSizing(issue2.origin);
            if (sizing) {
              return `\u0BAE\u0BBF\u0B95\u0B9A\u0BCD \u0B9A\u0BBF\u0BB1\u0BBF\u0BAF\u0BA4\u0BC1: \u0B8E\u0BA4\u0BBF\u0BB0\u0BCD\u0BAA\u0BBE\u0BB0\u0BCD\u0B95\u0BCD\u0B95\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${issue2.origin} ${adj}${issue2.minimum.toString()} ${sizing.unit} \u0B86\u0B95 \u0B87\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
            }
            return `\u0BAE\u0BBF\u0B95\u0B9A\u0BCD \u0B9A\u0BBF\u0BB1\u0BBF\u0BAF\u0BA4\u0BC1: \u0B8E\u0BA4\u0BBF\u0BB0\u0BCD\u0BAA\u0BBE\u0BB0\u0BCD\u0B95\u0BCD\u0B95\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${issue2.origin} ${adj}${issue2.minimum.toString()} \u0B86\u0B95 \u0B87\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
          }
          case "invalid_format": {
            const _issue = issue2;
            if (_issue.format === "starts_with")
              return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B9A\u0BB0\u0BAE\u0BCD: "${_issue.prefix}" \u0B87\u0BB2\u0BCD \u0BA4\u0BCA\u0B9F\u0B99\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
            if (_issue.format === "ends_with")
              return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B9A\u0BB0\u0BAE\u0BCD: "${_issue.suffix}" \u0B87\u0BB2\u0BCD \u0BAE\u0BC1\u0B9F\u0BBF\u0BB5\u0B9F\u0BC8\u0BAF \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
            if (_issue.format === "includes")
              return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B9A\u0BB0\u0BAE\u0BCD: "${_issue.includes}" \u0B90 \u0B89\u0BB3\u0BCD\u0BB3\u0B9F\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
            if (_issue.format === "regex")
              return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B9A\u0BB0\u0BAE\u0BCD: ${_issue.pattern} \u0BAE\u0BC1\u0BB1\u0BC8\u0BAA\u0BBE\u0B9F\u0BCD\u0B9F\u0BC1\u0B9F\u0BA9\u0BCD \u0BAA\u0BCA\u0BB0\u0BC1\u0BA8\u0BCD\u0BA4 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
            return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 ${Nouns[_issue.format] ?? issue2.format}`;
          }
          case "not_multiple_of":
            return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B8E\u0BA3\u0BCD: ${issue2.divisor} \u0B87\u0BA9\u0BCD \u0BAA\u0BB2\u0BAE\u0BBE\u0B95 \u0B87\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
          case "unrecognized_keys":
            return `\u0B85\u0B9F\u0BC8\u0BAF\u0BBE\u0BB3\u0BAE\u0BCD \u0BA4\u0BC6\u0BB0\u0BBF\u0BAF\u0BBE\u0BA4 \u0BB5\u0BBF\u0B9A\u0BC8${issue2.keys.length > 1 ? "\u0B95\u0BB3\u0BCD" : ""}: ${joinValues(issue2.keys, ", ")}`;
          case "invalid_key":
            return `${issue2.origin} \u0B87\u0BB2\u0BCD \u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0BB5\u0BBF\u0B9A\u0BC8`;
          case "invalid_union":
            return "\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B89\u0BB3\u0BCD\u0BB3\u0BC0\u0B9F\u0BC1";
          case "invalid_element":
            return `${issue2.origin} \u0B87\u0BB2\u0BCD \u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0BAE\u0BA4\u0BBF\u0BAA\u0BCD\u0BAA\u0BC1`;
          default:
            return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B89\u0BB3\u0BCD\u0BB3\u0BC0\u0B9F\u0BC1`;
        }
      };
    };
  }
});

// node_modules/zod/v4/locales/th.js
function th_default() {
  return {
    localeError: error38()
  };
}
var error38;
var init_th = __esm({
  "node_modules/zod/v4/locales/th.js"() {
    init_util();
    error38 = () => {
      const Sizable = {
        string: { unit: "\u0E15\u0E31\u0E27\u0E2D\u0E31\u0E01\u0E29\u0E23", verb: "\u0E04\u0E27\u0E23\u0E21\u0E35" },
        file: { unit: "\u0E44\u0E1A\u0E15\u0E4C", verb: "\u0E04\u0E27\u0E23\u0E21\u0E35" },
        array: { unit: "\u0E23\u0E32\u0E22\u0E01\u0E32\u0E23", verb: "\u0E04\u0E27\u0E23\u0E21\u0E35" },
        set: { unit: "\u0E23\u0E32\u0E22\u0E01\u0E32\u0E23", verb: "\u0E04\u0E27\u0E23\u0E21\u0E35" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const parsedType8 = (data) => {
        const t = typeof data;
        switch (t) {
          case "number": {
            return Number.isNaN(data) ? "\u0E44\u0E21\u0E48\u0E43\u0E0A\u0E48\u0E15\u0E31\u0E27\u0E40\u0E25\u0E02 (NaN)" : "\u0E15\u0E31\u0E27\u0E40\u0E25\u0E02";
          }
          case "object": {
            if (Array.isArray(data)) {
              return "\u0E2D\u0E32\u0E23\u0E4C\u0E40\u0E23\u0E22\u0E4C (Array)";
            }
            if (data === null) {
              return "\u0E44\u0E21\u0E48\u0E21\u0E35\u0E04\u0E48\u0E32 (null)";
            }
            if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
              return data.constructor.name;
            }
          }
        }
        return t;
      };
      const Nouns = {
        regex: "\u0E02\u0E49\u0E2D\u0E21\u0E39\u0E25\u0E17\u0E35\u0E48\u0E1B\u0E49\u0E2D\u0E19",
        email: "\u0E17\u0E35\u0E48\u0E2D\u0E22\u0E39\u0E48\u0E2D\u0E35\u0E40\u0E21\u0E25",
        url: "URL",
        emoji: "\u0E2D\u0E34\u0E42\u0E21\u0E08\u0E34",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "\u0E27\u0E31\u0E19\u0E17\u0E35\u0E48\u0E40\u0E27\u0E25\u0E32\u0E41\u0E1A\u0E1A ISO",
        date: "\u0E27\u0E31\u0E19\u0E17\u0E35\u0E48\u0E41\u0E1A\u0E1A ISO",
        time: "\u0E40\u0E27\u0E25\u0E32\u0E41\u0E1A\u0E1A ISO",
        duration: "\u0E0A\u0E48\u0E27\u0E07\u0E40\u0E27\u0E25\u0E32\u0E41\u0E1A\u0E1A ISO",
        ipv4: "\u0E17\u0E35\u0E48\u0E2D\u0E22\u0E39\u0E48 IPv4",
        ipv6: "\u0E17\u0E35\u0E48\u0E2D\u0E22\u0E39\u0E48 IPv6",
        cidrv4: "\u0E0A\u0E48\u0E27\u0E07 IP \u0E41\u0E1A\u0E1A IPv4",
        cidrv6: "\u0E0A\u0E48\u0E27\u0E07 IP \u0E41\u0E1A\u0E1A IPv6",
        base64: "\u0E02\u0E49\u0E2D\u0E04\u0E27\u0E32\u0E21\u0E41\u0E1A\u0E1A Base64",
        base64url: "\u0E02\u0E49\u0E2D\u0E04\u0E27\u0E32\u0E21\u0E41\u0E1A\u0E1A Base64 \u0E2A\u0E33\u0E2B\u0E23\u0E31\u0E1A URL",
        json_string: "\u0E02\u0E49\u0E2D\u0E04\u0E27\u0E32\u0E21\u0E41\u0E1A\u0E1A JSON",
        e164: "\u0E40\u0E1A\u0E2D\u0E23\u0E4C\u0E42\u0E17\u0E23\u0E28\u0E31\u0E1E\u0E17\u0E4C\u0E23\u0E30\u0E2B\u0E27\u0E48\u0E32\u0E07\u0E1B\u0E23\u0E30\u0E40\u0E17\u0E28 (E.164)",
        jwt: "\u0E42\u0E17\u0E40\u0E04\u0E19 JWT",
        template_literal: "\u0E02\u0E49\u0E2D\u0E21\u0E39\u0E25\u0E17\u0E35\u0E48\u0E1B\u0E49\u0E2D\u0E19"
      };
      return (issue2) => {
        switch (issue2.code) {
          case "invalid_type":
            return `\u0E1B\u0E23\u0E30\u0E40\u0E20\u0E17\u0E02\u0E49\u0E2D\u0E21\u0E39\u0E25\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E04\u0E27\u0E23\u0E40\u0E1B\u0E47\u0E19 ${issue2.expected} \u0E41\u0E15\u0E48\u0E44\u0E14\u0E49\u0E23\u0E31\u0E1A ${parsedType8(issue2.input)}`;
          case "invalid_value":
            if (issue2.values.length === 1)
              return `\u0E04\u0E48\u0E32\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E04\u0E27\u0E23\u0E40\u0E1B\u0E47\u0E19 ${stringifyPrimitive(issue2.values[0])}`;
            return `\u0E15\u0E31\u0E27\u0E40\u0E25\u0E37\u0E2D\u0E01\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E04\u0E27\u0E23\u0E40\u0E1B\u0E47\u0E19\u0E2B\u0E19\u0E36\u0E48\u0E07\u0E43\u0E19 ${joinValues(issue2.values, "|")}`;
          case "too_big": {
            const adj = issue2.inclusive ? "\u0E44\u0E21\u0E48\u0E40\u0E01\u0E34\u0E19" : "\u0E19\u0E49\u0E2D\u0E22\u0E01\u0E27\u0E48\u0E32";
            const sizing = getSizing(issue2.origin);
            if (sizing)
              return `\u0E40\u0E01\u0E34\u0E19\u0E01\u0E33\u0E2B\u0E19\u0E14: ${issue2.origin ?? "\u0E04\u0E48\u0E32"} \u0E04\u0E27\u0E23\u0E21\u0E35${adj} ${issue2.maximum.toString()} ${sizing.unit ?? "\u0E23\u0E32\u0E22\u0E01\u0E32\u0E23"}`;
            return `\u0E40\u0E01\u0E34\u0E19\u0E01\u0E33\u0E2B\u0E19\u0E14: ${issue2.origin ?? "\u0E04\u0E48\u0E32"} \u0E04\u0E27\u0E23\u0E21\u0E35${adj} ${issue2.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue2.inclusive ? "\u0E2D\u0E22\u0E48\u0E32\u0E07\u0E19\u0E49\u0E2D\u0E22" : "\u0E21\u0E32\u0E01\u0E01\u0E27\u0E48\u0E32";
            const sizing = getSizing(issue2.origin);
            if (sizing) {
              return `\u0E19\u0E49\u0E2D\u0E22\u0E01\u0E27\u0E48\u0E32\u0E01\u0E33\u0E2B\u0E19\u0E14: ${issue2.origin} \u0E04\u0E27\u0E23\u0E21\u0E35${adj} ${issue2.minimum.toString()} ${sizing.unit}`;
            }
            return `\u0E19\u0E49\u0E2D\u0E22\u0E01\u0E27\u0E48\u0E32\u0E01\u0E33\u0E2B\u0E19\u0E14: ${issue2.origin} \u0E04\u0E27\u0E23\u0E21\u0E35${adj} ${issue2.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue2;
            if (_issue.format === "starts_with") {
              return `\u0E23\u0E39\u0E1B\u0E41\u0E1A\u0E1A\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E02\u0E49\u0E2D\u0E04\u0E27\u0E32\u0E21\u0E15\u0E49\u0E2D\u0E07\u0E02\u0E36\u0E49\u0E19\u0E15\u0E49\u0E19\u0E14\u0E49\u0E27\u0E22 "${_issue.prefix}"`;
            }
            if (_issue.format === "ends_with")
              return `\u0E23\u0E39\u0E1B\u0E41\u0E1A\u0E1A\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E02\u0E49\u0E2D\u0E04\u0E27\u0E32\u0E21\u0E15\u0E49\u0E2D\u0E07\u0E25\u0E07\u0E17\u0E49\u0E32\u0E22\u0E14\u0E49\u0E27\u0E22 "${_issue.suffix}"`;
            if (_issue.format === "includes")
              return `\u0E23\u0E39\u0E1B\u0E41\u0E1A\u0E1A\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E02\u0E49\u0E2D\u0E04\u0E27\u0E32\u0E21\u0E15\u0E49\u0E2D\u0E07\u0E21\u0E35 "${_issue.includes}" \u0E2D\u0E22\u0E39\u0E48\u0E43\u0E19\u0E02\u0E49\u0E2D\u0E04\u0E27\u0E32\u0E21`;
            if (_issue.format === "regex")
              return `\u0E23\u0E39\u0E1B\u0E41\u0E1A\u0E1A\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E15\u0E49\u0E2D\u0E07\u0E15\u0E23\u0E07\u0E01\u0E31\u0E1A\u0E23\u0E39\u0E1B\u0E41\u0E1A\u0E1A\u0E17\u0E35\u0E48\u0E01\u0E33\u0E2B\u0E19\u0E14 ${_issue.pattern}`;
            return `\u0E23\u0E39\u0E1B\u0E41\u0E1A\u0E1A\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: ${Nouns[_issue.format] ?? issue2.format}`;
          }
          case "not_multiple_of":
            return `\u0E15\u0E31\u0E27\u0E40\u0E25\u0E02\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E15\u0E49\u0E2D\u0E07\u0E40\u0E1B\u0E47\u0E19\u0E08\u0E33\u0E19\u0E27\u0E19\u0E17\u0E35\u0E48\u0E2B\u0E32\u0E23\u0E14\u0E49\u0E27\u0E22 ${issue2.divisor} \u0E44\u0E14\u0E49\u0E25\u0E07\u0E15\u0E31\u0E27`;
          case "unrecognized_keys":
            return `\u0E1E\u0E1A\u0E04\u0E35\u0E22\u0E4C\u0E17\u0E35\u0E48\u0E44\u0E21\u0E48\u0E23\u0E39\u0E49\u0E08\u0E31\u0E01: ${joinValues(issue2.keys, ", ")}`;
          case "invalid_key":
            return `\u0E04\u0E35\u0E22\u0E4C\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07\u0E43\u0E19 ${issue2.origin}`;
          case "invalid_union":
            return "\u0E02\u0E49\u0E2D\u0E21\u0E39\u0E25\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E44\u0E21\u0E48\u0E15\u0E23\u0E07\u0E01\u0E31\u0E1A\u0E23\u0E39\u0E1B\u0E41\u0E1A\u0E1A\u0E22\u0E39\u0E40\u0E19\u0E35\u0E22\u0E19\u0E17\u0E35\u0E48\u0E01\u0E33\u0E2B\u0E19\u0E14\u0E44\u0E27\u0E49";
          case "invalid_element":
            return `\u0E02\u0E49\u0E2D\u0E21\u0E39\u0E25\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07\u0E43\u0E19 ${issue2.origin}`;
          default:
            return `\u0E02\u0E49\u0E2D\u0E21\u0E39\u0E25\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07`;
        }
      };
    };
  }
});

// node_modules/zod/v4/locales/tr.js
function tr_default() {
  return {
    localeError: error39()
  };
}
var parsedType7, error39;
var init_tr = __esm({
  "node_modules/zod/v4/locales/tr.js"() {
    init_util();
    parsedType7 = (data) => {
      const t = typeof data;
      switch (t) {
        case "number": {
          return Number.isNaN(data) ? "NaN" : "number";
        }
        case "object": {
          if (Array.isArray(data)) {
            return "array";
          }
          if (data === null) {
            return "null";
          }
          if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
            return data.constructor.name;
          }
        }
      }
      return t;
    };
    error39 = () => {
      const Sizable = {
        string: { unit: "karakter", verb: "olmal\u0131" },
        file: { unit: "bayt", verb: "olmal\u0131" },
        array: { unit: "\xF6\u011Fe", verb: "olmal\u0131" },
        set: { unit: "\xF6\u011Fe", verb: "olmal\u0131" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const Nouns = {
        regex: "girdi",
        email: "e-posta adresi",
        url: "URL",
        emoji: "emoji",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "ISO tarih ve saat",
        date: "ISO tarih",
        time: "ISO saat",
        duration: "ISO s\xFCre",
        ipv4: "IPv4 adresi",
        ipv6: "IPv6 adresi",
        cidrv4: "IPv4 aral\u0131\u011F\u0131",
        cidrv6: "IPv6 aral\u0131\u011F\u0131",
        base64: "base64 ile \u015Fifrelenmi\u015F metin",
        base64url: "base64url ile \u015Fifrelenmi\u015F metin",
        json_string: "JSON dizesi",
        e164: "E.164 say\u0131s\u0131",
        jwt: "JWT",
        template_literal: "\u015Eablon dizesi"
      };
      return (issue2) => {
        switch (issue2.code) {
          case "invalid_type":
            return `Ge\xE7ersiz de\u011Fer: beklenen ${issue2.expected}, al\u0131nan ${parsedType7(issue2.input)}`;
          case "invalid_value":
            if (issue2.values.length === 1)
              return `Ge\xE7ersiz de\u011Fer: beklenen ${stringifyPrimitive(issue2.values[0])}`;
            return `Ge\xE7ersiz se\xE7enek: a\u015Fa\u011F\u0131dakilerden biri olmal\u0131: ${joinValues(issue2.values, "|")}`;
          case "too_big": {
            const adj = issue2.inclusive ? "<=" : "<";
            const sizing = getSizing(issue2.origin);
            if (sizing)
              return `\xC7ok b\xFCy\xFCk: beklenen ${issue2.origin ?? "de\u011Fer"} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "\xF6\u011Fe"}`;
            return `\xC7ok b\xFCy\xFCk: beklenen ${issue2.origin ?? "de\u011Fer"} ${adj}${issue2.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue2.inclusive ? ">=" : ">";
            const sizing = getSizing(issue2.origin);
            if (sizing)
              return `\xC7ok k\xFC\xE7\xFCk: beklenen ${issue2.origin} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
            return `\xC7ok k\xFC\xE7\xFCk: beklenen ${issue2.origin} ${adj}${issue2.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue2;
            if (_issue.format === "starts_with")
              return `Ge\xE7ersiz metin: "${_issue.prefix}" ile ba\u015Flamal\u0131`;
            if (_issue.format === "ends_with")
              return `Ge\xE7ersiz metin: "${_issue.suffix}" ile bitmeli`;
            if (_issue.format === "includes")
              return `Ge\xE7ersiz metin: "${_issue.includes}" i\xE7ermeli`;
            if (_issue.format === "regex")
              return `Ge\xE7ersiz metin: ${_issue.pattern} desenine uymal\u0131`;
            return `Ge\xE7ersiz ${Nouns[_issue.format] ?? issue2.format}`;
          }
          case "not_multiple_of":
            return `Ge\xE7ersiz say\u0131: ${issue2.divisor} ile tam b\xF6l\xFCnebilmeli`;
          case "unrecognized_keys":
            return `Tan\u0131nmayan anahtar${issue2.keys.length > 1 ? "lar" : ""}: ${joinValues(issue2.keys, ", ")}`;
          case "invalid_key":
            return `${issue2.origin} i\xE7inde ge\xE7ersiz anahtar`;
          case "invalid_union":
            return "Ge\xE7ersiz de\u011Fer";
          case "invalid_element":
            return `${issue2.origin} i\xE7inde ge\xE7ersiz de\u011Fer`;
          default:
            return `Ge\xE7ersiz de\u011Fer`;
        }
      };
    };
  }
});

// node_modules/zod/v4/locales/uk.js
function uk_default() {
  return {
    localeError: error40()
  };
}
var error40;
var init_uk = __esm({
  "node_modules/zod/v4/locales/uk.js"() {
    init_util();
    error40 = () => {
      const Sizable = {
        string: { unit: "\u0441\u0438\u043C\u0432\u043E\u043B\u0456\u0432", verb: "\u043C\u0430\u0442\u0438\u043C\u0435" },
        file: { unit: "\u0431\u0430\u0439\u0442\u0456\u0432", verb: "\u043C\u0430\u0442\u0438\u043C\u0435" },
        array: { unit: "\u0435\u043B\u0435\u043C\u0435\u043D\u0442\u0456\u0432", verb: "\u043C\u0430\u0442\u0438\u043C\u0435" },
        set: { unit: "\u0435\u043B\u0435\u043C\u0435\u043D\u0442\u0456\u0432", verb: "\u043C\u0430\u0442\u0438\u043C\u0435" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const parsedType8 = (data) => {
        const t = typeof data;
        switch (t) {
          case "number": {
            return Number.isNaN(data) ? "NaN" : "\u0447\u0438\u0441\u043B\u043E";
          }
          case "object": {
            if (Array.isArray(data)) {
              return "\u043C\u0430\u0441\u0438\u0432";
            }
            if (data === null) {
              return "null";
            }
            if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
              return data.constructor.name;
            }
          }
        }
        return t;
      };
      const Nouns = {
        regex: "\u0432\u0445\u0456\u0434\u043D\u0456 \u0434\u0430\u043D\u0456",
        email: "\u0430\u0434\u0440\u0435\u0441\u0430 \u0435\u043B\u0435\u043A\u0442\u0440\u043E\u043D\u043D\u043E\u0457 \u043F\u043E\u0448\u0442\u0438",
        url: "URL",
        emoji: "\u0435\u043C\u043E\u0434\u0437\u0456",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "\u0434\u0430\u0442\u0430 \u0442\u0430 \u0447\u0430\u0441 ISO",
        date: "\u0434\u0430\u0442\u0430 ISO",
        time: "\u0447\u0430\u0441 ISO",
        duration: "\u0442\u0440\u0438\u0432\u0430\u043B\u0456\u0441\u0442\u044C ISO",
        ipv4: "\u0430\u0434\u0440\u0435\u0441\u0430 IPv4",
        ipv6: "\u0430\u0434\u0440\u0435\u0441\u0430 IPv6",
        cidrv4: "\u0434\u0456\u0430\u043F\u0430\u0437\u043E\u043D IPv4",
        cidrv6: "\u0434\u0456\u0430\u043F\u0430\u0437\u043E\u043D IPv6",
        base64: "\u0440\u044F\u0434\u043E\u043A \u0443 \u043A\u043E\u0434\u0443\u0432\u0430\u043D\u043D\u0456 base64",
        base64url: "\u0440\u044F\u0434\u043E\u043A \u0443 \u043A\u043E\u0434\u0443\u0432\u0430\u043D\u043D\u0456 base64url",
        json_string: "\u0440\u044F\u0434\u043E\u043A JSON",
        e164: "\u043D\u043E\u043C\u0435\u0440 E.164",
        jwt: "JWT",
        template_literal: "\u0432\u0445\u0456\u0434\u043D\u0456 \u0434\u0430\u043D\u0456"
      };
      return (issue2) => {
        switch (issue2.code) {
          case "invalid_type":
            return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0456 \u0432\u0445\u0456\u0434\u043D\u0456 \u0434\u0430\u043D\u0456: \u043E\u0447\u0456\u043A\u0443\u0454\u0442\u044C\u0441\u044F ${issue2.expected}, \u043E\u0442\u0440\u0438\u043C\u0430\u043D\u043E ${parsedType8(issue2.input)}`;
          // return `  :  ${issue.expected},  ${util.getParsedType(issue.input)}`;
          case "invalid_value":
            if (issue2.values.length === 1)
              return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0456 \u0432\u0445\u0456\u0434\u043D\u0456 \u0434\u0430\u043D\u0456: \u043E\u0447\u0456\u043A\u0443\u0454\u0442\u044C\u0441\u044F ${stringifyPrimitive(issue2.values[0])}`;
            return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0430 \u043E\u043F\u0446\u0456\u044F: \u043E\u0447\u0456\u043A\u0443\u0454\u0442\u044C\u0441\u044F \u043E\u0434\u043D\u0435 \u0437 ${joinValues(issue2.values, "|")}`;
          case "too_big": {
            const adj = issue2.inclusive ? "<=" : "<";
            const sizing = getSizing(issue2.origin);
            if (sizing)
              return `\u0417\u0430\u043D\u0430\u0434\u0442\u043E \u0432\u0435\u043B\u0438\u043A\u0435: \u043E\u0447\u0456\u043A\u0443\u0454\u0442\u044C\u0441\u044F, \u0449\u043E ${issue2.origin ?? "\u0437\u043D\u0430\u0447\u0435\u043D\u043D\u044F"} ${sizing.verb} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "\u0435\u043B\u0435\u043C\u0435\u043D\u0442\u0456\u0432"}`;
            return `\u0417\u0430\u043D\u0430\u0434\u0442\u043E \u0432\u0435\u043B\u0438\u043A\u0435: \u043E\u0447\u0456\u043A\u0443\u0454\u0442\u044C\u0441\u044F, \u0449\u043E ${issue2.origin ?? "\u0437\u043D\u0430\u0447\u0435\u043D\u043D\u044F"} \u0431\u0443\u0434\u0435 ${adj}${issue2.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue2.inclusive ? ">=" : ">";
            const sizing = getSizing(issue2.origin);
            if (sizing) {
              return `\u0417\u0430\u043D\u0430\u0434\u0442\u043E \u043C\u0430\u043B\u0435: \u043E\u0447\u0456\u043A\u0443\u0454\u0442\u044C\u0441\u044F, \u0449\u043E ${issue2.origin} ${sizing.verb} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
            }
            return `\u0417\u0430\u043D\u0430\u0434\u0442\u043E \u043C\u0430\u043B\u0435: \u043E\u0447\u0456\u043A\u0443\u0454\u0442\u044C\u0441\u044F, \u0449\u043E ${issue2.origin} \u0431\u0443\u0434\u0435 ${adj}${issue2.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue2;
            if (_issue.format === "starts_with")
              return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0438\u0439 \u0440\u044F\u0434\u043E\u043A: \u043F\u043E\u0432\u0438\u043D\u0435\u043D \u043F\u043E\u0447\u0438\u043D\u0430\u0442\u0438\u0441\u044F \u0437 "${_issue.prefix}"`;
            if (_issue.format === "ends_with")
              return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0438\u0439 \u0440\u044F\u0434\u043E\u043A: \u043F\u043E\u0432\u0438\u043D\u0435\u043D \u0437\u0430\u043A\u0456\u043D\u0447\u0443\u0432\u0430\u0442\u0438\u0441\u044F \u043D\u0430 "${_issue.suffix}"`;
            if (_issue.format === "includes")
              return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0438\u0439 \u0440\u044F\u0434\u043E\u043A: \u043F\u043E\u0432\u0438\u043D\u0435\u043D \u043C\u0456\u0441\u0442\u0438\u0442\u0438 "${_issue.includes}"`;
            if (_issue.format === "regex")
              return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0438\u0439 \u0440\u044F\u0434\u043E\u043A: \u043F\u043E\u0432\u0438\u043D\u0435\u043D \u0432\u0456\u0434\u043F\u043E\u0432\u0456\u0434\u0430\u0442\u0438 \u0448\u0430\u0431\u043B\u043E\u043D\u0443 ${_issue.pattern}`;
            return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0438\u0439 ${Nouns[_issue.format] ?? issue2.format}`;
          }
          case "not_multiple_of":
            return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0435 \u0447\u0438\u0441\u043B\u043E: \u043F\u043E\u0432\u0438\u043D\u043D\u043E \u0431\u0443\u0442\u0438 \u043A\u0440\u0430\u0442\u043D\u0438\u043C ${issue2.divisor}`;
          case "unrecognized_keys":
            return `\u041D\u0435\u0440\u043E\u0437\u043F\u0456\u0437\u043D\u0430\u043D\u0438\u0439 \u043A\u043B\u044E\u0447${issue2.keys.length > 1 ? "\u0456" : ""}: ${joinValues(issue2.keys, ", ")}`;
          case "invalid_key":
            return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0438\u0439 \u043A\u043B\u044E\u0447 \u0443 ${issue2.origin}`;
          case "invalid_union":
            return "\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0456 \u0432\u0445\u0456\u0434\u043D\u0456 \u0434\u0430\u043D\u0456";
          case "invalid_element":
            return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0435 \u0437\u043D\u0430\u0447\u0435\u043D\u043D\u044F \u0443 ${issue2.origin}`;
          default:
            return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0456 \u0432\u0445\u0456\u0434\u043D\u0456 \u0434\u0430\u043D\u0456`;
        }
      };
    };
  }
});

// node_modules/zod/v4/locales/ua.js
function ua_default() {
  return uk_default();
}
var init_ua = __esm({
  "node_modules/zod/v4/locales/ua.js"() {
    init_uk();
  }
});

// node_modules/zod/v4/locales/ur.js
function ur_default() {
  return {
    localeError: error41()
  };
}
var error41;
var init_ur = __esm({
  "node_modules/zod/v4/locales/ur.js"() {
    init_util();
    error41 = () => {
      const Sizable = {
        string: { unit: "\u062D\u0631\u0648\u0641", verb: "\u06C1\u0648\u0646\u0627" },
        file: { unit: "\u0628\u0627\u0626\u0679\u0633", verb: "\u06C1\u0648\u0646\u0627" },
        array: { unit: "\u0622\u0626\u0679\u0645\u0632", verb: "\u06C1\u0648\u0646\u0627" },
        set: { unit: "\u0622\u0626\u0679\u0645\u0632", verb: "\u06C1\u0648\u0646\u0627" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const parsedType8 = (data) => {
        const t = typeof data;
        switch (t) {
          case "number": {
            return Number.isNaN(data) ? "NaN" : "\u0646\u0645\u0628\u0631";
          }
          case "object": {
            if (Array.isArray(data)) {
              return "\u0622\u0631\u06D2";
            }
            if (data === null) {
              return "\u0646\u0644";
            }
            if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
              return data.constructor.name;
            }
          }
        }
        return t;
      };
      const Nouns = {
        regex: "\u0627\u0646 \u067E\u0679",
        email: "\u0627\u06CC \u0645\u06CC\u0644 \u0627\u06CC\u0688\u0631\u06CC\u0633",
        url: "\u06CC\u0648 \u0622\u0631 \u0627\u06CC\u0644",
        emoji: "\u0627\u06CC\u0645\u0648\u062C\u06CC",
        uuid: "\u06CC\u0648 \u06CC\u0648 \u0622\u0626\u06CC \u0688\u06CC",
        uuidv4: "\u06CC\u0648 \u06CC\u0648 \u0622\u0626\u06CC \u0688\u06CC \u0648\u06CC 4",
        uuidv6: "\u06CC\u0648 \u06CC\u0648 \u0622\u0626\u06CC \u0688\u06CC \u0648\u06CC 6",
        nanoid: "\u0646\u06CC\u0646\u0648 \u0622\u0626\u06CC \u0688\u06CC",
        guid: "\u062C\u06CC \u06CC\u0648 \u0622\u0626\u06CC \u0688\u06CC",
        cuid: "\u0633\u06CC \u06CC\u0648 \u0622\u0626\u06CC \u0688\u06CC",
        cuid2: "\u0633\u06CC \u06CC\u0648 \u0622\u0626\u06CC \u0688\u06CC 2",
        ulid: "\u06CC\u0648 \u0627\u06CC\u0644 \u0622\u0626\u06CC \u0688\u06CC",
        xid: "\u0627\u06CC\u06A9\u0633 \u0622\u0626\u06CC \u0688\u06CC",
        ksuid: "\u06A9\u06D2 \u0627\u06CC\u0633 \u06CC\u0648 \u0622\u0626\u06CC \u0688\u06CC",
        datetime: "\u0622\u0626\u06CC \u0627\u06CC\u0633 \u0627\u0648 \u0688\u06CC\u0679 \u0679\u0627\u0626\u0645",
        date: "\u0622\u0626\u06CC \u0627\u06CC\u0633 \u0627\u0648 \u062A\u0627\u0631\u06CC\u062E",
        time: "\u0622\u0626\u06CC \u0627\u06CC\u0633 \u0627\u0648 \u0648\u0642\u062A",
        duration: "\u0622\u0626\u06CC \u0627\u06CC\u0633 \u0627\u0648 \u0645\u062F\u062A",
        ipv4: "\u0622\u0626\u06CC \u067E\u06CC \u0648\u06CC 4 \u0627\u06CC\u0688\u0631\u06CC\u0633",
        ipv6: "\u0622\u0626\u06CC \u067E\u06CC \u0648\u06CC 6 \u0627\u06CC\u0688\u0631\u06CC\u0633",
        cidrv4: "\u0622\u0626\u06CC \u067E\u06CC \u0648\u06CC 4 \u0631\u06CC\u0646\u062C",
        cidrv6: "\u0622\u0626\u06CC \u067E\u06CC \u0648\u06CC 6 \u0631\u06CC\u0646\u062C",
        base64: "\u0628\u06CC\u0633 64 \u0627\u0646 \u06A9\u0648\u0688\u0688 \u0633\u0679\u0631\u0646\u06AF",
        base64url: "\u0628\u06CC\u0633 64 \u06CC\u0648 \u0622\u0631 \u0627\u06CC\u0644 \u0627\u0646 \u06A9\u0648\u0688\u0688 \u0633\u0679\u0631\u0646\u06AF",
        json_string: "\u062C\u06D2 \u0627\u06CC\u0633 \u0627\u0648 \u0627\u06CC\u0646 \u0633\u0679\u0631\u0646\u06AF",
        e164: "\u0627\u06CC 164 \u0646\u0645\u0628\u0631",
        jwt: "\u062C\u06D2 \u0688\u0628\u0644\u06CC\u0648 \u0679\u06CC",
        template_literal: "\u0627\u0646 \u067E\u0679"
      };
      return (issue2) => {
        switch (issue2.code) {
          case "invalid_type":
            return `\u063A\u0644\u0637 \u0627\u0646 \u067E\u0679: ${issue2.expected} \u0645\u062A\u0648\u0642\u0639 \u062A\u06BE\u0627\u060C ${parsedType8(issue2.input)} \u0645\u0648\u0635\u0648\u0644 \u06C1\u0648\u0627`;
          case "invalid_value":
            if (issue2.values.length === 1)
              return `\u063A\u0644\u0637 \u0627\u0646 \u067E\u0679: ${stringifyPrimitive(issue2.values[0])} \u0645\u062A\u0648\u0642\u0639 \u062A\u06BE\u0627`;
            return `\u063A\u0644\u0637 \u0622\u067E\u0634\u0646: ${joinValues(issue2.values, "|")} \u0645\u06CC\u06BA \u0633\u06D2 \u0627\u06CC\u06A9 \u0645\u062A\u0648\u0642\u0639 \u062A\u06BE\u0627`;
          case "too_big": {
            const adj = issue2.inclusive ? "<=" : "<";
            const sizing = getSizing(issue2.origin);
            if (sizing)
              return `\u0628\u06C1\u062A \u0628\u0691\u0627: ${issue2.origin ?? "\u0648\u06CC\u0644\u06CC\u0648"} \u06A9\u06D2 ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "\u0639\u0646\u0627\u0635\u0631"} \u06C1\u0648\u0646\u06D2 \u0645\u062A\u0648\u0642\u0639 \u062A\u06BE\u06D2`;
            return `\u0628\u06C1\u062A \u0628\u0691\u0627: ${issue2.origin ?? "\u0648\u06CC\u0644\u06CC\u0648"} \u06A9\u0627 ${adj}${issue2.maximum.toString()} \u06C1\u0648\u0646\u0627 \u0645\u062A\u0648\u0642\u0639 \u062A\u06BE\u0627`;
          }
          case "too_small": {
            const adj = issue2.inclusive ? ">=" : ">";
            const sizing = getSizing(issue2.origin);
            if (sizing) {
              return `\u0628\u06C1\u062A \u0686\u06BE\u0648\u0679\u0627: ${issue2.origin} \u06A9\u06D2 ${adj}${issue2.minimum.toString()} ${sizing.unit} \u06C1\u0648\u0646\u06D2 \u0645\u062A\u0648\u0642\u0639 \u062A\u06BE\u06D2`;
            }
            return `\u0628\u06C1\u062A \u0686\u06BE\u0648\u0679\u0627: ${issue2.origin} \u06A9\u0627 ${adj}${issue2.minimum.toString()} \u06C1\u0648\u0646\u0627 \u0645\u062A\u0648\u0642\u0639 \u062A\u06BE\u0627`;
          }
          case "invalid_format": {
            const _issue = issue2;
            if (_issue.format === "starts_with") {
              return `\u063A\u0644\u0637 \u0633\u0679\u0631\u0646\u06AF: "${_issue.prefix}" \u0633\u06D2 \u0634\u0631\u0648\u0639 \u06C1\u0648\u0646\u0627 \u0686\u0627\u06C1\u06CC\u06D2`;
            }
            if (_issue.format === "ends_with")
              return `\u063A\u0644\u0637 \u0633\u0679\u0631\u0646\u06AF: "${_issue.suffix}" \u067E\u0631 \u062E\u062A\u0645 \u06C1\u0648\u0646\u0627 \u0686\u0627\u06C1\u06CC\u06D2`;
            if (_issue.format === "includes")
              return `\u063A\u0644\u0637 \u0633\u0679\u0631\u0646\u06AF: "${_issue.includes}" \u0634\u0627\u0645\u0644 \u06C1\u0648\u0646\u0627 \u0686\u0627\u06C1\u06CC\u06D2`;
            if (_issue.format === "regex")
              return `\u063A\u0644\u0637 \u0633\u0679\u0631\u0646\u06AF: \u067E\u06CC\u0679\u0631\u0646 ${_issue.pattern} \u0633\u06D2 \u0645\u06CC\u0686 \u06C1\u0648\u0646\u0627 \u0686\u0627\u06C1\u06CC\u06D2`;
            return `\u063A\u0644\u0637 ${Nouns[_issue.format] ?? issue2.format}`;
          }
          case "not_multiple_of":
            return `\u063A\u0644\u0637 \u0646\u0645\u0628\u0631: ${issue2.divisor} \u06A9\u0627 \u0645\u0636\u0627\u0639\u0641 \u06C1\u0648\u0646\u0627 \u0686\u0627\u06C1\u06CC\u06D2`;
          case "unrecognized_keys":
            return `\u063A\u06CC\u0631 \u062A\u0633\u0644\u06CC\u0645 \u0634\u062F\u06C1 \u06A9\u06CC${issue2.keys.length > 1 ? "\u0632" : ""}: ${joinValues(issue2.keys, "\u060C ")}`;
          case "invalid_key":
            return `${issue2.origin} \u0645\u06CC\u06BA \u063A\u0644\u0637 \u06A9\u06CC`;
          case "invalid_union":
            return "\u063A\u0644\u0637 \u0627\u0646 \u067E\u0679";
          case "invalid_element":
            return `${issue2.origin} \u0645\u06CC\u06BA \u063A\u0644\u0637 \u0648\u06CC\u0644\u06CC\u0648`;
          default:
            return `\u063A\u0644\u0637 \u0627\u0646 \u067E\u0679`;
        }
      };
    };
  }
});

// node_modules/zod/v4/locales/vi.js
function vi_default() {
  return {
    localeError: error42()
  };
}
var error42;
var init_vi = __esm({
  "node_modules/zod/v4/locales/vi.js"() {
    init_util();
    error42 = () => {
      const Sizable = {
        string: { unit: "k\xFD t\u1EF1", verb: "c\xF3" },
        file: { unit: "byte", verb: "c\xF3" },
        array: { unit: "ph\u1EA7n t\u1EED", verb: "c\xF3" },
        set: { unit: "ph\u1EA7n t\u1EED", verb: "c\xF3" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const parsedType8 = (data) => {
        const t = typeof data;
        switch (t) {
          case "number": {
            return Number.isNaN(data) ? "NaN" : "s\u1ED1";
          }
          case "object": {
            if (Array.isArray(data)) {
              return "m\u1EA3ng";
            }
            if (data === null) {
              return "null";
            }
            if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
              return data.constructor.name;
            }
          }
        }
        return t;
      };
      const Nouns = {
        regex: "\u0111\u1EA7u v\xE0o",
        email: "\u0111\u1ECBa ch\u1EC9 email",
        url: "URL",
        emoji: "emoji",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "ng\xE0y gi\u1EDD ISO",
        date: "ng\xE0y ISO",
        time: "gi\u1EDD ISO",
        duration: "kho\u1EA3ng th\u1EDDi gian ISO",
        ipv4: "\u0111\u1ECBa ch\u1EC9 IPv4",
        ipv6: "\u0111\u1ECBa ch\u1EC9 IPv6",
        cidrv4: "d\u1EA3i IPv4",
        cidrv6: "d\u1EA3i IPv6",
        base64: "chu\u1ED7i m\xE3 h\xF3a base64",
        base64url: "chu\u1ED7i m\xE3 h\xF3a base64url",
        json_string: "chu\u1ED7i JSON",
        e164: "s\u1ED1 E.164",
        jwt: "JWT",
        template_literal: "\u0111\u1EA7u v\xE0o"
      };
      return (issue2) => {
        switch (issue2.code) {
          case "invalid_type":
            return `\u0110\u1EA7u v\xE0o kh\xF4ng h\u1EE3p l\u1EC7: mong \u0111\u1EE3i ${issue2.expected}, nh\u1EADn \u0111\u01B0\u1EE3c ${parsedType8(issue2.input)}`;
          case "invalid_value":
            if (issue2.values.length === 1)
              return `\u0110\u1EA7u v\xE0o kh\xF4ng h\u1EE3p l\u1EC7: mong \u0111\u1EE3i ${stringifyPrimitive(issue2.values[0])}`;
            return `T\xF9y ch\u1ECDn kh\xF4ng h\u1EE3p l\u1EC7: mong \u0111\u1EE3i m\u1ED9t trong c\xE1c gi\xE1 tr\u1ECB ${joinValues(issue2.values, "|")}`;
          case "too_big": {
            const adj = issue2.inclusive ? "<=" : "<";
            const sizing = getSizing(issue2.origin);
            if (sizing)
              return `Qu\xE1 l\u1EDBn: mong \u0111\u1EE3i ${issue2.origin ?? "gi\xE1 tr\u1ECB"} ${sizing.verb} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "ph\u1EA7n t\u1EED"}`;
            return `Qu\xE1 l\u1EDBn: mong \u0111\u1EE3i ${issue2.origin ?? "gi\xE1 tr\u1ECB"} ${adj}${issue2.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue2.inclusive ? ">=" : ">";
            const sizing = getSizing(issue2.origin);
            if (sizing) {
              return `Qu\xE1 nh\u1ECF: mong \u0111\u1EE3i ${issue2.origin} ${sizing.verb} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
            }
            return `Qu\xE1 nh\u1ECF: mong \u0111\u1EE3i ${issue2.origin} ${adj}${issue2.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue2;
            if (_issue.format === "starts_with")
              return `Chu\u1ED7i kh\xF4ng h\u1EE3p l\u1EC7: ph\u1EA3i b\u1EAFt \u0111\u1EA7u b\u1EB1ng "${_issue.prefix}"`;
            if (_issue.format === "ends_with")
              return `Chu\u1ED7i kh\xF4ng h\u1EE3p l\u1EC7: ph\u1EA3i k\u1EBFt th\xFAc b\u1EB1ng "${_issue.suffix}"`;
            if (_issue.format === "includes")
              return `Chu\u1ED7i kh\xF4ng h\u1EE3p l\u1EC7: ph\u1EA3i bao g\u1ED3m "${_issue.includes}"`;
            if (_issue.format === "regex")
              return `Chu\u1ED7i kh\xF4ng h\u1EE3p l\u1EC7: ph\u1EA3i kh\u1EDBp v\u1EDBi m\u1EABu ${_issue.pattern}`;
            return `${Nouns[_issue.format] ?? issue2.format} kh\xF4ng h\u1EE3p l\u1EC7`;
          }
          case "not_multiple_of":
            return `S\u1ED1 kh\xF4ng h\u1EE3p l\u1EC7: ph\u1EA3i l\xE0 b\u1ED9i s\u1ED1 c\u1EE7a ${issue2.divisor}`;
          case "unrecognized_keys":
            return `Kh\xF3a kh\xF4ng \u0111\u01B0\u1EE3c nh\u1EADn d\u1EA1ng: ${joinValues(issue2.keys, ", ")}`;
          case "invalid_key":
            return `Kh\xF3a kh\xF4ng h\u1EE3p l\u1EC7 trong ${issue2.origin}`;
          case "invalid_union":
            return "\u0110\u1EA7u v\xE0o kh\xF4ng h\u1EE3p l\u1EC7";
          case "invalid_element":
            return `Gi\xE1 tr\u1ECB kh\xF4ng h\u1EE3p l\u1EC7 trong ${issue2.origin}`;
          default:
            return `\u0110\u1EA7u v\xE0o kh\xF4ng h\u1EE3p l\u1EC7`;
        }
      };
    };
  }
});

// node_modules/zod/v4/locales/zh-CN.js
function zh_CN_default() {
  return {
    localeError: error43()
  };
}
var error43;
var init_zh_CN = __esm({
  "node_modules/zod/v4/locales/zh-CN.js"() {
    init_util();
    error43 = () => {
      const Sizable = {
        string: { unit: "\u5B57\u7B26", verb: "\u5305\u542B" },
        file: { unit: "\u5B57\u8282", verb: "\u5305\u542B" },
        array: { unit: "\u9879", verb: "\u5305\u542B" },
        set: { unit: "\u9879", verb: "\u5305\u542B" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const parsedType8 = (data) => {
        const t = typeof data;
        switch (t) {
          case "number": {
            return Number.isNaN(data) ? "\u975E\u6570\u5B57(NaN)" : "\u6570\u5B57";
          }
          case "object": {
            if (Array.isArray(data)) {
              return "\u6570\u7EC4";
            }
            if (data === null) {
              return "\u7A7A\u503C(null)";
            }
            if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
              return data.constructor.name;
            }
          }
        }
        return t;
      };
      const Nouns = {
        regex: "\u8F93\u5165",
        email: "\u7535\u5B50\u90AE\u4EF6",
        url: "URL",
        emoji: "\u8868\u60C5\u7B26\u53F7",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "ISO\u65E5\u671F\u65F6\u95F4",
        date: "ISO\u65E5\u671F",
        time: "ISO\u65F6\u95F4",
        duration: "ISO\u65F6\u957F",
        ipv4: "IPv4\u5730\u5740",
        ipv6: "IPv6\u5730\u5740",
        cidrv4: "IPv4\u7F51\u6BB5",
        cidrv6: "IPv6\u7F51\u6BB5",
        base64: "base64\u7F16\u7801\u5B57\u7B26\u4E32",
        base64url: "base64url\u7F16\u7801\u5B57\u7B26\u4E32",
        json_string: "JSON\u5B57\u7B26\u4E32",
        e164: "E.164\u53F7\u7801",
        jwt: "JWT",
        template_literal: "\u8F93\u5165"
      };
      return (issue2) => {
        switch (issue2.code) {
          case "invalid_type":
            return `\u65E0\u6548\u8F93\u5165\uFF1A\u671F\u671B ${issue2.expected}\uFF0C\u5B9E\u9645\u63A5\u6536 ${parsedType8(issue2.input)}`;
          case "invalid_value":
            if (issue2.values.length === 1)
              return `\u65E0\u6548\u8F93\u5165\uFF1A\u671F\u671B ${stringifyPrimitive(issue2.values[0])}`;
            return `\u65E0\u6548\u9009\u9879\uFF1A\u671F\u671B\u4EE5\u4E0B\u4E4B\u4E00 ${joinValues(issue2.values, "|")}`;
          case "too_big": {
            const adj = issue2.inclusive ? "<=" : "<";
            const sizing = getSizing(issue2.origin);
            if (sizing)
              return `\u6570\u503C\u8FC7\u5927\uFF1A\u671F\u671B ${issue2.origin ?? "\u503C"} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "\u4E2A\u5143\u7D20"}`;
            return `\u6570\u503C\u8FC7\u5927\uFF1A\u671F\u671B ${issue2.origin ?? "\u503C"} ${adj}${issue2.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue2.inclusive ? ">=" : ">";
            const sizing = getSizing(issue2.origin);
            if (sizing) {
              return `\u6570\u503C\u8FC7\u5C0F\uFF1A\u671F\u671B ${issue2.origin} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
            }
            return `\u6570\u503C\u8FC7\u5C0F\uFF1A\u671F\u671B ${issue2.origin} ${adj}${issue2.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue2;
            if (_issue.format === "starts_with")
              return `\u65E0\u6548\u5B57\u7B26\u4E32\uFF1A\u5FC5\u987B\u4EE5 "${_issue.prefix}" \u5F00\u5934`;
            if (_issue.format === "ends_with")
              return `\u65E0\u6548\u5B57\u7B26\u4E32\uFF1A\u5FC5\u987B\u4EE5 "${_issue.suffix}" \u7ED3\u5C3E`;
            if (_issue.format === "includes")
              return `\u65E0\u6548\u5B57\u7B26\u4E32\uFF1A\u5FC5\u987B\u5305\u542B "${_issue.includes}"`;
            if (_issue.format === "regex")
              return `\u65E0\u6548\u5B57\u7B26\u4E32\uFF1A\u5FC5\u987B\u6EE1\u8DB3\u6B63\u5219\u8868\u8FBE\u5F0F ${_issue.pattern}`;
            return `\u65E0\u6548${Nouns[_issue.format] ?? issue2.format}`;
          }
          case "not_multiple_of":
            return `\u65E0\u6548\u6570\u5B57\uFF1A\u5FC5\u987B\u662F ${issue2.divisor} \u7684\u500D\u6570`;
          case "unrecognized_keys":
            return `\u51FA\u73B0\u672A\u77E5\u7684\u952E(key): ${joinValues(issue2.keys, ", ")}`;
          case "invalid_key":
            return `${issue2.origin} \u4E2D\u7684\u952E(key)\u65E0\u6548`;
          case "invalid_union":
            return "\u65E0\u6548\u8F93\u5165";
          case "invalid_element":
            return `${issue2.origin} \u4E2D\u5305\u542B\u65E0\u6548\u503C(value)`;
          default:
            return `\u65E0\u6548\u8F93\u5165`;
        }
      };
    };
  }
});

// node_modules/zod/v4/locales/zh-TW.js
function zh_TW_default() {
  return {
    localeError: error44()
  };
}
var error44;
var init_zh_TW = __esm({
  "node_modules/zod/v4/locales/zh-TW.js"() {
    init_util();
    error44 = () => {
      const Sizable = {
        string: { unit: "\u5B57\u5143", verb: "\u64C1\u6709" },
        file: { unit: "\u4F4D\u5143\u7D44", verb: "\u64C1\u6709" },
        array: { unit: "\u9805\u76EE", verb: "\u64C1\u6709" },
        set: { unit: "\u9805\u76EE", verb: "\u64C1\u6709" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const parsedType8 = (data) => {
        const t = typeof data;
        switch (t) {
          case "number": {
            return Number.isNaN(data) ? "NaN" : "number";
          }
          case "object": {
            if (Array.isArray(data)) {
              return "array";
            }
            if (data === null) {
              return "null";
            }
            if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
              return data.constructor.name;
            }
          }
        }
        return t;
      };
      const Nouns = {
        regex: "\u8F38\u5165",
        email: "\u90F5\u4EF6\u5730\u5740",
        url: "URL",
        emoji: "emoji",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "ISO \u65E5\u671F\u6642\u9593",
        date: "ISO \u65E5\u671F",
        time: "ISO \u6642\u9593",
        duration: "ISO \u671F\u9593",
        ipv4: "IPv4 \u4F4D\u5740",
        ipv6: "IPv6 \u4F4D\u5740",
        cidrv4: "IPv4 \u7BC4\u570D",
        cidrv6: "IPv6 \u7BC4\u570D",
        base64: "base64 \u7DE8\u78BC\u5B57\u4E32",
        base64url: "base64url \u7DE8\u78BC\u5B57\u4E32",
        json_string: "JSON \u5B57\u4E32",
        e164: "E.164 \u6578\u503C",
        jwt: "JWT",
        template_literal: "\u8F38\u5165"
      };
      return (issue2) => {
        switch (issue2.code) {
          case "invalid_type":
            return `\u7121\u6548\u7684\u8F38\u5165\u503C\uFF1A\u9810\u671F\u70BA ${issue2.expected}\uFF0C\u4F46\u6536\u5230 ${parsedType8(issue2.input)}`;
          case "invalid_value":
            if (issue2.values.length === 1)
              return `\u7121\u6548\u7684\u8F38\u5165\u503C\uFF1A\u9810\u671F\u70BA ${stringifyPrimitive(issue2.values[0])}`;
            return `\u7121\u6548\u7684\u9078\u9805\uFF1A\u9810\u671F\u70BA\u4EE5\u4E0B\u5176\u4E2D\u4E4B\u4E00 ${joinValues(issue2.values, "|")}`;
          case "too_big": {
            const adj = issue2.inclusive ? "<=" : "<";
            const sizing = getSizing(issue2.origin);
            if (sizing)
              return `\u6578\u503C\u904E\u5927\uFF1A\u9810\u671F ${issue2.origin ?? "\u503C"} \u61C9\u70BA ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "\u500B\u5143\u7D20"}`;
            return `\u6578\u503C\u904E\u5927\uFF1A\u9810\u671F ${issue2.origin ?? "\u503C"} \u61C9\u70BA ${adj}${issue2.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue2.inclusive ? ">=" : ">";
            const sizing = getSizing(issue2.origin);
            if (sizing) {
              return `\u6578\u503C\u904E\u5C0F\uFF1A\u9810\u671F ${issue2.origin} \u61C9\u70BA ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
            }
            return `\u6578\u503C\u904E\u5C0F\uFF1A\u9810\u671F ${issue2.origin} \u61C9\u70BA ${adj}${issue2.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue2;
            if (_issue.format === "starts_with") {
              return `\u7121\u6548\u7684\u5B57\u4E32\uFF1A\u5FC5\u9808\u4EE5 "${_issue.prefix}" \u958B\u982D`;
            }
            if (_issue.format === "ends_with")
              return `\u7121\u6548\u7684\u5B57\u4E32\uFF1A\u5FC5\u9808\u4EE5 "${_issue.suffix}" \u7D50\u5C3E`;
            if (_issue.format === "includes")
              return `\u7121\u6548\u7684\u5B57\u4E32\uFF1A\u5FC5\u9808\u5305\u542B "${_issue.includes}"`;
            if (_issue.format === "regex")
              return `\u7121\u6548\u7684\u5B57\u4E32\uFF1A\u5FC5\u9808\u7B26\u5408\u683C\u5F0F ${_issue.pattern}`;
            return `\u7121\u6548\u7684 ${Nouns[_issue.format] ?? issue2.format}`;
          }
          case "not_multiple_of":
            return `\u7121\u6548\u7684\u6578\u5B57\uFF1A\u5FC5\u9808\u70BA ${issue2.divisor} \u7684\u500D\u6578`;
          case "unrecognized_keys":
            return `\u7121\u6CD5\u8B58\u5225\u7684\u9375\u503C${issue2.keys.length > 1 ? "\u5011" : ""}\uFF1A${joinValues(issue2.keys, "\u3001")}`;
          case "invalid_key":
            return `${issue2.origin} \u4E2D\u6709\u7121\u6548\u7684\u9375\u503C`;
          case "invalid_union":
            return "\u7121\u6548\u7684\u8F38\u5165\u503C";
          case "invalid_element":
            return `${issue2.origin} \u4E2D\u6709\u7121\u6548\u7684\u503C`;
          default:
            return `\u7121\u6548\u7684\u8F38\u5165\u503C`;
        }
      };
    };
  }
});

// node_modules/zod/v4/locales/yo.js
function yo_default() {
  return {
    localeError: error45()
  };
}
var error45;
var init_yo = __esm({
  "node_modules/zod/v4/locales/yo.js"() {
    init_util();
    error45 = () => {
      const Sizable = {
        string: { unit: "\xE0mi", verb: "n\xED" },
        file: { unit: "bytes", verb: "n\xED" },
        array: { unit: "nkan", verb: "n\xED" },
        set: { unit: "nkan", verb: "n\xED" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const parsedType8 = (data) => {
        const t = typeof data;
        switch (t) {
          case "number": {
            return Number.isNaN(data) ? "NaN" : "n\u1ECD\u0301mb\xE0";
          }
          case "object": {
            if (Array.isArray(data)) {
              return "akop\u1ECD";
            }
            if (data === null) {
              return "null";
            }
            if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
              return data.constructor.name;
            }
          }
        }
        return t;
      };
      const Nouns = {
        regex: "\u1EB9\u0300r\u1ECD \xECb\xE1w\u1ECDl\xE9",
        email: "\xE0d\xEDr\u1EB9\u0301s\xEC \xECm\u1EB9\u0301l\xEC",
        url: "URL",
        emoji: "emoji",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "\xE0k\xF3k\xF2 ISO",
        date: "\u1ECDj\u1ECD\u0301 ISO",
        time: "\xE0k\xF3k\xF2 ISO",
        duration: "\xE0k\xF3k\xF2 t\xF3 p\xE9 ISO",
        ipv4: "\xE0d\xEDr\u1EB9\u0301s\xEC IPv4",
        ipv6: "\xE0d\xEDr\u1EB9\u0301s\xEC IPv6",
        cidrv4: "\xE0gb\xE8gb\xE8 IPv4",
        cidrv6: "\xE0gb\xE8gb\xE8 IPv6",
        base64: "\u1ECD\u0300r\u1ECD\u0300 t\xED a k\u1ECD\u0301 n\xED base64",
        base64url: "\u1ECD\u0300r\u1ECD\u0300 base64url",
        json_string: "\u1ECD\u0300r\u1ECD\u0300 JSON",
        e164: "n\u1ECD\u0301mb\xE0 E.164",
        jwt: "JWT",
        template_literal: "\u1EB9\u0300r\u1ECD \xECb\xE1w\u1ECDl\xE9"
      };
      return (issue2) => {
        switch (issue2.code) {
          case "invalid_type":
            return `\xCCb\xE1w\u1ECDl\xE9 a\u1E63\xEC\u1E63e: a n\xED l\xE1ti fi ${issue2.expected}, \xE0m\u1ECD\u0300 a r\xED ${parsedType8(issue2.input)}`;
          case "invalid_value":
            if (issue2.values.length === 1)
              return `\xCCb\xE1w\u1ECDl\xE9 a\u1E63\xEC\u1E63e: a n\xED l\xE1ti fi ${stringifyPrimitive(issue2.values[0])}`;
            return `\xC0\u1E63\xE0y\xE0n a\u1E63\xEC\u1E63e: yan \u1ECD\u0300kan l\xE1ra ${joinValues(issue2.values, "|")}`;
          case "too_big": {
            const adj = issue2.inclusive ? "<=" : "<";
            const sizing = getSizing(issue2.origin);
            if (sizing)
              return `T\xF3 p\u1ECD\u0300 j\xF9: a n\xED l\xE1ti j\u1EB9\u0301 p\xE9 ${issue2.origin ?? "iye"} ${sizing.verb} ${adj}${issue2.maximum} ${sizing.unit}`;
            return `T\xF3 p\u1ECD\u0300 j\xF9: a n\xED l\xE1ti j\u1EB9\u0301 ${adj}${issue2.maximum}`;
          }
          case "too_small": {
            const adj = issue2.inclusive ? ">=" : ">";
            const sizing = getSizing(issue2.origin);
            if (sizing)
              return `K\xE9r\xE9 ju: a n\xED l\xE1ti j\u1EB9\u0301 p\xE9 ${issue2.origin} ${sizing.verb} ${adj}${issue2.minimum} ${sizing.unit}`;
            return `K\xE9r\xE9 ju: a n\xED l\xE1ti j\u1EB9\u0301 ${adj}${issue2.minimum}`;
          }
          case "invalid_format": {
            const _issue = issue2;
            if (_issue.format === "starts_with")
              return `\u1ECC\u0300r\u1ECD\u0300 a\u1E63\xEC\u1E63e: gb\u1ECD\u0301d\u1ECD\u0300 b\u1EB9\u0300r\u1EB9\u0300 p\u1EB9\u0300l\xFA "${_issue.prefix}"`;
            if (_issue.format === "ends_with")
              return `\u1ECC\u0300r\u1ECD\u0300 a\u1E63\xEC\u1E63e: gb\u1ECD\u0301d\u1ECD\u0300 par\xED p\u1EB9\u0300l\xFA "${_issue.suffix}"`;
            if (_issue.format === "includes")
              return `\u1ECC\u0300r\u1ECD\u0300 a\u1E63\xEC\u1E63e: gb\u1ECD\u0301d\u1ECD\u0300 n\xED "${_issue.includes}"`;
            if (_issue.format === "regex")
              return `\u1ECC\u0300r\u1ECD\u0300 a\u1E63\xEC\u1E63e: gb\u1ECD\u0301d\u1ECD\u0300 b\xE1 \xE0p\u1EB9\u1EB9r\u1EB9 mu ${_issue.pattern}`;
            return `A\u1E63\xEC\u1E63e: ${Nouns[_issue.format] ?? issue2.format}`;
          }
          case "not_multiple_of":
            return `N\u1ECD\u0301mb\xE0 a\u1E63\xEC\u1E63e: gb\u1ECD\u0301d\u1ECD\u0300 j\u1EB9\u0301 \xE8y\xE0 p\xEDp\xEDn ti ${issue2.divisor}`;
          case "unrecognized_keys":
            return `B\u1ECDt\xECn\xEC \xE0\xECm\u1ECD\u0300: ${joinValues(issue2.keys, ", ")}`;
          case "invalid_key":
            return `B\u1ECDt\xECn\xEC a\u1E63\xEC\u1E63e n\xEDn\xFA ${issue2.origin}`;
          case "invalid_union":
            return "\xCCb\xE1w\u1ECDl\xE9 a\u1E63\xEC\u1E63e";
          case "invalid_element":
            return `Iye a\u1E63\xEC\u1E63e n\xEDn\xFA ${issue2.origin}`;
          default:
            return "\xCCb\xE1w\u1ECDl\xE9 a\u1E63\xEC\u1E63e";
        }
      };
    };
  }
});

// node_modules/zod/v4/locales/index.js
var locales_exports = {};
__export(locales_exports, {
  ar: () => ar_default,
  az: () => az_default,
  be: () => be_default,
  bg: () => bg_default,
  ca: () => ca_default,
  cs: () => cs_default,
  da: () => da_default,
  de: () => de_default,
  en: () => en_default,
  eo: () => eo_default,
  es: () => es_default,
  fa: () => fa_default,
  fi: () => fi_default,
  fr: () => fr_default,
  frCA: () => fr_CA_default,
  he: () => he_default,
  hu: () => hu_default,
  id: () => id_default,
  is: () => is_default,
  it: () => it_default,
  ja: () => ja_default,
  ka: () => ka_default,
  kh: () => kh_default,
  km: () => km_default,
  ko: () => ko_default,
  lt: () => lt_default,
  mk: () => mk_default,
  ms: () => ms_default,
  nl: () => nl_default,
  no: () => no_default,
  ota: () => ota_default,
  pl: () => pl_default,
  ps: () => ps_default,
  pt: () => pt_default,
  ru: () => ru_default,
  sl: () => sl_default,
  sv: () => sv_default,
  ta: () => ta_default,
  th: () => th_default,
  tr: () => tr_default,
  ua: () => ua_default,
  uk: () => uk_default,
  ur: () => ur_default,
  vi: () => vi_default,
  yo: () => yo_default,
  zhCN: () => zh_CN_default,
  zhTW: () => zh_TW_default
});
var init_locales = __esm({
  "node_modules/zod/v4/locales/index.js"() {
    init_ar();
    init_az();
    init_be();
    init_bg();
    init_ca();
    init_cs();
    init_da();
    init_de();
    init_en();
    init_eo();
    init_es();
    init_fa();
    init_fi();
    init_fr();
    init_fr_CA();
    init_he();
    init_hu();
    init_id();
    init_is();
    init_it();
    init_ja();
    init_ka();
    init_kh();
    init_km();
    init_ko();
    init_lt();
    init_mk();
    init_ms();
    init_nl();
    init_no();
    init_ota();
    init_ps();
    init_pl();
    init_pt();
    init_ru();
    init_sl();
    init_sv();
    init_ta();
    init_th();
    init_tr();
    init_ua();
    init_uk();
    init_ur();
    init_vi();
    init_zh_CN();
    init_zh_TW();
    init_yo();
  }
});

// node_modules/zod/v4/core/registries.js
function registry() {
  return new $ZodRegistry();
}
var $output, $input, $ZodRegistry, globalRegistry;
var init_registries = __esm({
  "node_modules/zod/v4/core/registries.js"() {
    $output = Symbol("ZodOutput");
    $input = Symbol("ZodInput");
    $ZodRegistry = class {
      constructor() {
        this._map = /* @__PURE__ */ new WeakMap();
        this._idmap = /* @__PURE__ */ new Map();
      }
      add(schema2, ..._meta) {
        const meta = _meta[0];
        this._map.set(schema2, meta);
        if (meta && typeof meta === "object" && "id" in meta) {
          if (this._idmap.has(meta.id)) {
            throw new Error(`ID ${meta.id} already exists in the registry`);
          }
          this._idmap.set(meta.id, schema2);
        }
        return this;
      }
      clear() {
        this._map = /* @__PURE__ */ new WeakMap();
        this._idmap = /* @__PURE__ */ new Map();
        return this;
      }
      remove(schema2) {
        const meta = this._map.get(schema2);
        if (meta && typeof meta === "object" && "id" in meta) {
          this._idmap.delete(meta.id);
        }
        this._map.delete(schema2);
        return this;
      }
      get(schema2) {
        const p = schema2._zod.parent;
        if (p) {
          const pm = { ...this.get(p) ?? {} };
          delete pm.id;
          const f = { ...pm, ...this._map.get(schema2) };
          return Object.keys(f).length ? f : void 0;
        }
        return this._map.get(schema2);
      }
      has(schema2) {
        return this._map.has(schema2);
      }
    };
    globalRegistry = /* @__PURE__ */ registry();
  }
});

// node_modules/zod/v4/core/api.js
function _string(Class2, params) {
  return new Class2({
    type: "string",
    ...normalizeParams(params)
  });
}
function _coercedString(Class2, params) {
  return new Class2({
    type: "string",
    coerce: true,
    ...normalizeParams(params)
  });
}
function _email(Class2, params) {
  return new Class2({
    type: "string",
    format: "email",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _guid(Class2, params) {
  return new Class2({
    type: "string",
    format: "guid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _uuid(Class2, params) {
  return new Class2({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _uuidv4(Class2, params) {
  return new Class2({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: false,
    version: "v4",
    ...normalizeParams(params)
  });
}
function _uuidv6(Class2, params) {
  return new Class2({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: false,
    version: "v6",
    ...normalizeParams(params)
  });
}
function _uuidv7(Class2, params) {
  return new Class2({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: false,
    version: "v7",
    ...normalizeParams(params)
  });
}
function _url(Class2, params) {
  return new Class2({
    type: "string",
    format: "url",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _emoji2(Class2, params) {
  return new Class2({
    type: "string",
    format: "emoji",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _nanoid(Class2, params) {
  return new Class2({
    type: "string",
    format: "nanoid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _cuid(Class2, params) {
  return new Class2({
    type: "string",
    format: "cuid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _cuid2(Class2, params) {
  return new Class2({
    type: "string",
    format: "cuid2",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _ulid(Class2, params) {
  return new Class2({
    type: "string",
    format: "ulid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _xid(Class2, params) {
  return new Class2({
    type: "string",
    format: "xid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _ksuid(Class2, params) {
  return new Class2({
    type: "string",
    format: "ksuid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _ipv4(Class2, params) {
  return new Class2({
    type: "string",
    format: "ipv4",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _ipv6(Class2, params) {
  return new Class2({
    type: "string",
    format: "ipv6",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _cidrv4(Class2, params) {
  return new Class2({
    type: "string",
    format: "cidrv4",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _cidrv6(Class2, params) {
  return new Class2({
    type: "string",
    format: "cidrv6",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _base64(Class2, params) {
  return new Class2({
    type: "string",
    format: "base64",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _base64url(Class2, params) {
  return new Class2({
    type: "string",
    format: "base64url",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _e164(Class2, params) {
  return new Class2({
    type: "string",
    format: "e164",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _jwt(Class2, params) {
  return new Class2({
    type: "string",
    format: "jwt",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _isoDateTime(Class2, params) {
  return new Class2({
    type: "string",
    format: "datetime",
    check: "string_format",
    offset: false,
    local: false,
    precision: null,
    ...normalizeParams(params)
  });
}
function _isoDate(Class2, params) {
  return new Class2({
    type: "string",
    format: "date",
    check: "string_format",
    ...normalizeParams(params)
  });
}
function _isoTime(Class2, params) {
  return new Class2({
    type: "string",
    format: "time",
    check: "string_format",
    precision: null,
    ...normalizeParams(params)
  });
}
function _isoDuration(Class2, params) {
  return new Class2({
    type: "string",
    format: "duration",
    check: "string_format",
    ...normalizeParams(params)
  });
}
function _number(Class2, params) {
  return new Class2({
    type: "number",
    checks: [],
    ...normalizeParams(params)
  });
}
function _coercedNumber(Class2, params) {
  return new Class2({
    type: "number",
    coerce: true,
    checks: [],
    ...normalizeParams(params)
  });
}
function _int(Class2, params) {
  return new Class2({
    type: "number",
    check: "number_format",
    abort: false,
    format: "safeint",
    ...normalizeParams(params)
  });
}
function _float32(Class2, params) {
  return new Class2({
    type: "number",
    check: "number_format",
    abort: false,
    format: "float32",
    ...normalizeParams(params)
  });
}
function _float64(Class2, params) {
  return new Class2({
    type: "number",
    check: "number_format",
    abort: false,
    format: "float64",
    ...normalizeParams(params)
  });
}
function _int32(Class2, params) {
  return new Class2({
    type: "number",
    check: "number_format",
    abort: false,
    format: "int32",
    ...normalizeParams(params)
  });
}
function _uint32(Class2, params) {
  return new Class2({
    type: "number",
    check: "number_format",
    abort: false,
    format: "uint32",
    ...normalizeParams(params)
  });
}
function _boolean(Class2, params) {
  return new Class2({
    type: "boolean",
    ...normalizeParams(params)
  });
}
function _coercedBoolean(Class2, params) {
  return new Class2({
    type: "boolean",
    coerce: true,
    ...normalizeParams(params)
  });
}
function _bigint(Class2, params) {
  return new Class2({
    type: "bigint",
    ...normalizeParams(params)
  });
}
function _coercedBigint(Class2, params) {
  return new Class2({
    type: "bigint",
    coerce: true,
    ...normalizeParams(params)
  });
}
function _int64(Class2, params) {
  return new Class2({
    type: "bigint",
    check: "bigint_format",
    abort: false,
    format: "int64",
    ...normalizeParams(params)
  });
}
function _uint64(Class2, params) {
  return new Class2({
    type: "bigint",
    check: "bigint_format",
    abort: false,
    format: "uint64",
    ...normalizeParams(params)
  });
}
function _symbol(Class2, params) {
  return new Class2({
    type: "symbol",
    ...normalizeParams(params)
  });
}
function _undefined2(Class2, params) {
  return new Class2({
    type: "undefined",
    ...normalizeParams(params)
  });
}
function _null2(Class2, params) {
  return new Class2({
    type: "null",
    ...normalizeParams(params)
  });
}
function _any(Class2) {
  return new Class2({
    type: "any"
  });
}
function _unknown(Class2) {
  return new Class2({
    type: "unknown"
  });
}
function _never(Class2, params) {
  return new Class2({
    type: "never",
    ...normalizeParams(params)
  });
}
function _void(Class2, params) {
  return new Class2({
    type: "void",
    ...normalizeParams(params)
  });
}
function _date(Class2, params) {
  return new Class2({
    type: "date",
    ...normalizeParams(params)
  });
}
function _coercedDate(Class2, params) {
  return new Class2({
    type: "date",
    coerce: true,
    ...normalizeParams(params)
  });
}
function _nan(Class2, params) {
  return new Class2({
    type: "nan",
    ...normalizeParams(params)
  });
}
function _lt(value, params) {
  return new $ZodCheckLessThan({
    check: "less_than",
    ...normalizeParams(params),
    value,
    inclusive: false
  });
}
function _lte(value, params) {
  return new $ZodCheckLessThan({
    check: "less_than",
    ...normalizeParams(params),
    value,
    inclusive: true
  });
}
function _gt(value, params) {
  return new $ZodCheckGreaterThan({
    check: "greater_than",
    ...normalizeParams(params),
    value,
    inclusive: false
  });
}
function _gte(value, params) {
  return new $ZodCheckGreaterThan({
    check: "greater_than",
    ...normalizeParams(params),
    value,
    inclusive: true
  });
}
function _positive(params) {
  return _gt(0, params);
}
function _negative(params) {
  return _lt(0, params);
}
function _nonpositive(params) {
  return _lte(0, params);
}
function _nonnegative(params) {
  return _gte(0, params);
}
function _multipleOf(value, params) {
  return new $ZodCheckMultipleOf({
    check: "multiple_of",
    ...normalizeParams(params),
    value
  });
}
function _maxSize(maximum, params) {
  return new $ZodCheckMaxSize({
    check: "max_size",
    ...normalizeParams(params),
    maximum
  });
}
function _minSize(minimum, params) {
  return new $ZodCheckMinSize({
    check: "min_size",
    ...normalizeParams(params),
    minimum
  });
}
function _size(size, params) {
  return new $ZodCheckSizeEquals({
    check: "size_equals",
    ...normalizeParams(params),
    size
  });
}
function _maxLength(maximum, params) {
  const ch = new $ZodCheckMaxLength({
    check: "max_length",
    ...normalizeParams(params),
    maximum
  });
  return ch;
}
function _minLength(minimum, params) {
  return new $ZodCheckMinLength({
    check: "min_length",
    ...normalizeParams(params),
    minimum
  });
}
function _length(length, params) {
  return new $ZodCheckLengthEquals({
    check: "length_equals",
    ...normalizeParams(params),
    length
  });
}
function _regex(pattern, params) {
  return new $ZodCheckRegex({
    check: "string_format",
    format: "regex",
    ...normalizeParams(params),
    pattern
  });
}
function _lowercase(params) {
  return new $ZodCheckLowerCase({
    check: "string_format",
    format: "lowercase",
    ...normalizeParams(params)
  });
}
function _uppercase(params) {
  return new $ZodCheckUpperCase({
    check: "string_format",
    format: "uppercase",
    ...normalizeParams(params)
  });
}
function _includes(includes, params) {
  return new $ZodCheckIncludes({
    check: "string_format",
    format: "includes",
    ...normalizeParams(params),
    includes
  });
}
function _startsWith(prefix, params) {
  return new $ZodCheckStartsWith({
    check: "string_format",
    format: "starts_with",
    ...normalizeParams(params),
    prefix
  });
}
function _endsWith(suffix, params) {
  return new $ZodCheckEndsWith({
    check: "string_format",
    format: "ends_with",
    ...normalizeParams(params),
    suffix
  });
}
function _property(property, schema2, params) {
  return new $ZodCheckProperty({
    check: "property",
    property,
    schema: schema2,
    ...normalizeParams(params)
  });
}
function _mime(types3, params) {
  return new $ZodCheckMimeType({
    check: "mime_type",
    mime: types3,
    ...normalizeParams(params)
  });
}
function _overwrite(tx) {
  return new $ZodCheckOverwrite({
    check: "overwrite",
    tx
  });
}
function _normalize(form) {
  return _overwrite((input) => input.normalize(form));
}
function _trim() {
  return _overwrite((input) => input.trim());
}
function _toLowerCase() {
  return _overwrite((input) => input.toLowerCase());
}
function _toUpperCase() {
  return _overwrite((input) => input.toUpperCase());
}
function _array(Class2, element, params) {
  return new Class2({
    type: "array",
    element,
    // get element() {
    //   return element;
    // },
    ...normalizeParams(params)
  });
}
function _union(Class2, options, params) {
  return new Class2({
    type: "union",
    options,
    ...normalizeParams(params)
  });
}
function _discriminatedUnion(Class2, discriminator, options, params) {
  return new Class2({
    type: "union",
    options,
    discriminator,
    ...normalizeParams(params)
  });
}
function _intersection(Class2, left, right) {
  return new Class2({
    type: "intersection",
    left,
    right
  });
}
function _tuple(Class2, items, _paramsOrRest, _params) {
  const hasRest = _paramsOrRest instanceof $ZodType;
  const params = hasRest ? _params : _paramsOrRest;
  const rest = hasRest ? _paramsOrRest : null;
  return new Class2({
    type: "tuple",
    items,
    rest,
    ...normalizeParams(params)
  });
}
function _record(Class2, keyType, valueType, params) {
  return new Class2({
    type: "record",
    keyType,
    valueType,
    ...normalizeParams(params)
  });
}
function _map(Class2, keyType, valueType, params) {
  return new Class2({
    type: "map",
    keyType,
    valueType,
    ...normalizeParams(params)
  });
}
function _set(Class2, valueType, params) {
  return new Class2({
    type: "set",
    valueType,
    ...normalizeParams(params)
  });
}
function _enum(Class2, values, params) {
  const entries = Array.isArray(values) ? Object.fromEntries(values.map((v) => [v, v])) : values;
  return new Class2({
    type: "enum",
    entries,
    ...normalizeParams(params)
  });
}
function _nativeEnum(Class2, entries, params) {
  return new Class2({
    type: "enum",
    entries,
    ...normalizeParams(params)
  });
}
function _literal(Class2, value, params) {
  return new Class2({
    type: "literal",
    values: Array.isArray(value) ? value : [value],
    ...normalizeParams(params)
  });
}
function _file(Class2, params) {
  return new Class2({
    type: "file",
    ...normalizeParams(params)
  });
}
function _transform(Class2, fn) {
  return new Class2({
    type: "transform",
    transform: fn
  });
}
function _optional(Class2, innerType) {
  return new Class2({
    type: "optional",
    innerType
  });
}
function _nullable(Class2, innerType) {
  return new Class2({
    type: "nullable",
    innerType
  });
}
function _default(Class2, innerType, defaultValue) {
  return new Class2({
    type: "default",
    innerType,
    get defaultValue() {
      return typeof defaultValue === "function" ? defaultValue() : shallowClone(defaultValue);
    }
  });
}
function _nonoptional(Class2, innerType, params) {
  return new Class2({
    type: "nonoptional",
    innerType,
    ...normalizeParams(params)
  });
}
function _success(Class2, innerType) {
  return new Class2({
    type: "success",
    innerType
  });
}
function _catch(Class2, innerType, catchValue) {
  return new Class2({
    type: "catch",
    innerType,
    catchValue: typeof catchValue === "function" ? catchValue : () => catchValue
  });
}
function _pipe(Class2, in_, out) {
  return new Class2({
    type: "pipe",
    in: in_,
    out
  });
}
function _readonly(Class2, innerType) {
  return new Class2({
    type: "readonly",
    innerType
  });
}
function _templateLiteral(Class2, parts, params) {
  return new Class2({
    type: "template_literal",
    parts,
    ...normalizeParams(params)
  });
}
function _lazy(Class2, getter) {
  return new Class2({
    type: "lazy",
    getter
  });
}
function _promise(Class2, innerType) {
  return new Class2({
    type: "promise",
    innerType
  });
}
function _custom(Class2, fn, _params) {
  const norm = normalizeParams(_params);
  norm.abort ?? (norm.abort = true);
  const schema2 = new Class2({
    type: "custom",
    check: "custom",
    fn,
    ...norm
  });
  return schema2;
}
function _refine(Class2, fn, _params) {
  const schema2 = new Class2({
    type: "custom",
    check: "custom",
    fn,
    ...normalizeParams(_params)
  });
  return schema2;
}
function _superRefine(fn) {
  const ch = _check((payload) => {
    payload.addIssue = (issue2) => {
      if (typeof issue2 === "string") {
        payload.issues.push(issue(issue2, payload.value, ch._zod.def));
      } else {
        const _issue = issue2;
        if (_issue.fatal)
          _issue.continue = false;
        _issue.code ?? (_issue.code = "custom");
        _issue.input ?? (_issue.input = payload.value);
        _issue.inst ?? (_issue.inst = ch);
        _issue.continue ?? (_issue.continue = !ch._zod.def.abort);
        payload.issues.push(issue(_issue));
      }
    };
    return fn(payload.value, payload);
  });
  return ch;
}
function _check(fn, params) {
  const ch = new $ZodCheck({
    check: "custom",
    ...normalizeParams(params)
  });
  ch._zod.check = fn;
  return ch;
}
function _stringbool(Classes, _params) {
  const params = normalizeParams(_params);
  let truthyArray = params.truthy ?? ["true", "1", "yes", "on", "y", "enabled"];
  let falsyArray = params.falsy ?? ["false", "0", "no", "off", "n", "disabled"];
  if (params.case !== "sensitive") {
    truthyArray = truthyArray.map((v) => typeof v === "string" ? v.toLowerCase() : v);
    falsyArray = falsyArray.map((v) => typeof v === "string" ? v.toLowerCase() : v);
  }
  const truthySet = new Set(truthyArray);
  const falsySet = new Set(falsyArray);
  const _Codec = Classes.Codec ?? $ZodCodec;
  const _Boolean = Classes.Boolean ?? $ZodBoolean;
  const _String = Classes.String ?? $ZodString;
  const stringSchema = new _String({ type: "string", error: params.error });
  const booleanSchema = new _Boolean({ type: "boolean", error: params.error });
  const codec2 = new _Codec({
    type: "pipe",
    in: stringSchema,
    out: booleanSchema,
    transform: ((input, payload) => {
      let data = input;
      if (params.case !== "sensitive")
        data = data.toLowerCase();
      if (truthySet.has(data)) {
        return true;
      } else if (falsySet.has(data)) {
        return false;
      } else {
        payload.issues.push({
          code: "invalid_value",
          expected: "stringbool",
          values: [...truthySet, ...falsySet],
          input: payload.value,
          inst: codec2,
          continue: false
        });
        return {};
      }
    }),
    reverseTransform: ((input, _payload) => {
      if (input === true) {
        return truthyArray[0] || "true";
      } else {
        return falsyArray[0] || "false";
      }
    }),
    error: params.error
  });
  return codec2;
}
function _stringFormat(Class2, format, fnOrRegex, _params = {}) {
  const params = normalizeParams(_params);
  const def = {
    ...normalizeParams(_params),
    check: "string_format",
    type: "string",
    format,
    fn: typeof fnOrRegex === "function" ? fnOrRegex : (val) => fnOrRegex.test(val),
    ...params
  };
  if (fnOrRegex instanceof RegExp) {
    def.pattern = fnOrRegex;
  }
  const inst = new Class2(def);
  return inst;
}
var TimePrecision;
var init_api = __esm({
  "node_modules/zod/v4/core/api.js"() {
    init_checks();
    init_schemas();
    init_util();
    TimePrecision = {
      Any: null,
      Minute: -1,
      Second: 0,
      Millisecond: 3,
      Microsecond: 6
    };
  }
});

// node_modules/zod/v4/core/to-json-schema.js
function toJSONSchema(input, _params) {
  if (input instanceof $ZodRegistry) {
    const gen2 = new JSONSchemaGenerator(_params);
    const defs = {};
    for (const entry of input._idmap.entries()) {
      const [_, schema2] = entry;
      gen2.process(schema2);
    }
    const schemas = {};
    const external = {
      registry: input,
      uri: _params?.uri,
      defs
    };
    for (const entry of input._idmap.entries()) {
      const [key, schema2] = entry;
      schemas[key] = gen2.emit(schema2, {
        ..._params,
        external
      });
    }
    if (Object.keys(defs).length > 0) {
      const defsSegment = gen2.target === "draft-2020-12" ? "$defs" : "definitions";
      schemas.__shared = {
        [defsSegment]: defs
      };
    }
    return { schemas };
  }
  const gen = new JSONSchemaGenerator(_params);
  gen.process(input);
  return gen.emit(input, _params);
}
function isTransforming(_schema, _ctx) {
  const ctx = _ctx ?? { seen: /* @__PURE__ */ new Set() };
  if (ctx.seen.has(_schema))
    return false;
  ctx.seen.add(_schema);
  const schema2 = _schema;
  const def = schema2._zod.def;
  switch (def.type) {
    case "string":
    case "number":
    case "bigint":
    case "boolean":
    case "date":
    case "symbol":
    case "undefined":
    case "null":
    case "any":
    case "unknown":
    case "never":
    case "void":
    case "literal":
    case "enum":
    case "nan":
    case "file":
    case "template_literal":
      return false;
    case "array": {
      return isTransforming(def.element, ctx);
    }
    case "object": {
      for (const key in def.shape) {
        if (isTransforming(def.shape[key], ctx))
          return true;
      }
      return false;
    }
    case "union": {
      for (const option of def.options) {
        if (isTransforming(option, ctx))
          return true;
      }
      return false;
    }
    case "intersection": {
      return isTransforming(def.left, ctx) || isTransforming(def.right, ctx);
    }
    case "tuple": {
      for (const item of def.items) {
        if (isTransforming(item, ctx))
          return true;
      }
      if (def.rest && isTransforming(def.rest, ctx))
        return true;
      return false;
    }
    case "record": {
      return isTransforming(def.keyType, ctx) || isTransforming(def.valueType, ctx);
    }
    case "map": {
      return isTransforming(def.keyType, ctx) || isTransforming(def.valueType, ctx);
    }
    case "set": {
      return isTransforming(def.valueType, ctx);
    }
    // inner types
    case "promise":
    case "optional":
    case "nonoptional":
    case "nullable":
    case "readonly":
      return isTransforming(def.innerType, ctx);
    case "lazy":
      return isTransforming(def.getter(), ctx);
    case "default": {
      return isTransforming(def.innerType, ctx);
    }
    case "prefault": {
      return isTransforming(def.innerType, ctx);
    }
    case "custom": {
      return false;
    }
    case "transform": {
      return true;
    }
    case "pipe": {
      return isTransforming(def.in, ctx) || isTransforming(def.out, ctx);
    }
    case "success": {
      return false;
    }
    case "catch": {
      return false;
    }
    case "function": {
      return false;
    }
    default:
      def;
  }
  throw new Error(`Unknown schema type: ${def.type}`);
}
var JSONSchemaGenerator;
var init_to_json_schema = __esm({
  "node_modules/zod/v4/core/to-json-schema.js"() {
    init_registries();
    init_util();
    JSONSchemaGenerator = class {
      constructor(params) {
        this.counter = 0;
        this.metadataRegistry = params?.metadata ?? globalRegistry;
        this.target = params?.target ?? "draft-2020-12";
        this.unrepresentable = params?.unrepresentable ?? "throw";
        this.override = params?.override ?? (() => {
        });
        this.io = params?.io ?? "output";
        this.seen = /* @__PURE__ */ new Map();
      }
      process(schema2, _params = { path: [], schemaPath: [] }) {
        var _a;
        const def = schema2._zod.def;
        const formatMap = {
          guid: "uuid",
          url: "uri",
          datetime: "date-time",
          json_string: "json-string",
          regex: ""
          // do not set
        };
        const seen = this.seen.get(schema2);
        if (seen) {
          seen.count++;
          const isCycle = _params.schemaPath.includes(schema2);
          if (isCycle) {
            seen.cycle = _params.path;
          }
          return seen.schema;
        }
        const result = { schema: {}, count: 1, cycle: void 0, path: _params.path };
        this.seen.set(schema2, result);
        const overrideSchema = schema2._zod.toJSONSchema?.();
        if (overrideSchema) {
          result.schema = overrideSchema;
        } else {
          const params = {
            ..._params,
            schemaPath: [..._params.schemaPath, schema2],
            path: _params.path
          };
          const parent = schema2._zod.parent;
          if (parent) {
            result.ref = parent;
            this.process(parent, params);
            this.seen.get(parent).isParent = true;
          } else {
            const _json = result.schema;
            switch (def.type) {
              case "string": {
                const json3 = _json;
                json3.type = "string";
                const { minimum, maximum, format, patterns, contentEncoding } = schema2._zod.bag;
                if (typeof minimum === "number")
                  json3.minLength = minimum;
                if (typeof maximum === "number")
                  json3.maxLength = maximum;
                if (format) {
                  json3.format = formatMap[format] ?? format;
                  if (json3.format === "")
                    delete json3.format;
                }
                if (contentEncoding)
                  json3.contentEncoding = contentEncoding;
                if (patterns && patterns.size > 0) {
                  const regexes = [...patterns];
                  if (regexes.length === 1)
                    json3.pattern = regexes[0].source;
                  else if (regexes.length > 1) {
                    result.schema.allOf = [
                      ...regexes.map((regex) => ({
                        ...this.target === "draft-7" || this.target === "draft-4" || this.target === "openapi-3.0" ? { type: "string" } : {},
                        pattern: regex.source
                      }))
                    ];
                  }
                }
                break;
              }
              case "number": {
                const json3 = _json;
                const { minimum, maximum, format, multipleOf, exclusiveMaximum, exclusiveMinimum } = schema2._zod.bag;
                if (typeof format === "string" && format.includes("int"))
                  json3.type = "integer";
                else
                  json3.type = "number";
                if (typeof exclusiveMinimum === "number") {
                  if (this.target === "draft-4" || this.target === "openapi-3.0") {
                    json3.minimum = exclusiveMinimum;
                    json3.exclusiveMinimum = true;
                  } else {
                    json3.exclusiveMinimum = exclusiveMinimum;
                  }
                }
                if (typeof minimum === "number") {
                  json3.minimum = minimum;
                  if (typeof exclusiveMinimum === "number" && this.target !== "draft-4") {
                    if (exclusiveMinimum >= minimum)
                      delete json3.minimum;
                    else
                      delete json3.exclusiveMinimum;
                  }
                }
                if (typeof exclusiveMaximum === "number") {
                  if (this.target === "draft-4" || this.target === "openapi-3.0") {
                    json3.maximum = exclusiveMaximum;
                    json3.exclusiveMaximum = true;
                  } else {
                    json3.exclusiveMaximum = exclusiveMaximum;
                  }
                }
                if (typeof maximum === "number") {
                  json3.maximum = maximum;
                  if (typeof exclusiveMaximum === "number" && this.target !== "draft-4") {
                    if (exclusiveMaximum <= maximum)
                      delete json3.maximum;
                    else
                      delete json3.exclusiveMaximum;
                  }
                }
                if (typeof multipleOf === "number")
                  json3.multipleOf = multipleOf;
                break;
              }
              case "boolean": {
                const json3 = _json;
                json3.type = "boolean";
                break;
              }
              case "bigint": {
                if (this.unrepresentable === "throw") {
                  throw new Error("BigInt cannot be represented in JSON Schema");
                }
                break;
              }
              case "symbol": {
                if (this.unrepresentable === "throw") {
                  throw new Error("Symbols cannot be represented in JSON Schema");
                }
                break;
              }
              case "null": {
                if (this.target === "openapi-3.0") {
                  _json.type = "string";
                  _json.nullable = true;
                  _json.enum = [null];
                } else
                  _json.type = "null";
                break;
              }
              case "any": {
                break;
              }
              case "unknown": {
                break;
              }
              case "undefined": {
                if (this.unrepresentable === "throw") {
                  throw new Error("Undefined cannot be represented in JSON Schema");
                }
                break;
              }
              case "void": {
                if (this.unrepresentable === "throw") {
                  throw new Error("Void cannot be represented in JSON Schema");
                }
                break;
              }
              case "never": {
                _json.not = {};
                break;
              }
              case "date": {
                if (this.unrepresentable === "throw") {
                  throw new Error("Date cannot be represented in JSON Schema");
                }
                break;
              }
              case "array": {
                const json3 = _json;
                const { minimum, maximum } = schema2._zod.bag;
                if (typeof minimum === "number")
                  json3.minItems = minimum;
                if (typeof maximum === "number")
                  json3.maxItems = maximum;
                json3.type = "array";
                json3.items = this.process(def.element, { ...params, path: [...params.path, "items"] });
                break;
              }
              case "object": {
                const json3 = _json;
                json3.type = "object";
                json3.properties = {};
                const shape = def.shape;
                for (const key in shape) {
                  json3.properties[key] = this.process(shape[key], {
                    ...params,
                    path: [...params.path, "properties", key]
                  });
                }
                const allKeys = new Set(Object.keys(shape));
                const requiredKeys = new Set([...allKeys].filter((key) => {
                  const v = def.shape[key]._zod;
                  if (this.io === "input") {
                    return v.optin === void 0;
                  } else {
                    return v.optout === void 0;
                  }
                }));
                if (requiredKeys.size > 0) {
                  json3.required = Array.from(requiredKeys);
                }
                if (def.catchall?._zod.def.type === "never") {
                  json3.additionalProperties = false;
                } else if (!def.catchall) {
                  if (this.io === "output")
                    json3.additionalProperties = false;
                } else if (def.catchall) {
                  json3.additionalProperties = this.process(def.catchall, {
                    ...params,
                    path: [...params.path, "additionalProperties"]
                  });
                }
                break;
              }
              case "union": {
                const json3 = _json;
                const options = def.options.map((x, i) => this.process(x, {
                  ...params,
                  path: [...params.path, "anyOf", i]
                }));
                json3.anyOf = options;
                break;
              }
              case "intersection": {
                const json3 = _json;
                const a = this.process(def.left, {
                  ...params,
                  path: [...params.path, "allOf", 0]
                });
                const b = this.process(def.right, {
                  ...params,
                  path: [...params.path, "allOf", 1]
                });
                const isSimpleIntersection = (val) => "allOf" in val && Object.keys(val).length === 1;
                const allOf = [
                  ...isSimpleIntersection(a) ? a.allOf : [a],
                  ...isSimpleIntersection(b) ? b.allOf : [b]
                ];
                json3.allOf = allOf;
                break;
              }
              case "tuple": {
                const json3 = _json;
                json3.type = "array";
                const prefixPath = this.target === "draft-2020-12" ? "prefixItems" : "items";
                const restPath = this.target === "draft-2020-12" ? "items" : this.target === "openapi-3.0" ? "items" : "additionalItems";
                const prefixItems = def.items.map((x, i) => this.process(x, {
                  ...params,
                  path: [...params.path, prefixPath, i]
                }));
                const rest = def.rest ? this.process(def.rest, {
                  ...params,
                  path: [...params.path, restPath, ...this.target === "openapi-3.0" ? [def.items.length] : []]
                }) : null;
                if (this.target === "draft-2020-12") {
                  json3.prefixItems = prefixItems;
                  if (rest) {
                    json3.items = rest;
                  }
                } else if (this.target === "openapi-3.0") {
                  json3.items = {
                    anyOf: prefixItems
                  };
                  if (rest) {
                    json3.items.anyOf.push(rest);
                  }
                  json3.minItems = prefixItems.length;
                  if (!rest) {
                    json3.maxItems = prefixItems.length;
                  }
                } else {
                  json3.items = prefixItems;
                  if (rest) {
                    json3.additionalItems = rest;
                  }
                }
                const { minimum, maximum } = schema2._zod.bag;
                if (typeof minimum === "number")
                  json3.minItems = minimum;
                if (typeof maximum === "number")
                  json3.maxItems = maximum;
                break;
              }
              case "record": {
                const json3 = _json;
                json3.type = "object";
                if (this.target === "draft-7" || this.target === "draft-2020-12") {
                  json3.propertyNames = this.process(def.keyType, {
                    ...params,
                    path: [...params.path, "propertyNames"]
                  });
                }
                json3.additionalProperties = this.process(def.valueType, {
                  ...params,
                  path: [...params.path, "additionalProperties"]
                });
                break;
              }
              case "map": {
                if (this.unrepresentable === "throw") {
                  throw new Error("Map cannot be represented in JSON Schema");
                }
                break;
              }
              case "set": {
                if (this.unrepresentable === "throw") {
                  throw new Error("Set cannot be represented in JSON Schema");
                }
                break;
              }
              case "enum": {
                const json3 = _json;
                const values = getEnumValues(def.entries);
                if (values.every((v) => typeof v === "number"))
                  json3.type = "number";
                if (values.every((v) => typeof v === "string"))
                  json3.type = "string";
                json3.enum = values;
                break;
              }
              case "literal": {
                const json3 = _json;
                const vals = [];
                for (const val of def.values) {
                  if (val === void 0) {
                    if (this.unrepresentable === "throw") {
                      throw new Error("Literal `undefined` cannot be represented in JSON Schema");
                    } else {
                    }
                  } else if (typeof val === "bigint") {
                    if (this.unrepresentable === "throw") {
                      throw new Error("BigInt literals cannot be represented in JSON Schema");
                    } else {
                      vals.push(Number(val));
                    }
                  } else {
                    vals.push(val);
                  }
                }
                if (vals.length === 0) {
                } else if (vals.length === 1) {
                  const val = vals[0];
                  json3.type = val === null ? "null" : typeof val;
                  if (this.target === "draft-4" || this.target === "openapi-3.0") {
                    json3.enum = [val];
                  } else {
                    json3.const = val;
                  }
                } else {
                  if (vals.every((v) => typeof v === "number"))
                    json3.type = "number";
                  if (vals.every((v) => typeof v === "string"))
                    json3.type = "string";
                  if (vals.every((v) => typeof v === "boolean"))
                    json3.type = "string";
                  if (vals.every((v) => v === null))
                    json3.type = "null";
                  json3.enum = vals;
                }
                break;
              }
              case "file": {
                const json3 = _json;
                const file2 = {
                  type: "string",
                  format: "binary",
                  contentEncoding: "binary"
                };
                const { minimum, maximum, mime } = schema2._zod.bag;
                if (minimum !== void 0)
                  file2.minLength = minimum;
                if (maximum !== void 0)
                  file2.maxLength = maximum;
                if (mime) {
                  if (mime.length === 1) {
                    file2.contentMediaType = mime[0];
                    Object.assign(json3, file2);
                  } else {
                    json3.anyOf = mime.map((m) => {
                      const mFile = { ...file2, contentMediaType: m };
                      return mFile;
                    });
                  }
                } else {
                  Object.assign(json3, file2);
                }
                break;
              }
              case "transform": {
                if (this.unrepresentable === "throw") {
                  throw new Error("Transforms cannot be represented in JSON Schema");
                }
                break;
              }
              case "nullable": {
                const inner = this.process(def.innerType, params);
                if (this.target === "openapi-3.0") {
                  result.ref = def.innerType;
                  _json.nullable = true;
                } else {
                  _json.anyOf = [inner, { type: "null" }];
                }
                break;
              }
              case "nonoptional": {
                this.process(def.innerType, params);
                result.ref = def.innerType;
                break;
              }
              case "success": {
                const json3 = _json;
                json3.type = "boolean";
                break;
              }
              case "default": {
                this.process(def.innerType, params);
                result.ref = def.innerType;
                _json.default = JSON.parse(JSON.stringify(def.defaultValue));
                break;
              }
              case "prefault": {
                this.process(def.innerType, params);
                result.ref = def.innerType;
                if (this.io === "input")
                  _json._prefault = JSON.parse(JSON.stringify(def.defaultValue));
                break;
              }
              case "catch": {
                this.process(def.innerType, params);
                result.ref = def.innerType;
                let catchValue;
                try {
                  catchValue = def.catchValue(void 0);
                } catch {
                  throw new Error("Dynamic catch values are not supported in JSON Schema");
                }
                _json.default = catchValue;
                break;
              }
              case "nan": {
                if (this.unrepresentable === "throw") {
                  throw new Error("NaN cannot be represented in JSON Schema");
                }
                break;
              }
              case "template_literal": {
                const json3 = _json;
                const pattern = schema2._zod.pattern;
                if (!pattern)
                  throw new Error("Pattern not found in template literal");
                json3.type = "string";
                json3.pattern = pattern.source;
                break;
              }
              case "pipe": {
                const innerType = this.io === "input" ? def.in._zod.def.type === "transform" ? def.out : def.in : def.out;
                this.process(innerType, params);
                result.ref = innerType;
                break;
              }
              case "readonly": {
                this.process(def.innerType, params);
                result.ref = def.innerType;
                _json.readOnly = true;
                break;
              }
              // passthrough types
              case "promise": {
                this.process(def.innerType, params);
                result.ref = def.innerType;
                break;
              }
              case "optional": {
                this.process(def.innerType, params);
                result.ref = def.innerType;
                break;
              }
              case "lazy": {
                const innerType = schema2._zod.innerType;
                this.process(innerType, params);
                result.ref = innerType;
                break;
              }
              case "custom": {
                if (this.unrepresentable === "throw") {
                  throw new Error("Custom types cannot be represented in JSON Schema");
                }
                break;
              }
              case "function": {
                if (this.unrepresentable === "throw") {
                  throw new Error("Function types cannot be represented in JSON Schema");
                }
                break;
              }
              default: {
                def;
              }
            }
          }
        }
        const meta = this.metadataRegistry.get(schema2);
        if (meta)
          Object.assign(result.schema, meta);
        if (this.io === "input" && isTransforming(schema2)) {
          delete result.schema.examples;
          delete result.schema.default;
        }
        if (this.io === "input" && result.schema._prefault)
          (_a = result.schema).default ?? (_a.default = result.schema._prefault);
        delete result.schema._prefault;
        const _result = this.seen.get(schema2);
        return _result.schema;
      }
      emit(schema2, _params) {
        const params = {
          cycles: _params?.cycles ?? "ref",
          reused: _params?.reused ?? "inline",
          // unrepresentable: _params?.unrepresentable ?? "throw",
          // uri: _params?.uri ?? ((id) => `${id}`),
          external: _params?.external ?? void 0
        };
        const root = this.seen.get(schema2);
        if (!root)
          throw new Error("Unprocessed schema. This is a bug in Zod.");
        const makeURI = (entry) => {
          const defsSegment = this.target === "draft-2020-12" ? "$defs" : "definitions";
          if (params.external) {
            const externalId = params.external.registry.get(entry[0])?.id;
            const uriGenerator = params.external.uri ?? ((id2) => id2);
            if (externalId) {
              return { ref: uriGenerator(externalId) };
            }
            const id = entry[1].defId ?? entry[1].schema.id ?? `schema${this.counter++}`;
            entry[1].defId = id;
            return { defId: id, ref: `${uriGenerator("__shared")}#/${defsSegment}/${id}` };
          }
          if (entry[1] === root) {
            return { ref: "#" };
          }
          const uriPrefix = `#`;
          const defUriPrefix = `${uriPrefix}/${defsSegment}/`;
          const defId = entry[1].schema.id ?? `__schema${this.counter++}`;
          return { defId, ref: defUriPrefix + defId };
        };
        const extractToDef = (entry) => {
          if (entry[1].schema.$ref) {
            return;
          }
          const seen = entry[1];
          const { ref, defId } = makeURI(entry);
          seen.def = { ...seen.schema };
          if (defId)
            seen.defId = defId;
          const schema3 = seen.schema;
          for (const key in schema3) {
            delete schema3[key];
          }
          schema3.$ref = ref;
        };
        if (params.cycles === "throw") {
          for (const entry of this.seen.entries()) {
            const seen = entry[1];
            if (seen.cycle) {
              throw new Error(`Cycle detected: #/${seen.cycle?.join("/")}/<root>

Set the \`cycles\` parameter to \`"ref"\` to resolve cyclical schemas with defs.`);
            }
          }
        }
        for (const entry of this.seen.entries()) {
          const seen = entry[1];
          if (schema2 === entry[0]) {
            extractToDef(entry);
            continue;
          }
          if (params.external) {
            const ext = params.external.registry.get(entry[0])?.id;
            if (schema2 !== entry[0] && ext) {
              extractToDef(entry);
              continue;
            }
          }
          const id = this.metadataRegistry.get(entry[0])?.id;
          if (id) {
            extractToDef(entry);
            continue;
          }
          if (seen.cycle) {
            extractToDef(entry);
            continue;
          }
          if (seen.count > 1) {
            if (params.reused === "ref") {
              extractToDef(entry);
              continue;
            }
          }
        }
        const flattenRef = (zodSchema, params2) => {
          const seen = this.seen.get(zodSchema);
          const schema3 = seen.def ?? seen.schema;
          const _cached = { ...schema3 };
          if (seen.ref === null) {
            return;
          }
          const ref = seen.ref;
          seen.ref = null;
          if (ref) {
            flattenRef(ref, params2);
            const refSchema = this.seen.get(ref).schema;
            if (refSchema.$ref && (params2.target === "draft-7" || params2.target === "draft-4" || params2.target === "openapi-3.0")) {
              schema3.allOf = schema3.allOf ?? [];
              schema3.allOf.push(refSchema);
            } else {
              Object.assign(schema3, refSchema);
              Object.assign(schema3, _cached);
            }
          }
          if (!seen.isParent)
            this.override({
              zodSchema,
              jsonSchema: schema3,
              path: seen.path ?? []
            });
        };
        for (const entry of [...this.seen.entries()].reverse()) {
          flattenRef(entry[0], { target: this.target });
        }
        const result = {};
        if (this.target === "draft-2020-12") {
          result.$schema = "https://json-schema.org/draft/2020-12/schema";
        } else if (this.target === "draft-7") {
          result.$schema = "http://json-schema.org/draft-07/schema#";
        } else if (this.target === "draft-4") {
          result.$schema = "http://json-schema.org/draft-04/schema#";
        } else if (this.target === "openapi-3.0") {
        } else {
          console.warn(`Invalid target: ${this.target}`);
        }
        if (params.external?.uri) {
          const id = params.external.registry.get(schema2)?.id;
          if (!id)
            throw new Error("Schema is missing an `id` property");
          result.$id = params.external.uri(id);
        }
        Object.assign(result, root.def);
        const defs = params.external?.defs ?? {};
        for (const entry of this.seen.entries()) {
          const seen = entry[1];
          if (seen.def && seen.defId) {
            defs[seen.defId] = seen.def;
          }
        }
        if (params.external) {
        } else {
          if (Object.keys(defs).length > 0) {
            if (this.target === "draft-2020-12") {
              result.$defs = defs;
            } else {
              result.definitions = defs;
            }
          }
        }
        try {
          return JSON.parse(JSON.stringify(result));
        } catch (_err) {
          throw new Error("Error converting schema to JSON.");
        }
      }
    };
  }
});

// node_modules/zod/v4/core/json-schema.js
var json_schema_exports = {};
var init_json_schema = __esm({
  "node_modules/zod/v4/core/json-schema.js"() {
  }
});

// node_modules/zod/v4/core/index.js
var core_exports2 = {};
__export(core_exports2, {
  $ZodAny: () => $ZodAny,
  $ZodArray: () => $ZodArray,
  $ZodAsyncError: () => $ZodAsyncError,
  $ZodBase64: () => $ZodBase64,
  $ZodBase64URL: () => $ZodBase64URL,
  $ZodBigInt: () => $ZodBigInt,
  $ZodBigIntFormat: () => $ZodBigIntFormat,
  $ZodBoolean: () => $ZodBoolean,
  $ZodCIDRv4: () => $ZodCIDRv4,
  $ZodCIDRv6: () => $ZodCIDRv6,
  $ZodCUID: () => $ZodCUID,
  $ZodCUID2: () => $ZodCUID2,
  $ZodCatch: () => $ZodCatch,
  $ZodCheck: () => $ZodCheck,
  $ZodCheckBigIntFormat: () => $ZodCheckBigIntFormat,
  $ZodCheckEndsWith: () => $ZodCheckEndsWith,
  $ZodCheckGreaterThan: () => $ZodCheckGreaterThan,
  $ZodCheckIncludes: () => $ZodCheckIncludes,
  $ZodCheckLengthEquals: () => $ZodCheckLengthEquals,
  $ZodCheckLessThan: () => $ZodCheckLessThan,
  $ZodCheckLowerCase: () => $ZodCheckLowerCase,
  $ZodCheckMaxLength: () => $ZodCheckMaxLength,
  $ZodCheckMaxSize: () => $ZodCheckMaxSize,
  $ZodCheckMimeType: () => $ZodCheckMimeType,
  $ZodCheckMinLength: () => $ZodCheckMinLength,
  $ZodCheckMinSize: () => $ZodCheckMinSize,
  $ZodCheckMultipleOf: () => $ZodCheckMultipleOf,
  $ZodCheckNumberFormat: () => $ZodCheckNumberFormat,
  $ZodCheckOverwrite: () => $ZodCheckOverwrite,
  $ZodCheckProperty: () => $ZodCheckProperty,
  $ZodCheckRegex: () => $ZodCheckRegex,
  $ZodCheckSizeEquals: () => $ZodCheckSizeEquals,
  $ZodCheckStartsWith: () => $ZodCheckStartsWith,
  $ZodCheckStringFormat: () => $ZodCheckStringFormat,
  $ZodCheckUpperCase: () => $ZodCheckUpperCase,
  $ZodCodec: () => $ZodCodec,
  $ZodCustom: () => $ZodCustom,
  $ZodCustomStringFormat: () => $ZodCustomStringFormat,
  $ZodDate: () => $ZodDate,
  $ZodDefault: () => $ZodDefault,
  $ZodDiscriminatedUnion: () => $ZodDiscriminatedUnion,
  $ZodE164: () => $ZodE164,
  $ZodEmail: () => $ZodEmail,
  $ZodEmoji: () => $ZodEmoji,
  $ZodEncodeError: () => $ZodEncodeError,
  $ZodEnum: () => $ZodEnum,
  $ZodError: () => $ZodError,
  $ZodFile: () => $ZodFile,
  $ZodFunction: () => $ZodFunction,
  $ZodGUID: () => $ZodGUID,
  $ZodIPv4: () => $ZodIPv4,
  $ZodIPv6: () => $ZodIPv6,
  $ZodISODate: () => $ZodISODate,
  $ZodISODateTime: () => $ZodISODateTime,
  $ZodISODuration: () => $ZodISODuration,
  $ZodISOTime: () => $ZodISOTime,
  $ZodIntersection: () => $ZodIntersection,
  $ZodJWT: () => $ZodJWT,
  $ZodKSUID: () => $ZodKSUID,
  $ZodLazy: () => $ZodLazy,
  $ZodLiteral: () => $ZodLiteral,
  $ZodMap: () => $ZodMap,
  $ZodNaN: () => $ZodNaN,
  $ZodNanoID: () => $ZodNanoID,
  $ZodNever: () => $ZodNever,
  $ZodNonOptional: () => $ZodNonOptional,
  $ZodNull: () => $ZodNull,
  $ZodNullable: () => $ZodNullable,
  $ZodNumber: () => $ZodNumber,
  $ZodNumberFormat: () => $ZodNumberFormat,
  $ZodObject: () => $ZodObject,
  $ZodObjectJIT: () => $ZodObjectJIT,
  $ZodOptional: () => $ZodOptional,
  $ZodPipe: () => $ZodPipe,
  $ZodPrefault: () => $ZodPrefault,
  $ZodPromise: () => $ZodPromise,
  $ZodReadonly: () => $ZodReadonly,
  $ZodRealError: () => $ZodRealError,
  $ZodRecord: () => $ZodRecord,
  $ZodRegistry: () => $ZodRegistry,
  $ZodSet: () => $ZodSet,
  $ZodString: () => $ZodString,
  $ZodStringFormat: () => $ZodStringFormat,
  $ZodSuccess: () => $ZodSuccess,
  $ZodSymbol: () => $ZodSymbol,
  $ZodTemplateLiteral: () => $ZodTemplateLiteral,
  $ZodTransform: () => $ZodTransform,
  $ZodTuple: () => $ZodTuple,
  $ZodType: () => $ZodType,
  $ZodULID: () => $ZodULID,
  $ZodURL: () => $ZodURL,
  $ZodUUID: () => $ZodUUID,
  $ZodUndefined: () => $ZodUndefined,
  $ZodUnion: () => $ZodUnion,
  $ZodUnknown: () => $ZodUnknown,
  $ZodVoid: () => $ZodVoid,
  $ZodXID: () => $ZodXID,
  $brand: () => $brand,
  $constructor: () => $constructor,
  $input: () => $input,
  $output: () => $output,
  Doc: () => Doc,
  JSONSchema: () => json_schema_exports,
  JSONSchemaGenerator: () => JSONSchemaGenerator,
  NEVER: () => NEVER,
  TimePrecision: () => TimePrecision,
  _any: () => _any,
  _array: () => _array,
  _base64: () => _base64,
  _base64url: () => _base64url,
  _bigint: () => _bigint,
  _boolean: () => _boolean,
  _catch: () => _catch,
  _check: () => _check,
  _cidrv4: () => _cidrv4,
  _cidrv6: () => _cidrv6,
  _coercedBigint: () => _coercedBigint,
  _coercedBoolean: () => _coercedBoolean,
  _coercedDate: () => _coercedDate,
  _coercedNumber: () => _coercedNumber,
  _coercedString: () => _coercedString,
  _cuid: () => _cuid,
  _cuid2: () => _cuid2,
  _custom: () => _custom,
  _date: () => _date,
  _decode: () => _decode,
  _decodeAsync: () => _decodeAsync,
  _default: () => _default,
  _discriminatedUnion: () => _discriminatedUnion,
  _e164: () => _e164,
  _email: () => _email,
  _emoji: () => _emoji2,
  _encode: () => _encode,
  _encodeAsync: () => _encodeAsync,
  _endsWith: () => _endsWith,
  _enum: () => _enum,
  _file: () => _file,
  _float32: () => _float32,
  _float64: () => _float64,
  _gt: () => _gt,
  _gte: () => _gte,
  _guid: () => _guid,
  _includes: () => _includes,
  _int: () => _int,
  _int32: () => _int32,
  _int64: () => _int64,
  _intersection: () => _intersection,
  _ipv4: () => _ipv4,
  _ipv6: () => _ipv6,
  _isoDate: () => _isoDate,
  _isoDateTime: () => _isoDateTime,
  _isoDuration: () => _isoDuration,
  _isoTime: () => _isoTime,
  _jwt: () => _jwt,
  _ksuid: () => _ksuid,
  _lazy: () => _lazy,
  _length: () => _length,
  _literal: () => _literal,
  _lowercase: () => _lowercase,
  _lt: () => _lt,
  _lte: () => _lte,
  _map: () => _map,
  _max: () => _lte,
  _maxLength: () => _maxLength,
  _maxSize: () => _maxSize,
  _mime: () => _mime,
  _min: () => _gte,
  _minLength: () => _minLength,
  _minSize: () => _minSize,
  _multipleOf: () => _multipleOf,
  _nan: () => _nan,
  _nanoid: () => _nanoid,
  _nativeEnum: () => _nativeEnum,
  _negative: () => _negative,
  _never: () => _never,
  _nonnegative: () => _nonnegative,
  _nonoptional: () => _nonoptional,
  _nonpositive: () => _nonpositive,
  _normalize: () => _normalize,
  _null: () => _null2,
  _nullable: () => _nullable,
  _number: () => _number,
  _optional: () => _optional,
  _overwrite: () => _overwrite,
  _parse: () => _parse,
  _parseAsync: () => _parseAsync,
  _pipe: () => _pipe,
  _positive: () => _positive,
  _promise: () => _promise,
  _property: () => _property,
  _readonly: () => _readonly,
  _record: () => _record,
  _refine: () => _refine,
  _regex: () => _regex,
  _safeDecode: () => _safeDecode,
  _safeDecodeAsync: () => _safeDecodeAsync,
  _safeEncode: () => _safeEncode,
  _safeEncodeAsync: () => _safeEncodeAsync,
  _safeParse: () => _safeParse,
  _safeParseAsync: () => _safeParseAsync,
  _set: () => _set,
  _size: () => _size,
  _startsWith: () => _startsWith,
  _string: () => _string,
  _stringFormat: () => _stringFormat,
  _stringbool: () => _stringbool,
  _success: () => _success,
  _superRefine: () => _superRefine,
  _symbol: () => _symbol,
  _templateLiteral: () => _templateLiteral,
  _toLowerCase: () => _toLowerCase,
  _toUpperCase: () => _toUpperCase,
  _transform: () => _transform,
  _trim: () => _trim,
  _tuple: () => _tuple,
  _uint32: () => _uint32,
  _uint64: () => _uint64,
  _ulid: () => _ulid,
  _undefined: () => _undefined2,
  _union: () => _union,
  _unknown: () => _unknown,
  _uppercase: () => _uppercase,
  _url: () => _url,
  _uuid: () => _uuid,
  _uuidv4: () => _uuidv4,
  _uuidv6: () => _uuidv6,
  _uuidv7: () => _uuidv7,
  _void: () => _void,
  _xid: () => _xid,
  clone: () => clone2,
  config: () => config,
  decode: () => decode2,
  decodeAsync: () => decodeAsync,
  encode: () => encode2,
  encodeAsync: () => encodeAsync,
  flattenError: () => flattenError,
  formatError: () => formatError,
  globalConfig: () => globalConfig,
  globalRegistry: () => globalRegistry,
  isValidBase64: () => isValidBase64,
  isValidBase64URL: () => isValidBase64URL,
  isValidJWT: () => isValidJWT,
  locales: () => locales_exports,
  parse: () => parse2,
  parseAsync: () => parseAsync,
  prettifyError: () => prettifyError,
  regexes: () => regexes_exports,
  registry: () => registry,
  safeDecode: () => safeDecode,
  safeDecodeAsync: () => safeDecodeAsync,
  safeEncode: () => safeEncode,
  safeEncodeAsync: () => safeEncodeAsync,
  safeParse: () => safeParse,
  safeParseAsync: () => safeParseAsync,
  toDotPath: () => toDotPath,
  toJSONSchema: () => toJSONSchema,
  treeifyError: () => treeifyError,
  util: () => util_exports,
  version: () => version
});
var init_core2 = __esm({
  "node_modules/zod/v4/core/index.js"() {
    init_core();
    init_parse();
    init_errors2();
    init_schemas();
    init_checks();
    init_versions();
    init_util();
    init_regexes();
    init_locales();
    init_registries();
    init_doc();
    init_api();
    init_to_json_schema();
    init_json_schema();
  }
});

// node_modules/zod/v4/classic/checks.js
var init_checks2 = __esm({
  "node_modules/zod/v4/classic/checks.js"() {
    init_core2();
  }
});

// node_modules/zod/v4/classic/iso.js
var iso_exports = {};
__export(iso_exports, {
  ZodISODate: () => ZodISODate,
  ZodISODateTime: () => ZodISODateTime,
  ZodISODuration: () => ZodISODuration,
  ZodISOTime: () => ZodISOTime,
  date: () => date2,
  datetime: () => datetime2,
  duration: () => duration2,
  time: () => time2
});
function datetime2(params) {
  return _isoDateTime(ZodISODateTime, params);
}
function date2(params) {
  return _isoDate(ZodISODate, params);
}
function time2(params) {
  return _isoTime(ZodISOTime, params);
}
function duration2(params) {
  return _isoDuration(ZodISODuration, params);
}
var ZodISODateTime, ZodISODate, ZodISOTime, ZodISODuration;
var init_iso = __esm({
  "node_modules/zod/v4/classic/iso.js"() {
    init_core2();
    init_schemas2();
    ZodISODateTime = /* @__PURE__ */ $constructor("ZodISODateTime", (inst, def) => {
      $ZodISODateTime.init(inst, def);
      ZodStringFormat.init(inst, def);
    });
    ZodISODate = /* @__PURE__ */ $constructor("ZodISODate", (inst, def) => {
      $ZodISODate.init(inst, def);
      ZodStringFormat.init(inst, def);
    });
    ZodISOTime = /* @__PURE__ */ $constructor("ZodISOTime", (inst, def) => {
      $ZodISOTime.init(inst, def);
      ZodStringFormat.init(inst, def);
    });
    ZodISODuration = /* @__PURE__ */ $constructor("ZodISODuration", (inst, def) => {
      $ZodISODuration.init(inst, def);
      ZodStringFormat.init(inst, def);
    });
  }
});

// node_modules/zod/v4/classic/errors.js
var initializer2, ZodError, ZodRealError;
var init_errors3 = __esm({
  "node_modules/zod/v4/classic/errors.js"() {
    init_core2();
    init_core2();
    init_util();
    initializer2 = (inst, issues) => {
      $ZodError.init(inst, issues);
      inst.name = "ZodError";
      Object.defineProperties(inst, {
        format: {
          value: (mapper) => formatError(inst, mapper)
          // enumerable: false,
        },
        flatten: {
          value: (mapper) => flattenError(inst, mapper)
          // enumerable: false,
        },
        addIssue: {
          value: (issue2) => {
            inst.issues.push(issue2);
            inst.message = JSON.stringify(inst.issues, jsonStringifyReplacer, 2);
          }
          // enumerable: false,
        },
        addIssues: {
          value: (issues2) => {
            inst.issues.push(...issues2);
            inst.message = JSON.stringify(inst.issues, jsonStringifyReplacer, 2);
          }
          // enumerable: false,
        },
        isEmpty: {
          get() {
            return inst.issues.length === 0;
          }
          // enumerable: false,
        }
      });
    };
    ZodError = $constructor("ZodError", initializer2);
    ZodRealError = $constructor("ZodError", initializer2, {
      Parent: Error
    });
  }
});

// node_modules/zod/v4/classic/parse.js
var parse3, parseAsync2, safeParse2, safeParseAsync2, encode3, decode3, encodeAsync2, decodeAsync2, safeEncode2, safeDecode2, safeEncodeAsync2, safeDecodeAsync2;
var init_parse2 = __esm({
  "node_modules/zod/v4/classic/parse.js"() {
    init_core2();
    init_errors3();
    parse3 = /* @__PURE__ */ _parse(ZodRealError);
    parseAsync2 = /* @__PURE__ */ _parseAsync(ZodRealError);
    safeParse2 = /* @__PURE__ */ _safeParse(ZodRealError);
    safeParseAsync2 = /* @__PURE__ */ _safeParseAsync(ZodRealError);
    encode3 = /* @__PURE__ */ _encode(ZodRealError);
    decode3 = /* @__PURE__ */ _decode(ZodRealError);
    encodeAsync2 = /* @__PURE__ */ _encodeAsync(ZodRealError);
    decodeAsync2 = /* @__PURE__ */ _decodeAsync(ZodRealError);
    safeEncode2 = /* @__PURE__ */ _safeEncode(ZodRealError);
    safeDecode2 = /* @__PURE__ */ _safeDecode(ZodRealError);
    safeEncodeAsync2 = /* @__PURE__ */ _safeEncodeAsync(ZodRealError);
    safeDecodeAsync2 = /* @__PURE__ */ _safeDecodeAsync(ZodRealError);
  }
});

// node_modules/zod/v4/classic/schemas.js
function string2(params) {
  return _string(ZodString, params);
}
function email2(params) {
  return _email(ZodEmail, params);
}
function guid2(params) {
  return _guid(ZodGUID, params);
}
function uuid2(params) {
  return _uuid(ZodUUID, params);
}
function uuidv4(params) {
  return _uuidv4(ZodUUID, params);
}
function uuidv6(params) {
  return _uuidv6(ZodUUID, params);
}
function uuidv7(params) {
  return _uuidv7(ZodUUID, params);
}
function url(params) {
  return _url(ZodURL, params);
}
function httpUrl(params) {
  return _url(ZodURL, {
    protocol: /^https?$/,
    hostname: regexes_exports.domain,
    ...util_exports.normalizeParams(params)
  });
}
function emoji2(params) {
  return _emoji2(ZodEmoji, params);
}
function nanoid2(params) {
  return _nanoid(ZodNanoID, params);
}
function cuid3(params) {
  return _cuid(ZodCUID, params);
}
function cuid22(params) {
  return _cuid2(ZodCUID2, params);
}
function ulid2(params) {
  return _ulid(ZodULID, params);
}
function xid2(params) {
  return _xid(ZodXID, params);
}
function ksuid2(params) {
  return _ksuid(ZodKSUID, params);
}
function ipv42(params) {
  return _ipv4(ZodIPv4, params);
}
function ipv62(params) {
  return _ipv6(ZodIPv6, params);
}
function cidrv42(params) {
  return _cidrv4(ZodCIDRv4, params);
}
function cidrv62(params) {
  return _cidrv6(ZodCIDRv6, params);
}
function base642(params) {
  return _base64(ZodBase64, params);
}
function base64url2(params) {
  return _base64url(ZodBase64URL, params);
}
function e1642(params) {
  return _e164(ZodE164, params);
}
function jwt(params) {
  return _jwt(ZodJWT, params);
}
function stringFormat(format, fnOrRegex, _params = {}) {
  return _stringFormat(ZodCustomStringFormat, format, fnOrRegex, _params);
}
function hostname2(_params) {
  return _stringFormat(ZodCustomStringFormat, "hostname", regexes_exports.hostname, _params);
}
function hex2(_params) {
  return _stringFormat(ZodCustomStringFormat, "hex", regexes_exports.hex, _params);
}
function hash(alg, params) {
  const enc = params?.enc ?? "hex";
  const format = `${alg}_${enc}`;
  const regex = regexes_exports[format];
  if (!regex)
    throw new Error(`Unrecognized hash format: ${format}`);
  return _stringFormat(ZodCustomStringFormat, format, regex, params);
}
function number2(params) {
  return _number(ZodNumber, params);
}
function int(params) {
  return _int(ZodNumberFormat, params);
}
function float32(params) {
  return _float32(ZodNumberFormat, params);
}
function float64(params) {
  return _float64(ZodNumberFormat, params);
}
function int32(params) {
  return _int32(ZodNumberFormat, params);
}
function uint32(params) {
  return _uint32(ZodNumberFormat, params);
}
function boolean2(params) {
  return _boolean(ZodBoolean, params);
}
function bigint2(params) {
  return _bigint(ZodBigInt, params);
}
function int64(params) {
  return _int64(ZodBigIntFormat, params);
}
function uint64(params) {
  return _uint64(ZodBigIntFormat, params);
}
function symbol(params) {
  return _symbol(ZodSymbol, params);
}
function _undefined3(params) {
  return _undefined2(ZodUndefined, params);
}
function _null3(params) {
  return _null2(ZodNull, params);
}
function any() {
  return _any(ZodAny);
}
function unknown() {
  return _unknown(ZodUnknown);
}
function never(params) {
  return _never(ZodNever, params);
}
function _void2(params) {
  return _void(ZodVoid, params);
}
function date3(params) {
  return _date(ZodDate, params);
}
function array(element, params) {
  return _array(ZodArray, element, params);
}
function keyof(schema2) {
  const shape = schema2._zod.def.shape;
  return _enum2(Object.keys(shape));
}
function object(shape, params) {
  const def = {
    type: "object",
    shape: shape ?? {},
    ...util_exports.normalizeParams(params)
  };
  return new ZodObject(def);
}
function strictObject(shape, params) {
  return new ZodObject({
    type: "object",
    shape,
    catchall: never(),
    ...util_exports.normalizeParams(params)
  });
}
function looseObject(shape, params) {
  return new ZodObject({
    type: "object",
    shape,
    catchall: unknown(),
    ...util_exports.normalizeParams(params)
  });
}
function union(options, params) {
  return new ZodUnion({
    type: "union",
    options,
    ...util_exports.normalizeParams(params)
  });
}
function discriminatedUnion(discriminator, options, params) {
  return new ZodDiscriminatedUnion({
    type: "union",
    options,
    discriminator,
    ...util_exports.normalizeParams(params)
  });
}
function intersection(left, right) {
  return new ZodIntersection({
    type: "intersection",
    left,
    right
  });
}
function tuple(items, _paramsOrRest, _params) {
  const hasRest = _paramsOrRest instanceof $ZodType;
  const params = hasRest ? _params : _paramsOrRest;
  const rest = hasRest ? _paramsOrRest : null;
  return new ZodTuple({
    type: "tuple",
    items,
    rest,
    ...util_exports.normalizeParams(params)
  });
}
function record(keyType, valueType, params) {
  return new ZodRecord({
    type: "record",
    keyType,
    valueType,
    ...util_exports.normalizeParams(params)
  });
}
function partialRecord(keyType, valueType, params) {
  const k = clone2(keyType);
  k._zod.values = void 0;
  return new ZodRecord({
    type: "record",
    keyType: k,
    valueType,
    ...util_exports.normalizeParams(params)
  });
}
function map(keyType, valueType, params) {
  return new ZodMap({
    type: "map",
    keyType,
    valueType,
    ...util_exports.normalizeParams(params)
  });
}
function set(valueType, params) {
  return new ZodSet({
    type: "set",
    valueType,
    ...util_exports.normalizeParams(params)
  });
}
function _enum2(values, params) {
  const entries = Array.isArray(values) ? Object.fromEntries(values.map((v) => [v, v])) : values;
  return new ZodEnum({
    type: "enum",
    entries,
    ...util_exports.normalizeParams(params)
  });
}
function nativeEnum(entries, params) {
  return new ZodEnum({
    type: "enum",
    entries,
    ...util_exports.normalizeParams(params)
  });
}
function literal2(value, params) {
  return new ZodLiteral({
    type: "literal",
    values: Array.isArray(value) ? value : [value],
    ...util_exports.normalizeParams(params)
  });
}
function file(params) {
  return _file(ZodFile, params);
}
function transform(fn) {
  return new ZodTransform({
    type: "transform",
    transform: fn
  });
}
function optional(innerType) {
  return new ZodOptional({
    type: "optional",
    innerType
  });
}
function nullable(innerType) {
  return new ZodNullable({
    type: "nullable",
    innerType
  });
}
function nullish2(innerType) {
  return optional(nullable(innerType));
}
function _default2(innerType, defaultValue) {
  return new ZodDefault({
    type: "default",
    innerType,
    get defaultValue() {
      return typeof defaultValue === "function" ? defaultValue() : util_exports.shallowClone(defaultValue);
    }
  });
}
function prefault(innerType, defaultValue) {
  return new ZodPrefault({
    type: "prefault",
    innerType,
    get defaultValue() {
      return typeof defaultValue === "function" ? defaultValue() : util_exports.shallowClone(defaultValue);
    }
  });
}
function nonoptional(innerType, params) {
  return new ZodNonOptional({
    type: "nonoptional",
    innerType,
    ...util_exports.normalizeParams(params)
  });
}
function success(innerType) {
  return new ZodSuccess({
    type: "success",
    innerType
  });
}
function _catch2(innerType, catchValue) {
  return new ZodCatch({
    type: "catch",
    innerType,
    catchValue: typeof catchValue === "function" ? catchValue : () => catchValue
  });
}
function nan(params) {
  return _nan(ZodNaN, params);
}
function pipe(in_, out) {
  return new ZodPipe({
    type: "pipe",
    in: in_,
    out
    // ...util.normalizeParams(params),
  });
}
function codec(in_, out, params) {
  return new ZodCodec({
    type: "pipe",
    in: in_,
    out,
    transform: params.decode,
    reverseTransform: params.encode
  });
}
function readonly(innerType) {
  return new ZodReadonly({
    type: "readonly",
    innerType
  });
}
function templateLiteral(parts, params) {
  return new ZodTemplateLiteral({
    type: "template_literal",
    parts,
    ...util_exports.normalizeParams(params)
  });
}
function lazy(getter) {
  return new ZodLazy({
    type: "lazy",
    getter
  });
}
function promise(innerType) {
  return new ZodPromise({
    type: "promise",
    innerType
  });
}
function _function(params) {
  return new ZodFunction({
    type: "function",
    input: Array.isArray(params?.input) ? tuple(params?.input) : params?.input ?? array(unknown()),
    output: params?.output ?? unknown()
  });
}
function check(fn) {
  const ch = new $ZodCheck({
    check: "custom"
    // ...util.normalizeParams(params),
  });
  ch._zod.check = fn;
  return ch;
}
function custom(fn, _params) {
  return _custom(ZodCustom, fn ?? (() => true), _params);
}
function refine(fn, _params = {}) {
  return _refine(ZodCustom, fn, _params);
}
function superRefine(fn) {
  return _superRefine(fn);
}
function _instanceof(cls, params = {
  error: `Input not instance of ${cls.name}`
}) {
  const inst = new ZodCustom({
    type: "custom",
    check: "custom",
    fn: (data) => data instanceof cls,
    abort: true,
    ...util_exports.normalizeParams(params)
  });
  inst._zod.bag.Class = cls;
  return inst;
}
function json(params) {
  const jsonSchema = lazy(() => {
    return union([string2(params), number2(), boolean2(), _null3(), array(jsonSchema), record(string2(), jsonSchema)]);
  });
  return jsonSchema;
}
function preprocess(fn, schema2) {
  return pipe(transform(fn), schema2);
}
var ZodType, _ZodString, ZodString, ZodStringFormat, ZodEmail, ZodGUID, ZodUUID, ZodURL, ZodEmoji, ZodNanoID, ZodCUID, ZodCUID2, ZodULID, ZodXID, ZodKSUID, ZodIPv4, ZodIPv6, ZodCIDRv4, ZodCIDRv6, ZodBase64, ZodBase64URL, ZodE164, ZodJWT, ZodCustomStringFormat, ZodNumber, ZodNumberFormat, ZodBoolean, ZodBigInt, ZodBigIntFormat, ZodSymbol, ZodUndefined, ZodNull, ZodAny, ZodUnknown, ZodNever, ZodVoid, ZodDate, ZodArray, ZodObject, ZodUnion, ZodDiscriminatedUnion, ZodIntersection, ZodTuple, ZodRecord, ZodMap, ZodSet, ZodEnum, ZodLiteral, ZodFile, ZodTransform, ZodOptional, ZodNullable, ZodDefault, ZodPrefault, ZodNonOptional, ZodSuccess, ZodCatch, ZodNaN, ZodPipe, ZodCodec, ZodReadonly, ZodTemplateLiteral, ZodLazy, ZodPromise, ZodFunction, ZodCustom, stringbool;
var init_schemas2 = __esm({
  "node_modules/zod/v4/classic/schemas.js"() {
    init_core2();
    init_core2();
    init_checks2();
    init_iso();
    init_parse2();
    ZodType = /* @__PURE__ */ $constructor("ZodType", (inst, def) => {
      $ZodType.init(inst, def);
      inst.def = def;
      inst.type = def.type;
      Object.defineProperty(inst, "_def", { value: def });
      inst.check = (...checks) => {
        return inst.clone(util_exports.mergeDefs(def, {
          checks: [
            ...def.checks ?? [],
            ...checks.map((ch) => typeof ch === "function" ? { _zod: { check: ch, def: { check: "custom" }, onattach: [] } } : ch)
          ]
        }));
      };
      inst.clone = (def2, params) => clone2(inst, def2, params);
      inst.brand = () => inst;
      inst.register = ((reg, meta) => {
        reg.add(inst, meta);
        return inst;
      });
      inst.parse = (data, params) => parse3(inst, data, params, { callee: inst.parse });
      inst.safeParse = (data, params) => safeParse2(inst, data, params);
      inst.parseAsync = async (data, params) => parseAsync2(inst, data, params, { callee: inst.parseAsync });
      inst.safeParseAsync = async (data, params) => safeParseAsync2(inst, data, params);
      inst.spa = inst.safeParseAsync;
      inst.encode = (data, params) => encode3(inst, data, params);
      inst.decode = (data, params) => decode3(inst, data, params);
      inst.encodeAsync = async (data, params) => encodeAsync2(inst, data, params);
      inst.decodeAsync = async (data, params) => decodeAsync2(inst, data, params);
      inst.safeEncode = (data, params) => safeEncode2(inst, data, params);
      inst.safeDecode = (data, params) => safeDecode2(inst, data, params);
      inst.safeEncodeAsync = async (data, params) => safeEncodeAsync2(inst, data, params);
      inst.safeDecodeAsync = async (data, params) => safeDecodeAsync2(inst, data, params);
      inst.refine = (check2, params) => inst.check(refine(check2, params));
      inst.superRefine = (refinement) => inst.check(superRefine(refinement));
      inst.overwrite = (fn) => inst.check(_overwrite(fn));
      inst.optional = () => optional(inst);
      inst.nullable = () => nullable(inst);
      inst.nullish = () => optional(nullable(inst));
      inst.nonoptional = (params) => nonoptional(inst, params);
      inst.array = () => array(inst);
      inst.or = (arg) => union([inst, arg]);
      inst.and = (arg) => intersection(inst, arg);
      inst.transform = (tx) => pipe(inst, transform(tx));
      inst.default = (def2) => _default2(inst, def2);
      inst.prefault = (def2) => prefault(inst, def2);
      inst.catch = (params) => _catch2(inst, params);
      inst.pipe = (target) => pipe(inst, target);
      inst.readonly = () => readonly(inst);
      inst.describe = (description) => {
        const cl = inst.clone();
        globalRegistry.add(cl, { description });
        return cl;
      };
      Object.defineProperty(inst, "description", {
        get() {
          return globalRegistry.get(inst)?.description;
        },
        configurable: true
      });
      inst.meta = (...args) => {
        if (args.length === 0) {
          return globalRegistry.get(inst);
        }
        const cl = inst.clone();
        globalRegistry.add(cl, args[0]);
        return cl;
      };
      inst.isOptional = () => inst.safeParse(void 0).success;
      inst.isNullable = () => inst.safeParse(null).success;
      return inst;
    });
    _ZodString = /* @__PURE__ */ $constructor("_ZodString", (inst, def) => {
      $ZodString.init(inst, def);
      ZodType.init(inst, def);
      const bag = inst._zod.bag;
      inst.format = bag.format ?? null;
      inst.minLength = bag.minimum ?? null;
      inst.maxLength = bag.maximum ?? null;
      inst.regex = (...args) => inst.check(_regex(...args));
      inst.includes = (...args) => inst.check(_includes(...args));
      inst.startsWith = (...args) => inst.check(_startsWith(...args));
      inst.endsWith = (...args) => inst.check(_endsWith(...args));
      inst.min = (...args) => inst.check(_minLength(...args));
      inst.max = (...args) => inst.check(_maxLength(...args));
      inst.length = (...args) => inst.check(_length(...args));
      inst.nonempty = (...args) => inst.check(_minLength(1, ...args));
      inst.lowercase = (params) => inst.check(_lowercase(params));
      inst.uppercase = (params) => inst.check(_uppercase(params));
      inst.trim = () => inst.check(_trim());
      inst.normalize = (...args) => inst.check(_normalize(...args));
      inst.toLowerCase = () => inst.check(_toLowerCase());
      inst.toUpperCase = () => inst.check(_toUpperCase());
    });
    ZodString = /* @__PURE__ */ $constructor("ZodString", (inst, def) => {
      $ZodString.init(inst, def);
      _ZodString.init(inst, def);
      inst.email = (params) => inst.check(_email(ZodEmail, params));
      inst.url = (params) => inst.check(_url(ZodURL, params));
      inst.jwt = (params) => inst.check(_jwt(ZodJWT, params));
      inst.emoji = (params) => inst.check(_emoji2(ZodEmoji, params));
      inst.guid = (params) => inst.check(_guid(ZodGUID, params));
      inst.uuid = (params) => inst.check(_uuid(ZodUUID, params));
      inst.uuidv4 = (params) => inst.check(_uuidv4(ZodUUID, params));
      inst.uuidv6 = (params) => inst.check(_uuidv6(ZodUUID, params));
      inst.uuidv7 = (params) => inst.check(_uuidv7(ZodUUID, params));
      inst.nanoid = (params) => inst.check(_nanoid(ZodNanoID, params));
      inst.guid = (params) => inst.check(_guid(ZodGUID, params));
      inst.cuid = (params) => inst.check(_cuid(ZodCUID, params));
      inst.cuid2 = (params) => inst.check(_cuid2(ZodCUID2, params));
      inst.ulid = (params) => inst.check(_ulid(ZodULID, params));
      inst.base64 = (params) => inst.check(_base64(ZodBase64, params));
      inst.base64url = (params) => inst.check(_base64url(ZodBase64URL, params));
      inst.xid = (params) => inst.check(_xid(ZodXID, params));
      inst.ksuid = (params) => inst.check(_ksuid(ZodKSUID, params));
      inst.ipv4 = (params) => inst.check(_ipv4(ZodIPv4, params));
      inst.ipv6 = (params) => inst.check(_ipv6(ZodIPv6, params));
      inst.cidrv4 = (params) => inst.check(_cidrv4(ZodCIDRv4, params));
      inst.cidrv6 = (params) => inst.check(_cidrv6(ZodCIDRv6, params));
      inst.e164 = (params) => inst.check(_e164(ZodE164, params));
      inst.datetime = (params) => inst.check(datetime2(params));
      inst.date = (params) => inst.check(date2(params));
      inst.time = (params) => inst.check(time2(params));
      inst.duration = (params) => inst.check(duration2(params));
    });
    ZodStringFormat = /* @__PURE__ */ $constructor("ZodStringFormat", (inst, def) => {
      $ZodStringFormat.init(inst, def);
      _ZodString.init(inst, def);
    });
    ZodEmail = /* @__PURE__ */ $constructor("ZodEmail", (inst, def) => {
      $ZodEmail.init(inst, def);
      ZodStringFormat.init(inst, def);
    });
    ZodGUID = /* @__PURE__ */ $constructor("ZodGUID", (inst, def) => {
      $ZodGUID.init(inst, def);
      ZodStringFormat.init(inst, def);
    });
    ZodUUID = /* @__PURE__ */ $constructor("ZodUUID", (inst, def) => {
      $ZodUUID.init(inst, def);
      ZodStringFormat.init(inst, def);
    });
    ZodURL = /* @__PURE__ */ $constructor("ZodURL", (inst, def) => {
      $ZodURL.init(inst, def);
      ZodStringFormat.init(inst, def);
    });
    ZodEmoji = /* @__PURE__ */ $constructor("ZodEmoji", (inst, def) => {
      $ZodEmoji.init(inst, def);
      ZodStringFormat.init(inst, def);
    });
    ZodNanoID = /* @__PURE__ */ $constructor("ZodNanoID", (inst, def) => {
      $ZodNanoID.init(inst, def);
      ZodStringFormat.init(inst, def);
    });
    ZodCUID = /* @__PURE__ */ $constructor("ZodCUID", (inst, def) => {
      $ZodCUID.init(inst, def);
      ZodStringFormat.init(inst, def);
    });
    ZodCUID2 = /* @__PURE__ */ $constructor("ZodCUID2", (inst, def) => {
      $ZodCUID2.init(inst, def);
      ZodStringFormat.init(inst, def);
    });
    ZodULID = /* @__PURE__ */ $constructor("ZodULID", (inst, def) => {
      $ZodULID.init(inst, def);
      ZodStringFormat.init(inst, def);
    });
    ZodXID = /* @__PURE__ */ $constructor("ZodXID", (inst, def) => {
      $ZodXID.init(inst, def);
      ZodStringFormat.init(inst, def);
    });
    ZodKSUID = /* @__PURE__ */ $constructor("ZodKSUID", (inst, def) => {
      $ZodKSUID.init(inst, def);
      ZodStringFormat.init(inst, def);
    });
    ZodIPv4 = /* @__PURE__ */ $constructor("ZodIPv4", (inst, def) => {
      $ZodIPv4.init(inst, def);
      ZodStringFormat.init(inst, def);
    });
    ZodIPv6 = /* @__PURE__ */ $constructor("ZodIPv6", (inst, def) => {
      $ZodIPv6.init(inst, def);
      ZodStringFormat.init(inst, def);
    });
    ZodCIDRv4 = /* @__PURE__ */ $constructor("ZodCIDRv4", (inst, def) => {
      $ZodCIDRv4.init(inst, def);
      ZodStringFormat.init(inst, def);
    });
    ZodCIDRv6 = /* @__PURE__ */ $constructor("ZodCIDRv6", (inst, def) => {
      $ZodCIDRv6.init(inst, def);
      ZodStringFormat.init(inst, def);
    });
    ZodBase64 = /* @__PURE__ */ $constructor("ZodBase64", (inst, def) => {
      $ZodBase64.init(inst, def);
      ZodStringFormat.init(inst, def);
    });
    ZodBase64URL = /* @__PURE__ */ $constructor("ZodBase64URL", (inst, def) => {
      $ZodBase64URL.init(inst, def);
      ZodStringFormat.init(inst, def);
    });
    ZodE164 = /* @__PURE__ */ $constructor("ZodE164", (inst, def) => {
      $ZodE164.init(inst, def);
      ZodStringFormat.init(inst, def);
    });
    ZodJWT = /* @__PURE__ */ $constructor("ZodJWT", (inst, def) => {
      $ZodJWT.init(inst, def);
      ZodStringFormat.init(inst, def);
    });
    ZodCustomStringFormat = /* @__PURE__ */ $constructor("ZodCustomStringFormat", (inst, def) => {
      $ZodCustomStringFormat.init(inst, def);
      ZodStringFormat.init(inst, def);
    });
    ZodNumber = /* @__PURE__ */ $constructor("ZodNumber", (inst, def) => {
      $ZodNumber.init(inst, def);
      ZodType.init(inst, def);
      inst.gt = (value, params) => inst.check(_gt(value, params));
      inst.gte = (value, params) => inst.check(_gte(value, params));
      inst.min = (value, params) => inst.check(_gte(value, params));
      inst.lt = (value, params) => inst.check(_lt(value, params));
      inst.lte = (value, params) => inst.check(_lte(value, params));
      inst.max = (value, params) => inst.check(_lte(value, params));
      inst.int = (params) => inst.check(int(params));
      inst.safe = (params) => inst.check(int(params));
      inst.positive = (params) => inst.check(_gt(0, params));
      inst.nonnegative = (params) => inst.check(_gte(0, params));
      inst.negative = (params) => inst.check(_lt(0, params));
      inst.nonpositive = (params) => inst.check(_lte(0, params));
      inst.multipleOf = (value, params) => inst.check(_multipleOf(value, params));
      inst.step = (value, params) => inst.check(_multipleOf(value, params));
      inst.finite = () => inst;
      const bag = inst._zod.bag;
      inst.minValue = Math.max(bag.minimum ?? Number.NEGATIVE_INFINITY, bag.exclusiveMinimum ?? Number.NEGATIVE_INFINITY) ?? null;
      inst.maxValue = Math.min(bag.maximum ?? Number.POSITIVE_INFINITY, bag.exclusiveMaximum ?? Number.POSITIVE_INFINITY) ?? null;
      inst.isInt = (bag.format ?? "").includes("int") || Number.isSafeInteger(bag.multipleOf ?? 0.5);
      inst.isFinite = true;
      inst.format = bag.format ?? null;
    });
    ZodNumberFormat = /* @__PURE__ */ $constructor("ZodNumberFormat", (inst, def) => {
      $ZodNumberFormat.init(inst, def);
      ZodNumber.init(inst, def);
    });
    ZodBoolean = /* @__PURE__ */ $constructor("ZodBoolean", (inst, def) => {
      $ZodBoolean.init(inst, def);
      ZodType.init(inst, def);
    });
    ZodBigInt = /* @__PURE__ */ $constructor("ZodBigInt", (inst, def) => {
      $ZodBigInt.init(inst, def);
      ZodType.init(inst, def);
      inst.gte = (value, params) => inst.check(_gte(value, params));
      inst.min = (value, params) => inst.check(_gte(value, params));
      inst.gt = (value, params) => inst.check(_gt(value, params));
      inst.gte = (value, params) => inst.check(_gte(value, params));
      inst.min = (value, params) => inst.check(_gte(value, params));
      inst.lt = (value, params) => inst.check(_lt(value, params));
      inst.lte = (value, params) => inst.check(_lte(value, params));
      inst.max = (value, params) => inst.check(_lte(value, params));
      inst.positive = (params) => inst.check(_gt(BigInt(0), params));
      inst.negative = (params) => inst.check(_lt(BigInt(0), params));
      inst.nonpositive = (params) => inst.check(_lte(BigInt(0), params));
      inst.nonnegative = (params) => inst.check(_gte(BigInt(0), params));
      inst.multipleOf = (value, params) => inst.check(_multipleOf(value, params));
      const bag = inst._zod.bag;
      inst.minValue = bag.minimum ?? null;
      inst.maxValue = bag.maximum ?? null;
      inst.format = bag.format ?? null;
    });
    ZodBigIntFormat = /* @__PURE__ */ $constructor("ZodBigIntFormat", (inst, def) => {
      $ZodBigIntFormat.init(inst, def);
      ZodBigInt.init(inst, def);
    });
    ZodSymbol = /* @__PURE__ */ $constructor("ZodSymbol", (inst, def) => {
      $ZodSymbol.init(inst, def);
      ZodType.init(inst, def);
    });
    ZodUndefined = /* @__PURE__ */ $constructor("ZodUndefined", (inst, def) => {
      $ZodUndefined.init(inst, def);
      ZodType.init(inst, def);
    });
    ZodNull = /* @__PURE__ */ $constructor("ZodNull", (inst, def) => {
      $ZodNull.init(inst, def);
      ZodType.init(inst, def);
    });
    ZodAny = /* @__PURE__ */ $constructor("ZodAny", (inst, def) => {
      $ZodAny.init(inst, def);
      ZodType.init(inst, def);
    });
    ZodUnknown = /* @__PURE__ */ $constructor("ZodUnknown", (inst, def) => {
      $ZodUnknown.init(inst, def);
      ZodType.init(inst, def);
    });
    ZodNever = /* @__PURE__ */ $constructor("ZodNever", (inst, def) => {
      $ZodNever.init(inst, def);
      ZodType.init(inst, def);
    });
    ZodVoid = /* @__PURE__ */ $constructor("ZodVoid", (inst, def) => {
      $ZodVoid.init(inst, def);
      ZodType.init(inst, def);
    });
    ZodDate = /* @__PURE__ */ $constructor("ZodDate", (inst, def) => {
      $ZodDate.init(inst, def);
      ZodType.init(inst, def);
      inst.min = (value, params) => inst.check(_gte(value, params));
      inst.max = (value, params) => inst.check(_lte(value, params));
      const c = inst._zod.bag;
      inst.minDate = c.minimum ? new Date(c.minimum) : null;
      inst.maxDate = c.maximum ? new Date(c.maximum) : null;
    });
    ZodArray = /* @__PURE__ */ $constructor("ZodArray", (inst, def) => {
      $ZodArray.init(inst, def);
      ZodType.init(inst, def);
      inst.element = def.element;
      inst.min = (minLength, params) => inst.check(_minLength(minLength, params));
      inst.nonempty = (params) => inst.check(_minLength(1, params));
      inst.max = (maxLength, params) => inst.check(_maxLength(maxLength, params));
      inst.length = (len, params) => inst.check(_length(len, params));
      inst.unwrap = () => inst.element;
    });
    ZodObject = /* @__PURE__ */ $constructor("ZodObject", (inst, def) => {
      $ZodObjectJIT.init(inst, def);
      ZodType.init(inst, def);
      util_exports.defineLazy(inst, "shape", () => {
        return def.shape;
      });
      inst.keyof = () => _enum2(Object.keys(inst._zod.def.shape));
      inst.catchall = (catchall) => inst.clone({ ...inst._zod.def, catchall });
      inst.passthrough = () => inst.clone({ ...inst._zod.def, catchall: unknown() });
      inst.loose = () => inst.clone({ ...inst._zod.def, catchall: unknown() });
      inst.strict = () => inst.clone({ ...inst._zod.def, catchall: never() });
      inst.strip = () => inst.clone({ ...inst._zod.def, catchall: void 0 });
      inst.extend = (incoming) => {
        return util_exports.extend(inst, incoming);
      };
      inst.safeExtend = (incoming) => {
        return util_exports.safeExtend(inst, incoming);
      };
      inst.merge = (other) => util_exports.merge(inst, other);
      inst.pick = (mask) => util_exports.pick(inst, mask);
      inst.omit = (mask) => util_exports.omit(inst, mask);
      inst.partial = (...args) => util_exports.partial(ZodOptional, inst, args[0]);
      inst.required = (...args) => util_exports.required(ZodNonOptional, inst, args[0]);
    });
    ZodUnion = /* @__PURE__ */ $constructor("ZodUnion", (inst, def) => {
      $ZodUnion.init(inst, def);
      ZodType.init(inst, def);
      inst.options = def.options;
    });
    ZodDiscriminatedUnion = /* @__PURE__ */ $constructor("ZodDiscriminatedUnion", (inst, def) => {
      ZodUnion.init(inst, def);
      $ZodDiscriminatedUnion.init(inst, def);
    });
    ZodIntersection = /* @__PURE__ */ $constructor("ZodIntersection", (inst, def) => {
      $ZodIntersection.init(inst, def);
      ZodType.init(inst, def);
    });
    ZodTuple = /* @__PURE__ */ $constructor("ZodTuple", (inst, def) => {
      $ZodTuple.init(inst, def);
      ZodType.init(inst, def);
      inst.rest = (rest) => inst.clone({
        ...inst._zod.def,
        rest
      });
    });
    ZodRecord = /* @__PURE__ */ $constructor("ZodRecord", (inst, def) => {
      $ZodRecord.init(inst, def);
      ZodType.init(inst, def);
      inst.keyType = def.keyType;
      inst.valueType = def.valueType;
    });
    ZodMap = /* @__PURE__ */ $constructor("ZodMap", (inst, def) => {
      $ZodMap.init(inst, def);
      ZodType.init(inst, def);
      inst.keyType = def.keyType;
      inst.valueType = def.valueType;
    });
    ZodSet = /* @__PURE__ */ $constructor("ZodSet", (inst, def) => {
      $ZodSet.init(inst, def);
      ZodType.init(inst, def);
      inst.min = (...args) => inst.check(_minSize(...args));
      inst.nonempty = (params) => inst.check(_minSize(1, params));
      inst.max = (...args) => inst.check(_maxSize(...args));
      inst.size = (...args) => inst.check(_size(...args));
    });
    ZodEnum = /* @__PURE__ */ $constructor("ZodEnum", (inst, def) => {
      $ZodEnum.init(inst, def);
      ZodType.init(inst, def);
      inst.enum = def.entries;
      inst.options = Object.values(def.entries);
      const keys = new Set(Object.keys(def.entries));
      inst.extract = (values, params) => {
        const newEntries = {};
        for (const value of values) {
          if (keys.has(value)) {
            newEntries[value] = def.entries[value];
          } else
            throw new Error(`Key ${value} not found in enum`);
        }
        return new ZodEnum({
          ...def,
          checks: [],
          ...util_exports.normalizeParams(params),
          entries: newEntries
        });
      };
      inst.exclude = (values, params) => {
        const newEntries = { ...def.entries };
        for (const value of values) {
          if (keys.has(value)) {
            delete newEntries[value];
          } else
            throw new Error(`Key ${value} not found in enum`);
        }
        return new ZodEnum({
          ...def,
          checks: [],
          ...util_exports.normalizeParams(params),
          entries: newEntries
        });
      };
    });
    ZodLiteral = /* @__PURE__ */ $constructor("ZodLiteral", (inst, def) => {
      $ZodLiteral.init(inst, def);
      ZodType.init(inst, def);
      inst.values = new Set(def.values);
      Object.defineProperty(inst, "value", {
        get() {
          if (def.values.length > 1) {
            throw new Error("This schema contains multiple valid literal values. Use `.values` instead.");
          }
          return def.values[0];
        }
      });
    });
    ZodFile = /* @__PURE__ */ $constructor("ZodFile", (inst, def) => {
      $ZodFile.init(inst, def);
      ZodType.init(inst, def);
      inst.min = (size, params) => inst.check(_minSize(size, params));
      inst.max = (size, params) => inst.check(_maxSize(size, params));
      inst.mime = (types3, params) => inst.check(_mime(Array.isArray(types3) ? types3 : [types3], params));
    });
    ZodTransform = /* @__PURE__ */ $constructor("ZodTransform", (inst, def) => {
      $ZodTransform.init(inst, def);
      ZodType.init(inst, def);
      inst._zod.parse = (payload, _ctx) => {
        if (_ctx.direction === "backward") {
          throw new $ZodEncodeError(inst.constructor.name);
        }
        payload.addIssue = (issue2) => {
          if (typeof issue2 === "string") {
            payload.issues.push(util_exports.issue(issue2, payload.value, def));
          } else {
            const _issue = issue2;
            if (_issue.fatal)
              _issue.continue = false;
            _issue.code ?? (_issue.code = "custom");
            _issue.input ?? (_issue.input = payload.value);
            _issue.inst ?? (_issue.inst = inst);
            payload.issues.push(util_exports.issue(_issue));
          }
        };
        const output = def.transform(payload.value, payload);
        if (output instanceof Promise) {
          return output.then((output2) => {
            payload.value = output2;
            return payload;
          });
        }
        payload.value = output;
        return payload;
      };
    });
    ZodOptional = /* @__PURE__ */ $constructor("ZodOptional", (inst, def) => {
      $ZodOptional.init(inst, def);
      ZodType.init(inst, def);
      inst.unwrap = () => inst._zod.def.innerType;
    });
    ZodNullable = /* @__PURE__ */ $constructor("ZodNullable", (inst, def) => {
      $ZodNullable.init(inst, def);
      ZodType.init(inst, def);
      inst.unwrap = () => inst._zod.def.innerType;
    });
    ZodDefault = /* @__PURE__ */ $constructor("ZodDefault", (inst, def) => {
      $ZodDefault.init(inst, def);
      ZodType.init(inst, def);
      inst.unwrap = () => inst._zod.def.innerType;
      inst.removeDefault = inst.unwrap;
    });
    ZodPrefault = /* @__PURE__ */ $constructor("ZodPrefault", (inst, def) => {
      $ZodPrefault.init(inst, def);
      ZodType.init(inst, def);
      inst.unwrap = () => inst._zod.def.innerType;
    });
    ZodNonOptional = /* @__PURE__ */ $constructor("ZodNonOptional", (inst, def) => {
      $ZodNonOptional.init(inst, def);
      ZodType.init(inst, def);
      inst.unwrap = () => inst._zod.def.innerType;
    });
    ZodSuccess = /* @__PURE__ */ $constructor("ZodSuccess", (inst, def) => {
      $ZodSuccess.init(inst, def);
      ZodType.init(inst, def);
      inst.unwrap = () => inst._zod.def.innerType;
    });
    ZodCatch = /* @__PURE__ */ $constructor("ZodCatch", (inst, def) => {
      $ZodCatch.init(inst, def);
      ZodType.init(inst, def);
      inst.unwrap = () => inst._zod.def.innerType;
      inst.removeCatch = inst.unwrap;
    });
    ZodNaN = /* @__PURE__ */ $constructor("ZodNaN", (inst, def) => {
      $ZodNaN.init(inst, def);
      ZodType.init(inst, def);
    });
    ZodPipe = /* @__PURE__ */ $constructor("ZodPipe", (inst, def) => {
      $ZodPipe.init(inst, def);
      ZodType.init(inst, def);
      inst.in = def.in;
      inst.out = def.out;
    });
    ZodCodec = /* @__PURE__ */ $constructor("ZodCodec", (inst, def) => {
      ZodPipe.init(inst, def);
      $ZodCodec.init(inst, def);
    });
    ZodReadonly = /* @__PURE__ */ $constructor("ZodReadonly", (inst, def) => {
      $ZodReadonly.init(inst, def);
      ZodType.init(inst, def);
      inst.unwrap = () => inst._zod.def.innerType;
    });
    ZodTemplateLiteral = /* @__PURE__ */ $constructor("ZodTemplateLiteral", (inst, def) => {
      $ZodTemplateLiteral.init(inst, def);
      ZodType.init(inst, def);
    });
    ZodLazy = /* @__PURE__ */ $constructor("ZodLazy", (inst, def) => {
      $ZodLazy.init(inst, def);
      ZodType.init(inst, def);
      inst.unwrap = () => inst._zod.def.getter();
    });
    ZodPromise = /* @__PURE__ */ $constructor("ZodPromise", (inst, def) => {
      $ZodPromise.init(inst, def);
      ZodType.init(inst, def);
      inst.unwrap = () => inst._zod.def.innerType;
    });
    ZodFunction = /* @__PURE__ */ $constructor("ZodFunction", (inst, def) => {
      $ZodFunction.init(inst, def);
      ZodType.init(inst, def);
    });
    ZodCustom = /* @__PURE__ */ $constructor("ZodCustom", (inst, def) => {
      $ZodCustom.init(inst, def);
      ZodType.init(inst, def);
    });
    stringbool = (...args) => _stringbool({
      Codec: ZodCodec,
      Boolean: ZodBoolean,
      String: ZodString
    }, ...args);
  }
});

// node_modules/zod/v4/classic/compat.js
function setErrorMap(map3) {
  config({
    customError: map3
  });
}
function getErrorMap() {
  return config().customError;
}
var ZodIssueCode, ZodFirstPartyTypeKind;
var init_compat = __esm({
  "node_modules/zod/v4/classic/compat.js"() {
    init_core2();
    init_core2();
    ZodIssueCode = {
      invalid_type: "invalid_type",
      too_big: "too_big",
      too_small: "too_small",
      invalid_format: "invalid_format",
      not_multiple_of: "not_multiple_of",
      unrecognized_keys: "unrecognized_keys",
      invalid_union: "invalid_union",
      invalid_key: "invalid_key",
      invalid_element: "invalid_element",
      invalid_value: "invalid_value",
      custom: "custom"
    };
    /* @__PURE__ */ (function(ZodFirstPartyTypeKind2) {
    })(ZodFirstPartyTypeKind || (ZodFirstPartyTypeKind = {}));
  }
});

// node_modules/zod/v4/classic/coerce.js
var coerce_exports = {};
__export(coerce_exports, {
  bigint: () => bigint3,
  boolean: () => boolean3,
  date: () => date4,
  number: () => number3,
  string: () => string3
});
function string3(params) {
  return _coercedString(ZodString, params);
}
function number3(params) {
  return _coercedNumber(ZodNumber, params);
}
function boolean3(params) {
  return _coercedBoolean(ZodBoolean, params);
}
function bigint3(params) {
  return _coercedBigint(ZodBigInt, params);
}
function date4(params) {
  return _coercedDate(ZodDate, params);
}
var init_coerce = __esm({
  "node_modules/zod/v4/classic/coerce.js"() {
    init_core2();
    init_schemas2();
  }
});

// node_modules/zod/v4/classic/external.js
var external_exports = {};
__export(external_exports, {
  $brand: () => $brand,
  $input: () => $input,
  $output: () => $output,
  NEVER: () => NEVER,
  TimePrecision: () => TimePrecision,
  ZodAny: () => ZodAny,
  ZodArray: () => ZodArray,
  ZodBase64: () => ZodBase64,
  ZodBase64URL: () => ZodBase64URL,
  ZodBigInt: () => ZodBigInt,
  ZodBigIntFormat: () => ZodBigIntFormat,
  ZodBoolean: () => ZodBoolean,
  ZodCIDRv4: () => ZodCIDRv4,
  ZodCIDRv6: () => ZodCIDRv6,
  ZodCUID: () => ZodCUID,
  ZodCUID2: () => ZodCUID2,
  ZodCatch: () => ZodCatch,
  ZodCodec: () => ZodCodec,
  ZodCustom: () => ZodCustom,
  ZodCustomStringFormat: () => ZodCustomStringFormat,
  ZodDate: () => ZodDate,
  ZodDefault: () => ZodDefault,
  ZodDiscriminatedUnion: () => ZodDiscriminatedUnion,
  ZodE164: () => ZodE164,
  ZodEmail: () => ZodEmail,
  ZodEmoji: () => ZodEmoji,
  ZodEnum: () => ZodEnum,
  ZodError: () => ZodError,
  ZodFile: () => ZodFile,
  ZodFirstPartyTypeKind: () => ZodFirstPartyTypeKind,
  ZodFunction: () => ZodFunction,
  ZodGUID: () => ZodGUID,
  ZodIPv4: () => ZodIPv4,
  ZodIPv6: () => ZodIPv6,
  ZodISODate: () => ZodISODate,
  ZodISODateTime: () => ZodISODateTime,
  ZodISODuration: () => ZodISODuration,
  ZodISOTime: () => ZodISOTime,
  ZodIntersection: () => ZodIntersection,
  ZodIssueCode: () => ZodIssueCode,
  ZodJWT: () => ZodJWT,
  ZodKSUID: () => ZodKSUID,
  ZodLazy: () => ZodLazy,
  ZodLiteral: () => ZodLiteral,
  ZodMap: () => ZodMap,
  ZodNaN: () => ZodNaN,
  ZodNanoID: () => ZodNanoID,
  ZodNever: () => ZodNever,
  ZodNonOptional: () => ZodNonOptional,
  ZodNull: () => ZodNull,
  ZodNullable: () => ZodNullable,
  ZodNumber: () => ZodNumber,
  ZodNumberFormat: () => ZodNumberFormat,
  ZodObject: () => ZodObject,
  ZodOptional: () => ZodOptional,
  ZodPipe: () => ZodPipe,
  ZodPrefault: () => ZodPrefault,
  ZodPromise: () => ZodPromise,
  ZodReadonly: () => ZodReadonly,
  ZodRealError: () => ZodRealError,
  ZodRecord: () => ZodRecord,
  ZodSet: () => ZodSet,
  ZodString: () => ZodString,
  ZodStringFormat: () => ZodStringFormat,
  ZodSuccess: () => ZodSuccess,
  ZodSymbol: () => ZodSymbol,
  ZodTemplateLiteral: () => ZodTemplateLiteral,
  ZodTransform: () => ZodTransform,
  ZodTuple: () => ZodTuple,
  ZodType: () => ZodType,
  ZodULID: () => ZodULID,
  ZodURL: () => ZodURL,
  ZodUUID: () => ZodUUID,
  ZodUndefined: () => ZodUndefined,
  ZodUnion: () => ZodUnion,
  ZodUnknown: () => ZodUnknown,
  ZodVoid: () => ZodVoid,
  ZodXID: () => ZodXID,
  _ZodString: () => _ZodString,
  _default: () => _default2,
  _function: () => _function,
  any: () => any,
  array: () => array,
  base64: () => base642,
  base64url: () => base64url2,
  bigint: () => bigint2,
  boolean: () => boolean2,
  catch: () => _catch2,
  check: () => check,
  cidrv4: () => cidrv42,
  cidrv6: () => cidrv62,
  clone: () => clone2,
  codec: () => codec,
  coerce: () => coerce_exports,
  config: () => config,
  core: () => core_exports2,
  cuid: () => cuid3,
  cuid2: () => cuid22,
  custom: () => custom,
  date: () => date3,
  decode: () => decode3,
  decodeAsync: () => decodeAsync2,
  discriminatedUnion: () => discriminatedUnion,
  e164: () => e1642,
  email: () => email2,
  emoji: () => emoji2,
  encode: () => encode3,
  encodeAsync: () => encodeAsync2,
  endsWith: () => _endsWith,
  enum: () => _enum2,
  file: () => file,
  flattenError: () => flattenError,
  float32: () => float32,
  float64: () => float64,
  formatError: () => formatError,
  function: () => _function,
  getErrorMap: () => getErrorMap,
  globalRegistry: () => globalRegistry,
  gt: () => _gt,
  gte: () => _gte,
  guid: () => guid2,
  hash: () => hash,
  hex: () => hex2,
  hostname: () => hostname2,
  httpUrl: () => httpUrl,
  includes: () => _includes,
  instanceof: () => _instanceof,
  int: () => int,
  int32: () => int32,
  int64: () => int64,
  intersection: () => intersection,
  ipv4: () => ipv42,
  ipv6: () => ipv62,
  iso: () => iso_exports,
  json: () => json,
  jwt: () => jwt,
  keyof: () => keyof,
  ksuid: () => ksuid2,
  lazy: () => lazy,
  length: () => _length,
  literal: () => literal2,
  locales: () => locales_exports,
  looseObject: () => looseObject,
  lowercase: () => _lowercase,
  lt: () => _lt,
  lte: () => _lte,
  map: () => map,
  maxLength: () => _maxLength,
  maxSize: () => _maxSize,
  mime: () => _mime,
  minLength: () => _minLength,
  minSize: () => _minSize,
  multipleOf: () => _multipleOf,
  nan: () => nan,
  nanoid: () => nanoid2,
  nativeEnum: () => nativeEnum,
  negative: () => _negative,
  never: () => never,
  nonnegative: () => _nonnegative,
  nonoptional: () => nonoptional,
  nonpositive: () => _nonpositive,
  normalize: () => _normalize,
  null: () => _null3,
  nullable: () => nullable,
  nullish: () => nullish2,
  number: () => number2,
  object: () => object,
  optional: () => optional,
  overwrite: () => _overwrite,
  parse: () => parse3,
  parseAsync: () => parseAsync2,
  partialRecord: () => partialRecord,
  pipe: () => pipe,
  positive: () => _positive,
  prefault: () => prefault,
  preprocess: () => preprocess,
  prettifyError: () => prettifyError,
  promise: () => promise,
  property: () => _property,
  readonly: () => readonly,
  record: () => record,
  refine: () => refine,
  regex: () => _regex,
  regexes: () => regexes_exports,
  registry: () => registry,
  safeDecode: () => safeDecode2,
  safeDecodeAsync: () => safeDecodeAsync2,
  safeEncode: () => safeEncode2,
  safeEncodeAsync: () => safeEncodeAsync2,
  safeParse: () => safeParse2,
  safeParseAsync: () => safeParseAsync2,
  set: () => set,
  setErrorMap: () => setErrorMap,
  size: () => _size,
  startsWith: () => _startsWith,
  strictObject: () => strictObject,
  string: () => string2,
  stringFormat: () => stringFormat,
  stringbool: () => stringbool,
  success: () => success,
  superRefine: () => superRefine,
  symbol: () => symbol,
  templateLiteral: () => templateLiteral,
  toJSONSchema: () => toJSONSchema,
  toLowerCase: () => _toLowerCase,
  toUpperCase: () => _toUpperCase,
  transform: () => transform,
  treeifyError: () => treeifyError,
  trim: () => _trim,
  tuple: () => tuple,
  uint32: () => uint32,
  uint64: () => uint64,
  ulid: () => ulid2,
  undefined: () => _undefined3,
  union: () => union,
  unknown: () => unknown,
  uppercase: () => _uppercase,
  url: () => url,
  util: () => util_exports,
  uuid: () => uuid2,
  uuidv4: () => uuidv4,
  uuidv6: () => uuidv6,
  uuidv7: () => uuidv7,
  void: () => _void2,
  xid: () => xid2
});
var init_external = __esm({
  "node_modules/zod/v4/classic/external.js"() {
    init_core2();
    init_schemas2();
    init_checks2();
    init_errors3();
    init_parse2();
    init_compat();
    init_core2();
    init_en();
    init_core2();
    init_locales();
    init_iso();
    init_iso();
    init_coerce();
    config(en_default());
  }
});

// node_modules/zod/index.js
var init_zod = __esm({
  "node_modules/zod/index.js"() {
    init_external();
    init_external();
  }
});

// src/ts/core/coreTypes.ts
var ImmutableId;
var init_coreTypes = __esm({
  "src/ts/core/coreTypes.ts"() {
    "use strict";
    init_zod();
    ImmutableId = external_exports.number().int().min(0).max(999999999999);
  }
});

// src/ts/core/overallProgressSchema.ts
function isValidLessonId(lessonId, registry2) {
  return registry2.hasLesson(lessonId);
}
function isValidDomainId(domainId, registry2) {
  return registry2.hasDomain(domainId);
}
function getDefaultOverallProgress() {
  return {
    lessonCompletions: {},
    domainCompletions: {},
    currentStreak: 0,
    lastStreakCheck: 0,
    totalLessonsCompleted: 0,
    totalDomainsCompleted: 0
  };
}
var CompletionDataSchema, OverallProgressDataSchema, OverallProgressManager, OverallProgressMessageSchema, OverallProgressMessageQueueManager, OverallProgressMessageHandler;
var init_overallProgressSchema = __esm({
  "src/ts/core/overallProgressSchema.ts"() {
    "use strict";
    init_zod();
    init_coreTypes();
    CompletionDataSchema = external_exports.object({
      timeCompleted: external_exports.number().nullable(),
      lastUpdated: external_exports.number()
    });
    OverallProgressDataSchema = external_exports.object({
      lessonCompletions: external_exports.record(external_exports.string(), CompletionDataSchema),
      domainCompletions: external_exports.record(external_exports.string(), CompletionDataSchema),
      currentStreak: external_exports.number().min(0).max(1e3),
      lastStreakCheck: external_exports.number().int().min(0),
      totalLessonsCompleted: external_exports.number().int().min(0).max(1e3),
      totalDomainsCompleted: external_exports.number().int().min(0).max(1e3)
    });
    OverallProgressManager = class {
      constructor(initialProgress, curriculumRegistry) {
        this.curriculumRegistry = curriculumRegistry;
        this.progress = structuredClone(initialProgress);
      }
      /**
       * Returns cloned progress data for persistence.
       *
       * Clone ensures external code cannot mutate manager's internal state.
       * Core calls this during save to build the bundle.
       */
      getProgress() {
        return structuredClone(this.progress);
      }
      /**
       * Mark a lesson as complete with current timestamp.
       *
       * Validates lesson exists in curriculum using shared helper.
       * Updates lastUpdated even if already completed (tracks most recent interaction).
       * Sets timeCompleted only on first completion, increments counter accordingly.
       *
       * @param lessonId - Lesson to mark complete
       * @throws Error if lesson ID not in curriculum
       */
      markLessonComplete(lessonId) {
        if (!isValidLessonId(lessonId, this.curriculumRegistry)) {
          throw new Error(`Invalid lesson ID: ${lessonId}`);
        }
        const lessonKey = lessonId.toString();
        const timestamp2 = Math.floor(Date.now() / 1e3);
        const current = this.progress.lessonCompletions[lessonKey];
        if (!current || current.timeCompleted === null) {
          this.progress.lessonCompletions[lessonKey] = {
            timeCompleted: timestamp2,
            lastUpdated: timestamp2
          };
          this.progress.totalLessonsCompleted++;
        } else {
          this.progress.lessonCompletions[lessonKey] = {
            timeCompleted: current.timeCompleted,
            lastUpdated: timestamp2
          };
        }
        for (const domainId of this.curriculumRegistry.getAllDomainIds()) {
          const lessonIdsInDomain = this.curriculumRegistry.getLessonsInDomain(domainId);
          if (lessonIdsInDomain && lessonIdsInDomain.includes(lessonId)) {
            const allComplete = lessonIdsInDomain.every((lid) => {
              const completion = this.progress.lessonCompletions[lid.toString()];
              return completion && completion.timeCompleted !== null;
            });
            if (allComplete) {
              this.markDomainComplete(domainId);
            }
          }
        }
      }
      /**
       * Mark a lesson as incomplete (set timeCompleted to null).
       *
       * Validates lesson exists in curriculum using shared helper.
       * Updates lastUpdated to track when incompletion happened.
       * Safe to call even if lesson was not completed.
       * Decrements counter only if lesson was actually completed.
       *
       * @param lessonId - Lesson to mark incomplete
       * @throws Error if lesson ID not in curriculum
       */
      markLessonIncomplete(lessonId) {
        if (!isValidLessonId(lessonId, this.curriculumRegistry)) {
          throw new Error(`Invalid lesson ID: ${lessonId}`);
        }
        const lessonKey = lessonId.toString();
        const timestamp2 = Math.floor(Date.now() / 1e3);
        const current = this.progress.lessonCompletions[lessonKey];
        if (current && current.timeCompleted !== null) {
          this.progress.lessonCompletions[lessonKey] = {
            timeCompleted: null,
            lastUpdated: timestamp2
          };
          this.progress.totalLessonsCompleted--;
        } else if (current) {
          this.progress.lessonCompletions[lessonKey] = {
            timeCompleted: null,
            lastUpdated: timestamp2
          };
        } else {
          this.progress.lessonCompletions[lessonKey] = {
            timeCompleted: null,
            lastUpdated: timestamp2
          };
        }
      }
      /**
       * Mark a domain as complete with current timestamp.
       *
       * Similar logic to markLessonComplete but for domains.
       *
       * @param domainId - Domain to mark complete
       * @throws Error if domain ID not in curriculum
       */
      markDomainComplete(domainId) {
        if (!isValidDomainId(domainId, this.curriculumRegistry)) {
          throw new Error(`Invalid domain ID: ${domainId}`);
        }
        const domainKey = domainId.toString();
        const timestamp2 = Math.floor(Date.now() / 1e3);
        const current = this.progress.domainCompletions[domainKey];
        if (!current || current.timeCompleted === null) {
          this.progress.domainCompletions[domainKey] = {
            timeCompleted: timestamp2,
            lastUpdated: timestamp2
          };
          this.progress.totalDomainsCompleted++;
        } else {
          this.progress.domainCompletions[domainKey] = {
            timeCompleted: current.timeCompleted,
            lastUpdated: timestamp2
          };
        }
      }
      /**
       * Mark a domain as incomplete (set timeCompleted to null).
       *
       * Similar logic to markLessonIncomplete but for domains.
       *
       * @param domainId - Domain to mark incomplete
       * @throws Error if domain ID not in curriculum
       */
      markDomainIncomplete(domainId) {
        if (!isValidDomainId(domainId, this.curriculumRegistry)) {
          throw new Error(`Invalid domain ID: ${domainId}`);
        }
        const domainKey = domainId.toString();
        const timestamp2 = Math.floor(Date.now() / 1e3);
        const current = this.progress.domainCompletions[domainKey];
        if (current && current.timeCompleted !== null) {
          this.progress.domainCompletions[domainKey] = {
            timeCompleted: null,
            lastUpdated: timestamp2
          };
          this.progress.totalDomainsCompleted--;
        } else if (current) {
          this.progress.domainCompletions[domainKey] = {
            timeCompleted: null,
            lastUpdated: timestamp2
          };
        } else {
          this.progress.domainCompletions[domainKey] = {
            timeCompleted: null,
            lastUpdated: timestamp2
          };
        }
      }
      /**
       * Update streak to a specific value.
       *
       * Called by motivation component after validating weekly goals.
       *
       * @param newStreak - New streak value
       */
      updateStreak(newStreak) {
        this.progress.currentStreak = newStreak;
        this.progress.lastStreakCheck = Math.floor(Date.now() / 1e3);
      }
      /**
       * Reset streak to zero.
       *
       * Called when weekly goal not met.
       */
      resetStreak() {
        this.progress.currentStreak = 0;
        this.progress.lastStreakCheck = Math.floor(Date.now() / 1e3);
      }
      /**
       * Increment streak by one.
       *
       * Called when previous week's goal was met.
       */
      incrementStreak() {
        this.progress.currentStreak += 1;
        this.progress.lastStreakCheck = Math.floor(Date.now() / 1e3);
      }
      /**
       * Get progress for a specific domain.
       *
       * Counts completed lessons vs total lessons in the domain.
       * Used by main menu for domain progress visualization.
       *
       * @param domainId - Domain to check
       * @returns Object with completed and total lesson counts
       * @throws Error if domain ID invalid
       */
      getDomainProgress(domainId) {
        if (!isValidDomainId(domainId, this.curriculumRegistry)) {
          throw new Error(`Invalid domain ID: ${domainId}`);
        }
        const lessonsInDomain = this.curriculumRegistry.getLessonsInDomain(domainId);
        if (!lessonsInDomain) {
          return { completed: 0, total: 0 };
        }
        let completed = 0;
        for (const lessonId of lessonsInDomain) {
          const lessonKey = lessonId.toString();
          const completion = this.progress.lessonCompletions[lessonKey];
          if (completion && completion.timeCompleted !== null) {
            completed++;
          }
        }
        return {
          completed,
          total: lessonsInDomain.length
        };
      }
    };
    OverallProgressMessageSchema = external_exports.object({
      method: external_exports.enum([
        "markLessonComplete",
        "markLessonIncomplete",
        "markDomainComplete",
        "markDomainIncomplete",
        "updateStreak",
        "resetStreak",
        "incrementStreak"
      ]),
      args: external_exports.array(external_exports.any())
    });
    OverallProgressMessageQueueManager = class {
      constructor(curriculumRegistry) {
        this.curriculumRegistry = curriculumRegistry;
        this.messageQueue = [];
      }
      /**
       * Queue a lesson completion message.
       *
       * Validates lesson ID using shared helper before queueing.
       *
       * @param lessonId - Lesson to mark complete
       * @throws Error if lesson ID invalid or not in curriculum
       */
      queueLessonComplete(lessonId) {
        const message2 = {
          method: "markLessonComplete",
          args: [lessonId]
        };
        if (message2.args.length !== 1) {
          throw new Error("markLessonComplete requires exactly 1 argument");
        }
        const parseResult = ImmutableId.safeParse(lessonId);
        if (!parseResult.success) {
          throw new Error(
            `lessonId must be a valid immutable ID, got: ${lessonId}`
          );
        }
        if (!isValidLessonId(lessonId, this.curriculumRegistry)) {
          throw new Error(
            `Invalid lesson ID: ${lessonId} does not exist in curriculum`
          );
        }
        this.messageQueue.push(message2);
      }
      /**
       * Queue a lesson incomplete message.
       *
       * Validates lesson ID using shared helper before queueing.
       *
       * @param lessonId - Lesson to mark incomplete
       * @throws Error if lesson ID invalid or not in curriculum
       */
      queueLessonIncomplete(lessonId) {
        const message2 = {
          method: "markLessonIncomplete",
          args: [lessonId]
        };
        if (message2.args.length !== 1) {
          throw new Error("markLessonIncomplete requires exactly 1 argument");
        }
        const parseResult = ImmutableId.safeParse(lessonId);
        if (!parseResult.success) {
          throw new Error(
            `lessonId must be a valid immutable ID, got: ${lessonId}`
          );
        }
        if (!isValidLessonId(lessonId, this.curriculumRegistry)) {
          throw new Error(
            `Invalid lesson ID: ${lessonId} does not exist in curriculum`
          );
        }
        this.messageQueue.push(message2);
      }
      /**
       * Queue a domain completion message.
       *
       * Validates domain ID using shared helper before queueing.
       *
       * @param domainId - Domain to mark complete
       * @throws Error if domain ID invalid or not in curriculum
       */
      queueDomainComplete(domainId) {
        const message2 = {
          method: "markDomainComplete",
          args: [domainId]
        };
        if (message2.args.length !== 1) {
          throw new Error("markDomainComplete requires exactly 1 argument");
        }
        const parseResult = ImmutableId.safeParse(domainId);
        if (!parseResult.success) {
          throw new Error(
            `domainId must be a valid immutable ID, got: ${domainId}`
          );
        }
        if (!isValidDomainId(domainId, this.curriculumRegistry)) {
          throw new Error(
            `Invalid domain ID: ${domainId} does not exist in curriculum`
          );
        }
        this.messageQueue.push(message2);
      }
      /**
       * Queue a domain incomplete message.
       *
       * Validates domain ID using shared helper before queueing.
       *
       * @param domainId - Domain to mark incomplete
       * @throws Error if domain ID invalid or not in curriculum
       */
      queueDomainIncomplete(domainId) {
        const message2 = {
          method: "markDomainIncomplete",
          args: [domainId]
        };
        if (message2.args.length !== 1) {
          throw new Error("markDomainIncomplete requires exactly 1 argument");
        }
        const parseResult = ImmutableId.safeParse(domainId);
        if (!parseResult.success) {
          throw new Error(
            `domainId must be a valid immutable ID, got: ${domainId}`
          );
        }
        if (!isValidDomainId(domainId, this.curriculumRegistry)) {
          throw new Error(
            `Invalid domain ID: ${domainId} does not exist in curriculum`
          );
        }
        this.messageQueue.push(message2);
      }
      /**
       * Queue a streak update message.
       *
       * @param newStreak - New streak value
       */
      queueUpdateStreak(newStreak) {
        const message2 = {
          method: "updateStreak",
          args: [newStreak]
        };
        if (message2.args.length !== 1) {
          throw new Error("updateStreak requires exactly 1 argument");
        }
        if (typeof newStreak !== "number" || newStreak < 0) {
          throw new Error("newStreak must be a non-negative number");
        }
        this.messageQueue.push(message2);
      }
      /**
       * Queue a streak reset message.
       */
      queueResetStreak() {
        const message2 = {
          method: "resetStreak",
          args: []
        };
        this.messageQueue.push(message2);
      }
      /**
       * Queue a streak increment message.
       */
      queueIncrementStreak() {
        const message2 = {
          method: "incrementStreak",
          args: []
        };
        this.messageQueue.push(message2);
      }
      /**
       * Get all queued messages and clear the queue.
       *
       * Called by Main Core polling cycle to process messages.
       *
       * @returns Array of queued messages
       */
      getMessages() {
        const messages = [...this.messageQueue];
        this.messageQueue = [];
        return messages;
      }
    };
    OverallProgressMessageHandler = class {
      constructor(progressManager, curriculumRegistry) {
        this.progressManager = progressManager;
        this.curriculumRegistry = curriculumRegistry;
      }
      /**
       * Validate message structure and arguments.
       *
       * Checks method name, argument count, and value types.
       * Does NOT validate entity IDs - that's done by manager methods.
       *
       * @param message - Message to validate
       * @throws Error if message structure invalid
       */
      validateMessage(message2) {
        const zodResult = OverallProgressMessageSchema.safeParse(message2);
        if (!zodResult.success) {
          throw new Error(
            `Invalid overall progress message: ${zodResult.error.message}`
          );
        }
        const argCounts = {
          markLessonComplete: 1,
          markLessonIncomplete: 1,
          markDomainComplete: 1,
          markDomainIncomplete: 1,
          updateStreak: 1,
          resetStreak: 0,
          incrementStreak: 0
        };
        const expectedCount = argCounts[message2.method];
        if (message2.args.length !== expectedCount) {
          throw new Error(
            `${message2.method} requires ${expectedCount} argument(s), got ${message2.args.length}`
          );
        }
      }
      /**
       * Handle validated message by routing to manager.
       *
       * Routes validated message to appropriate OverallProgressManager method.
       */
      handleMessage(message2) {
        this.validateMessage(message2);
        switch (message2.method) {
          case "markLessonComplete":
            this.progressManager.markLessonComplete(message2.args[0]);
            break;
          case "markLessonIncomplete":
            this.progressManager.markLessonIncomplete(message2.args[0]);
            break;
          case "markDomainComplete":
            this.progressManager.markDomainComplete(message2.args[0]);
            break;
          case "markDomainIncomplete":
            this.progressManager.markDomainIncomplete(message2.args[0]);
            break;
          case "updateStreak":
            this.progressManager.updateStreak(message2.args[0]);
            break;
          case "resetStreak":
            this.progressManager.resetStreak();
            break;
          case "incrementStreak":
            this.progressManager.incrementStreak();
            break;
        }
      }
    };
  }
});

// src/ts/core/settingsSchema.ts
function getDefaultSettings() {
  return {
    weekStartDay: ["sunday", 0],
    weekStartTimeUTC: ["00:00", 0],
    theme: ["auto", 0],
    learningPace: ["standard", 0],
    optOutDailyPing: [false, 0],
    optOutErrorPing: [false, 0],
    fontSize: ["medium", 0],
    highContrast: [false, 0],
    reducedMotion: [false, 0],
    focusIndicatorStyle: ["default", 0],
    audioEnabled: [true, 0]
  };
}
var SettingsDataSchema, SettingsDataManager, SettingsMessageSchema, SettingsMessageHandler, SettingsMessageQueueManager;
var init_settingsSchema = __esm({
  "src/ts/core/settingsSchema.ts"() {
    "use strict";
    init_zod();
    SettingsDataSchema = external_exports.object({
      // Week timing for streaks: [value, lastUpdated]
      weekStartDay: external_exports.tuple([
        external_exports.enum([
          "sunday",
          "monday",
          "tuesday",
          "wednesday",
          "thursday",
          "friday",
          "saturday"
        ]),
        external_exports.number().int().min(0)
        // lastUpdated timestamp
      ]),
      weekStartTimeUTC: external_exports.tuple([
        external_exports.string().regex(/^([01]\d|2[0-3]):[0-5]\d$/, "Time must be HH:MM in 24-hour format"),
        external_exports.number().int().min(0)
      ]),
      // Appearance: [value, lastUpdated]
      theme: external_exports.tuple([
        external_exports.enum(["light", "dark", "auto"]),
        external_exports.number().int().min(0)
      ]),
      // Learning: [value, lastUpdated]
      learningPace: external_exports.tuple([
        external_exports.enum(["accelerated", "standard", "flexible"]),
        external_exports.number().int().min(0)
      ]),
      // Privacy/Analytics: [value, lastUpdated]
      optOutDailyPing: external_exports.tuple([
        external_exports.boolean(),
        external_exports.number().int().min(0)
      ]),
      optOutErrorPing: external_exports.tuple([
        external_exports.boolean(),
        external_exports.number().int().min(0)
      ]),
      // Accessibility: [value, lastUpdated]
      fontSize: external_exports.tuple([
        external_exports.enum(["small", "medium", "large"]),
        external_exports.number().int().min(0)
      ]),
      highContrast: external_exports.tuple([
        external_exports.boolean(),
        external_exports.number().int().min(0)
      ]),
      reducedMotion: external_exports.tuple([
        external_exports.boolean(),
        external_exports.number().int().min(0)
      ]),
      focusIndicatorStyle: external_exports.tuple([
        external_exports.enum(["default", "enhanced"]),
        external_exports.number().int().min(0)
      ]),
      audioEnabled: external_exports.tuple([
        external_exports.boolean(),
        external_exports.number().int().min(0)
      ])
    });
    SettingsDataManager = class {
      constructor(initialSettings) {
        this.settings = structuredClone(initialSettings);
      }
      // Readonly getters for all settings (return value only, not timestamp)
      getWeekStartDay() {
        return this.settings.weekStartDay[0];
      }
      getWeekStartTimeUTC() {
        return this.settings.weekStartTimeUTC[0];
      }
      getTheme() {
        return this.settings.theme[0];
      }
      getLearningPace() {
        return this.settings.learningPace[0];
      }
      getOptOutDailyPing() {
        return this.settings.optOutDailyPing[0];
      }
      getOptOutErrorPing() {
        return this.settings.optOutErrorPing[0];
      }
      getFontSize() {
        return this.settings.fontSize[0];
      }
      getHighContrast() {
        return this.settings.highContrast[0];
      }
      getReducedMotion() {
        return this.settings.reducedMotion[0];
      }
      getFocusIndicatorStyle() {
        return this.settings.focusIndicatorStyle[0];
      }
      getAudioEnabled() {
        return this.settings.audioEnabled[0];
      }
      /**
       * Returns cloned settings data for persistence.
       *
       * Clone ensures external code cannot mutate manager's internal state.
       * Core calls this during save to build the bundle.
       */
      getSettings() {
        return structuredClone(this.settings);
      }
      // Setters construct tuple and validate against schema (ensures schema consistency)
      setWeekStartDay(day2) {
        const validated = SettingsDataSchema.shape.weekStartDay.parse([
          day2,
          Math.floor(Date.now() / 1e3)
        ]);
        this.settings.weekStartDay = validated;
      }
      setWeekStartTimeUTC(time3) {
        const validated = SettingsDataSchema.shape.weekStartTimeUTC.parse([
          time3,
          Math.floor(Date.now() / 1e3)
        ]);
        this.settings.weekStartTimeUTC = validated;
      }
      setTheme(theme) {
        const validated = SettingsDataSchema.shape.theme.parse([
          theme,
          Math.floor(Date.now() / 1e3)
        ]);
        this.settings.theme = validated;
      }
      setLearningPace(pace) {
        const validated = SettingsDataSchema.shape.learningPace.parse([
          pace,
          Math.floor(Date.now() / 1e3)
        ]);
        this.settings.learningPace = validated;
      }
      setOptOutDailyPing(optOut) {
        const validated = SettingsDataSchema.shape.optOutDailyPing.parse([
          optOut,
          Math.floor(Date.now() / 1e3)
        ]);
        this.settings.optOutDailyPing = validated;
      }
      setOptOutErrorPing(optOut) {
        const validated = SettingsDataSchema.shape.optOutErrorPing.parse([
          optOut,
          Math.floor(Date.now() / 1e3)
        ]);
        this.settings.optOutErrorPing = validated;
      }
      setFontSize(size) {
        const validated = SettingsDataSchema.shape.fontSize.parse([
          size,
          Math.floor(Date.now() / 1e3)
        ]);
        this.settings.fontSize = validated;
      }
      setHighContrast(enabled) {
        const validated = SettingsDataSchema.shape.highContrast.parse([
          enabled,
          Math.floor(Date.now() / 1e3)
        ]);
        this.settings.highContrast = validated;
      }
      setReducedMotion(enabled) {
        const validated = SettingsDataSchema.shape.reducedMotion.parse([
          enabled,
          Math.floor(Date.now() / 1e3)
        ]);
        this.settings.reducedMotion = validated;
      }
      setFocusIndicatorStyle(style) {
        const validated = SettingsDataSchema.shape.focusIndicatorStyle.parse([
          style,
          Math.floor(Date.now() / 1e3)
        ]);
        this.settings.focusIndicatorStyle = validated;
      }
      setAudioEnabled(enabled) {
        const validated = SettingsDataSchema.shape.audioEnabled.parse([
          enabled,
          Math.floor(Date.now() / 1e3)
        ]);
        this.settings.audioEnabled = validated;
      }
      /**
       * Calculate Unix timestamp of last week start based on user's week preferences.
       *
       * Used by streak tracking to determine if user completed learning goals.
       * Accounts for custom week start day and time in UTC.
       */
      getLastWeekStart() {
        const now = /* @__PURE__ */ new Date();
        const currentDay = now.getUTCDay();
        const [weekStartTimeStr] = this.settings.weekStartTimeUTC;
        const [hourStr, minuteStr] = weekStartTimeStr.split(":");
        const weekStartHour = parseInt(hourStr, 10);
        const weekStartMinute = parseInt(minuteStr, 10);
        const weekStartDayMap = {
          sunday: 0,
          monday: 1,
          tuesday: 2,
          wednesday: 3,
          thursday: 4,
          friday: 5,
          saturday: 6
        };
        const [weekStartDayValue] = this.settings.weekStartDay;
        const targetDay = weekStartDayMap[weekStartDayValue];
        let daysSinceWeekStart = currentDay - targetDay;
        if (daysSinceWeekStart < 0) daysSinceWeekStart += 7;
        const lastWeekStart = new Date(now);
        lastWeekStart.setUTCDate(now.getUTCDate() - daysSinceWeekStart);
        lastWeekStart.setUTCHours(weekStartHour, weekStartMinute, 0, 0);
        if (lastWeekStart.getTime() > now.getTime()) {
          lastWeekStart.setUTCDate(lastWeekStart.getUTCDate() - 7);
        }
        return Math.floor(lastWeekStart.getTime() / 1e3);
      }
    };
    SettingsMessageSchema = external_exports.object({
      method: external_exports.enum([
        "setWeekStartDay",
        "setWeekStartTimeUTC",
        "setTheme",
        "setLearningPace",
        "setOptOutDailyPing",
        "setOptOutErrorPing",
        "setFontSize",
        "setHighContrast",
        "setReducedMotion",
        "setFocusIndicatorStyle",
        "setAudioEnabled"
      ]),
      args: external_exports.array(external_exports.any())
      // Validate per-method
    });
    SettingsMessageHandler = class {
      constructor(settingsManager) {
        this.settingsManager = settingsManager;
      }
      /**
       * Validate a settings message.
       *
       * Per-method validation of argument count and types.
       *
       * @param message - Settings message to validate
       * @throws Error if message invalid
       */
      validateMessage(message2) {
        switch (message2.method) {
          case "setWeekStartDay":
            if (message2.args.length !== 1) {
              throw new Error("setWeekStartDay requires exactly 1 argument");
            }
            external_exports.enum(["sunday", "monday", "tuesday", "wednesday", "thursday", "friday", "saturday"]).parse(message2.args[0]);
            break;
          case "setWeekStartTimeUTC":
            if (message2.args.length !== 1) {
              throw new Error("setWeekStartTimeUTC requires exactly 1 argument");
            }
            external_exports.string().regex(/^([01]\d|2[0-3]):[0-5]\d$/).parse(message2.args[0]);
            break;
          case "setTheme":
            if (message2.args.length !== 1) {
              throw new Error("setTheme requires exactly 1 argument");
            }
            external_exports.enum(["light", "dark", "auto"]).parse(message2.args[0]);
            break;
          case "setLearningPace":
            if (message2.args.length !== 1) {
              throw new Error("setLearningPace requires exactly 1 argument");
            }
            external_exports.enum(["accelerated", "standard", "flexible"]).parse(message2.args[0]);
            break;
          case "setOptOutDailyPing":
            if (message2.args.length !== 1) {
              throw new Error("setOptOutDailyPing requires exactly 1 argument");
            }
            external_exports.boolean().parse(message2.args[0]);
            break;
          case "setOptOutErrorPing":
            if (message2.args.length !== 1) {
              throw new Error("setOptOutErrorPing requires exactly 1 argument");
            }
            external_exports.boolean().parse(message2.args[0]);
            break;
          case "setFontSize":
            if (message2.args.length !== 1) {
              throw new Error("setFontSize requires exactly 1 argument");
            }
            external_exports.enum(["small", "medium", "large"]).parse(message2.args[0]);
            break;
          case "setHighContrast":
            if (message2.args.length !== 1) {
              throw new Error("setHighContrast requires exactly 1 argument");
            }
            external_exports.boolean().parse(message2.args[0]);
            break;
          case "setReducedMotion":
            if (message2.args.length !== 1) {
              throw new Error("setReducedMotion requires exactly 1 argument");
            }
            external_exports.boolean().parse(message2.args[0]);
            break;
          case "setFocusIndicatorStyle":
            if (message2.args.length !== 1) {
              throw new Error("setFocusIndicatorStyle requires exactly 1 argument");
            }
            external_exports.enum(["default", "enhanced"]).parse(message2.args[0]);
            break;
          case "setAudioEnabled":
            if (message2.args.length !== 1) {
              throw new Error("setAudioEnabled requires exactly 1 argument");
            }
            external_exports.boolean().parse(message2.args[0]);
            break;
        }
      }
      /**
       * Handle validated message.
       *
       * Routes validated message to appropriate SettingsDataManager method.
       */
      handleMessage(message2) {
        this.validateMessage(message2);
        switch (message2.method) {
          case "setWeekStartDay":
            this.settingsManager.setWeekStartDay(message2.args[0]);
            break;
          case "setWeekStartTimeUTC":
            this.settingsManager.setWeekStartTimeUTC(message2.args[0]);
            break;
          case "setTheme":
            this.settingsManager.setTheme(message2.args[0]);
            break;
          case "setLearningPace":
            this.settingsManager.setLearningPace(message2.args[0]);
            break;
          case "setOptOutDailyPing":
            this.settingsManager.setOptOutDailyPing(message2.args[0]);
            break;
          case "setOptOutErrorPing":
            this.settingsManager.setOptOutErrorPing(message2.args[0]);
            break;
          case "setFontSize":
            this.settingsManager.setFontSize(message2.args[0]);
            break;
          case "setHighContrast":
            this.settingsManager.setHighContrast(message2.args[0]);
            break;
          case "setReducedMotion":
            this.settingsManager.setReducedMotion(message2.args[0]);
            break;
          case "setFocusIndicatorStyle":
            this.settingsManager.setFocusIndicatorStyle(message2.args[0]);
            break;
          case "setAudioEnabled":
            this.settingsManager.setAudioEnabled(message2.args[0]);
            break;
        }
      }
    };
    SettingsMessageQueueManager = class {
      constructor() {
        this.messageQueue = [];
      }
      queueWeekStartDay(day2) {
        const message2 = { method: "setWeekStartDay", args: [day2] };
        if (message2.args.length !== 1) {
          throw new Error("setWeekStartDay requires exactly 1 argument");
        }
        external_exports.enum(["sunday", "monday", "tuesday", "wednesday", "thursday", "friday", "saturday"]).parse(message2.args[0]);
        this.messageQueue.push(message2);
      }
      queueWeekStartTimeUTC(time3) {
        const message2 = { method: "setWeekStartTimeUTC", args: [time3] };
        if (message2.args.length !== 1) {
          throw new Error("setWeekStartTimeUTC requires exactly 1 argument");
        }
        external_exports.string().regex(/^([01]\d|2[0-3]):[0-5]\d$/).parse(message2.args[0]);
        this.messageQueue.push(message2);
      }
      queueTheme(theme) {
        const message2 = { method: "setTheme", args: [theme] };
        if (message2.args.length !== 1) {
          throw new Error("setTheme requires exactly 1 argument");
        }
        external_exports.enum(["light", "dark", "auto"]).parse(message2.args[0]);
        this.messageQueue.push(message2);
      }
      queueLearningPace(pace) {
        const message2 = { method: "setLearningPace", args: [pace] };
        if (message2.args.length !== 1) {
          throw new Error("setLearningPace requires exactly 1 argument");
        }
        external_exports.enum(["accelerated", "standard", "flexible"]).parse(message2.args[0]);
        this.messageQueue.push(message2);
      }
      queueOptOutDailyPing(optOut) {
        const message2 = { method: "setOptOutDailyPing", args: [optOut] };
        if (message2.args.length !== 1) {
          throw new Error("setOptOutDailyPing requires exactly 1 argument");
        }
        external_exports.boolean().parse(message2.args[0]);
        this.messageQueue.push(message2);
      }
      queueOptOutErrorPing(optOut) {
        const message2 = { method: "setOptOutErrorPing", args: [optOut] };
        if (message2.args.length !== 1) {
          throw new Error("setOptOutErrorPing requires exactly 1 argument");
        }
        external_exports.boolean().parse(message2.args[0]);
        this.messageQueue.push(message2);
      }
      queueFontSize(size) {
        const message2 = { method: "setFontSize", args: [size] };
        if (message2.args.length !== 1) {
          throw new Error("setFontSize requires exactly 1 argument");
        }
        external_exports.enum(["small", "medium", "large"]).parse(message2.args[0]);
        this.messageQueue.push(message2);
      }
      queueHighContrast(enabled) {
        const message2 = { method: "setHighContrast", args: [enabled] };
        if (message2.args.length !== 1) {
          throw new Error("setHighContrast requires exactly 1 argument");
        }
        external_exports.boolean().parse(message2.args[0]);
        this.messageQueue.push(message2);
      }
      queueReducedMotion(enabled) {
        const message2 = { method: "setReducedMotion", args: [enabled] };
        if (message2.args.length !== 1) {
          throw new Error("setReducedMotion requires exactly 1 argument");
        }
        external_exports.boolean().parse(message2.args[0]);
        this.messageQueue.push(message2);
      }
      queueFocusIndicatorStyle(style) {
        const message2 = { method: "setFocusIndicatorStyle", args: [style] };
        if (message2.args.length !== 1) {
          throw new Error("setFocusIndicatorStyle requires exactly 1 argument");
        }
        external_exports.enum(["default", "enhanced"]).parse(message2.args[0]);
        this.messageQueue.push(message2);
      }
      queueAudioEnabled(enabled) {
        const message2 = { method: "setAudioEnabled", args: [enabled] };
        if (message2.args.length !== 1) {
          throw new Error("setAudioEnabled requires exactly 1 argument");
        }
        external_exports.boolean().parse(message2.args[0]);
        this.messageQueue.push(message2);
      }
      /**
       * Retrieve and clear all queued messages.
       *
       * Core polls this method to get pending settings updates.
       * Messages are removed from queue after retrieval.
       *
       * @returns Array of queued messages
       */
      getMessages() {
        const messages = [...this.messageQueue];
        this.messageQueue = [];
        return messages;
      }
    };
  }
});

// src/ts/core/navigationSchema.ts
function getDefaultNavigationState() {
  return {
    currentEntityId: 0,
    currentPage: 0,
    lastUpdated: 0
  };
}
function isValidEntityId(entityId, curriculum) {
  return entityId === 0 || curriculum.hasEntity(entityId);
}
function isValidPageNumber(entityId, page, curriculum) {
  const pageCount = curriculum.getEntityPageCount(entityId);
  return page >= 0 && page < pageCount;
}
function validateNavigationEntity(data, curriculum) {
  const entityId = data.currentEntityId;
  if (!isValidEntityId(entityId, curriculum)) {
    return {
      cleaned: getDefaultNavigationState(),
      wasDefaulted: true
    };
  }
  if (!isValidPageNumber(entityId, data.currentPage, curriculum)) {
    return {
      cleaned: getDefaultNavigationState(),
      wasDefaulted: true
    };
  }
  return {
    cleaned: data,
    wasDefaulted: false
  };
}
var NavigationStateSchema, NavigationStateManager, NavigationMessageSchema, NavigationMessageHandler, NavigationMessageQueueManager;
var init_navigationSchema = __esm({
  "src/ts/core/navigationSchema.ts"() {
    "use strict";
    init_zod();
    init_coreTypes();
    NavigationStateSchema = external_exports.object({
      currentEntityId: ImmutableId,
      // 0 = main menu by convention
      currentPage: external_exports.number().min(0),
      lastUpdated: external_exports.number().int().min(0)
      // Unix timestamp
    });
    NavigationStateManager = class {
      constructor(initialState, curriculumRegistry) {
        this.curriculumRegistry = curriculumRegistry;
        this.state = structuredClone(initialState);
      }
      /**
       * Returns cloned state for persistence.
       *
       * Clone ensures external code cannot mutate manager's internal state.
       * Validates before returning using private helper.
       *
       * @returns Cloned navigation state
       * @throws Error if current state is invalid (entity/page doesn't exist)
       */
      getState() {
        this.validateCurrentView();
        return structuredClone(this.state);
      }
      /**
       * Returns current view for startup after page load.
       *
       * Reverts to main menu if timestamp is older than 30 minutes.
       *
       * @returns Entity ID and page number for startup
       */
      getCurrentViewStartup() {
        const now = Math.floor(Date.now() / 1e3);
        const thirtyMinutesAgo = now - 30 * 60;
        if (this.state.lastUpdated < thirtyMinutesAgo) {
          return { entityId: 0, page: 0 };
        }
        this.validateCurrentView();
        return {
          entityId: this.state.currentEntityId,
          page: this.state.currentPage
        };
      }
      /**
       * Returns current view while running.
       *
       * Used by core to check if new page needs to be loaded.
       *
       * @returns Entity ID and page number
       */
      getCurrentViewRunning() {
        return {
          entityId: this.state.currentEntityId,
          page: this.state.currentPage
        };
      }
      /**
       * Set navigation to specific entity and page.
       *
       * The only setter available via messages from components.
       * Completely replaces current state with new timestamp.
       *
       * @param entityId - Entity ID to navigate to
       * @param page - Page number within entity
       */
      setCurrentView(entityId, page) {
        this.state.currentEntityId = entityId;
        this.state.currentPage = page;
        this.state.lastUpdated = Math.floor(Date.now() / 1e3);
      }
      /**
       * Reset navigation to main menu with current timestamp.
       */
      setDefaults() {
        this.state.currentEntityId = 0;
        this.state.currentPage = 0;
        this.state.lastUpdated = Math.floor(Date.now() / 1e3);
      }
      /**
       * Validate current navigation state.
       *
       * Uses shared validation helpers to ensure entity and page are valid.
       * Throws if validation fails (defensive runtime check).
       *
       * @throws Error if entity doesn't exist or page is out of bounds
       */
      validateCurrentView() {
        const { currentEntityId, currentPage } = this.state;
        if (!isValidEntityId(currentEntityId, this.curriculumRegistry)) {
          throw new Error(
            `Invalid navigation state: Entity ${currentEntityId} does not exist in registry`
          );
        }
        if (!isValidPageNumber(currentEntityId, currentPage, this.curriculumRegistry)) {
          const pageCount = this.curriculumRegistry.getEntityPageCount(currentEntityId);
          throw new Error(
            `Invalid navigation state: Page ${currentPage} exceeds entity ${currentEntityId} page count (${pageCount})`
          );
        }
      }
    };
    NavigationMessageSchema = external_exports.object({
      method: external_exports.literal("setCurrentView"),
      args: external_exports.tuple([ImmutableId, external_exports.number().min(0)])
    });
    NavigationMessageHandler = class {
      constructor(navigationManager, curriculumRegistry) {
        this.navigationManager = navigationManager;
        this.curriculumRegistry = curriculumRegistry;
      }
      /**
       * Validate a navigation message.
       *
       * Uses shared validation helpers to ensure entity and page are valid.
       *
       * @param message - Navigation message to validate
       * @throws Error if entity doesn't exist or page is out of bounds
       */
      validateMessage(message2) {
        const [entityId, page] = message2.args;
        if (!isValidEntityId(entityId, this.curriculumRegistry)) {
          throw new Error(`Invalid entity ID: ${entityId}`);
        }
        if (!isValidPageNumber(entityId, page, this.curriculumRegistry)) {
          const pageCount = this.curriculumRegistry.getEntityPageCount(entityId);
          throw new Error(
            `Invalid page ${page} for entity ${entityId} (max: ${pageCount - 1})`
          );
        }
      }
      /**
       * Validate and handle a navigation message.
       *
       * Validates message, then forwards to navigation manager if valid.
       *
       * @param message - Navigation message to handle
       * @throws Error if validation fails
       */
      handleMessage(message2) {
        this.validateMessage(message2);
        const [entityId, page] = message2.args;
        this.navigationManager.setCurrentView(entityId, page);
      }
    };
    NavigationMessageQueueManager = class {
      constructor(curriculumRegistry) {
        this.curriculumRegistry = curriculumRegistry;
        this.messageQueue = [];
      }
      /**
       * Queue a navigation message.
       *
       * Validates entity and page using shared helpers before queueing.
       *
       * @param entityId - Entity to navigate to
       * @param page - Page number within entity
       * @throws Error if entity doesn't exist or page is out of bounds
       */
      queueNavigationMessage(entityId, page) {
        const message2 = {
          method: "setCurrentView",
          args: [entityId, page]
        };
        if (!isValidEntityId(entityId, this.curriculumRegistry)) {
          throw new Error(`Invalid entity ID: ${entityId}`);
        }
        if (!isValidPageNumber(entityId, page, this.curriculumRegistry)) {
          throw new Error(`Invalid page ${page} for entity ${entityId}`);
        }
        this.messageQueue.push(message2);
      }
      /**
       * Retrieve and clear all queued messages.
       *
       * Core polls this method to get pending navigation updates.
       * Messages are removed from queue after retrieval.
       *
       * @returns Array of queued messages
       */
      getMessages() {
        const messages = [...this.messageQueue];
        this.messageQueue = [];
        return messages;
      }
    };
  }
});

// src/ts/core/combinedComponentProgressSchema.ts
var CombinedComponentProgressSchema;
var init_combinedComponentProgressSchema = __esm({
  "src/ts/core/combinedComponentProgressSchema.ts"() {
    "use strict";
    init_zod();
    CombinedComponentProgressSchema = external_exports.object({
      components: external_exports.record(external_exports.string(), external_exports.any())
      // componentId -> progress data
    });
  }
});

// src/ts/persistence/podStorageSchema.ts
var PodMetadataSchema, PodStorageBundleSchema;
var init_podStorageSchema = __esm({
  "src/ts/persistence/podStorageSchema.ts"() {
    "use strict";
    init_zod();
    init_overallProgressSchema();
    init_settingsSchema();
    init_navigationSchema();
    init_combinedComponentProgressSchema();
    PodMetadataSchema = external_exports.object({
      webId: external_exports.string().regex(/^https?:\/\/.+/, "Must be a valid WebID URL")
    });
    PodStorageBundleSchema = external_exports.object({
      overallProgress: OverallProgressDataSchema,
      settings: SettingsDataSchema,
      navigationState: NavigationStateSchema,
      combinedComponentProgress: CombinedComponentProgressSchema,
      metadata: PodMetadataSchema
    });
  }
});

// src/ts/components/cores/baseComponentCore.ts
var BaseComponentConfigSchema, BaseComponentProgressSchema, BaseComponentProgressManager, BaseComponentCore;
var init_baseComponentCore = __esm({
  "src/ts/components/cores/baseComponentCore.ts"() {
    "use strict";
    init_zod();
    init_overallProgressSchema();
    init_navigationSchema();
    init_settingsSchema();
    init_coreTypes();
    BaseComponentConfigSchema = external_exports.object({
      id: ImmutableId,
      // Immutable ID for progress tracking
      type: external_exports.string().min(1),
      // Component type: text, quiz, task, etc.
      accessibility_label: external_exports.string().min(2),
      // Screen reader description
      order: external_exports.number().int().min(-1e6).max(1e6)
      // Display order: 100, 200, 300, etc.
    });
    BaseComponentProgressSchema = external_exports.object({
      lastUpdated: external_exports.number().int().min(0)
      // NO .default() - explicit defaulting only
    });
    BaseComponentProgressManager = class {
      // Protected - child classes can mutate, external code cannot
      /**
       * Construct manager with config reference and cloned progress data.
       *
       * CLONING: Progress data is cloned to prevent external mutations from
       * corrupting the manager's internal state. Config is stored as readonly
       * reference since it's immutable.
       *
       * @param config - Component configuration (immutable, safe to share reference)
       * @param initialProgress - Progress data from Main Core (will be cloned)
       */
      constructor(config2, initialProgress) {
        this.config = config2;
        this.progress = structuredClone(initialProgress);
      }
      /**
       * Get current progress state (cloned).
       *
       * CLONING: Returns clone to prevent external code from mutating the
       * manager's internal state. Component Core and Interface receive a
       * snapshot they can read but cannot corrupt.
       *
       * @returns Cloned progress state
       */
      getProgress() {
        return structuredClone(this.progress);
      }
      /**
       * Update lastUpdated timestamp to current time.
       *
       * IMPORTANT: All mutation methods in subclasses MUST call this
       * after modifying progress state to maintain accurate timestamps
       * for conflict resolution.
       *
       * Protected helper - only accessible to subclass mutation methods.
       */
      updateTimestamp() {
        this.progress.lastUpdated = Math.floor(Date.now() / 1e3);
      }
    };
    BaseComponentCore = class {
      /**
       * Construct component core with readonly references to shared state.
       *
       * @param config Component configuration from YAML (readonly)
       * @param progressManager Validated progress mutations with cloning
       * @param timeline Container for component rendering
       * @param overallProgress Readonly lesson completion state
       * @param navigationState Readonly current page/lesson position
       * @param settings Readonly user preferences
       * @param curriculumRegistry Lesson/domain lookup for validation
       */
      constructor(config2, progressManager, timeline2, overallProgressManager, navigationManager, settingsManager, curriculumRegistry) {
        // Operations control - components can't produce messages until coordinator releases them
        this._operationsEnabled = false;
        this._config = config2;
        this._progressManager = progressManager;
        this._navigationQueueManager = new NavigationMessageQueueManager(
          curriculumRegistry
        );
        this._settingsQueueManager = new SettingsMessageQueueManager();
        this._overallProgressQueueManager = new OverallProgressMessageQueueManager(
          curriculumRegistry
        );
        this._interface = this.createInterface(timeline2);
      }
      /**
       * Retrieve component-specific progress messages.
       *
       * Main Core polls this during its update cycle.
       * Returns empty array until operations enabled by coordinator.
       * 
       * Gating is enforced at base level - subclasses cannot bypass it.
       *
       * @returns Array of component progress messages
       */
      getComponentProgressMessages() {
        if (!this._operationsEnabled) {
          return [];
        }
        return this.getComponentProgressMessagesInternal();
      }
      // ============================================================================
      // LIFECYCLE MANAGEMENT METHODS (called by Coordinator)
      // ============================================================================
      /**
       * Check if interface is ready to render.
       *
       * Called by coordinator to determine when component can be displayed.
       * Delegates to interface which tracks asset loading state.
       *
       * @returns true if interface ready (assets loaded or acceptable failure state)
       */
      isInterfaceReady() {
        return this._interface.isReady();
      }
      /**
       * Display interface and enable operations.
       *
       * Called by coordinator when all components ready.
       * Performs two actions:
       * 1. Renders component to DOM (creates timeline slot, displays content)
       * 2. Enables message production (allows getMessages() to return queued updates)
       *
       * After this method, component is fully active and can interact with user.
       */
      displayInterface() {
        this._interface.renderToDOM();
        this._operationsEnabled = true;
      }
      // ============================================================================
      // READONLY ACCESSORS
      // ============================================================================
      /**
       * Get component configuration (readonly)
       */
      get config() {
        return this._config;
      }
      /**
       * Get component interface instance (readonly)
       */
      get interface() {
        return this._interface;
      }
      // ============================================================================
      // MESSAGE QUEUE CONVENIENCE METHODS
      // ============================================================================
      /**
       * Convenience wrapper for queueing lesson completion message.
       *
       * Components call this when they trigger lesson completion
       * (e.g., final quiz question answered correctly).
       *
       * @param lessonId Immutable lesson ID
       */
      queueLessonComplete(lessonId) {
        this._overallProgressQueueManager.queueLessonComplete(lessonId);
      }
      /**
       * Convenience wrapper for queueing lesson incompletion message.
       *
       * Used when component state changes invalidate lesson completion
       * (e.g., quiz answer changed after lesson marked complete).
       *
       * @param lessonId Immutable lesson ID
       */
      queueLessonIncomplete(lessonId) {
        this._overallProgressQueueManager.queueLessonIncomplete(lessonId);
      }
      /**
       * Retrieve queued navigation messages.
       *
       * Main Core polls this during update cycle.
       */
      getNavigationMessages() {
        if (!this._operationsEnabled) {
          return [];
        }
        return this._navigationQueueManager.getMessages();
      }
      /**
       * Retrieve queued settings messages.
       *
       * Main Core polls this during update cycle.
       */
      getSettingsMessages() {
        if (!this._operationsEnabled) {
          return [];
        }
        return this._settingsQueueManager.getMessages();
      }
      /**
       * Retrieve queued overall progress messages.
       *
       * Main Core polls this during update cycle.
       */
      getOverallProgressMessages() {
        if (!this._operationsEnabled) {
          return [];
        }
        return this._overallProgressQueueManager.getMessages();
      }
    };
  }
});

// src/ts/components/interfaces/baseComponentInterface.ts
var BaseComponentInterface;
var init_baseComponentInterface = __esm({
  "src/ts/components/interfaces/baseComponentInterface.ts"() {
    "use strict";
    BaseComponentInterface = class {
      /**
       * Construct interface and start loading assets.
       * 
       * Asset loading begins immediately in background.
       * NO DOM WORK in constructor - rendering managed by coordinator.
       * 
       * Initial states:
       * - assetLoadingState: 'loading'
       * - lifecycleState: 'not_displayed'
       */
      constructor(componentCore, timelineContainer) {
        this.componentCore = componentCore;
        this.timelineContainer = timelineContainer;
        this.assetLoadingState = "loading";
        this.lifecycleState = "not_displayed";
        this.internal = this.createInternalState();
        this.loadComponentSpecificAssets().then(() => {
          if (this.assetLoadingState === "loading") {
            this.assetLoadingState = "ready";
          }
        }).catch((error46) => {
          console.error("Asset loading failed:", error46);
          if (this.assetLoadingState === "loading") {
            this.assetLoadingState = "complete_failure";
          }
        });
      }
      /**
       * Set asset loading state.
       * 
       * Protected - only subclasses can update state during asset loading.
       * Allows components to communicate loading status to coordinator.
       * 
       * @param state New asset loading state
       */
      setAssetLoadingState(state) {
        this.assetLoadingState = state;
      }
      /**
       * Check if interface is ready to render.
       * 
       * Called by coordinator to determine when component can be displayed.
       * Returns true for states where rendering makes sense:
       * - ready: All assets loaded successfully
       * - partial_failure: Some assets failed, but component can function in degraded mode
       * - slow_connection: Still loading but slow, can render with loading indicator
       * 
       * Returns false for:
       * - loading: Normal loading in progress
       * - complete_failure: Critical failure, component cannot function
       * 
       * @returns true if component can be rendered
       */
      isReady() {
        return this.assetLoadingState === "ready" || this.assetLoadingState === "partial_failure" || this.assetLoadingState === "slow_connection";
      }
      /**
       * Get current asset loading state.
       * 
       * Allows coordinator to make informed decisions:
       * - Show different loading UI for slow_connection
       * - Warn user about partial_failure components
       * - Skip complete_failure components
       * 
       * @returns Current asset loading state
       */
      getAssetLoadingState() {
        return this.assetLoadingState;
      }
      /**
       * Get progress information for assets being loaded.
       * 
       * Optional - components that support progress tracking override this.
       * Default implementation returns null (no progress info available).
       * 
       * Used by coordinator to show "10 MB of 50 MB" type progress.
       * 
       * @returns Progress info or null if not supported
       */
      getLoadingProgress() {
        return null;
      }
      /**
       * Render component to DOM.
       * 
       * Called by coordinator after isReady() returns true.
       * Creates timeline slot and delegates to concrete render() implementation.
       * Updates lifecycle state: not_displayed  displayed
       */
      renderToDOM() {
        this.timelineContainer.addComponentSlot(
          this.componentCore.config.id
        );
        this.render();
        this.lifecycleState = "displayed";
      }
    };
  }
});

// src/ts/components/interfaces/newUserWelcomeInterface.ts
var newUserWelcomeInterface_exports = {};
__export(newUserWelcomeInterface_exports, {
  NewUserWelcomeInterface: () => NewUserWelcomeInterface
});
var NewUserWelcomeInterface;
var init_newUserWelcomeInterface = __esm({
  "src/ts/components/interfaces/newUserWelcomeInterface.ts"() {
    "use strict";
    init_baseComponentInterface();
    NewUserWelcomeInterface = class extends BaseComponentInterface {
      constructor(core2, timeline2) {
        super(core2, timeline2);
      }
      /**
       * Create initial internal state
       */
      createInternalState() {
        return {
          rendered: false,
          currentScreen: "welcome",
          screenHistory: [],
          userChoices: {
            showAccessibility: false,
            accessibilityOptions: {
              fontSize: "medium",
              highContrast: false,
              reducedMotion: false,
              focusIndicatorStyle: "default",
              audioEnabled: false
            },
            optOutTelemetry: false,
            learningPace: "standard",
            weekStartDay: "monday",
            weekStartTime: "00:00"
          }
        };
      }
      /**
       * Load component-specific assets
       * No external assets needed for this component
       */
      async loadComponentSpecificAssets() {
        return Promise.resolve();
      }
      /**
       * Cleanup method - remove event listeners
       */
      destroy() {
      }
      /**
       * Main render method - delegates to screen-specific renderers
       */
      render() {
        const slot = this.timelineContainer.getComponentArea(this.componentCore.config.id);
        if (!slot) {
          console.error(`Slot not found for component ${this.componentCore.config.id}`);
          return;
        }
        let screenHtml = "";
        switch (this.internal.currentScreen) {
          case "welcome":
            screenHtml = this.renderWelcomeScreen();
            break;
          case "accessibility-gateway":
            screenHtml = this.renderAccessibilityGatewayScreen();
            break;
          case "accessibility-options":
            screenHtml = this.renderAccessibilityOptionsScreen();
            break;
          case "telemetry":
            screenHtml = this.renderTelemetryScreen();
            break;
          case "learning-pace":
            screenHtml = this.renderLearningPaceScreen();
            break;
          case "week-start":
            screenHtml = this.renderWeekStartScreen();
            break;
          case "complete":
            screenHtml = this.renderCompleteScreen();
            break;
        }
        slot.innerHTML = screenHtml;
        this.attachEventListeners();
      }
      // ==========================================================================
      // SCREEN RENDERERS
      // ==========================================================================
      renderWelcomeScreen() {
        return `
      <div class="max-w-2xl mx-auto text-center space-y-6">
        <h2 class="text-3xl font-bold text-gray-900 dark:text-white">
          Welcome to Mera! \u{1F331}
        </h2>
        <p class="text-lg text-gray-700 dark:text-gray-300">
          Let's take a moment to set up your learning experience. 
          This will only take a minute.
        </p>
        <div class="pt-4">
          <button 
            id="btn-start"
            class="bg-green-600 hover:bg-green-700 text-white px-8 py-4 rounded-lg font-bold text-lg transition-colors">
            Let's Get Started
          </button>
        </div>
      </div>
    `;
      }
      renderAccessibilityGatewayScreen() {
        return `
      <div class="max-w-2xl mx-auto space-y-6">
        <h2 class="text-2xl font-bold text-gray-900 dark:text-white text-center">
          Accessibility Options
        </h2>
        <p class="text-lg text-gray-700 dark:text-gray-300 text-center">
          Mera is for everyone. Would you like to customize accessibility settings?
        </p>
        <p class="text-sm text-gray-600 dark:text-gray-400 text-center">
          If an option you need is missing, please let us know.
        </p>
        <div class="flex flex-col gap-4 pt-4">
          <div class="flex justify-between items-center">
            <button 
              id="btn-back"
              class="text-gray-600 dark:text-gray-400 hover:text-gray-900 dark:hover:text-white font-semibold">
              \u2190 Back
            </button>
          </div>
          <div class="flex flex-col sm:flex-row gap-4 justify-center">
            <button 
              id="btn-show-accessibility"
              class="bg-green-600 hover:bg-green-700 text-white px-6 py-3 rounded-lg font-semibold transition-colors">
              Yes, Show Options
            </button>
            <button 
              id="btn-skip-accessibility"
              class="bg-gray-600 hover:bg-gray-700 text-white px-6 py-3 rounded-lg font-semibold transition-colors">
              No Thanks, Use Defaults
            </button>
          </div>
        </div>
      </div>
    `;
      }
      renderAccessibilityOptionsScreen() {
        const opts = this.internal.userChoices.accessibilityOptions;
        return `
      <div class="max-w-2xl mx-auto space-y-6">
        <h2 class="text-2xl font-bold text-gray-900 dark:text-white">
          Customize Accessibility
        </h2>
        <p class="text-gray-700 dark:text-gray-300">
          Select the options that work best for you. Changes apply immediately.
        </p>
        
        <div class="space-y-4">
          <!-- Font Size -->
          <div class="bg-white dark:bg-gray-700 p-4 rounded-lg">
            <label class="block text-sm font-semibold text-gray-900 dark:text-white mb-2">
              Font Size
            </label>
            <select 
              id="select-font-size"
              class="w-full px-4 py-2 bg-white dark:bg-gray-800 border border-gray-300 dark:border-gray-600 rounded text-gray-900 dark:text-white">
              <option value="small" ${opts.fontSize === "small" ? "selected" : ""}>Small</option>
              <option value="medium" ${opts.fontSize === "medium" ? "selected" : ""}>Medium (Default)</option>
              <option value="large" ${opts.fontSize === "large" ? "selected" : ""}>Large</option>
            </select>
          </div>

          <!-- High Contrast -->
          <div class="bg-white dark:bg-gray-700 p-4 rounded-lg">
            <label class="flex items-center space-x-3">
              <input 
                type="checkbox" 
                id="check-high-contrast"
                ${opts.highContrast ? "checked" : ""}
                class="w-5 h-5 text-green-600 border-gray-300 rounded focus:ring-green-500">
              <span class="text-sm font-semibold text-gray-900 dark:text-white">
                High Contrast Mode
              </span>
            </label>
          </div>

          <!-- Reduced Motion -->
          <div class="bg-white dark:bg-gray-700 p-4 rounded-lg">
            <label class="flex items-center space-x-3">
              <input 
                type="checkbox" 
                id="check-reduced-motion"
                ${opts.reducedMotion ? "checked" : ""}
                class="w-5 h-5 text-green-600 border-gray-300 rounded focus:ring-green-500">
              <span class="text-sm font-semibold text-gray-900 dark:text-white">
                Reduce Motion & Animations
              </span>
            </label>
          </div>

          <!-- Focus Style -->
          <div class="bg-white dark:bg-gray-700 p-4 rounded-lg">
            <label class="block text-sm font-semibold text-gray-900 dark:text-white mb-2">
              Focus Indicator Style
            </label>
            <select 
              id="select-focus-style"
              class="w-full px-4 py-2 bg-white dark:bg-gray-800 border border-gray-300 dark:border-gray-600 rounded text-gray-900 dark:text-white">
              <option value="default" ${opts.focusIndicatorStyle === "default" ? "selected" : ""}>Default</option>
              <option value="enhanced" ${opts.focusIndicatorStyle === "enhanced" ? "selected" : ""}>Enhanced (More Visible)</option>
            </select>
          </div>

          <!-- Audio -->
          <div class="bg-white dark:bg-gray-700 p-4 rounded-lg">
            <label class="flex items-center space-x-3">
              <input 
                type="checkbox" 
                id="check-audio-enabled"
                ${opts.audioEnabled ? "checked" : ""}
                class="w-5 h-5 text-green-600 border-gray-300 rounded focus:ring-green-500">
              <span class="text-sm font-semibold text-gray-900 dark:text-white">
                Enable Audio Descriptions
              </span>
            </label>
          </div>
        </div>

        <div class="flex justify-between items-center pt-4">
          <button 
            id="btn-back"
            class="text-gray-600 dark:text-gray-400 hover:text-gray-900 dark:hover:text-white font-semibold">
            \u2190 Back
          </button>
          <button 
            id="btn-continue-accessibility"
            class="bg-green-600 hover:bg-green-700 text-white px-6 py-3 rounded-lg font-semibold transition-colors">
            Continue
          </button>
        </div>
      </div>
    `;
      }
      renderTelemetryScreen() {
        return `
      <div class="max-w-2xl mx-auto space-y-6">
        <h2 class="text-2xl font-bold text-gray-900 dark:text-white">
          Privacy & Telemetry
        </h2>
        <div class="bg-blue-50 dark:bg-blue-900/20 border border-blue-200 dark:border-blue-800 rounded-lg p-4 space-y-3">
          <p class="text-gray-700 dark:text-gray-300">
            We believe in <strong>privacy</strong>. We only collect simple anonymous counters:
          </p>
          <ul class="list-disc list-inside text-gray-700 dark:text-gray-300 space-y-1 ml-4">
            <li>Number of active users (daily ping)</li>
            <li>Major error reports (to fix bugs)</li>
          </ul>
          <p class="text-gray-700 dark:text-gray-300">
            These reveal <strong>nothing</strong> about your identity, location, or activity.
          </p>
        </div>
        
        <div class="bg-amber-50 dark:bg-amber-900/20 border border-amber-200 dark:border-amber-800 rounded-lg p-4">
          <p class="text-sm text-gray-700 dark:text-gray-300">
            <strong>Note:</strong> We keep 48 hours of IP address logs to protect against 
            denial-of-service attacks. Use a VPN if you want to hide your IP address.
          </p>
        </div>

        <div class="flex flex-col gap-4 pt-4">
          <button 
            id="btn-back"
            class="text-gray-600 dark:text-gray-400 hover:text-gray-900 dark:hover:text-white font-semibold text-left">
            \u2190 Back
          </button>
          <div class="flex flex-col sm:flex-row gap-4 justify-center">
            <button 
              id="btn-telemetry-accept"
              class="bg-green-600 hover:bg-green-700 text-white px-6 py-3 rounded-lg font-semibold transition-colors">
              That's Fine
            </button>
            <button 
              id="btn-telemetry-optout"
              class="bg-gray-600 hover:bg-gray-700 text-white px-6 py-3 rounded-lg font-semibold transition-colors">
              Opt Out
            </button>
          </div>
        </div>
      </div>
    `;
      }
      renderLearningPaceScreen() {
        return `
      <div class="max-w-2xl mx-auto space-y-6">
        <h2 class="text-2xl font-bold text-gray-900 dark:text-white">
          Your Learning Pace
        </h2>
        <p class="text-lg text-gray-700 dark:text-gray-300">
          Mera gently encourages you to stick with making digital security improvements 
          by tracking weekly goals. Lessons are typically 10 minutes long.
        </p>
        <p class="text-gray-700 dark:text-gray-300">
          How many lessons would you like to complete per week?
        </p>
        
        <div class="space-y-3">
          <button 
            id="btn-pace-accelerated"
            class="w-full bg-white dark:bg-gray-700 border-2 border-gray-300 dark:border-gray-600 hover:border-green-600 dark:hover:border-green-500 p-4 rounded-lg text-left transition-colors">
            <div class="font-bold text-gray-900 dark:text-white text-lg">Accelerated (2 lessons)</div>
            <div class="text-gray-600 dark:text-gray-400 text-sm">For those who want to move quickly</div>
          </button>
          
          <button 
            id="btn-pace-standard"
            class="w-full bg-white dark:bg-gray-700 border-2 border-gray-300 dark:border-gray-600 hover:border-green-600 dark:hover:border-green-500 p-4 rounded-lg text-left transition-colors">
            <div class="font-bold text-gray-900 dark:text-white text-lg">Standard (1 lesson) \u2B50 Recommended</div>
            <div class="text-gray-600 dark:text-gray-400 text-sm">Steady progress without feeling rushed</div>
          </button>
          
          <button 
            id="btn-pace-flexible"
            class="w-full bg-white dark:bg-gray-700 border-2 border-gray-300 dark:border-gray-600 hover:border-green-600 dark:hover:border-green-500 p-4 rounded-lg text-left transition-colors">
            <div class="font-bold text-gray-900 dark:text-white text-lg">Flexible (Learn at your own pace)</div>
            <div class="text-gray-600 dark:text-gray-400 text-sm">No weekly goals, just track your progress</div>
          </button>
        </div>

        <div class="pt-4">
          <button 
            id="btn-back"
            class="text-gray-600 dark:text-gray-400 hover:text-gray-900 dark:hover:text-white font-semibold">
            \u2190 Back
          </button>
        </div>
      </div>
    `;
      }
      renderWeekStartScreen() {
        const day2 = this.internal.userChoices.weekStartDay;
        const time3 = this.internal.userChoices.weekStartTime;
        return `
      <div class="max-w-2xl mx-auto space-y-6">
        <h2 class="text-2xl font-bold text-gray-900 dark:text-white">
          When Does Your Week Start?
        </h2>
        <p class="text-gray-700 dark:text-gray-300">
          Weekly goals reset at the start of your week. Choose when that should be:
        </p>
        
        <div class="space-y-4">
          <div class="bg-white dark:bg-gray-700 p-4 rounded-lg">
            <label class="block text-sm font-semibold text-gray-900 dark:text-white mb-2">
              Day of Week
            </label>
            <select 
              id="select-week-day"
              class="w-full px-4 py-2 bg-white dark:bg-gray-800 border border-gray-300 dark:border-gray-600 rounded text-gray-900 dark:text-white">
              <option value="monday" ${day2 === "monday" ? "selected" : ""}>Monday</option>
              <option value="tuesday" ${day2 === "tuesday" ? "selected" : ""}>Tuesday</option>
              <option value="wednesday" ${day2 === "wednesday" ? "selected" : ""}>Wednesday</option>
              <option value="thursday" ${day2 === "thursday" ? "selected" : ""}>Thursday</option>
              <option value="friday" ${day2 === "friday" ? "selected" : ""}>Friday</option>
              <option value="saturday" ${day2 === "saturday" ? "selected" : ""}>Saturday</option>
              <option value="sunday" ${day2 === "sunday" ? "selected" : ""}>Sunday</option>
            </select>
          </div>

          <div class="bg-white dark:bg-gray-700 p-4 rounded-lg">
            <label class="block text-sm font-semibold text-gray-900 dark:text-white mb-2">
              Time of Day (Your Local Time)
            </label>
            <input 
              type="time"
              id="input-week-time"
              value="${time3}"
              class="w-full px-4 py-2 bg-white dark:bg-gray-800 border border-gray-300 dark:border-gray-600 rounded text-gray-900 dark:text-white">
          </div>
        </div>

        <div class="flex justify-between items-center pt-4">
          <button 
            id="btn-back"
            class="text-gray-600 dark:text-gray-400 hover:text-gray-900 dark:hover:text-white font-semibold">
            \u2190 Back
          </button>
          <button 
            id="btn-save-week-start"
            class="bg-green-600 hover:bg-green-700 text-white px-6 py-3 rounded-lg font-semibold transition-colors">
            Continue
          </button>
        </div>
      </div>
    `;
      }
      renderCompleteScreen() {
        return `
      <div class="max-w-2xl mx-auto text-center space-y-6">
        <div class="text-6xl">\u2705</div>
        <h2 class="text-3xl font-bold text-gray-900 dark:text-white">
          You're All Set!
        </h2>
        <p class="text-lg text-gray-700 dark:text-gray-300">
          Your settings have been saved. Let's begin your journey to better digital security.
        </p>
        <div class="pt-4">
          <button 
            id="btn-finish"
            class="bg-green-600 hover:bg-green-700 text-white px-8 py-4 rounded-lg font-bold text-lg transition-colors">
            Start Learning
          </button>
        </div>
      </div>
    `;
      }
      // ==========================================================================
      // EVENT HANDLERS
      // ==========================================================================
      attachEventListeners() {
        console.log(`\u{1F517} Attaching event listeners for screen: ${this.internal.currentScreen}`);
        document.getElementById("btn-back")?.addEventListener("click", () => {
          this.goBack();
        });
        document.getElementById("btn-start")?.addEventListener("click", () => {
          this.advanceToScreen("accessibility-gateway");
        });
        document.getElementById("btn-show-accessibility")?.addEventListener("click", () => {
          this.internal.userChoices.showAccessibility = true;
          this.advanceToScreen("accessibility-options");
        });
        document.getElementById("btn-skip-accessibility")?.addEventListener("click", () => {
          this.internal.userChoices.showAccessibility = false;
          this.queueAccessibilitySettings();
          this.advanceToScreen("telemetry");
        });
        this.attachAccessibilityListeners();
        document.getElementById("btn-continue-accessibility")?.addEventListener("click", () => {
          this.advanceToScreen("telemetry");
        });
        document.getElementById("btn-telemetry-accept")?.addEventListener("click", () => {
          this.internal.userChoices.optOutTelemetry = false;
          this.queueTelemetrySettings();
          this.advanceToScreen("learning-pace");
        });
        document.getElementById("btn-telemetry-optout")?.addEventListener("click", () => {
          this.internal.userChoices.optOutTelemetry = true;
          this.queueTelemetrySettings();
          this.advanceToScreen("learning-pace");
        });
        document.getElementById("btn-pace-accelerated")?.addEventListener("click", () => {
          this.internal.userChoices.learningPace = "accelerated";
          this.componentCore.queueSettingsMessage({
            method: "setLearningPace",
            args: ["accelerated"]
          });
          this.advanceToScreen("week-start");
        });
        document.getElementById("btn-pace-standard")?.addEventListener("click", () => {
          this.internal.userChoices.learningPace = "standard";
          this.componentCore.queueSettingsMessage({
            method: "setLearningPace",
            args: ["standard"]
          });
          this.advanceToScreen("week-start");
        });
        document.getElementById("btn-pace-flexible")?.addEventListener("click", () => {
          this.internal.userChoices.learningPace = "flexible";
          this.componentCore.queueSettingsMessage({
            method: "setLearningPace",
            args: ["flexible"]
          });
          this.advanceToScreen("complete");
        });
        document.getElementById("btn-save-week-start")?.addEventListener("click", () => {
          this.captureAndQueueWeekStartChoices();
          this.advanceToScreen("complete");
        });
        document.getElementById("btn-finish")?.addEventListener("click", () => {
          console.log("\u2705 Finish button clicked - queuing theme and navigation");
          this.componentCore.queueSettingsMessage({
            method: "setTheme",
            args: ["auto"]
          });
          this.componentCore.queueNavigationToMainMenu();
        });
      }
      /**
       * Attach listeners for accessibility options that apply changes immediately
       */
      attachAccessibilityListeners() {
        const fontSizeSelect = document.getElementById("select-font-size");
        fontSizeSelect?.addEventListener("change", () => {
          const fontSize = fontSizeSelect.value;
          this.internal.userChoices.accessibilityOptions.fontSize = fontSize;
          this.componentCore.queueSettingsMessage({
            method: "setFontSize",
            args: [fontSize]
          });
          this.applyFontSize(fontSize);
        });
        const highContrastCheck = document.getElementById("check-high-contrast");
        highContrastCheck?.addEventListener("change", () => {
          const highContrast = highContrastCheck.checked;
          this.internal.userChoices.accessibilityOptions.highContrast = highContrast;
          this.componentCore.queueSettingsMessage({
            method: "setHighContrast",
            args: [highContrast]
          });
          this.applyHighContrast(highContrast);
        });
        const reducedMotionCheck = document.getElementById("check-reduced-motion");
        reducedMotionCheck?.addEventListener("change", () => {
          const reducedMotion = reducedMotionCheck.checked;
          this.internal.userChoices.accessibilityOptions.reducedMotion = reducedMotion;
          this.componentCore.queueSettingsMessage({
            method: "setReducedMotion",
            args: [reducedMotion]
          });
          this.applyReducedMotion(reducedMotion);
        });
        const focusStyleSelect = document.getElementById("select-focus-style");
        focusStyleSelect?.addEventListener("change", () => {
          const focusStyle = focusStyleSelect.value;
          this.internal.userChoices.accessibilityOptions.focusIndicatorStyle = focusStyle;
          this.componentCore.queueSettingsMessage({
            method: "setFocusIndicatorStyle",
            args: [focusStyle]
          });
          this.applyFocusStyle(focusStyle);
        });
        const audioEnabledCheck = document.getElementById("check-audio-enabled");
        audioEnabledCheck?.addEventListener("change", () => {
          const audioEnabled = audioEnabledCheck.checked;
          this.internal.userChoices.accessibilityOptions.audioEnabled = audioEnabled;
          this.componentCore.queueSettingsMessage({
            method: "setAudioEnabled",
            args: [audioEnabled]
          });
        });
      }
      // ==========================================================================
      // HELPER METHODS
      // ==========================================================================
      advanceToScreen(screen) {
        this.internal.screenHistory.push(this.internal.currentScreen);
        this.internal.currentScreen = screen;
        this.render();
      }
      goBack() {
        const previousScreen = this.internal.screenHistory.pop();
        if (previousScreen) {
          this.internal.currentScreen = previousScreen;
          this.render();
        }
      }
      /**
       * Queue all accessibility settings (used when skipping accessibility options)
       */
      queueAccessibilitySettings() {
        const opts = this.internal.userChoices.accessibilityOptions;
        this.componentCore.queueSettingsMessage({
          method: "setFontSize",
          args: [opts.fontSize]
        });
        this.componentCore.queueSettingsMessage({
          method: "setHighContrast",
          args: [opts.highContrast]
        });
        this.componentCore.queueSettingsMessage({
          method: "setReducedMotion",
          args: [opts.reducedMotion]
        });
        this.componentCore.queueSettingsMessage({
          method: "setFocusIndicatorStyle",
          args: [opts.focusIndicatorStyle]
        });
        this.componentCore.queueSettingsMessage({
          method: "setAudioEnabled",
          args: [opts.audioEnabled]
        });
      }
      /**
       * Queue telemetry settings
       */
      queueTelemetrySettings() {
        this.componentCore.queueSettingsMessage({
          method: "setOptOutDailyPing",
          args: [this.internal.userChoices.optOutTelemetry]
        });
        this.componentCore.queueSettingsMessage({
          method: "setOptOutErrorPing",
          args: [this.internal.userChoices.optOutTelemetry]
        });
      }
      /**
       * Capture week start choices from DOM and queue immediately
       */
      captureAndQueueWeekStartChoices() {
        const day2 = document.getElementById("select-week-day")?.value || "monday";
        const time3 = document.getElementById("input-week-time")?.value || "00:00";
        this.internal.userChoices.weekStartDay = day2;
        this.internal.userChoices.weekStartTime = time3;
        this.componentCore.queueSettingsMessage({
          method: "setWeekStartDay",
          args: [day2]
        });
        const utcTime = this.convertLocalTimeToUTC(time3);
        this.componentCore.queueSettingsMessage({
          method: "setWeekStartTimeUTC",
          args: [utcTime]
        });
      }
      /**
       * Convert local time to UTC for storage
       * 
       * @param localTime - Time in HH:MM format (local timezone)
       * @returns Time in HH:MM format (UTC timezone)
       */
      convertLocalTimeToUTC(localTime) {
        const [hours, minutes] = localTime.split(":").map(Number);
        const localDate = /* @__PURE__ */ new Date();
        localDate.setHours(hours, minutes, 0, 0);
        const utcHours = localDate.getUTCHours();
        const utcMinutes = localDate.getUTCMinutes();
        const utcTime = `${String(utcHours).padStart(2, "0")}:${String(utcMinutes).padStart(2, "0")}`;
        return utcTime;
      }
      // ==========================================================================
      // DYNAMIC ACCESSIBILITY APPLICATION
      // ==========================================================================
      /**
       * Apply font size changes to the document root
       */
      applyFontSize(size) {
        const root = document.documentElement;
        root.classList.remove("font-size-small", "font-size-medium", "font-size-large");
        root.classList.add(`font-size-${size}`);
        console.log(`\u2728 Applied font size: ${size}`);
      }
      /**
       * Apply high contrast changes to the document root
       */
      applyHighContrast(enabled) {
        const root = document.documentElement;
        if (enabled) {
          root.classList.add("high-contrast");
        } else {
          root.classList.remove("high-contrast");
        }
        console.log(`\u2728 Applied high contrast: ${enabled}`);
      }
      /**
       * Apply reduced motion changes to the document root
       */
      applyReducedMotion(enabled) {
        const root = document.documentElement;
        if (enabled) {
          root.classList.add("reduce-motion");
        } else {
          root.classList.remove("reduce-motion");
        }
        console.log(`\u2728 Applied reduced motion: ${enabled}`);
      }
      /**
       * Apply focus indicator style changes to the document root
       */
      applyFocusStyle(style) {
        const root = document.documentElement;
        root.classList.remove("focus-default", "focus-enhanced");
        root.classList.add(`focus-${style}`);
        console.log(`\u2728 Applied focus style: ${style}`);
      }
    };
  }
});

// src/ts/components/cores/newUserWelcomeCore.ts
function createInitialProgress(config2) {
  const tempManager = new NewUserWelcomeProgressManager(
    config2,
    { lastUpdated: 0 }
  );
  return tempManager.createInitialProgress(config2);
}
var NewUserWelcomeComponentConfigSchema, NewUserWelcomeComponentProgressSchema, NewUserWelcomeProgressManager, NewUserWelcomeSettingsMessageQueueManager, NewUserWelcomeNavigationMessageQueueManager, NewUserWelcomeCore;
var init_newUserWelcomeCore = __esm({
  "src/ts/components/cores/newUserWelcomeCore.ts"() {
    "use strict";
    init_zod();
    init_baseComponentCore();
    NewUserWelcomeComponentConfigSchema = external_exports.object({
      type: external_exports.literal("new_user_welcome"),
      id: external_exports.number(),
      accessibility_label: external_exports.string(),
      order: external_exports.number()
    });
    NewUserWelcomeComponentProgressSchema = external_exports.object({
      lastUpdated: external_exports.number()
    });
    NewUserWelcomeProgressManager = class extends BaseComponentProgressManager {
      /**
       * Create initial progress structure
       * 
       * Just the base lastUpdated field set to 0
       */
      createInitialProgress(config2) {
        return {
          lastUpdated: 0
        };
      }
    };
    NewUserWelcomeSettingsMessageQueueManager = class {
      constructor() {
        this.queue = [];
      }
      /**
       * Queue a settings message
       */
      queueMessage(message2) {
        console.log(`\u{1F4E4} NewUserWelcome queuing settings message:`, message2.method);
        this.queue.push(message2);
      }
      /**
       * Get all queued messages and clear the queue
       */
      getMessages() {
        const messages = [...this.queue];
        this.queue = [];
        return messages;
      }
    };
    NewUserWelcomeNavigationMessageQueueManager = class {
      constructor() {
        this.queue = [];
      }
      /**
       * Queue navigation to main menu
       */
      queueNavigationToMainMenu() {
        console.log(`\u{1F4E4} NewUserWelcome queuing navigation to main menu`);
        this.queue.push({
          method: "setCurrentView",
          args: [0, 0]
          // Entity 0 (main menu), page 0
        });
      }
      /**
       * Get all queued messages and clear the queue
       */
      getMessages() {
        const messages = [...this.queue];
        this.queue = [];
        return messages;
      }
    };
    NewUserWelcomeCore = class extends BaseComponentCore {
      constructor(config2, progressManager, timeline2, overallProgressManager, navigationManager, settingsManager, curriculumRegistry) {
        super(
          config2,
          progressManager,
          timeline2,
          overallProgressManager,
          navigationManager,
          settingsManager,
          curriculumRegistry
        );
        this.settingsMessageQueue = new NewUserWelcomeSettingsMessageQueueManager();
        this.navigationMessageQueue = new NewUserWelcomeNavigationMessageQueueManager();
      }
      /**
       * Create the interface for this core
       */
      createInterface(timeline2) {
        const { NewUserWelcomeInterface: NewUserWelcomeInterface2 } = (init_newUserWelcomeInterface(), __toCommonJS(newUserWelcomeInterface_exports));
        return new NewUserWelcomeInterface2(this, timeline2);
      }
      /**
       * Check if component is complete
       * 
       * Always returns true - completion determined by navigation away
       */
      isComplete() {
        return true;
      }
      /**
       * Get component-specific progress messages (internal)
       * 
       * Always returns empty array - no progress to track
       */
      getComponentProgressMessagesInternal() {
        return [];
      }
      /**
       * Get queued settings messages
       */
      getSettingsMessages() {
        if (!this._operationsEnabled) {
          return [];
        }
        return this.settingsMessageQueue.getMessages();
      }
      /**
       * Get queued navigation messages
       */
      getNavigationMessages() {
        if (!this._operationsEnabled) {
          return [];
        }
        return this.navigationMessageQueue.getMessages();
      }
      /**
       * Public interface for component to queue settings message
       */
      queueSettingsMessage(message2) {
        this.settingsMessageQueue.queueMessage(message2);
      }
      /**
       * Public interface for component to queue navigation to main menu
       */
      queueNavigationToMainMenu() {
        this.navigationMessageQueue.queueNavigationToMainMenu();
      }
    };
  }
});

// src/ts/ui/meraStyles.ts
var MeraStyles;
var init_meraStyles = __esm({
  "src/ts/ui/meraStyles.ts"() {
    "use strict";
    MeraStyles = {
      // ==========================================================================
      // TYPOGRAPHY
      // ==========================================================================
      typography: {
        /** Page title (e.g., "Mera") - 3xl, bold, centered */
        heading1: "text-3xl font-bold text-gray-900 dark:text-amber-50 mb-6 text-center",
        /** Section headers (e.g., "Learning Streak") - xl, semibold */
        heading2: "text-xl font-semibold text-gray-900 dark:text-amber-50 mb-3",
        /** Subsection headers (e.g., domain titles) - xl, bold */
        heading3: "text-xl font-bold",
        /** Item titles (e.g., lesson titles) - medium weight */
        heading4: "font-medium",
        /** Primary body text */
        body: "text-gray-800 dark:text-amber-100",
        /** Secondary/smaller body text */
        bodySmall: "text-sm text-gray-800 dark:text-amber-100",
        /** Emphasized text color only (no size) */
        textPrimary: "text-gray-900 dark:text-amber-50",
        /** Large display numbers (e.g., streak count) */
        displayLarge: "text-5xl font-bold text-green-600 dark:text-green-500",
        /** Medium display text (e.g., emojis, section icons) */
        displayMedium: "text-2xl",
        /** Icon/indicator size text */
        iconText: "text-lg"
      },
      // ==========================================================================
      // CONTAINERS & CARDS
      // ==========================================================================
      containers: {
        /** Full page wrapper */
        pageWrapper: "min-h-screen bg-mera-light dark:bg-mera-dark p-4",
        /** Main content container with responsive max-width */
        contentContainer: "max-w-4xl lg:max-w-6xl mx-auto space-y-6",
        /** Primary card (rounded corners, shadow, padding) */
        card: "bg-amber-100 dark:bg-amber-900/30 rounded-xl shadow-lg p-8",
        /** Secondary card (less padding, medium shadow) */
        cardMedium: "bg-amber-100 dark:bg-amber-900/30 rounded-lg shadow-md p-6",
        /** Compact card (for nested content) */
        cardCompact: "bg-amber-100 dark:bg-amber-900/30 rounded-lg shadow-md overflow-hidden",
        /** Message box (lighter, less prominent) */
        messageBox: "bg-amber-50 dark:bg-amber-900/20 rounded-lg p-4"
      },
      // ==========================================================================
      // STATUS & FEEDBACK
      // ==========================================================================
      status: {
        /** Success message container */
        successBox: "bg-green-50 dark:bg-green-900/20 rounded-lg p-4",
        /** Success text (primary) - for headings */
        successText: "font-medium text-green-900 dark:text-green-200",
        /** Success text (secondary) - for body text */
        successTextSecondary: "text-sm text-green-700 dark:text-green-300",
        /** Success accent (checkmarks, highlights) */
        successAccent: "text-green-600 dark:text-green-500",
        /** Info/encouragement box (uses amber) */
        infoBox: "bg-amber-50 dark:bg-amber-900/20 rounded-lg p-4"
      },
      // ==========================================================================
      // INTERACTIVE ELEMENTS
      // ==========================================================================
      interactive: {
        /** Primary action button (green, prominent) */
        buttonPrimary: "px-4 py-2 bg-green-600 dark:bg-green-500 text-white rounded hover:opacity-90 transition-opacity",
        /** Large clickable area (domain/section toggle) */
        buttonLarge: "w-full p-6 text-left hover:bg-amber-200 dark:hover:bg-amber-900/50 transition-colors text-gray-900 dark:text-amber-50",
        /** Medium clickable area (lesson toggle) */
        buttonMedium: "flex-1 p-4 text-left flex items-center gap-3 text-gray-900 dark:text-amber-50",
        /** Standard hover state wrapper */
        hoverWrapper: "hover:bg-amber-200 dark:hover:bg-amber-900/50 transition-colors"
      },
      // ==========================================================================
      // PROGRESS & VISUAL ELEMENTS
      // ==========================================================================
      progress: {
        /** Progress bar container (background track) */
        barContainer: "w-full bg-gray-200 dark:bg-gray-700 rounded-full h-3",
        /** Progress bar fill (animated green) */
        barFill: "bg-green-600 dark:bg-green-500 h-3 rounded-full transition-all duration-300"
      },
      // ==========================================================================
      // BORDERS & DIVIDERS
      // ==========================================================================
      borders: {
        /** Standard border color */
        default: "border-gray-200 dark:border-gray-700",
        /** Top border with padding */
        topSection: "border-t border-gray-200 dark:border-gray-700 pt-6",
        /** Bottom border on all children except last */
        bottomExceptLast: "border-b last:border-b-0 dark:border-gray-700"
      },
      // ==========================================================================
      // LAYOUT & SPACING
      // ==========================================================================
      layout: {
        /** Vertical spacing between major sections */
        spaceYLarge: "space-y-6",
        /** Vertical spacing between subsections */
        spaceYMedium: "space-y-4",
        /** Horizontal gap in flex/grid */
        gapSmall: "gap-3",
        /** Flex with items centered vertically */
        flexCenter: "flex items-center",
        /** Flex with space-between */
        flexBetween: "flex justify-between",
        /** Flex items centered, space between */
        flexCenterBetween: "flex items-center justify-between",
        /** Inline flex with baseline alignment */
        inlineFlexBaseline: "inline-flex items-baseline",
        /** Text alignment */
        textCenter: "text-center"
      },
      // ==========================================================================
      // SPECIFIC PATTERNS (commonly repeated combinations)
      // ==========================================================================
      patterns: {
        /** Icon + text message layout */
        messageLayout: "flex items-center",
        /** Accordion arrow (expands/collapses) */
        expandArrow: "text-2xl",
        /** Domain/section emoji */
        sectionEmoji: "text-2xl",
        /** Status icon (lesson completion) */
        statusIcon: "text-lg",
        /** Margin spacing after icons */
        iconMarginRight: "mr-3",
        /** Margin spacing on left side */
        marginLeftMedium: "ml-4",
        /** Bottom margin variations */
        marginBottom: {
          xlarge: "mb-6",
          large: "mb-4",
          medium: "mb-3",
          small: "mb-2",
          xsmall: "mb-1"
        },
        /** Top margin */
        marginTop: {
          small: "mt-1",
          medium: "mt-2"
        },
        /** Padding variations */
        padding: {
          medium: "px-4 pb-4",
          leftLarge: "pl-16"
        }
      }
    };
  }
});

// src/ts/components/interfaces/mainMenuInterface.ts
var MainMenuInterface;
var init_mainMenuInterface = __esm({
  "src/ts/components/interfaces/mainMenuInterface.ts"() {
    "use strict";
    init_baseComponentInterface();
    init_meraStyles();
    MainMenuInterface = class extends BaseComponentInterface {
      constructor(componentCore, timelineContainer) {
        super(componentCore, timelineContainer);
        this.componentCore = componentCore;
      }
      createInternalState() {
        return {
          rendered: false,
          expandedDomainId: null,
          expandedLessonId: null
        };
      }
      async loadComponentSpecificAssets() {
        this.setAssetLoadingState("ready");
      }
      /**
       * Render main menu: streak card + domain accordions
       */
      render() {
        this.componentCore.checkAndQueueStreakUpdates();
        const area = this.timelineContainer.getComponentArea(
          this.componentCore.config.id
        );
        if (area) {
          area.innerHTML = `
        <div class="${MeraStyles.containers.pageWrapper}">
          <div class="${MeraStyles.containers.contentContainer}">
            ${this.renderStreakCard()}
            ${this.renderDomainAccordions()}
          </div>
        </div>
      `;
          this.attachEventListeners();
          this.internal.rendered = true;
        }
      }
      /**
       * Clean up DOM and event listeners.
       */
      destroy() {
        this.internal.rendered = false;
      }
      // ============================================================================
      // RENDERING METHODS
      // ============================================================================
      /**
       * Render the streak tracking card.
       * 
       * Displays:
       * - Current streak count (completed weeks)
       * - Current week progress (X/Y lessons this week)
       * - Encouragement message if behind on weekly goal
       */
      renderStreakCard() {
        const progress = this.componentCore.overallProgressManager.getProgress();
        const currentStreak = progress.currentStreak;
        const settingsManager = this.componentCore.settingsManager;
        const weekStart = settingsManager.getLastWeekStart();
        const now = Math.floor(Date.now() / 1e3);
        const weekEnd = weekStart + 7 * 24 * 60 * 60;
        const lessonsThisWeek = this.componentCore.countLessonsSince(weekStart);
        const weeklyGoal = this.getWeeklyGoal();
        const settings = this.componentCore.settingsManager.getSettings();
        const pace = settings.learningPace[0];
        if (pace === "flexible") {
          return this.renderFlexibleStreakCard(currentStreak, lessonsThisWeek);
        }
        const remaining = Math.max(0, weeklyGoal - lessonsThisWeek);
        const goalMet = lessonsThisWeek >= weeklyGoal;
        const secondsRemaining = weekEnd - now;
        const daysRemaining = Math.ceil(secondsRemaining / (24 * 60 * 60));
        return `
      <div class="${MeraStyles.containers.card}">
        <!-- Header -->
        <h1 class="${MeraStyles.typography.heading1}">
          Mera
        </h1>

        <!-- Streak Display -->
        <div class="${MeraStyles.patterns.marginBottom.xlarge}">
          <h2 class="${MeraStyles.typography.heading2}">
            Learning Streak
          </h2>
          <div class="${MeraStyles.layout.textCenter} ${MeraStyles.patterns.marginBottom.large}">
            <div class="${MeraStyles.layout.inlineFlexBaseline}">
              <span class="${MeraStyles.typography.displayLarge}">${currentStreak}</span>
              <span class="${MeraStyles.typography.displayMedium} ml-2">\u{1F525}</span>
            </div>
            <div class="${MeraStyles.typography.body} ${MeraStyles.patterns.marginTop.small}">
              week${currentStreak === 1 ? "" : "s"} streak
            </div>
          </div>
        </div>

        <!-- Current Week Progress -->
        <div class="${MeraStyles.borders.topSection}">
          <div class="${MeraStyles.patterns.marginBottom.large}">
            <div class="${MeraStyles.layout.flexBetween} ${MeraStyles.typography.bodySmall} ${MeraStyles.patterns.marginBottom.small}">
              <span>This week's progress</span>
              <span class="font-medium">${lessonsThisWeek} / ${weeklyGoal} lessons</span>
            </div>
            <!-- Progress bar -->
            <div class="${MeraStyles.progress.barContainer}">
              <div 
                class="${MeraStyles.progress.barFill}"
                style="width: ${Math.min(100, lessonsThisWeek / weeklyGoal * 100)}%"
              ></div>
            </div>
          </div>

          <!-- Status message -->
          ${this.renderWeeklyStatusMessage(goalMet, remaining, daysRemaining)}
        </div>
      </div>
    `;
      }
      /**
       * Render status message based on weekly progress.
       */
      renderWeeklyStatusMessage(goalMet, remaining, daysRemaining) {
        if (goalMet) {
          return `
        <div class="${MeraStyles.status.successBox}">
          <div class="${MeraStyles.patterns.messageLayout}">
            <span class="${MeraStyles.typography.displayMedium} ${MeraStyles.patterns.iconMarginRight}">\u2705</span>
            <div>
              <p class="${MeraStyles.status.successText}">Goal complete!</p>
              <p class="${MeraStyles.status.successTextSecondary}">You've hit your weekly target.</p>
            </div>
          </div>
        </div>
      `;
        }
        const lessonWord = remaining === 1 ? "lesson" : "lessons";
        const dayWord = daysRemaining === 1 ? "day" : "days";
        return `
      <div class="${MeraStyles.status.infoBox}">
        <div class="${MeraStyles.patterns.messageLayout}">
          <span class="${MeraStyles.typography.displayMedium} ${MeraStyles.patterns.iconMarginRight}">\u{1F4DA}</span>
          <div>
            <p class="${MeraStyles.status.successText} ${MeraStyles.typography.textPrimary}">Keep it up!</p>
            <p class="${MeraStyles.typography.bodySmall}">
              Complete <strong>${remaining}</strong> more ${lessonWord} 
              in the next ${daysRemaining} ${dayWord} to maintain your streak.
            </p>
          </div>
        </div>
      </div>
    `;
      }
      /**
       * Render streak card for flexible pace (no weekly goals).
       */
      renderFlexibleStreakCard(currentStreak, lessonsThisWeek) {
        return `
      <div class="${MeraStyles.containers.card}">
        <!-- Header -->
        <h1 class="${MeraStyles.typography.heading1}">
          Mera
        </h1>

        <!-- Flexible Pace Message -->
        <div class="${MeraStyles.patterns.marginBottom.xlarge} ${MeraStyles.layout.textCenter}">
          <h2 class="${MeraStyles.typography.heading2}">
            Learning at Your Own Pace
          </h2>
          <div class="${MeraStyles.typography.body}">
            <p class="${MeraStyles.patterns.marginBottom.small}">
              You've completed <strong class="${MeraStyles.typography.textPrimary}">${lessonsThisWeek}</strong> 
              ${lessonsThisWeek === 1 ? "lesson" : "lessons"} this week.
            </p>
            <p class="${MeraStyles.typography.bodySmall}">No weekly goals - learn whenever works for you!</p>
          </div>
        </div>
      </div>
    `;
      }
      // ============================================================================
      // DOMAIN ACCORDIONS (Phase 4)
      // ============================================================================
      renderDomainAccordions() {
        const domains = this.componentCore.getAllDomains();
        const domainCards = domains.map((domain2) => {
          const isExpanded = this.internal.expandedDomainId === domain2.id;
          return `
        <div class="${MeraStyles.containers.cardCompact}">
          ${this.renderDomainHeader(domain2, isExpanded)}
          ${isExpanded ? this.renderDomainContent(domain2) : ""}
        </div>
      `;
        }).join("");
        return `<div class="${MeraStyles.layout.spaceYMedium}">${domainCards}</div>`;
      }
      renderDomainHeader(domain2, isExpanded) {
        return `
      <button
        class="${MeraStyles.interactive.buttonLarge}"
        data-domain-toggle="${domain2.id}"
      >
        <div class="${MeraStyles.layout.flexCenterBetween}">
          <div class="${MeraStyles.layout.flexCenter} ${MeraStyles.layout.gapSmall} flex-1">
            <span class="${MeraStyles.patterns.expandArrow}">${isExpanded ? "\u25BC" : "\u25B6"}</span>
            <span class="${MeraStyles.patterns.sectionEmoji}">${domain2.emoji}</span>
            <div class="flex-1">
              <h3 class="${MeraStyles.typography.heading3}">${domain2.title}</h3>
              <p class="${MeraStyles.typography.bodySmall}">
                ${domain2.completed} / ${domain2.total} lessons \u2022 ${domain2.percentage}%
              </p>
            </div>
          </div>
          ${domain2.completed === domain2.total && domain2.total > 0 ? `
            <span class="${MeraStyles.status.successAccent} ${MeraStyles.typography.displayMedium} ${MeraStyles.patterns.marginLeftMedium}">\u2713</span>
          ` : ""}
        </div>
      </button>
    `;
      }
      renderDomainContent(domain2) {
        const lessons = this.componentCore.getLessonsInDomain(domain2.id);
        const lessonItems = lessons.map((lesson) => {
          const isExpanded = this.internal.expandedLessonId === lesson.id;
          return `
        <div class="${MeraStyles.borders.bottomExceptLast}">
          ${this.renderLessonHeader(lesson, isExpanded)}
          ${isExpanded ? this.renderLessonContent(lesson) : ""}
        </div>
      `;
        }).join("");
        return `
      <div>
        ${lessonItems}
      </div>
    `;
      }
      renderLessonHeader(lesson, isExpanded) {
        const statusIcon = this.getLessonStatusIcon(lesson.status);
        return `
      <div class="${MeraStyles.layout.flexCenter} ${MeraStyles.interactive.hoverWrapper}">
        <button
          class="${MeraStyles.interactive.buttonMedium}"
          data-lesson-toggle="${lesson.id}"
        >
          <span class="${MeraStyles.patterns.statusIcon}">${isExpanded ? "\u25BC" : "\u25B6"}</span>
          <span class="${MeraStyles.patterns.statusIcon}">${statusIcon}</span>
          <div class="flex-1">
            <h4 class="${MeraStyles.typography.heading4}">${lesson.title}</h4>
            <p class="${MeraStyles.typography.bodySmall}">
              ${lesson.estimatedMinutes} min \u2022 ${lesson.difficulty}
            </p>
          </div>
        </button>
      </div>
    `;
      }
      renderLessonContent(lesson) {
        return `
      <div class="${MeraStyles.patterns.padding.medium} ${MeraStyles.patterns.padding.leftLarge}">
        <p class="${MeraStyles.typography.body} ${MeraStyles.patterns.marginBottom.large}">
          ${lesson.description || "No description available."}
        </p>
        <button
          class="${MeraStyles.interactive.buttonPrimary}"
          data-lesson-navigate="${lesson.id}"
        >
          ${lesson.status === "completed" ? "Review Lesson" : lesson.status === "started" ? "Continue Lesson" : "Start Lesson"} \u2192
        </button>
      </div>
    `;
      }
      getLessonStatusIcon(status) {
        switch (status) {
          case "completed":
            return `<span class="${MeraStyles.status.successAccent}">\u2713</span>`;
          case "started":
            return '<span class="text-amber-600 dark:text-amber-500">\u25CF</span>';
          case "not-started":
            return '<span class="text-gray-400 dark:text-amber-200">\u25CB</span>';
        }
      }
      // ============================================================================
      // EVENT HANDLERS (Phase 4)
      // ============================================================================
      attachEventListeners() {
        const area = this.timelineContainer.getComponentArea(
          this.componentCore.config.id
        );
        if (!area) return;
        area.querySelectorAll("[data-domain-toggle]").forEach((button) => {
          button.addEventListener("click", (e) => {
            const domainId = parseInt(e.currentTarget.dataset.domainToggle);
            this.toggleDomain(domainId);
          });
        });
        area.querySelectorAll("[data-lesson-toggle]").forEach((button) => {
          button.addEventListener("click", (e) => {
            const lessonId = parseInt(e.currentTarget.dataset.lessonToggle);
            this.toggleLesson(lessonId);
          });
        });
        area.querySelectorAll("[data-lesson-navigate]").forEach((button) => {
          button.addEventListener("click", (e) => {
            const lessonId = parseInt(e.currentTarget.dataset.lessonNavigate);
            this.navigateToLesson(lessonId);
          });
        });
      }
      toggleDomain(domainId) {
        if (this.internal.expandedDomainId === domainId) {
          this.internal.expandedDomainId = null;
          this.internal.expandedLessonId = null;
        } else {
          this.internal.expandedDomainId = domainId;
          this.internal.expandedLessonId = null;
        }
        this.render();
      }
      toggleLesson(lessonId) {
        if (this.internal.expandedLessonId === lessonId) {
          this.internal.expandedLessonId = null;
        } else {
          this.internal.expandedLessonId = lessonId;
        }
        this.render();
      }
      navigateToLesson(lessonId) {
        this.componentCore.queueNavigation(lessonId, 0);
      }
      // ============================================================================
      // HELPER METHODS
      // ============================================================================
      /**
       * Get weekly goal based on current learning pace setting.
       */
      getWeeklyGoal() {
        const settings = this.componentCore.settingsManager.getSettings();
        const pace = settings.learningPace[0];
        const goalMap = {
          accelerated: 6,
          // 6 lessons/week
          standard: 3,
          // 3 lessons/week (recommended)
          flexible: 0
          // No weekly goal
        };
        return goalMap[pace];
      }
    };
  }
});

// src/ts/components/cores/mainMenuCore.ts
function createInitialProgress2(config2) {
  const tempManager = new MainMenuProgressManager(
    config2,
    { lastUpdated: 0 }
  );
  return tempManager.createInitialProgress(config2);
}
var MainMenuComponentConfigSchema, MainMenuComponentProgressSchema, MainMenuProgressManager, MainMenuCore;
var init_mainMenuCore = __esm({
  "src/ts/components/cores/mainMenuCore.ts"() {
    "use strict";
    init_zod();
    init_baseComponentCore();
    init_mainMenuInterface();
    init_overallProgressSchema();
    init_navigationSchema();
    init_mera_registry();
    MainMenuComponentConfigSchema = BaseComponentConfigSchema.extend({
      type: external_exports.literal("main_menu")
    });
    MainMenuComponentProgressSchema = BaseComponentProgressSchema.extend({
      // No additional fields needed
    });
    MainMenuProgressManager = class extends BaseComponentProgressManager {
      /**
       * Create initial progress for new users.
       * Main menu has no progress fields, just timestamp.
       */
      createInitialProgress(config2) {
        return {
          lastUpdated: 0
        };
      }
    };
    MainMenuCore = class extends BaseComponentCore {
      constructor(config2, progressManager, timeline2, overallProgressManager, navigationManager, settingsManager, curriculumRegistry) {
        super(
          config2,
          progressManager,
          timeline2,
          overallProgressManager,
          navigationManager,
          settingsManager,
          curriculumRegistry
        );
        this._overallProgressManager = overallProgressManager;
        this._navigationManager = navigationManager;
        this._settingsManager = settingsManager;
        this._curriculumRegistry = curriculumRegistry;
        this.overallProgressMessageQueue = new OverallProgressMessageQueueManager(curriculumRegistry);
        this.navigationMessageQueue = new NavigationMessageQueueManager(curriculumRegistry);
      }
      /**
       * Create the interface for this core
       */
      createInterface(timeline2) {
        return new MainMenuInterface(this, timeline2);
      }
      /**
       * Check if component is complete
       * Main menu is always "complete"
       */
      isComplete() {
        return true;
      }
      /**
       * Get component-specific progress messages (internal)
       * Main menu has no component-specific progress
       */
      getComponentProgressMessagesInternal() {
        return [];
      }
      // ============================================================================
      // PUBLIC GETTERS FOR INTERFACE
      // ============================================================================
      /**
       * Get readonly overall progress manager for interface queries.
       */
      get overallProgressManager() {
        return this._overallProgressManager;
      }
      /**
       * Get readonly settings manager for interface queries.
       */
      get settingsManager() {
        return this._settingsManager;
      }
      /**
       * Get readonly navigation manager for interface queries.
       */
      get navigationManager() {
        return this._navigationManager;
      }
      /**
       * Get curriculum registry for domain/lesson queries.
       */
      get curriculumRegistry() {
        return this._curriculumRegistry;
      }
      // ============================================================================
      // MESSAGE POLLING
      // ============================================================================
      /**
       * Get queued navigation messages for Main Core to process.
       */
      getNavigationMessages() {
        if (!this._operationsEnabled) return [];
        return this.navigationMessageQueue.getMessages();
      }
      /**
       * Get queued overall progress messages for Main Core to process.
       */
      getOverallProgressMessages() {
        if (!this._operationsEnabled) return [];
        return this.overallProgressMessageQueue.getMessages();
      }
      // ============================================================================
      // PUBLIC INTERFACE METHODS
      // ============================================================================
      /**
       * Check for complete weeks since last streak check and queue appropriate messages.
       * 
       * Called by interface on render. Processes all complete weeks sequentially,
       * queuing increment for weeks with goal met, reset for weeks with goal missed.
       * 
       * For flexible pace (no weekly goal), this is a no-op.
       */
      checkAndQueueStreakUpdates() {
        if (!this._operationsEnabled) return;
        const settings = this._settingsManager.getSettings();
        const pace = settings.learningPace[0];
        if (pace === "flexible") return;
        const progress = this._overallProgressManager.getProgress();
        const lastCheck = progress.lastStreakCheck;
        const now = Math.floor(Date.now() / 1e3);
        const weeklyGoal = this.getWeeklyGoal();
        const completeWeeks = this.getCompleteWeeksSince(lastCheck, now);
        for (const week2 of completeWeeks) {
          const lessonsInWeek = this.countLessonsInWeek(week2.start, week2.end);
          if (lessonsInWeek >= weeklyGoal) {
            this.overallProgressMessageQueue.queueIncrementStreak();
          } else {
            this.overallProgressMessageQueue.queueResetStreak();
          }
        }
      }
      /**
       * Queue navigation to a specific lesson.
       */
      queueNavigation(entityId, page = 0) {
        if (!this._operationsEnabled) return;
        this.navigationMessageQueue.queueNavigationMessage(entityId, page);
      }
      /**
       * Queue lesson reset (Phase 7 - stub for now).
       */
      queueResetLesson(lessonId) {
        throw new Error("Lesson reset not yet implemented");
      }
      // ============================================================================
      // PRIVATE HELPER METHODS
      // ============================================================================
      /**
       * Get weekly goal based on learning pace setting.
       */
      getWeeklyGoal() {
        const settings = this._settingsManager.getSettings();
        const pace = settings.learningPace[0];
        const goalMap = {
          accelerated: 6,
          // 6 lessons/week
          standard: 3,
          // 3 lessons/week (recommended)
          flexible: 0
          // No weekly goal
        };
        return goalMap[pace];
      }
      /**
       * Get all complete week boundaries between two timestamps.
       * Uses user's configured week start day/time from settings.
       */
      getCompleteWeeksSince(since, until) {
        const weeks = [];
        let weekStart = this.getNextWeekStartAfter(since);
        while (true) {
          const weekEnd = weekStart + 7 * 24 * 60 * 60;
          if (weekEnd > until) break;
          weeks.push({ start: weekStart, end: weekEnd });
          weekStart = weekEnd;
        }
        return weeks;
      }
      /**
       * Get the first week start timestamp after a given time.
       * Uses SettingsDataManager.getLastWeekStart() which handles week config.
       */
      getNextWeekStartAfter(after) {
        const settingsManager = this._settingsManager;
        const lastWeekStart = settingsManager.getLastWeekStart();
        if (lastWeekStart > after) {
          return lastWeekStart;
        }
        let weekStart = lastWeekStart;
        const weekSeconds = 7 * 24 * 60 * 60;
        while (weekStart <= after) {
          weekStart += weekSeconds;
        }
        return weekStart;
      }
      /**
       * Count lessons first completed within a time range.
       * Uses timeCompleted timestamp to ensure lessons only counted once.
       */
      countLessonsInWeek(startTime, endTime) {
        const progress = this._overallProgressManager.getProgress();
        let count = 0;
        for (const completion of Object.values(progress.lessonCompletions)) {
          const timeCompleted = completion.timeCompleted;
          if (timeCompleted !== null && timeCompleted >= startTime && timeCompleted < endTime) {
            count++;
          }
        }
        return count;
      }
      // ============================================================================
      // DOMAIN & LESSON METHODS (Phase 4)
      // ============================================================================
      /**
       * Get all domains with calculated progress
       */
      getAllDomains() {
        const domainIds = this._curriculumRegistry.getAllDomainIds();
        return domainIds.map((domainId) => {
          const metadata = domainData.find((d) => d.id === domainId);
          const progress = this._overallProgressManager.getDomainProgress(domainId);
          return {
            id: domainId,
            title: metadata?.title || `Domain ${domainId}`,
            description: metadata?.description || "",
            emoji: "\u{1F4DA}",
            // Not in domain YAML yet, using default
            color: "#84e67b",
            // Not in domain YAML yet, using default green
            completed: progress.completed,
            total: progress.total,
            percentage: progress.total > 0 ? Math.round(progress.completed / progress.total * 100) : 0
          };
        });
      }
      /**
       * Get all lessons in a domain with status
       */
      getLessonsInDomain(domainId) {
        const lessonIds = this._curriculumRegistry.getLessonsInDomain(domainId);
        if (!lessonIds) return [];
        return lessonIds.map((lessonId) => {
          const metadata = lessonMetadata.find((l) => l.id === lessonId);
          const status = this.getLessonStatus(lessonId);
          return {
            id: lessonId,
            title: metadata?.title || `Lesson ${lessonId}`,
            description: "",
            // TODO: Add description field to lesson YAML files
            difficulty: metadata?.difficulty || "beginner",
            estimatedMinutes: metadata?.estimatedMinutes || 10,
            status
          };
        });
      }
      /**
       * Determine lesson status: not-started, started, or completed
       */
      getLessonStatus(lessonId) {
        const progress = this._overallProgressManager.getProgress();
        const completion = progress.lessonCompletions[lessonId.toString()];
        if (!completion) return "not-started";
        if (completion.timeCompleted !== null) return "completed";
        if (completion.lastUpdated > 0) return "started";
        return "not-started";
      }
      /**
       * Count lessons first completed since a timestamp (for current week display).
       * Public method for interface to call.
       */
      countLessonsSince(since) {
        const progress = this._overallProgressManager.getProgress();
        let count = 0;
        for (const completion of Object.values(progress.lessonCompletions)) {
          const timeCompleted = completion.timeCompleted;
          if (timeCompleted !== null && timeCompleted >= since) {
            count++;
          }
        }
        return count;
      }
    };
  }
});

// src/ts/components/cores/basicTaskCore.ts
function isValidCheckboxIndex(index, config2) {
  return index >= 0 && index < config2.checkboxes.length;
}
function isValidProgressStructure(progress, config2) {
  return progress.checkbox_checked.length === config2.checkboxes.length;
}
function validateBasicTaskStructure(progress, config2) {
  if (!isValidProgressStructure(progress, config2)) {
    return {
      cleaned: {
        checkbox_checked: new Array(config2.checkboxes.length).fill(false),
        lastUpdated: 0
        // Explicit timestamp 0 = never set
      },
      defaultedRatio: 1
    };
  }
  return {
    cleaned: progress,
    defaultedRatio: 0
  };
}
function createInitialProgress3(config2) {
  return {
    lastUpdated: 0,
    checkbox_checked: new Array(config2.checkboxes.length).fill(false)
  };
}
var CheckboxItemSchema, BasicTaskComponentConfigSchema, BasicTaskComponentProgressSchema, BasicTaskProgressManager, BasicTaskMessageQueueManager, BasicTaskCore, BasicTaskProgressMessageHandler;
var init_basicTaskCore = __esm({
  "src/ts/components/cores/basicTaskCore.ts"() {
    "use strict";
    init_zod();
    init_baseComponentCore();
    CheckboxItemSchema = external_exports.object({
      content: external_exports.string().min(1).max(1e3),
      required: external_exports.boolean().default(false)
    });
    BasicTaskComponentConfigSchema = BaseComponentConfigSchema.extend({
      type: external_exports.literal("basic_task"),
      title: external_exports.string().min(1).max(200),
      description: external_exports.string().min(1).max(1e3),
      checkboxes: external_exports.array(CheckboxItemSchema).min(1).max(20)
    });
    BasicTaskComponentProgressSchema = BaseComponentProgressSchema.extend({
      checkbox_checked: external_exports.array(external_exports.boolean())
      // NO .default() - explicit defaulting only
    });
    BasicTaskProgressManager = class extends BaseComponentProgressManager {
      /**
       * Set individual checkbox state with validation
       *
       * Uses shared validation helpers to ensure index is valid and
       * progress structure matches config. Calls updateTimestamp() after mutation.
       *
       * @param index - Checkbox index to update
       * @param checked - New checked state
       * @throws Error if index out of bounds or structure mismatch
       */
      setCheckboxState(index, checked) {
        if (!isValidProgressStructure(this.progress, this.config)) {
          throw new Error(
            `Progress has ${this.progress.checkbox_checked.length} checkboxes, config expects ${this.config.checkboxes.length}`
          );
        }
        if (!isValidCheckboxIndex(index, this.config)) {
          throw new Error(`Checkbox index ${index} out of range`);
        }
        this.progress.checkbox_checked[index] = checked;
        this.updateTimestamp();
      }
      /**
       * Create initial progress structure matching config requirements.
       *
       * Called for new users or when component is first encountered.
       * Creates array of false values matching checkbox count.
       *
       * IMPORTANT: Explicitly sets lastUpdated to 0 (timestamp 0 = never set by user).
       *
       * @param config Component configuration with checkbox definitions
       * @returns Fresh progress object with all checkboxes unchecked
       */
      createInitialProgress(config2) {
        return {
          checkbox_checked: new Array(config2.checkboxes.length).fill(false),
          lastUpdated: 0
          // Explicit timestamp 0 = never set by user
        };
      }
    };
    BasicTaskMessageQueueManager = class {
      constructor(componentId) {
        this.componentId = componentId;
        this.messageQueue = [];
      }
      /**
       * Queue checkbox state change message
       *
       * @param index Checkbox index
       * @param checked New checked state
       */
      queueCheckboxState(index, checked) {
        this.messageQueue.push({
          type: "component_progress",
          componentId: this.componentId,
          method: "setCheckboxState",
          args: [index, checked]
        });
      }
      /**
       * Retrieve and clear all queued messages.
       *
       * Core polls this method to get pending updates.
       * Messages are removed from queue after retrieval.
       *
       * @returns Array of queued messages
       */
      getMessages() {
        const messages = [...this.messageQueue];
        this.messageQueue = [];
        return messages;
      }
    };
    BasicTaskCore = class extends BaseComponentCore {
      constructor(config2, progressManager, timeline2, overallProgressManager, navigationManager, settingsManager, curriculumRegistry) {
        super(
          config2,
          progressManager,
          timeline2,
          overallProgressManager,
          navigationManager,
          settingsManager,
          curriculumRegistry
        );
        this._componentProgressQueueManager = new BasicTaskMessageQueueManager(
          config2.id
        );
      }
      /**
       * Create the interface for this core
       */
      createInterface(timeline2) {
        throw new Error("BasicTaskInterface not yet implemented");
      }
      /**
       * Set checkbox state and queue message to main core
       */
      setCheckboxState(index, checked) {
        this._progressManager.setCheckboxState(
          index,
          checked
        );
        this._componentProgressQueueManager.queueCheckboxState(index, checked);
      }
      /**
       * Check if task is complete
       *
       * Task is complete when all required checkboxes are checked.
       * Optional checkboxes don't affect completion status.
       */
      isComplete() {
        const progress = this._progressManager.getProgress();
        for (let i = 0; i < this._config.checkboxes.length; i++) {
          const checkbox = this._config.checkboxes[i];
          if (checkbox.required) {
            if (i >= progress.checkbox_checked.length || !progress.checkbox_checked[i]) {
              return false;
            }
          }
        }
        return true;
      }
      /**
       * Get component progress messages for core polling
       */
      getComponentProgressMessagesInternal() {
        return this._componentProgressQueueManager.getMessages();
      }
    };
    BasicTaskProgressMessageHandler = class {
      constructor(componentManagers) {
        this.componentManagers = componentManagers;
      }
      getComponentType() {
        return "basic_task";
      }
      handleMessage(message2) {
        const manager = this.componentManagers.get(
          message2.componentId
        );
        if (!manager) {
          throw new Error(`No manager found for component ${message2.componentId}`);
        }
        switch (message2.method) {
          case "setCheckboxState":
            manager.setCheckboxState(
              message2.args[0],
              message2.args[1]
            );
            break;
          default:
            throw new Error(
              `BasicTask components only support: setCheckboxState. Got: ${message2.method}`
            );
        }
      }
    };
  }
});

// src/ts/registry/mera-registry.ts
var progressSchemaMap, componentValidatorMap, componentInitializerMap, componentRegistrations, allLessonIds, allComponentIds, lessonMetrics, componentIdToTypeMap, componentToLessonMap, domainLessonMap, curriculumDataRaw, CurriculumRegistry, curriculumData, domainData, lessonMetadata;
var init_mera_registry = __esm({
  "src/ts/registry/mera-registry.ts"() {
    "use strict";
    init_newUserWelcomeCore();
    init_mainMenuCore();
    init_basicTaskCore();
    progressSchemaMap = /* @__PURE__ */ new Map([
      ["new_user_welcome", NewUserWelcomeComponentProgressSchema],
      ["main_menu", MainMenuComponentProgressSchema],
      ["basic_task", BasicTaskComponentProgressSchema]
    ]);
    componentValidatorMap = /* @__PURE__ */ new Map([
      ["basic_task", validateBasicTaskStructure]
    ]);
    componentInitializerMap = /* @__PURE__ */ new Map([
      ["new_user_welcome", createInitialProgress],
      ["main_menu", createInitialProgress2],
      ["basic_task", createInitialProgress3]
    ]);
    componentRegistrations = [
      {
        componentClass: NewUserWelcomeProgressManager,
        configSchema: NewUserWelcomeComponentConfigSchema,
        progressSchema: NewUserWelcomeComponentProgressSchema,
        typeName: "new_user_welcome"
      },
      {
        componentClass: MainMenuProgressManager,
        configSchema: MainMenuComponentConfigSchema,
        progressSchema: MainMenuComponentProgressSchema,
        typeName: "main_menu"
      },
      {
        componentClass: BasicTaskProgressManager,
        configSchema: BasicTaskComponentConfigSchema,
        progressSchema: BasicTaskComponentProgressSchema,
        typeName: "basic_task"
      }
    ];
    allLessonIds = [0, 1, 12345, 12346, 12347, 12348];
    allComponentIds = [123456, 123457, 223456, 223457, 323456, 323457, 423456, 423457, 1e6, 1000001];
    lessonMetrics = /* @__PURE__ */ new Map([
      [12348, { pageCount: 2, componentCount: 2, title: "Phishing Recognition Basics", difficulty: "beginner" }],
      [0, { pageCount: 1, componentCount: 1, title: "Main Menu", difficulty: "beginner" }],
      [12345, { pageCount: 2, componentCount: 2, title: "Phishing Recognition Basics", difficulty: "beginner" }],
      [1, { pageCount: 1, componentCount: 1, title: "Welcome to Mera", difficulty: "beginner" }],
      [12346, { pageCount: 2, componentCount: 2, title: "Phishing Recognition Basics", difficulty: "beginner" }],
      [12347, { pageCount: 2, componentCount: 2, title: "Phishing Recognition Basics", difficulty: "beginner" }]
    ]);
    componentIdToTypeMap = /* @__PURE__ */ new Map([
      [123456, "basic_task"],
      [123457, "basic_task"],
      [223456, "basic_task"],
      [223457, "basic_task"],
      [323456, "basic_task"],
      [323457, "basic_task"],
      [423456, "basic_task"],
      [423457, "basic_task"],
      [1e6, "main_menu"],
      [1000001, "new_user_welcome"]
    ]);
    componentToLessonMap = /* @__PURE__ */ new Map([
      [123456, 12345],
      [123457, 12345],
      [223456, 12346],
      [223457, 12346],
      [323456, 12347],
      [323457, 12347],
      [423456, 12348],
      [423457, 12348],
      [1e6, 0],
      [1000001, 1]
    ]);
    domainLessonMap = /* @__PURE__ */ new Map([
      [1003, [12347]],
      [1002, [12346]],
      [1001, [12345]],
      [1004, [12348]]
    ]);
    curriculumDataRaw = null;
    CurriculumRegistry = class {
      constructor(curriculum, lessonIds, domainMap, componentIdToType, componentToLesson) {
        this.curriculum = curriculum;
        this.lessonIds = lessonIds;
        this.domainMap = domainMap;
        this.componentIdToType = componentIdToType;
        this.componentToLesson = componentToLesson;
      }
      hasEntity(entityId) {
        return this.lessonIds.has(entityId);
      }
      hasLesson(lessonId) {
        const metadata = lessonMetadata.find((l) => l.id === lessonId);
        return metadata?.entityType === "lesson" || false;
      }
      hasMenu(menuId) {
        const metadata = lessonMetadata.find((l) => l.id === menuId);
        return metadata?.entityType === "menu" || false;
      }
      hasDomain(domainId) {
        return this.domainMap.has(domainId);
      }
      getEntityPageCount(entityId) {
        const metrics = lessonMetrics.get(entityId);
        if (!metrics) {
          throw new Error(
            `Entity ${entityId} not found in registry. Cannot determine page count.`
          );
        }
        return metrics.pageCount;
      }
      hasComponent(componentId) {
        return this.componentIdToType.has(componentId);
      }
      getComponentType(componentId) {
        return this.componentIdToType.get(componentId);
      }
      getAllComponentIds() {
        return Array.from(this.componentIdToType.keys());
      }
      getAllLessonIds() {
        return Array.from(this.lessonIds);
      }
      getAllDomainIds() {
        return Array.from(this.domainMap.keys());
      }
      getLessonsInDomain(domainId) {
        return this.domainMap.get(domainId);
      }
      getLessonIdForComponent(componentId) {
        return this.componentToLesson.get(componentId);
      }
    };
    curriculumData = new CurriculumRegistry(
      curriculumDataRaw,
      new Set(allLessonIds),
      domainLessonMap,
      componentIdToTypeMap,
      componentToLessonMap
    );
    domainData = [
      {
        "id": 1003,
        "title": "Communicate Securely",
        "description": "Protect your conversations from surveillance and interception",
        "pedagogical_focus": "Secure communication tools and practices for activist organizing",
        "lesson_count": 20,
        "estimated_weeks": 7,
        "order": 3,
        "key_outcomes": [
          "Use Signal for sensitive communications",
          "Verify safety numbers with key contacts",
          "Understand metadata risks in messaging",
          "Share files securely without corporate surveillance"
        ],
        "core_concept": "End-to-end encryption - protect message content and minimize metadata exposure"
      },
      {
        "id": 1002,
        "title": "Lock Down Your Accounts",
        "description": "Secure existing accounts with strong passwords, 2FA, and proper device settings",
        "pedagogical_focus": "Basic account security and device hardening for everyday protection",
        "lesson_count": 20,
        "estimated_weeks": 7,
        "order": 2,
        "key_outcomes": [
          "Implement strong unique passwords with password manager",
          "Enable two-factor authentication on critical accounts",
          "Configure secure device settings (disable FaceID, auto-backup)",
          "Understand and manage app permissions"
        ],
        "core_concept": "Defense in depth - multiple layers of security on devices and accounts"
      },
      {
        "id": 1001,
        "title": "Separate Your Identities",
        "description": "Learn to compartmentalize your digital life between activist and civilian identities",
        "pedagogical_focus": "Identity separation and account isolation to protect activist work from surveillance",
        "lesson_count": 20,
        "estimated_weeks": 7,
        "order": 1,
        "key_outcomes": [
          "Create separate activist and civilian email accounts",
          "Migrate sensitive accounts to protected identity",
          "Understand metadata risks in social media",
          "Maintain boundaries between identities"
        ],
        "core_concept": "Compartmentalization - assume civilian identity is compromised, protect activist identity"
      },
      {
        "id": 1004,
        "title": "Recognize & Respond to Threats",
        "description": "Identify phishing, social engineering, and surveillance, then respond appropriately",
        "pedagogical_focus": "Threat recognition and incident response for activist contexts",
        "lesson_count": 18,
        "estimated_weeks": 6,
        "order": 4,
        "key_outcomes": [
          "Recognize phishing attempts and social engineering",
          "Identify surveillance indicators",
          "Respond appropriately to device seizure",
          "Implement threat-appropriate security measures"
        ],
        "core_concept": "Threat modeling - recognize attacks and respond proportionally to actual risk"
      }
    ];
    lessonMetadata = [
      {
        "id": 12348,
        "path": "static/yaml/lessons/phishing-basics-4.yaml",
        "title": "Phishing Recognition Basics",
        "entityType": "lesson",
        "pageCount": 2,
        "componentCount": 2,
        "difficulty": "beginner",
        "estimatedMinutes": 8,
        "required": true,
        "domainId": 1004
      },
      {
        "id": 0,
        "path": "static/yaml/lessons/main_menu.yaml",
        "title": "Main Menu",
        "entityType": "lesson",
        "pageCount": 1,
        "componentCount": 1,
        "difficulty": "beginner",
        "estimatedMinutes": 1,
        "required": true,
        "domainId": null
      },
      {
        "id": 12345,
        "path": "static/yaml/lessons/phishing-basics.yaml",
        "title": "Phishing Recognition Basics",
        "entityType": "lesson",
        "pageCount": 2,
        "componentCount": 2,
        "difficulty": "beginner",
        "estimatedMinutes": 8,
        "required": true,
        "domainId": 1001
      },
      {
        "id": 1,
        "path": "static/yaml/lessons/welcome_menu.yaml",
        "title": "Welcome to Mera",
        "entityType": "lesson",
        "pageCount": 1,
        "componentCount": 1,
        "difficulty": "beginner",
        "estimatedMinutes": 5,
        "required": true,
        "domainId": null
      },
      {
        "id": 12346,
        "path": "static/yaml/lessons/phishing-basics-2.yaml",
        "title": "Phishing Recognition Basics",
        "entityType": "lesson",
        "pageCount": 2,
        "componentCount": 2,
        "difficulty": "beginner",
        "estimatedMinutes": 8,
        "required": true,
        "domainId": 1002
      },
      {
        "id": 12347,
        "path": "static/yaml/lessons/phishing-basics-3.yaml",
        "title": "Phishing Recognition Basics",
        "entityType": "lesson",
        "pageCount": 2,
        "componentCount": 2,
        "difficulty": "beginner",
        "estimatedMinutes": 8,
        "required": true,
        "domainId": 1003
      }
    ];
    console.log(`Mera Registry loaded with all 12 mappings:`);
    console.log(`  - ${componentRegistrations.length} component types`);
    console.log(`  - ${allLessonIds.length} entities (lessons + menus)`);
    console.log(`  - ${allComponentIds.length} component IDs`);
    console.log(`  - ${componentIdToTypeMap.size} component ID->type mappings`);
    console.log(`  - ${domainLessonMap.size} domains`);
  }
});

// src/ts/initialization/progressIntegrity.ts
var progressIntegrity_exports = {};
__export(progressIntegrity_exports, {
  enforceDataIntegrity: () => enforceDataIntegrity
});
function getComponentConfig(componentId, lessonConfigs) {
  const lessonId = curriculumData.getLessonIdForComponent(componentId);
  if (!lessonId) return null;
  const lessonConfig = lessonConfigs.get(lessonId);
  if (!lessonConfig) return null;
  return lessonConfig.components.find((c) => c.id === componentId) || null;
}
function enforceDataIntegrity(rawJson, expectedWebId, lessonConfigs) {
  if (!lessonConfigs || lessonConfigs.size === 0) {
    throw new Error(
      "progressRecovery requires parsed lesson configs. Ensure YAML parsing phase completes before recovery phase."
    );
  }
  let parsed;
  try {
    parsed = JSON.parse(rawJson);
  } catch (e) {
    console.warn("\u26A0\uFE0F JSON parse failed, returning fully defaulted bundle");
    return createFullyDefaultedResult(expectedWebId, null, lessonConfigs);
  }
  const metadataResult = extractMetadata(parsed, expectedWebId);
  const overallProgressResult = extractOverallProgress(parsed);
  const settingsResult = extractSettings(parsed);
  const navigationResult = extractNavigationState(parsed);
  const componentProgressResult = extractCombinedComponentProgress(
    parsed,
    lessonConfigs
  );
  let bundle = {
    metadata: metadataResult.data,
    overallProgress: overallProgressResult.data,
    settings: settingsResult.data,
    navigationState: navigationResult.data,
    combinedComponentProgress: componentProgressResult.data
  };
  try {
    bundle = PodStorageBundleSchema.parse(bundle);
  } catch (validationError) {
    console.error(
      "CRITICAL: Assembled bundle failed schema validation:",
      validationError
    );
    throw new Error(
      "Bundle validation failed - this is a bug in progressIntegrity.ts"
    );
  }
  const hasCriticalFailures = metadataResult.webIDMismatch !== void 0;
  const perfectlyValidInput = !hasCriticalFailures && !overallProgressResult.corruptionDetected && metadataResult.defaultedRatio === 0 && overallProgressResult.lessonsDroppedRatio === 0 && overallProgressResult.domainsDroppedRatio === 0 && settingsResult.defaultedRatio === 0 && !navigationResult.wasDefaulted && componentProgressResult.defaultedRatio === 0;
  return {
    perfectlyValidInput,
    bundle,
    recoveryMetrics: {
      metadata: {
        defaultedRatio: metadataResult.defaultedRatio
      },
      overallProgress: {
        lessonsDroppedRatio: overallProgressResult.lessonsDroppedRatio,
        domainsDroppedRatio: overallProgressResult.domainsDroppedRatio,
        lessonsDroppedCount: overallProgressResult.lessonsDroppedCount,
        domainsDroppedCount: overallProgressResult.domainsDroppedCount,
        corruptionDetected: overallProgressResult.corruptionDetected,
        lessonsLostToCorruption: overallProgressResult.lessonsLostToCorruption,
        domainsLostToCorruption: overallProgressResult.domainsLostToCorruption
      },
      settings: {
        defaultedRatio: settingsResult.defaultedRatio
      },
      navigationState: {
        wasDefaulted: navigationResult.wasDefaulted
      },
      combinedComponentProgress: {
        defaultedRatio: componentProgressResult.defaultedRatio,
        componentsRetained: componentProgressResult.componentsRetained,
        componentsDefaulted: componentProgressResult.componentsDefaulted
      }
    },
    criticalFailures: metadataResult.webIDMismatch ? {
      webIdMismatch: metadataResult.webIDMismatch
    } : {}
  };
}
function extractMetadata(parsed, expectedWebId) {
  const zodResult = PodMetadataSchema.safeParse(parsed?.metadata);
  if (zodResult.success) {
    if (zodResult.data.webId !== expectedWebId) {
      return {
        data: { webId: "https://error.mera.invalid/webid-mismatch" },
        // Security: Never use mismatched webId
        defaultedRatio: 1,
        webIDMismatch: {
          expected: expectedWebId,
          found: zodResult.data.webId
        }
      };
    }
    return {
      data: zodResult.data,
      defaultedRatio: 0
    };
  }
  const candidate = parsed?.metadata || {};
  const webId = typeof candidate.webId === "string" ? candidate.webId : expectedWebId;
  const webIDMismatch = webId !== expectedWebId ? {
    expected: expectedWebId,
    found: webId
  } : void 0;
  return {
    data: { webId: "https://error.mera.invalid/webid-mismatch" },
    // Security: Never use mismatched webId
    defaultedRatio: 1,
    webIDMismatch
  };
}
function extractOverallProgress(parsed) {
  const zodResult = OverallProgressDataSchema.safeParse(
    parsed?.overallProgress
  );
  if (zodResult.success) {
    return reconcileOverallProgress(zodResult.data);
  }
  const candidate = parsed?.overallProgress || {};
  const overallProgress = getDefaultOverallProgress();
  if (typeof candidate.lessonCompletions === "object" && candidate.lessonCompletions !== null) {
    overallProgress.lessonCompletions = candidate.lessonCompletions;
  }
  if (typeof candidate.domainCompletions === "object" && candidate.domainCompletions !== null) {
    overallProgress.domainCompletions = candidate.domainCompletions;
  }
  if (typeof candidate.currentStreak === "number" && candidate.currentStreak >= 0) {
    overallProgress.currentStreak = candidate.currentStreak;
  }
  if (typeof candidate.lastStreakCheck === "number" && candidate.lastStreakCheck >= 0) {
    overallProgress.lastStreakCheck = candidate.lastStreakCheck;
  }
  if (typeof candidate.totalLessonsCompleted === "number" && candidate.totalLessonsCompleted >= 0) {
    overallProgress.totalLessonsCompleted = candidate.totalLessonsCompleted;
  }
  if (typeof candidate.totalDomainsCompleted === "number" && candidate.totalDomainsCompleted >= 0) {
    overallProgress.totalDomainsCompleted = candidate.totalDomainsCompleted;
  }
  return reconcileOverallProgress(overallProgress);
}
function reconcileOverallProgress(progress) {
  const result = {
    lessonCompletions: {},
    domainCompletions: {},
    currentStreak: progress.currentStreak,
    lastStreakCheck: progress.lastStreakCheck,
    totalLessonsCompleted: 0,
    totalDomainsCompleted: 0
  };
  const claimedLessons = progress.totalLessonsCompleted ?? 0;
  const claimedDomains = progress.totalDomainsCompleted ?? 0;
  let actualCompletedLessons = 0;
  let actualCompletedDomains = 0;
  let lessonsDropped = 0;
  let domainsDropped = 0;
  for (const [lessonIdStr, completion] of Object.entries(
    progress.lessonCompletions
  )) {
    const lessonId = parseInt(lessonIdStr, 10);
    if (!curriculumData.hasLesson(lessonId)) {
      lessonsDropped++;
      continue;
    }
    const zodResult = CompletionDataSchema.safeParse(completion);
    if (!zodResult.success) {
      lessonsDropped++;
      continue;
    }
    result.lessonCompletions[lessonIdStr] = zodResult.data;
    if (zodResult.data.timeCompleted !== null) {
      actualCompletedLessons++;
    }
  }
  for (const [domainIdStr, completion] of Object.entries(
    progress.domainCompletions
  )) {
    const domainId = parseInt(domainIdStr, 10);
    if (!curriculumData.hasDomain(domainId)) {
      domainsDropped++;
      continue;
    }
    const zodResult = CompletionDataSchema.safeParse(completion);
    if (!zodResult.success) {
      domainsDropped++;
      continue;
    }
    result.domainCompletions[domainIdStr] = zodResult.data;
    if (zodResult.data.timeCompleted !== null) {
      actualCompletedDomains++;
    }
  }
  const allLessonIds2 = curriculumData.getAllLessonIds();
  for (const lessonId of allLessonIds2) {
    const key = lessonId.toString();
    if (!result.lessonCompletions[key]) {
      result.lessonCompletions[key] = {
        timeCompleted: null,
        lastUpdated: 0
      };
    }
  }
  const allDomainIds = curriculumData.getAllDomainIds();
  for (const domainId of allDomainIds) {
    const key = domainId.toString();
    if (!result.domainCompletions[key]) {
      result.domainCompletions[key] = {
        timeCompleted: null,
        lastUpdated: 0
      };
    }
  }
  const corruptionDetected = claimedLessons !== actualCompletedLessons || claimedDomains !== actualCompletedDomains;
  const lessonsLostToCorruption = Math.max(
    0,
    claimedLessons - actualCompletedLessons
  );
  const domainsLostToCorruption = Math.max(
    0,
    claimedDomains - actualCompletedDomains
  );
  result.totalLessonsCompleted = actualCompletedLessons;
  result.totalDomainsCompleted = actualCompletedDomains;
  const originalLessonCount = Object.keys(progress.lessonCompletions).length;
  const originalDomainCount = Object.keys(progress.domainCompletions).length;
  return {
    data: result,
    lessonsDroppedRatio: originalLessonCount > 0 ? lessonsDropped / originalLessonCount : 0,
    domainsDroppedRatio: originalDomainCount > 0 ? domainsDropped / originalDomainCount : 0,
    lessonsDroppedCount: lessonsDropped,
    domainsDroppedCount: domainsDropped,
    corruptionDetected,
    lessonsLostToCorruption,
    domainsLostToCorruption
  };
}
function extractSettings(parsed) {
  const defaults = getDefaultSettings();
  const candidate = parsed?.settings || {};
  const settings = {};
  const totalFields = 11;
  let defaultedFields = 0;
  if (Array.isArray(candidate.weekStartDay) && [
    "monday",
    "tuesday",
    "wednesday",
    "thursday",
    "friday",
    "saturday",
    "sunday"
  ].includes(candidate.weekStartDay[0])) {
    settings.weekStartDay = [
      candidate.weekStartDay[0],
      candidate.weekStartDay[1] ?? 0
    ];
  } else {
    settings.weekStartDay = defaults.weekStartDay;
    defaultedFields++;
  }
  if (Array.isArray(candidate.weekStartTimeUTC) && typeof candidate.weekStartTimeUTC[0] === "string" && /^\d{2}:\d{2}$/.test(candidate.weekStartTimeUTC[0])) {
    settings.weekStartTimeUTC = [
      candidate.weekStartTimeUTC[0],
      candidate.weekStartTimeUTC[1] ?? 0
    ];
  } else {
    settings.weekStartTimeUTC = defaults.weekStartTimeUTC;
    defaultedFields++;
  }
  if (Array.isArray(candidate.theme) && ["light", "dark", "auto"].includes(candidate.theme[0])) {
    settings.theme = [candidate.theme[0], candidate.theme[1] ?? 0];
  } else {
    settings.theme = defaults.theme;
    defaultedFields++;
  }
  if (Array.isArray(candidate.learningPace) && ["accelerated", "standard", "flexible"].includes(candidate.learningPace[0])) {
    settings.learningPace = [
      candidate.learningPace[0],
      candidate.learningPace[1] ?? 0
    ];
  } else {
    settings.learningPace = defaults.learningPace;
    defaultedFields++;
  }
  if (Array.isArray(candidate.optOutDailyPing) && typeof candidate.optOutDailyPing[0] === "boolean") {
    settings.optOutDailyPing = [
      candidate.optOutDailyPing[0],
      candidate.optOutDailyPing[1] ?? 0
    ];
  } else {
    settings.optOutDailyPing = defaults.optOutDailyPing;
    defaultedFields++;
  }
  if (Array.isArray(candidate.optOutErrorPing) && typeof candidate.optOutErrorPing[0] === "boolean") {
    settings.optOutErrorPing = [
      candidate.optOutErrorPing[0],
      candidate.optOutErrorPing[1] ?? 0
    ];
  } else {
    settings.optOutErrorPing = defaults.optOutErrorPing;
    defaultedFields++;
  }
  if (Array.isArray(candidate.fontSize) && ["small", "medium", "large"].includes(candidate.fontSize[0])) {
    settings.fontSize = [candidate.fontSize[0], candidate.fontSize[1] ?? 0];
  } else {
    settings.fontSize = defaults.fontSize;
    defaultedFields++;
  }
  if (Array.isArray(candidate.highContrast) && typeof candidate.highContrast[0] === "boolean") {
    settings.highContrast = [
      candidate.highContrast[0],
      candidate.highContrast[1] ?? 0
    ];
  } else {
    settings.highContrast = defaults.highContrast;
    defaultedFields++;
  }
  if (Array.isArray(candidate.reducedMotion) && typeof candidate.reducedMotion[0] === "boolean") {
    settings.reducedMotion = [
      candidate.reducedMotion[0],
      candidate.reducedMotion[1] ?? 0
    ];
  } else {
    settings.reducedMotion = defaults.reducedMotion;
    defaultedFields++;
  }
  if (Array.isArray(candidate.focusIndicatorStyle) && ["default", "enhanced"].includes(candidate.focusIndicatorStyle[0])) {
    settings.focusIndicatorStyle = [
      candidate.focusIndicatorStyle[0],
      candidate.focusIndicatorStyle[1] ?? 0
    ];
  } else {
    settings.focusIndicatorStyle = defaults.focusIndicatorStyle;
    defaultedFields++;
  }
  if (Array.isArray(candidate.audioEnabled) && typeof candidate.audioEnabled[0] === "boolean") {
    settings.audioEnabled = [
      candidate.audioEnabled[0],
      candidate.audioEnabled[1] ?? 0
    ];
  } else {
    settings.audioEnabled = defaults.audioEnabled;
    defaultedFields++;
  }
  return {
    data: settings,
    defaultedRatio: defaultedFields / totalFields
  };
}
function extractNavigationState(parsed) {
  const zodResult = NavigationStateSchema.safeParse(parsed?.navigationState);
  if (zodResult.success) {
    const validationResult = validateNavigationEntity(
      zodResult.data,
      curriculumData
    );
    return {
      data: validationResult.cleaned,
      defaultedRatio: validationResult.wasDefaulted ? 1 : 0,
      wasDefaulted: validationResult.wasDefaulted
    };
  }
  return {
    data: getDefaultNavigationState(),
    // <-- Use centralized default function
    defaultedRatio: 1,
    wasDefaulted: true
  };
}
function extractCombinedComponentProgress(parsed, lessonConfigs) {
  const candidateComponents = parsed?.combinedComponentProgress?.components;
  const savedComponents = typeof candidateComponents === "object" && candidateComponents !== null ? candidateComponents : {};
  const components = {};
  let componentsRetained = 0;
  let componentsDefaulted = 0;
  const allComponentIds2 = curriculumData.getAllComponentIds();
  for (const componentId of allComponentIds2) {
    const componentIdStr = componentId.toString();
    const savedProgress = savedComponents[componentIdStr];
    if (savedProgress === void 0) {
      const componentType2 = curriculumData.getComponentType(componentId);
      if (componentType2) {
        const componentConfig = getComponentConfig(componentId, lessonConfigs);
        const initializer3 = componentInitializerMap.get(componentType2);
        components[componentIdStr] = initializer3 && componentConfig ? initializer3(componentConfig) : { lastUpdated: 0 };
      } else {
        components[componentIdStr] = { lastUpdated: 0 };
      }
      componentsDefaulted++;
      continue;
    }
    const componentType = curriculumData.getComponentType(componentId);
    if (!componentType) {
      componentsDefaulted++;
      const componentConfig = getComponentConfig(componentId, lessonConfigs);
      const initializer3 = componentInitializerMap.get("unknown");
      components[componentIdStr] = initializer3 && componentConfig ? initializer3(componentConfig) : { lastUpdated: 0 };
      continue;
    }
    const progressSchema = progressSchemaMap.get(componentType);
    if (!progressSchema) {
      componentsDefaulted++;
      const componentConfig = getComponentConfig(componentId, lessonConfigs);
      const initializer3 = componentInitializerMap.get(componentType);
      components[componentIdStr] = initializer3 && componentConfig ? initializer3(componentConfig) : { lastUpdated: 0 };
      continue;
    }
    const zodResult = progressSchema.safeParse(savedProgress);
    if (!zodResult.success) {
      componentsDefaulted++;
      const componentConfig = getComponentConfig(componentId, lessonConfigs);
      const initializer3 = componentInitializerMap.get(componentType);
      components[componentIdStr] = initializer3 && componentConfig ? initializer3(componentConfig) : { lastUpdated: 0 };
      continue;
    }
    const validator = componentValidatorMap.get(componentType);
    if (validator) {
      const lessonId = curriculumData.getLessonIdForComponent(componentId);
      const lessonConfig = lessonId ? lessonConfigs.get(lessonId) : null;
      const componentConfig = lessonConfig?.components.find(
        (c) => c.id === componentId
      );
      if (componentConfig) {
        const validationResult = validator(zodResult.data, componentConfig);
        if (validationResult.defaultedRatio > 0) {
          componentsDefaulted++;
          components[componentIdStr] = validationResult.cleaned;
          continue;
        }
      }
    }
    components[componentIdStr] = zodResult.data;
    componentsRetained++;
  }
  const totalComponents = allComponentIds2.length;
  const defaultedRatio = totalComponents > 0 ? componentsDefaulted / totalComponents : 0;
  return {
    data: { components },
    defaultedRatio,
    componentsRetained,
    componentsDefaulted
  };
}
function initializeAllLessonsAndDomainsWithDefaults() {
  const lessonCompletions = {};
  const domainCompletions = {};
  const allLessonIds2 = curriculumData.getAllLessonIds();
  for (const lessonId of allLessonIds2) {
    lessonCompletions[lessonId.toString()] = {
      timeCompleted: null,
      lastUpdated: 0
    };
  }
  const allDomainIds = curriculumData.getAllDomainIds();
  for (const domainId of allDomainIds) {
    domainCompletions[domainId.toString()] = {
      timeCompleted: null,
      lastUpdated: 0
    };
  }
  return { lessonCompletions, domainCompletions };
}
function initializeAllComponentsWithDefaults(lessonConfigs) {
  const components = {};
  const allComponentIds2 = curriculumData.getAllComponentIds();
  for (const componentId of allComponentIds2) {
    const componentIdStr = componentId.toString();
    const componentType = curriculumData.getComponentType(componentId);
    if (componentType) {
      const componentConfig = getComponentConfig(componentId, lessonConfigs);
      const initializer3 = componentInitializerMap.get(componentType);
      components[componentIdStr] = initializer3 && componentConfig ? initializer3(componentConfig) : { lastUpdated: 0 };
    } else {
      components[componentIdStr] = { lastUpdated: 0 };
    }
  }
  return components;
}
function createFullyDefaultedResult(expectedWebId, foundWebId, lessonConfigs) {
  const allComponentIds2 = curriculumData.getAllComponentIds();
  const { lessonCompletions, domainCompletions } = initializeAllLessonsAndDomainsWithDefaults();
  const defaultSettings = getDefaultSettings();
  const defaultProgress = getDefaultOverallProgress();
  let bundle = {
    metadata: {
      webId: "https://error.mera.invalid/unparseable-json"
      // Security: Unparseable = treat as mismatch
    },
    overallProgress: {
      ...defaultProgress,
      lessonCompletions,
      domainCompletions
    },
    settings: defaultSettings,
    navigationState: {
      currentEntityId: 1,
      // Welcome screen for new users
      currentPage: 0,
      lastUpdated: 0
    },
    combinedComponentProgress: {
      components: initializeAllComponentsWithDefaults(lessonConfigs)
    }
  };
  try {
    bundle = PodStorageBundleSchema.parse(bundle);
  } catch (validationError) {
    console.error(
      "CRITICAL: Default bundle failed schema validation:",
      validationError
    );
    throw new Error(
      "Default bundle validation failed - this is a bug in progressIntegrity.ts"
    );
  }
  return {
    perfectlyValidInput: false,
    // Fully defaulted = not valid input
    bundle,
    recoveryMetrics: {
      metadata: { defaultedRatio: 1 },
      overallProgress: {
        lessonsDroppedRatio: 1,
        domainsDroppedRatio: 1,
        lessonsDroppedCount: 0,
        // Nothing to drop - fully defaulted
        domainsDroppedCount: 0,
        // Nothing to drop - fully defaulted
        corruptionDetected: false,
        // Fully defaulted = no corruption, just empty
        lessonsLostToCorruption: 0,
        domainsLostToCorruption: 0
      },
      settings: { defaultedRatio: 1 },
      navigationState: { wasDefaulted: true },
      combinedComponentProgress: {
        defaultedRatio: 1,
        componentsRetained: 0,
        componentsDefaulted: allComponentIds2.length
      }
    },
    criticalFailures: {
      webIdMismatch: {
        expected: expectedWebId,
        found: foundWebId
      }
    }
  };
}
var init_progressIntegrity = __esm({
  "src/ts/initialization/progressIntegrity.ts"() {
    "use strict";
    init_podStorageSchema();
    init_overallProgressSchema();
    init_settingsSchema();
    init_navigationSchema();
    init_mera_registry();
  }
});

// src/ts/ui/errorDisplay.ts
var ErrorDisplay = class {
  /**
   * Constructor accepts optional timeline parameter for backward compatibility.
   * Parameter is ignored - overlay approach doesn't need timeline reference.
   */
  constructor(timelineContainer = null) {
    this.activeErrors = /* @__PURE__ */ new Map();
    this.errorQueue = [];
    // Queue of error IDs to display
    this.currentlyDisplayedError = null;
    this.ensureOverlayExists();
  }
  /**
   * Ensure error overlay container exists in DOM.
   * Creates it if missing - idempotent, safe to call multiple times.
   */
  ensureOverlayExists() {
    if (!document.getElementById("error-overlay")) {
      document.body.insertAdjacentHTML("beforeend", `
                <div id="error-overlay" class="hidden fixed inset-0 z-50">
                    <div class="absolute inset-0 bg-black bg-opacity-50 backdrop-blur-sm"></div>
                    <div class="relative min-h-screen flex items-center justify-center p-4">
                        <div id="error-container" class="w-full max-w-md">
                            <!-- Error cards render here -->
                        </div>
                    </div>
                </div>
            `);
    }
  }
  /**
   * Display a system error (YAML loading, TypeScript issues, etc.)
   */
  showSystemError(errorId = "system", context = "", details = "") {
    this._showError({
      errorId,
      errorType: "system",
      title: "System Error",
      message: "We're having trouble loading lesson content.",
      context,
      details,
      actions: ["check_connection", "refresh", "email_support"]
    });
  }
  /**
   * Display a network connectivity error
   */
  showNetworkError(errorId = "network", context = "") {
    this._showError({
      errorId,
      errorType: "network",
      title: "Connection Issue",
      message: "Unable to reach the server.",
      context,
      actions: ["check_connection", "retry", "email_support"]
    });
  }
  /**
   * Display an error specific to a component
   */
  showComponentError(componentId, errorMessage) {
    this._showError({
      errorId: `component-${componentId}`,
      errorType: "component",
      title: "Component Error",
      message: `Component ${componentId} encountered an issue.`,
      context: errorMessage,
      actions: ["refresh", "skip_component", "email_support"]
    });
  }
  /**
   * Display an authentication error
   */
  showAuthError(errorId = "auth", context = "") {
    this._showError({
      errorId,
      errorType: "authentication",
      title: "Authentication Required",
      message: "Your session has expired or authentication failed.",
      context,
      actions: ["retry", "refresh"]
    });
  }
  /**
   * Display a Solid Pod specific error
   */
  showSolidError(errorId = "solid", context = "", details = "") {
    this._showError({
      errorId,
      errorType: "solid",
      title: "Solid Pod Error",
      message: "Unable to access your Solid Pod.",
      context,
      details,
      actions: ["retry_solid", "check_connection", "email_support"]
    });
  }
  /**
   * Remove a specific error and show next in queue if any
   */
  clearError(errorId) {
    if (this.activeErrors.has(errorId)) {
      this.activeErrors.delete(errorId);
      console.log(`\u{1F9F9} Cleared error: ${errorId}`);
      if (this.currentlyDisplayedError === errorId) {
        this.currentlyDisplayedError = null;
        this._hideOverlay();
        this._showNextInQueue();
      } else {
        this.errorQueue = this.errorQueue.filter((id) => id !== errorId);
      }
    }
  }
  /**
   * Clear all active errors and hide overlay
   */
  clearAllErrors() {
    const errorIds = Array.from(this.activeErrors.keys());
    this.activeErrors.clear();
    this.errorQueue = [];
    this.currentlyDisplayedError = null;
    this._hideOverlay();
    console.log("\u{1F9F9} All errors cleared");
  }
  /**
   * Internal method to display an error as modal overlay.
   * Queues errors if one is already being displayed.
   */
  _showError(params) {
    const { errorId, errorType, title, message: message2, context = "", details = "", actions = ["refresh", "email_support"] } = params;
    this.activeErrors.set(errorId, {
      type: errorType,
      title,
      message: message2,
      context
    });
    if (this.currentlyDisplayedError === null) {
      this._displayError(errorId, title, message2, context, details, actions);
    } else {
      if (!this.errorQueue.includes(errorId)) {
        this.errorQueue.push(errorId);
        console.log(`\u23F3 Queued error: ${errorId} (${this.errorQueue.length} in queue)`);
      }
    }
  }
  /**
   * Actually display an error in the overlay
   */
  _displayError(errorId, title, message2, context, details, actions) {
    this.currentlyDisplayedError = errorId;
    const overlay = document.getElementById("error-overlay");
    const container = document.getElementById("error-container");
    if (!overlay || !container) {
      console.error("\u274C Error overlay not found");
      return;
    }
    const errorHtml = this._buildErrorModal(errorId, title, message2, context, details, actions);
    container.innerHTML = errorHtml;
    overlay.classList.remove("hidden");
    document.body.style.overflow = "hidden";
    console.log(`\u274C Displayed error: ${errorId}`);
  }
  /**
   * Show next error in queue, if any
   */
  _showNextInQueue() {
    if (this.errorQueue.length > 0) {
      const nextErrorId = this.errorQueue.shift();
      const errorInfo = this.activeErrors.get(nextErrorId);
      if (errorInfo) {
        this._displayError(
          nextErrorId,
          errorInfo.title,
          errorInfo.message,
          errorInfo.context,
          "",
          // details not stored, would need to expand ErrorInfo if needed
          ["refresh", "email_support"]
          // default actions
        );
      }
    }
  }
  /**
   * Hide the error overlay and re-enable scroll
   */
  _hideOverlay() {
    const overlay = document.getElementById("error-overlay");
    if (overlay) {
      overlay.classList.add("hidden");
      document.body.style.overflow = "";
    }
  }
  /**
   * Build the HTML for an error modal
   */
  _buildErrorModal(errorId, title, message2, context, details, actions) {
    const contextHtml = context ? `<p class="text-sm text-red-700 mt-2"><strong>Context:</strong> ${this._escapeHtml(context)}</p>` : "";
    const detailsHtml = details ? `<details class="mt-3 text-xs text-gray-600">
                 <summary class="cursor-pointer hover:text-gray-900">Technical Details</summary>
                 <pre class="mt-2 p-2 bg-gray-100 rounded overflow-x-auto">${this._escapeHtml(details)}</pre>
               </details>` : "";
    const actionsHtml = this._buildActionButtons(errorId, actions);
    return `
            <div id="error-modal-${errorId}" 
                 class="bg-white rounded-lg shadow-2xl p-6 animate-fadeIn">
                <div class="flex items-start">
                    <div class="flex-shrink-0">
                        <svg class="w-6 h-6 text-red-500" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" 
                                  d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z">
                            </path>
                        </svg>
                    </div>
                    <div class="ml-3 flex-1">
                        <h3 class="text-lg font-semibold text-gray-900">${this._escapeHtml(title)}</h3>
                        <p class="text-sm text-gray-700 mt-2">${this._escapeHtml(message2)}</p>
                        ${contextHtml}
                        ${detailsHtml}
                        <div class="mt-4 flex flex-wrap gap-2">
                            ${actionsHtml}
                        </div>
                    </div>
                </div>
            </div>
        `;
  }
  /**
   * Build action buttons based on the provided actions list
   */
  _buildActionButtons(errorId, actions) {
    const buttons = [];
    for (const action of actions) {
      switch (action) {
        case "refresh":
          buttons.push(`
                        <button onclick="location.reload()" 
                                class="px-4 py-2 bg-blue-600 text-white rounded hover:bg-blue-700 transition-colors">
                            Refresh Page
                        </button>
                    `);
          break;
        case "retry":
          buttons.push(`
                        <button onclick="location.reload()" 
                                class="px-4 py-2 bg-blue-600 text-white rounded hover:bg-blue-700 transition-colors">
                            Retry
                        </button>
                    `);
          break;
        case "check_connection":
          buttons.push(`
                        <button onclick="window.open('https://www.google.com', '_blank')" 
                                class="px-4 py-2 bg-gray-200 text-gray-700 rounded hover:bg-gray-300 transition-colors">
                            Check Connection
                        </button>
                    `);
          break;
        case "email_support":
          buttons.push(`
                        <button onclick="window.location.href='mailto:support@example.com?subject=Mera Error: ${errorId}'" 
                                class="px-4 py-2 bg-gray-200 text-gray-700 rounded hover:bg-gray-300 transition-colors">
                            Contact Support
                        </button>
                    `);
          break;
        case "skip_component":
          buttons.push(`
                        <button onclick="window.errorDisplay?.clearError('${errorId}')" 
                                class="px-4 py-2 bg-yellow-600 text-white rounded hover:bg-yellow-700 transition-colors">
                            Skip Component
                        </button>
                    `);
          break;
        case "retry_solid":
          buttons.push(`
                        <button onclick="location.href='/solid'" 
                                class="px-4 py-2 bg-blue-600 text-white rounded hover:bg-blue-700 transition-colors">
                            Retry Connection
                        </button>
                    `);
          break;
      }
    }
    buttons.push(`
            <button onclick="window.errorDisplay?.clearError('${errorId}')" 
                    class="px-4 py-2 bg-gray-200 text-gray-700 rounded hover:bg-gray-300 transition-colors">
                Dismiss
            </button>
        `);
    return buttons.join("");
  }
  /**
   * Escape HTML to prevent XSS
   */
  _escapeHtml(text) {
    const div = document.createElement("div");
    div.textContent = text;
    return div.innerHTML;
  }
};
function showCriticalError(options) {
  const { title, message: message2, technicalDetails, errorCode } = options;
  document.body.innerHTML = "";
  const detailsHtml = technicalDetails ? `<details class="mt-4 text-sm text-gray-300">
             <summary class="cursor-pointer hover:text-white">Technical Details</summary>
             <pre class="mt-2 p-3 bg-gray-900 rounded overflow-x-auto text-xs">${technicalDetails}</pre>
           </details>` : "";
  const errorCodeHtml = errorCode ? `<p class="text-sm text-gray-400 mt-2">Error Code: ${errorCode}</p>` : "";
  document.body.innerHTML = `
        <div class="min-h-screen bg-gray-800 flex items-center justify-center p-4">
            <div class="max-w-md w-full bg-gray-900 rounded-lg shadow-2xl p-6 border border-red-500">
                <div class="flex items-center mb-4">
                    <svg class="w-8 h-8 text-red-500" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" 
                              d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z">
                        </path>
                    </svg>
                    <h1 class="ml-3 text-2xl font-bold text-white">${title}</h1>
                </div>
                <p class="text-gray-300 mb-4">${message2}</p>
                ${errorCodeHtml}
                ${detailsHtml}
                <div class="mt-6 flex gap-3">
                    <button onclick="location.reload()" 
                            class="flex-1 px-4 py-2 bg-red-600 text-white rounded hover:bg-red-700 transition-colors">
                        Reload Application
                    </button>
                    <button onclick="location.href='/'" 
                            class="flex-1 px-4 py-2 bg-gray-700 text-white rounded hover:bg-gray-600 transition-colors">
                        Go Home
                    </button>
                </div>
            </div>
        </div>
    `;
}
var SolidConnectionErrorDisplay = class extends ErrorDisplay {
  /**
   * Display Solid Pod connection error
   */
  showConnectionError(context = "") {
    this.showSolidError("solid-connection", context);
  }
  /**
   * Display Solid authentication error
   */
  showAuthenticationError(context = "") {
    this.showAuthError("solid-auth", context);
  }
  /**
   * Display Solid permission error
   */
  showPermissionError(context = "") {
    this._showError({
      errorId: "solid-permission",
      errorType: "solid",
      title: "Permission Denied",
      message: "The application does not have permission to access your Solid Pod.",
      context,
      actions: ["retry_solid", "email_support"]
    });
  }
};

// src/ts/initialization/bootstrap.ts
init_meraBridge();

// src/ts/initialization/progressLoader.ts
init_progressIntegrity();

// src/ts/initialization/progressMerger.ts
function mergeOverallProgress(dataA, dataB) {
  const mergedLessons = {};
  for (const [lessonId, compA] of Object.entries(dataA.lessonCompletions)) {
    const compB = dataB.lessonCompletions[lessonId];
    mergedLessons[lessonId] = compA.lastUpdated >= compB.lastUpdated ? compA : compB;
  }
  const mergedDomains = {};
  for (const [domainId, compA] of Object.entries(dataA.domainCompletions)) {
    const compB = dataB.domainCompletions[domainId];
    mergedDomains[domainId] = compA.lastUpdated >= compB.lastUpdated ? compA : compB;
  }
  const totalLessonsCompleted = Object.values(mergedLessons).filter((c) => c.timeCompleted !== null).length;
  const totalDomainsCompleted = Object.values(mergedDomains).filter((c) => c.timeCompleted !== null).length;
  const useDataA = dataA.lastStreakCheck >= dataB.lastStreakCheck;
  const mergedStreak = useDataA ? dataA.currentStreak : dataB.currentStreak;
  const mergedStreakCheck = Math.max(dataA.lastStreakCheck, dataB.lastStreakCheck);
  return {
    lessonCompletions: mergedLessons,
    domainCompletions: mergedDomains,
    totalLessonsCompleted,
    totalDomainsCompleted,
    currentStreak: mergedStreak,
    lastStreakCheck: mergedStreakCheck
  };
}
function mergeSettings(dataA, dataB) {
  return {
    weekStartDay: dataA.weekStartDay[1] >= dataB.weekStartDay[1] ? dataA.weekStartDay : dataB.weekStartDay,
    weekStartTimeUTC: dataA.weekStartTimeUTC[1] >= dataB.weekStartTimeUTC[1] ? dataA.weekStartTimeUTC : dataB.weekStartTimeUTC,
    theme: dataA.theme[1] >= dataB.theme[1] ? dataA.theme : dataB.theme,
    learningPace: dataA.learningPace[1] >= dataB.learningPace[1] ? dataA.learningPace : dataB.learningPace,
    optOutDailyPing: dataA.optOutDailyPing[1] >= dataB.optOutDailyPing[1] ? dataA.optOutDailyPing : dataB.optOutDailyPing,
    optOutErrorPing: dataA.optOutErrorPing[1] >= dataB.optOutErrorPing[1] ? dataA.optOutErrorPing : dataB.optOutErrorPing,
    fontSize: dataA.fontSize[1] >= dataB.fontSize[1] ? dataA.fontSize : dataB.fontSize,
    highContrast: dataA.highContrast[1] >= dataB.highContrast[1] ? dataA.highContrast : dataB.highContrast,
    reducedMotion: dataA.reducedMotion[1] >= dataB.reducedMotion[1] ? dataA.reducedMotion : dataB.reducedMotion,
    focusIndicatorStyle: dataA.focusIndicatorStyle[1] >= dataB.focusIndicatorStyle[1] ? dataA.focusIndicatorStyle : dataB.focusIndicatorStyle,
    audioEnabled: dataA.audioEnabled[1] >= dataB.audioEnabled[1] ? dataA.audioEnabled : dataB.audioEnabled
  };
}
function mergeNavigationState(dataA, dataB) {
  return dataA.lastUpdated >= dataB.lastUpdated ? dataA : dataB;
}
function mergeCombinedComponentProgress(dataA, dataB) {
  const mergedComponents = {};
  for (const [componentId, progA] of Object.entries(dataA.components)) {
    const progB = dataB.components[componentId];
    mergedComponents[componentId] = progA.lastUpdated >= progB.lastUpdated ? progA : progB;
  }
  return { components: mergedComponents };
}
function mergeBundles(bundleA, bundleB) {
  console.log("Merging bundles using timestamp-based conflict resolution");
  return {
    // Metadata from primary bundle (webId should be identical in both)
    metadata: bundleA.metadata,
    // Merge user data sections using timestamps
    overallProgress: mergeOverallProgress(
      bundleA.overallProgress,
      bundleB.overallProgress
    ),
    settings: mergeSettings(
      bundleA.settings,
      bundleB.settings
    ),
    navigationState: mergeNavigationState(
      bundleA.navigationState,
      bundleB.navigationState
    ),
    combinedComponentProgress: mergeCombinedComponentProgress(
      bundleA.combinedComponentProgress,
      bundleB.combinedComponentProgress
    )
  };
}

// src/ts/persistence/schemaVersion.ts
var CURRENT_SCHEMA_VERSION = {
  major: 1,
  minor: 0,
  patch: 0
};

// src/ts/initialization/escapeHatch.ts
async function makeEscapeHatchBackup(rawJson) {
  try {
    const existingBackups = await listEscapeHatchBackups();
    if (existingBackups.length > 0) {
      const mostRecent = existingBackups[0];
      const age = Date.now() - mostRecent.timestamp;
      if (age < MIN_INTERVAL_MS) {
        console.log("Skipping escape hatch: recent backup exists (< 1 hour old)");
        return;
      }
    }
    const timestamp2 = Date.now();
    const filename = generateEscapeHatchFilename(timestamp2);
    const { MeraBridge: MeraBridge2 } = await Promise.resolve().then(() => (init_meraBridge(), meraBridge_exports));
    const bridge = MeraBridge2.getInstance();
    const result = await bridge.solidSave(filename, rawJson);
    if (!result.success) {
      console.error("Failed to create escape hatch backup:", result.error);
      return;
    }
    console.log(`Escape hatch backup created: ${filename}`);
    cleanupOldEscapeHatches(existingBackups.length + 1, existingBackups).catch((err) => {
      console.error("Escape hatch cleanup failed:", err);
    });
  } catch (err) {
    console.error("Escape hatch backup failed:", err);
  }
}
var MAX_ESCAPE_HATCHES = 20;
var MIN_INTERVAL_MS = 60 * 60 * 1e3;
function generateEscapeHatchFilename(timestamp2) {
  const v = CURRENT_SCHEMA_VERSION;
  return `mera.${v.major}.${v.minor}.${v.patch}.ehb.${timestamp2}.json`;
}
async function listEscapeHatchBackups() {
  const { MeraBridge: MeraBridge2 } = await Promise.resolve().then(() => (init_meraBridge(), meraBridge_exports));
  const bridge = MeraBridge2.getInstance();
  const result = await bridge.solidList("mera.*.*.*.ehb.*.json");
  if (!result.success || !result.data) {
    if (!result.success) {
      console.warn("Failed to list escape hatch backups:", result.error);
    }
    return [];
  }
  const backups = result.data.map((filename) => {
    const match = filename.match(/\.(\d+)\.json$/);
    if (!match) {
      console.warn(`Invalid escape hatch filename: ${filename}`);
      return null;
    }
    return {
      filename,
      timestamp: parseInt(match[1], 10)
    };
  }).filter((b) => b !== null);
  backups.sort((a, b) => b.timestamp - a.timestamp);
  return backups;
}
async function cleanupOldEscapeHatches(currentCount, existingBackups) {
  if (currentCount <= MAX_ESCAPE_HATCHES) {
    console.log(`Escape hatch cleanup: ${currentCount} backups, under limit`);
    return;
  }
  const numToDelete = currentCount - MAX_ESCAPE_HATCHES;
  const toDelete = existingBackups.slice(-numToDelete);
  console.log(`Escape hatch cleanup: deleting ${toDelete.length} old backups`);
  const { MeraBridge: MeraBridge2 } = await Promise.resolve().then(() => (init_meraBridge(), meraBridge_exports));
  const bridge = MeraBridge2.getInstance();
  for (const backup of toDelete) {
    const result = await bridge.solidDelete(backup.filename);
    if (!result.success) {
      console.error(`Failed to delete escape hatch ${backup.filename}:`, result.error);
    }
  }
  console.log("Escape hatch cleanup complete");
}

// src/ts/initialization/progressLoader.ts
async function orchestrateProgressLoading(lessonConfigs) {
  console.log("Starting progress loading orchestration");
  const { MeraBridge: MeraBridge2 } = await Promise.resolve().then(() => (init_meraBridge(), meraBridge_exports));
  const bridge = MeraBridge2.getInstance();
  const webId = bridge.getWebId();
  if (!webId) {
    console.error("No webId available - user not authenticated");
    return null;
  }
  console.log(
    `Loading progress for webId: ${webId}, with ${lessonConfigs.size} lesson configs`
  );
  const podBackups = await listPodBackups();
  const localBackups = await listLocalStorageBackups();
  console.log(
    `Found ${podBackups.length} Pod backups, ${localBackups.length} localStorage backups`
  );
  let mostRecentPodJson = null;
  if (podBackups.length > 0) {
    const primaryBackup = podBackups.find((b) => b.filename.includes(".sp."));
    if (primaryBackup) {
      const data = await loadBackupData(primaryBackup);
      if (data && typeof data === "string") {
        mostRecentPodJson = data;
        console.log(`Captured escape hatch source: ${primaryBackup.filename}`);
      } else {
        console.warn(
          "Failed to capture escape hatch source: invalid data type or load failure"
        );
      }
    }
  }
  let possiblyDestructiveLoad = false;
  let mergeWasPerformed = false;
  let hadWebIdMismatch = false;
  let hadLoadFailures = false;
  const result = await selectBestBackup(
    podBackups,
    localBackups,
    webId,
    lessonConfigs,
    // Pass callbacks to capture escape hatch triggers
    (wasDestructive) => {
      possiblyDestructiveLoad = wasDestructive;
    },
    () => {
      mergeWasPerformed = true;
    },
    // Pass callbacks to track scenario classification
    () => {
      hadWebIdMismatch = true;
    },
    () => {
      hadLoadFailures = true;
    }
  );
  if (!result) {
    console.error("No valid backups available");
    const noBackupsScenario = classifyNoBackupsScenario(
      podBackups.length + localBackups.length,
      hadWebIdMismatch,
      hadLoadFailures
    );
    return {
      scenario: noBackupsScenario,
      mergeOccurred: false,
      bundle: null,
      // No bundle when no backups (orchestrator handles this)
      recoveryMetrics: null
      // No metrics when no backups
    };
  }
  if ((possiblyDestructiveLoad || mergeWasPerformed) && mostRecentPodJson) {
    makeEscapeHatchBackup(mostRecentPodJson).catch((err) => {
      console.error("Failed to create escape hatch backup:", err);
    });
  }
  const scenario = classifyRecoveryScenario(result, mergeWasPerformed);
  console.log("Progress loading complete:", {
    scenario,
    mergeOccurred: mergeWasPerformed,
    perfectlyValidInput: result.perfectlyValidInput,
    lessonsLostToCorruption: result.recoveryMetrics.overallProgress.lessonsLostToCorruption,
    lessonsDroppedRatio: result.recoveryMetrics.overallProgress.lessonsDroppedRatio,
    componentsDefaulted: result.recoveryMetrics.combinedComponentProgress.componentsDefaulted
  });
  return {
    scenario,
    mergeOccurred: mergeWasPerformed,
    bundle: result.bundle,
    recoveryMetrics: result.recoveryMetrics
  };
}
function classifyNoBackupsScenario(totalBackups, hadWebIdMismatch, hadLoadFailures) {
  if (totalBackups === 0) {
    return "DEFAULT_NO_SAVES" /* DEFAULT_NO_SAVES */;
  }
  if (hadWebIdMismatch) {
    return "DEFAULT_WEBID_MISMATCH" /* DEFAULT_WEBID_MISMATCH */;
  }
  return "DEFAULT_FAILED_RECOVERY" /* DEFAULT_FAILED_RECOVERY */;
}
function classifyRecoveryScenario(result, mergeOccurred) {
  if (result.perfectlyValidInput) {
    return "PERFECT_RECOVERY" /* PERFECT_RECOVERY */;
  }
  if (result.recoveryMetrics.overallProgress.corruptionDetected) {
    return "IMPERFECT_RECOVERY_CORRUPTION" /* IMPERFECT_RECOVERY_CORRUPTION */;
  }
  return "IMPERFECT_RECOVERY_MIGRATION" /* IMPERFECT_RECOVERY_MIGRATION */;
}
var SCORING = {
  /** Per lesson lost to corruption (counter mismatch) */
  LESSON_LOST: 2e4,
  /** Per lesson removed from curriculum (reconciliation) */
  LESSON_DEFAULTED: 1e3,
  /** Baseline penalty for any settings defaulted */
  SETTINGS_BASELINE: 1e3,
  /** Additional proportional penalty for settings (scaled by ratio) */
  SETTINGS_PROPORTIONAL: 4e3,
  /** Per component defaulted (migration or corruption) */
  COMPONENT_DEFAULTED: 5,
  /** Per backup step back in time (recency tie-breaker) */
  BACKUP_STEP: 500,
  /** Quality threshold - above this, check localStorage as backup source */
  QUALITY_THRESHOLD: 1e3
};
function parseBackupFilename(filename, source) {
  const match = filename.match(/\.(\d+)\.json$/);
  if (!match) {
    throw new Error(`Invalid backup filename format: ${filename}`);
  }
  const timestamp2 = parseInt(match[1], 10);
  return {
    filename,
    timestamp: timestamp2,
    source,
    data: null
    // Will load when scoring
  };
}
async function loadBackupData(backup) {
  const { MeraBridge: MeraBridge2 } = await Promise.resolve().then(() => (init_meraBridge(), meraBridge_exports));
  const bridge = MeraBridge2.getInstance();
  const loadFn = backup.source === "pod" ? bridge.solidLoad : bridge.localLoad;
  const result = await loadFn.call(bridge, backup.filename);
  if (!result.success || !result.data) {
    console.error(`Failed to load backup ${backup.filename}:`, result.error);
    return null;
  }
  return result.data;
}
async function listPodBackups() {
  const { MeraBridge: MeraBridge2 } = await Promise.resolve().then(() => (init_meraBridge(), meraBridge_exports));
  const bridge = MeraBridge2.getInstance();
  const primaryResult = await bridge.solidList("mera.*.*.*.sp.*.json");
  const duplicateResult = await bridge.solidList("mera.*.*.*.sd.*.json");
  const allBackups = [];
  if (primaryResult.success && primaryResult.data) {
    const primaryBackups = primaryResult.data.map(
      (filename) => parseBackupFilename(filename, "pod")
    );
    allBackups.push(...primaryBackups);
  } else if (!primaryResult.success) {
    console.error("Failed to list Pod primary backups:", primaryResult.error);
  }
  if (duplicateResult.success && duplicateResult.data) {
    const duplicateBackups = duplicateResult.data.map(
      (filename) => parseBackupFilename(filename, "pod")
    );
    allBackups.push(...duplicateBackups);
  } else if (!duplicateResult.success) {
    console.error(
      "Failed to list Pod duplicate backups:",
      duplicateResult.error
    );
  }
  allBackups.sort((a, b) => b.timestamp - a.timestamp);
  return allBackups;
}
async function listLocalStorageBackups() {
  const { MeraBridge: MeraBridge2 } = await Promise.resolve().then(() => (init_meraBridge(), meraBridge_exports));
  const bridge = MeraBridge2.getInstance();
  const offlinePrimaryResult = await bridge.localList("mera.*.*.*.lofp.*.json");
  const offlineDuplicateResult = await bridge.localList(
    "mera.*.*.*.lofd.*.json"
  );
  const onlinePrimaryResult = await bridge.localList("mera.*.*.*.lonp.*.json");
  const onlineDuplicateResult = await bridge.localList(
    "mera.*.*.*.lond.*.json"
  );
  const allBackups = [];
  if (offlinePrimaryResult.success && offlinePrimaryResult.data) {
    const backups = offlinePrimaryResult.data.map(
      (filename) => parseBackupFilename(filename, "localStorage")
    );
    allBackups.push(...backups);
  } else if (!offlinePrimaryResult.success) {
    console.error(
      "Failed to list offline primary localStorage backups:",
      offlinePrimaryResult.error
    );
  }
  if (offlineDuplicateResult.success && offlineDuplicateResult.data) {
    const backups = offlineDuplicateResult.data.map(
      (filename) => parseBackupFilename(filename, "localStorage")
    );
    allBackups.push(...backups);
  } else if (!offlineDuplicateResult.success) {
    console.error(
      "Failed to list offline duplicate localStorage backups:",
      offlineDuplicateResult.error
    );
  }
  if (onlinePrimaryResult.success && onlinePrimaryResult.data) {
    const backups = onlinePrimaryResult.data.map(
      (filename) => parseBackupFilename(filename, "localStorage")
    );
    allBackups.push(...backups);
  } else if (!onlinePrimaryResult.success) {
    console.error(
      "Failed to list online primary localStorage backups:",
      onlinePrimaryResult.error
    );
  }
  if (onlineDuplicateResult.success && onlineDuplicateResult.data) {
    const backups = onlineDuplicateResult.data.map(
      (filename) => parseBackupFilename(filename, "localStorage")
    );
    allBackups.push(...backups);
  } else if (!onlineDuplicateResult.success) {
    console.error(
      "Failed to list online duplicate localStorage backups:",
      onlineDuplicateResult.error
    );
  }
  allBackups.sort((a, b) => b.timestamp - a.timestamp);
  return allBackups;
}
function scoreBackup(result, backupIndex) {
  if (result.perfectlyValidInput) {
    return 0;
  }
  let score = 0;
  score += backupIndex * SCORING.BACKUP_STEP;
  score += result.recoveryMetrics.overallProgress.lessonsLostToCorruption * SCORING.LESSON_LOST;
  score += result.recoveryMetrics.overallProgress.lessonsDroppedCount * SCORING.LESSON_DEFAULTED;
  if (result.recoveryMetrics.settings.defaultedRatio > 0) {
    const settingsBaseline = SCORING.SETTINGS_BASELINE;
    const settingsProportional = Math.round(
      result.recoveryMetrics.settings.defaultedRatio * SCORING.SETTINGS_PROPORTIONAL
    );
    score += settingsBaseline + settingsProportional;
  }
  score += result.recoveryMetrics.combinedComponentProgress.componentsDefaulted * SCORING.COMPONENT_DEFAULTED;
  return score;
}
async function scoreSortedBackups(backups, webId, lessonConfigs, onImperfectBackup, onWebIdMismatch, onLoadFailure) {
  if (backups.length === 0) {
    return null;
  }
  let bestResult = null;
  let bestScore = Infinity;
  for (let i = 0; i < backups.length; i++) {
    const backup = backups[i];
    const data = await loadBackupData(backup);
    if (!data) {
      console.warn(`Skipping backup ${backup.filename}: failed to load`);
      if (onLoadFailure) onLoadFailure();
      continue;
    }
    if (typeof data !== "string") {
      throw new Error(
        `meraBridge returned non-string data for ${backup.filename}. This is a bug in meraBridge. Expected string, got ${typeof data}`
      );
    }
    const result = enforceDataIntegrity(data, webId, lessonConfigs);
    if (result.criticalFailures.webIdMismatch) {
      console.warn(`Backup ${backup.filename} is for different user, skipping`);
      if (onWebIdMismatch) onWebIdMismatch();
      continue;
    }
    const score = scoreBackup(result, i);
    if (!result.perfectlyValidInput && onImperfectBackup) {
      onImperfectBackup(true);
    }
    if (score === 0) {
      console.log(`Perfect backup found: ${backup.filename}`);
      return { result, score, backup };
    }
    if (score < bestScore) {
      bestScore = score;
      bestResult = { result, score, backup };
    }
  }
  if (bestResult) {
    console.log(
      `Best backup: ${bestResult.backup.filename} (score: ${bestResult.score})`
    );
  }
  return bestResult;
}
function hasOfflineTag(backup) {
  return backup.filename.includes(".lofp.");
}
async function validateAndMerge(primary, secondary, webId, lessonConfigs) {
  console.log(
    `Merging ${primary.backup.filename} + ${secondary.backup.filename}`
  );
  const mergedBundle = mergeBundles(
    primary.result.bundle,
    secondary.result.bundle
  );
  const mergedJson = JSON.stringify(mergedBundle);
  const finalResult = enforceDataIntegrity(mergedJson, webId, lessonConfigs);
  if (finalResult.recoveryMetrics.overallProgress.corruptionDetected) {
    throw new Error(
      `Merge created corruption (counter mismatch). This is a bug in progressMerger.ts. Primary: ${primary.backup.filename}, Secondary: ${secondary.backup.filename}, Corruption: ${finalResult.recoveryMetrics.overallProgress.lessonsLostToCorruption} lessons lost`
    );
  }
  console.log("Merge successful");
  return finalResult;
}
async function selectBestBackup(podBackups, localBackups, webId, lessonConfigs, onDestructive, onMerge, onWebIdMismatch, onLoadFailure) {
  const bestPod = await scoreSortedBackups(
    podBackups,
    webId,
    lessonConfigs,
    onDestructive,
    // Flag if imperfect
    onWebIdMismatch,
    onLoadFailure
  );
  const bestLocal = await scoreSortedBackups(
    localBackups,
    webId,
    lessonConfigs,
    void 0,
    // Don't track localStorage imperfections for escape hatch
    onWebIdMismatch,
    onLoadFailure
  );
  if (!bestPod && !bestLocal) {
    console.error("No valid backups found in either Pod or localStorage");
    return null;
  }
  if (!bestPod) {
    console.log("No valid Pod backups, using localStorage");
    return bestLocal.result;
  }
  if (!bestLocal) {
    console.log("No valid localStorage backups, using Pod");
    return bestPod.result;
  }
  if (bestPod.score < SCORING.QUALITY_THRESHOLD) {
    if (hasOfflineTag(bestLocal.backup)) {
      console.log("Good Pod backup + offline work detected, merging");
      if (onMerge) onMerge();
      return validateAndMerge(bestPod, bestLocal, webId, lessonConfigs);
    }
    console.log("Good Pod backup, no offline work, using Pod");
    return bestPod.result;
  }
  console.log("Pod backup has quality issues, merging with localStorage");
  if (onMerge) onMerge();
  return validateAndMerge(bestLocal, bestPod, webId, lessonConfigs);
}

// node_modules/js-yaml/dist/js-yaml.mjs
function isNothing(subject) {
  return typeof subject === "undefined" || subject === null;
}
function isObject3(subject) {
  return typeof subject === "object" && subject !== null;
}
function toArray(sequence) {
  if (Array.isArray(sequence)) return sequence;
  else if (isNothing(sequence)) return [];
  return [sequence];
}
function extend2(target, source) {
  var index, length, key, sourceKeys;
  if (source) {
    sourceKeys = Object.keys(source);
    for (index = 0, length = sourceKeys.length; index < length; index += 1) {
      key = sourceKeys[index];
      target[key] = source[key];
    }
  }
  return target;
}
function repeat(string4, count) {
  var result = "", cycle;
  for (cycle = 0; cycle < count; cycle += 1) {
    result += string4;
  }
  return result;
}
function isNegativeZero(number4) {
  return number4 === 0 && Number.NEGATIVE_INFINITY === 1 / number4;
}
var isNothing_1 = isNothing;
var isObject_1 = isObject3;
var toArray_1 = toArray;
var repeat_1 = repeat;
var isNegativeZero_1 = isNegativeZero;
var extend_1 = extend2;
var common = {
  isNothing: isNothing_1,
  isObject: isObject_1,
  toArray: toArray_1,
  repeat: repeat_1,
  isNegativeZero: isNegativeZero_1,
  extend: extend_1
};
function formatError2(exception2, compact) {
  var where = "", message2 = exception2.reason || "(unknown reason)";
  if (!exception2.mark) return message2;
  if (exception2.mark.name) {
    where += 'in "' + exception2.mark.name + '" ';
  }
  where += "(" + (exception2.mark.line + 1) + ":" + (exception2.mark.column + 1) + ")";
  if (!compact && exception2.mark.snippet) {
    where += "\n\n" + exception2.mark.snippet;
  }
  return message2 + " " + where;
}
function YAMLException$1(reason, mark) {
  Error.call(this);
  this.name = "YAMLException";
  this.reason = reason;
  this.mark = mark;
  this.message = formatError2(this, false);
  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, this.constructor);
  } else {
    this.stack = new Error().stack || "";
  }
}
YAMLException$1.prototype = Object.create(Error.prototype);
YAMLException$1.prototype.constructor = YAMLException$1;
YAMLException$1.prototype.toString = function toString(compact) {
  return this.name + ": " + formatError2(this, compact);
};
var exception = YAMLException$1;
function getLine(buffer, lineStart, lineEnd, position, maxLineLength) {
  var head = "";
  var tail = "";
  var maxHalfLength = Math.floor(maxLineLength / 2) - 1;
  if (position - lineStart > maxHalfLength) {
    head = " ... ";
    lineStart = position - maxHalfLength + head.length;
  }
  if (lineEnd - position > maxHalfLength) {
    tail = " ...";
    lineEnd = position + maxHalfLength - tail.length;
  }
  return {
    str: head + buffer.slice(lineStart, lineEnd).replace(/\t/g, "\u2192") + tail,
    pos: position - lineStart + head.length
    // relative position
  };
}
function padStart(string4, max) {
  return common.repeat(" ", max - string4.length) + string4;
}
function makeSnippet(mark, options) {
  options = Object.create(options || null);
  if (!mark.buffer) return null;
  if (!options.maxLength) options.maxLength = 79;
  if (typeof options.indent !== "number") options.indent = 1;
  if (typeof options.linesBefore !== "number") options.linesBefore = 3;
  if (typeof options.linesAfter !== "number") options.linesAfter = 2;
  var re = /\r?\n|\r|\0/g;
  var lineStarts = [0];
  var lineEnds = [];
  var match;
  var foundLineNo = -1;
  while (match = re.exec(mark.buffer)) {
    lineEnds.push(match.index);
    lineStarts.push(match.index + match[0].length);
    if (mark.position <= match.index && foundLineNo < 0) {
      foundLineNo = lineStarts.length - 2;
    }
  }
  if (foundLineNo < 0) foundLineNo = lineStarts.length - 1;
  var result = "", i, line;
  var lineNoLength = Math.min(mark.line + options.linesAfter, lineEnds.length).toString().length;
  var maxLineLength = options.maxLength - (options.indent + lineNoLength + 3);
  for (i = 1; i <= options.linesBefore; i++) {
    if (foundLineNo - i < 0) break;
    line = getLine(
      mark.buffer,
      lineStarts[foundLineNo - i],
      lineEnds[foundLineNo - i],
      mark.position - (lineStarts[foundLineNo] - lineStarts[foundLineNo - i]),
      maxLineLength
    );
    result = common.repeat(" ", options.indent) + padStart((mark.line - i + 1).toString(), lineNoLength) + " | " + line.str + "\n" + result;
  }
  line = getLine(mark.buffer, lineStarts[foundLineNo], lineEnds[foundLineNo], mark.position, maxLineLength);
  result += common.repeat(" ", options.indent) + padStart((mark.line + 1).toString(), lineNoLength) + " | " + line.str + "\n";
  result += common.repeat("-", options.indent + lineNoLength + 3 + line.pos) + "^\n";
  for (i = 1; i <= options.linesAfter; i++) {
    if (foundLineNo + i >= lineEnds.length) break;
    line = getLine(
      mark.buffer,
      lineStarts[foundLineNo + i],
      lineEnds[foundLineNo + i],
      mark.position - (lineStarts[foundLineNo] - lineStarts[foundLineNo + i]),
      maxLineLength
    );
    result += common.repeat(" ", options.indent) + padStart((mark.line + i + 1).toString(), lineNoLength) + " | " + line.str + "\n";
  }
  return result.replace(/\n$/, "");
}
var snippet = makeSnippet;
var TYPE_CONSTRUCTOR_OPTIONS = [
  "kind",
  "multi",
  "resolve",
  "construct",
  "instanceOf",
  "predicate",
  "represent",
  "representName",
  "defaultStyle",
  "styleAliases"
];
var YAML_NODE_KINDS = [
  "scalar",
  "sequence",
  "mapping"
];
function compileStyleAliases(map3) {
  var result = {};
  if (map3 !== null) {
    Object.keys(map3).forEach(function(style) {
      map3[style].forEach(function(alias) {
        result[String(alias)] = style;
      });
    });
  }
  return result;
}
function Type$1(tag2, options) {
  options = options || {};
  Object.keys(options).forEach(function(name) {
    if (TYPE_CONSTRUCTOR_OPTIONS.indexOf(name) === -1) {
      throw new exception('Unknown option "' + name + '" is met in definition of "' + tag2 + '" YAML type.');
    }
  });
  this.options = options;
  this.tag = tag2;
  this.kind = options["kind"] || null;
  this.resolve = options["resolve"] || function() {
    return true;
  };
  this.construct = options["construct"] || function(data) {
    return data;
  };
  this.instanceOf = options["instanceOf"] || null;
  this.predicate = options["predicate"] || null;
  this.represent = options["represent"] || null;
  this.representName = options["representName"] || null;
  this.defaultStyle = options["defaultStyle"] || null;
  this.multi = options["multi"] || false;
  this.styleAliases = compileStyleAliases(options["styleAliases"] || null);
  if (YAML_NODE_KINDS.indexOf(this.kind) === -1) {
    throw new exception('Unknown kind "' + this.kind + '" is specified for "' + tag2 + '" YAML type.');
  }
}
var type = Type$1;
function compileList(schema2, name) {
  var result = [];
  schema2[name].forEach(function(currentType) {
    var newIndex = result.length;
    result.forEach(function(previousType, previousIndex) {
      if (previousType.tag === currentType.tag && previousType.kind === currentType.kind && previousType.multi === currentType.multi) {
        newIndex = previousIndex;
      }
    });
    result[newIndex] = currentType;
  });
  return result;
}
function compileMap() {
  var result = {
    scalar: {},
    sequence: {},
    mapping: {},
    fallback: {},
    multi: {
      scalar: [],
      sequence: [],
      mapping: [],
      fallback: []
    }
  }, index, length;
  function collectType(type2) {
    if (type2.multi) {
      result.multi[type2.kind].push(type2);
      result.multi["fallback"].push(type2);
    } else {
      result[type2.kind][type2.tag] = result["fallback"][type2.tag] = type2;
    }
  }
  for (index = 0, length = arguments.length; index < length; index += 1) {
    arguments[index].forEach(collectType);
  }
  return result;
}
function Schema$1(definition) {
  return this.extend(definition);
}
Schema$1.prototype.extend = function extend3(definition) {
  var implicit = [];
  var explicit = [];
  if (definition instanceof type) {
    explicit.push(definition);
  } else if (Array.isArray(definition)) {
    explicit = explicit.concat(definition);
  } else if (definition && (Array.isArray(definition.implicit) || Array.isArray(definition.explicit))) {
    if (definition.implicit) implicit = implicit.concat(definition.implicit);
    if (definition.explicit) explicit = explicit.concat(definition.explicit);
  } else {
    throw new exception("Schema.extend argument should be a Type, [ Type ], or a schema definition ({ implicit: [...], explicit: [...] })");
  }
  implicit.forEach(function(type$1) {
    if (!(type$1 instanceof type)) {
      throw new exception("Specified list of YAML types (or a single Type object) contains a non-Type object.");
    }
    if (type$1.loadKind && type$1.loadKind !== "scalar") {
      throw new exception("There is a non-scalar type in the implicit list of a schema. Implicit resolving of such types is not supported.");
    }
    if (type$1.multi) {
      throw new exception("There is a multi type in the implicit list of a schema. Multi tags can only be listed as explicit.");
    }
  });
  explicit.forEach(function(type$1) {
    if (!(type$1 instanceof type)) {
      throw new exception("Specified list of YAML types (or a single Type object) contains a non-Type object.");
    }
  });
  var result = Object.create(Schema$1.prototype);
  result.implicit = (this.implicit || []).concat(implicit);
  result.explicit = (this.explicit || []).concat(explicit);
  result.compiledImplicit = compileList(result, "implicit");
  result.compiledExplicit = compileList(result, "explicit");
  result.compiledTypeMap = compileMap(result.compiledImplicit, result.compiledExplicit);
  return result;
};
var schema = Schema$1;
var str = new type("tag:yaml.org,2002:str", {
  kind: "scalar",
  construct: function(data) {
    return data !== null ? data : "";
  }
});
var seq = new type("tag:yaml.org,2002:seq", {
  kind: "sequence",
  construct: function(data) {
    return data !== null ? data : [];
  }
});
var map2 = new type("tag:yaml.org,2002:map", {
  kind: "mapping",
  construct: function(data) {
    return data !== null ? data : {};
  }
});
var failsafe = new schema({
  explicit: [
    str,
    seq,
    map2
  ]
});
function resolveYamlNull(data) {
  if (data === null) return true;
  var max = data.length;
  return max === 1 && data === "~" || max === 4 && (data === "null" || data === "Null" || data === "NULL");
}
function constructYamlNull() {
  return null;
}
function isNull(object2) {
  return object2 === null;
}
var _null4 = new type("tag:yaml.org,2002:null", {
  kind: "scalar",
  resolve: resolveYamlNull,
  construct: constructYamlNull,
  predicate: isNull,
  represent: {
    canonical: function() {
      return "~";
    },
    lowercase: function() {
      return "null";
    },
    uppercase: function() {
      return "NULL";
    },
    camelcase: function() {
      return "Null";
    },
    empty: function() {
      return "";
    }
  },
  defaultStyle: "lowercase"
});
function resolveYamlBoolean(data) {
  if (data === null) return false;
  var max = data.length;
  return max === 4 && (data === "true" || data === "True" || data === "TRUE") || max === 5 && (data === "false" || data === "False" || data === "FALSE");
}
function constructYamlBoolean(data) {
  return data === "true" || data === "True" || data === "TRUE";
}
function isBoolean(object2) {
  return Object.prototype.toString.call(object2) === "[object Boolean]";
}
var bool = new type("tag:yaml.org,2002:bool", {
  kind: "scalar",
  resolve: resolveYamlBoolean,
  construct: constructYamlBoolean,
  predicate: isBoolean,
  represent: {
    lowercase: function(object2) {
      return object2 ? "true" : "false";
    },
    uppercase: function(object2) {
      return object2 ? "TRUE" : "FALSE";
    },
    camelcase: function(object2) {
      return object2 ? "True" : "False";
    }
  },
  defaultStyle: "lowercase"
});
function isHexCode(c) {
  return 48 <= c && c <= 57 || 65 <= c && c <= 70 || 97 <= c && c <= 102;
}
function isOctCode(c) {
  return 48 <= c && c <= 55;
}
function isDecCode(c) {
  return 48 <= c && c <= 57;
}
function resolveYamlInteger(data) {
  if (data === null) return false;
  var max = data.length, index = 0, hasDigits = false, ch;
  if (!max) return false;
  ch = data[index];
  if (ch === "-" || ch === "+") {
    ch = data[++index];
  }
  if (ch === "0") {
    if (index + 1 === max) return true;
    ch = data[++index];
    if (ch === "b") {
      index++;
      for (; index < max; index++) {
        ch = data[index];
        if (ch === "_") continue;
        if (ch !== "0" && ch !== "1") return false;
        hasDigits = true;
      }
      return hasDigits && ch !== "_";
    }
    if (ch === "x") {
      index++;
      for (; index < max; index++) {
        ch = data[index];
        if (ch === "_") continue;
        if (!isHexCode(data.charCodeAt(index))) return false;
        hasDigits = true;
      }
      return hasDigits && ch !== "_";
    }
    if (ch === "o") {
      index++;
      for (; index < max; index++) {
        ch = data[index];
        if (ch === "_") continue;
        if (!isOctCode(data.charCodeAt(index))) return false;
        hasDigits = true;
      }
      return hasDigits && ch !== "_";
    }
  }
  if (ch === "_") return false;
  for (; index < max; index++) {
    ch = data[index];
    if (ch === "_") continue;
    if (!isDecCode(data.charCodeAt(index))) {
      return false;
    }
    hasDigits = true;
  }
  if (!hasDigits || ch === "_") return false;
  return true;
}
function constructYamlInteger(data) {
  var value = data, sign2 = 1, ch;
  if (value.indexOf("_") !== -1) {
    value = value.replace(/_/g, "");
  }
  ch = value[0];
  if (ch === "-" || ch === "+") {
    if (ch === "-") sign2 = -1;
    value = value.slice(1);
    ch = value[0];
  }
  if (value === "0") return 0;
  if (ch === "0") {
    if (value[1] === "b") return sign2 * parseInt(value.slice(2), 2);
    if (value[1] === "x") return sign2 * parseInt(value.slice(2), 16);
    if (value[1] === "o") return sign2 * parseInt(value.slice(2), 8);
  }
  return sign2 * parseInt(value, 10);
}
function isInteger(object2) {
  return Object.prototype.toString.call(object2) === "[object Number]" && (object2 % 1 === 0 && !common.isNegativeZero(object2));
}
var int2 = new type("tag:yaml.org,2002:int", {
  kind: "scalar",
  resolve: resolveYamlInteger,
  construct: constructYamlInteger,
  predicate: isInteger,
  represent: {
    binary: function(obj) {
      return obj >= 0 ? "0b" + obj.toString(2) : "-0b" + obj.toString(2).slice(1);
    },
    octal: function(obj) {
      return obj >= 0 ? "0o" + obj.toString(8) : "-0o" + obj.toString(8).slice(1);
    },
    decimal: function(obj) {
      return obj.toString(10);
    },
    /* eslint-disable max-len */
    hexadecimal: function(obj) {
      return obj >= 0 ? "0x" + obj.toString(16).toUpperCase() : "-0x" + obj.toString(16).toUpperCase().slice(1);
    }
  },
  defaultStyle: "decimal",
  styleAliases: {
    binary: [2, "bin"],
    octal: [8, "oct"],
    decimal: [10, "dec"],
    hexadecimal: [16, "hex"]
  }
});
var YAML_FLOAT_PATTERN = new RegExp(
  // 2.5e4, 2.5 and integers
  "^(?:[-+]?(?:[0-9][0-9_]*)(?:\\.[0-9_]*)?(?:[eE][-+]?[0-9]+)?|\\.[0-9_]+(?:[eE][-+]?[0-9]+)?|[-+]?\\.(?:inf|Inf|INF)|\\.(?:nan|NaN|NAN))$"
);
function resolveYamlFloat(data) {
  if (data === null) return false;
  if (!YAML_FLOAT_PATTERN.test(data) || // Quick hack to not allow integers end with `_`
  // Probably should update regexp & check speed
  data[data.length - 1] === "_") {
    return false;
  }
  return true;
}
function constructYamlFloat(data) {
  var value, sign2;
  value = data.replace(/_/g, "").toLowerCase();
  sign2 = value[0] === "-" ? -1 : 1;
  if ("+-".indexOf(value[0]) >= 0) {
    value = value.slice(1);
  }
  if (value === ".inf") {
    return sign2 === 1 ? Number.POSITIVE_INFINITY : Number.NEGATIVE_INFINITY;
  } else if (value === ".nan") {
    return NaN;
  }
  return sign2 * parseFloat(value, 10);
}
var SCIENTIFIC_WITHOUT_DOT = /^[-+]?[0-9]+e/;
function representYamlFloat(object2, style) {
  var res;
  if (isNaN(object2)) {
    switch (style) {
      case "lowercase":
        return ".nan";
      case "uppercase":
        return ".NAN";
      case "camelcase":
        return ".NaN";
    }
  } else if (Number.POSITIVE_INFINITY === object2) {
    switch (style) {
      case "lowercase":
        return ".inf";
      case "uppercase":
        return ".INF";
      case "camelcase":
        return ".Inf";
    }
  } else if (Number.NEGATIVE_INFINITY === object2) {
    switch (style) {
      case "lowercase":
        return "-.inf";
      case "uppercase":
        return "-.INF";
      case "camelcase":
        return "-.Inf";
    }
  } else if (common.isNegativeZero(object2)) {
    return "-0.0";
  }
  res = object2.toString(10);
  return SCIENTIFIC_WITHOUT_DOT.test(res) ? res.replace("e", ".e") : res;
}
function isFloat(object2) {
  return Object.prototype.toString.call(object2) === "[object Number]" && (object2 % 1 !== 0 || common.isNegativeZero(object2));
}
var float = new type("tag:yaml.org,2002:float", {
  kind: "scalar",
  resolve: resolveYamlFloat,
  construct: constructYamlFloat,
  predicate: isFloat,
  represent: representYamlFloat,
  defaultStyle: "lowercase"
});
var json2 = failsafe.extend({
  implicit: [
    _null4,
    bool,
    int2,
    float
  ]
});
var core = json2;
var YAML_DATE_REGEXP = new RegExp(
  "^([0-9][0-9][0-9][0-9])-([0-9][0-9])-([0-9][0-9])$"
);
var YAML_TIMESTAMP_REGEXP = new RegExp(
  "^([0-9][0-9][0-9][0-9])-([0-9][0-9]?)-([0-9][0-9]?)(?:[Tt]|[ \\t]+)([0-9][0-9]?):([0-9][0-9]):([0-9][0-9])(?:\\.([0-9]*))?(?:[ \\t]*(Z|([-+])([0-9][0-9]?)(?::([0-9][0-9]))?))?$"
);
function resolveYamlTimestamp(data) {
  if (data === null) return false;
  if (YAML_DATE_REGEXP.exec(data) !== null) return true;
  if (YAML_TIMESTAMP_REGEXP.exec(data) !== null) return true;
  return false;
}
function constructYamlTimestamp(data) {
  var match, year2, month, day2, hour2, minute2, second, fraction = 0, delta = null, tz_hour, tz_minute, date5;
  match = YAML_DATE_REGEXP.exec(data);
  if (match === null) match = YAML_TIMESTAMP_REGEXP.exec(data);
  if (match === null) throw new Error("Date resolve error");
  year2 = +match[1];
  month = +match[2] - 1;
  day2 = +match[3];
  if (!match[4]) {
    return new Date(Date.UTC(year2, month, day2));
  }
  hour2 = +match[4];
  minute2 = +match[5];
  second = +match[6];
  if (match[7]) {
    fraction = match[7].slice(0, 3);
    while (fraction.length < 3) {
      fraction += "0";
    }
    fraction = +fraction;
  }
  if (match[9]) {
    tz_hour = +match[10];
    tz_minute = +(match[11] || 0);
    delta = (tz_hour * 60 + tz_minute) * 6e4;
    if (match[9] === "-") delta = -delta;
  }
  date5 = new Date(Date.UTC(year2, month, day2, hour2, minute2, second, fraction));
  if (delta) date5.setTime(date5.getTime() - delta);
  return date5;
}
function representYamlTimestamp(object2) {
  return object2.toISOString();
}
var timestamp = new type("tag:yaml.org,2002:timestamp", {
  kind: "scalar",
  resolve: resolveYamlTimestamp,
  construct: constructYamlTimestamp,
  instanceOf: Date,
  represent: representYamlTimestamp
});
function resolveYamlMerge(data) {
  return data === "<<" || data === null;
}
var merge3 = new type("tag:yaml.org,2002:merge", {
  kind: "scalar",
  resolve: resolveYamlMerge
});
var BASE64_MAP = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\n\r";
function resolveYamlBinary(data) {
  if (data === null) return false;
  var code, idx, bitlen = 0, max = data.length, map3 = BASE64_MAP;
  for (idx = 0; idx < max; idx++) {
    code = map3.indexOf(data.charAt(idx));
    if (code > 64) continue;
    if (code < 0) return false;
    bitlen += 6;
  }
  return bitlen % 8 === 0;
}
function constructYamlBinary(data) {
  var idx, tailbits, input = data.replace(/[\r\n=]/g, ""), max = input.length, map3 = BASE64_MAP, bits = 0, result = [];
  for (idx = 0; idx < max; idx++) {
    if (idx % 4 === 0 && idx) {
      result.push(bits >> 16 & 255);
      result.push(bits >> 8 & 255);
      result.push(bits & 255);
    }
    bits = bits << 6 | map3.indexOf(input.charAt(idx));
  }
  tailbits = max % 4 * 6;
  if (tailbits === 0) {
    result.push(bits >> 16 & 255);
    result.push(bits >> 8 & 255);
    result.push(bits & 255);
  } else if (tailbits === 18) {
    result.push(bits >> 10 & 255);
    result.push(bits >> 2 & 255);
  } else if (tailbits === 12) {
    result.push(bits >> 4 & 255);
  }
  return new Uint8Array(result);
}
function representYamlBinary(object2) {
  var result = "", bits = 0, idx, tail, max = object2.length, map3 = BASE64_MAP;
  for (idx = 0; idx < max; idx++) {
    if (idx % 3 === 0 && idx) {
      result += map3[bits >> 18 & 63];
      result += map3[bits >> 12 & 63];
      result += map3[bits >> 6 & 63];
      result += map3[bits & 63];
    }
    bits = (bits << 8) + object2[idx];
  }
  tail = max % 3;
  if (tail === 0) {
    result += map3[bits >> 18 & 63];
    result += map3[bits >> 12 & 63];
    result += map3[bits >> 6 & 63];
    result += map3[bits & 63];
  } else if (tail === 2) {
    result += map3[bits >> 10 & 63];
    result += map3[bits >> 4 & 63];
    result += map3[bits << 2 & 63];
    result += map3[64];
  } else if (tail === 1) {
    result += map3[bits >> 2 & 63];
    result += map3[bits << 4 & 63];
    result += map3[64];
    result += map3[64];
  }
  return result;
}
function isBinary(obj) {
  return Object.prototype.toString.call(obj) === "[object Uint8Array]";
}
var binary = new type("tag:yaml.org,2002:binary", {
  kind: "scalar",
  resolve: resolveYamlBinary,
  construct: constructYamlBinary,
  predicate: isBinary,
  represent: representYamlBinary
});
var _hasOwnProperty$3 = Object.prototype.hasOwnProperty;
var _toString$2 = Object.prototype.toString;
function resolveYamlOmap(data) {
  if (data === null) return true;
  var objectKeys = [], index, length, pair, pairKey, pairHasKey, object2 = data;
  for (index = 0, length = object2.length; index < length; index += 1) {
    pair = object2[index];
    pairHasKey = false;
    if (_toString$2.call(pair) !== "[object Object]") return false;
    for (pairKey in pair) {
      if (_hasOwnProperty$3.call(pair, pairKey)) {
        if (!pairHasKey) pairHasKey = true;
        else return false;
      }
    }
    if (!pairHasKey) return false;
    if (objectKeys.indexOf(pairKey) === -1) objectKeys.push(pairKey);
    else return false;
  }
  return true;
}
function constructYamlOmap(data) {
  return data !== null ? data : [];
}
var omap = new type("tag:yaml.org,2002:omap", {
  kind: "sequence",
  resolve: resolveYamlOmap,
  construct: constructYamlOmap
});
var _toString$1 = Object.prototype.toString;
function resolveYamlPairs(data) {
  if (data === null) return true;
  var index, length, pair, keys, result, object2 = data;
  result = new Array(object2.length);
  for (index = 0, length = object2.length; index < length; index += 1) {
    pair = object2[index];
    if (_toString$1.call(pair) !== "[object Object]") return false;
    keys = Object.keys(pair);
    if (keys.length !== 1) return false;
    result[index] = [keys[0], pair[keys[0]]];
  }
  return true;
}
function constructYamlPairs(data) {
  if (data === null) return [];
  var index, length, pair, keys, result, object2 = data;
  result = new Array(object2.length);
  for (index = 0, length = object2.length; index < length; index += 1) {
    pair = object2[index];
    keys = Object.keys(pair);
    result[index] = [keys[0], pair[keys[0]]];
  }
  return result;
}
var pairs = new type("tag:yaml.org,2002:pairs", {
  kind: "sequence",
  resolve: resolveYamlPairs,
  construct: constructYamlPairs
});
var _hasOwnProperty$2 = Object.prototype.hasOwnProperty;
function resolveYamlSet(data) {
  if (data === null) return true;
  var key, object2 = data;
  for (key in object2) {
    if (_hasOwnProperty$2.call(object2, key)) {
      if (object2[key] !== null) return false;
    }
  }
  return true;
}
function constructYamlSet(data) {
  return data !== null ? data : {};
}
var set2 = new type("tag:yaml.org,2002:set", {
  kind: "mapping",
  resolve: resolveYamlSet,
  construct: constructYamlSet
});
var _default3 = core.extend({
  implicit: [
    timestamp,
    merge3
  ],
  explicit: [
    binary,
    omap,
    pairs,
    set2
  ]
});
var _hasOwnProperty$1 = Object.prototype.hasOwnProperty;
var CONTEXT_FLOW_IN = 1;
var CONTEXT_FLOW_OUT = 2;
var CONTEXT_BLOCK_IN = 3;
var CONTEXT_BLOCK_OUT = 4;
var CHOMPING_CLIP = 1;
var CHOMPING_STRIP = 2;
var CHOMPING_KEEP = 3;
var PATTERN_NON_PRINTABLE = /[\x00-\x08\x0B\x0C\x0E-\x1F\x7F-\x84\x86-\x9F\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
var PATTERN_NON_ASCII_LINE_BREAKS = /[\x85\u2028\u2029]/;
var PATTERN_FLOW_INDICATORS = /[,\[\]\{\}]/;
var PATTERN_TAG_HANDLE = /^(?:!|!!|![a-z\-]+!)$/i;
var PATTERN_TAG_URI = /^(?:!|[^,\[\]\{\}])(?:%[0-9a-f]{2}|[0-9a-z\-#;\/\?:@&=\+\$,_\.!~\*'\(\)\[\]])*$/i;
function _class(obj) {
  return Object.prototype.toString.call(obj);
}
function is_EOL(c) {
  return c === 10 || c === 13;
}
function is_WHITE_SPACE(c) {
  return c === 9 || c === 32;
}
function is_WS_OR_EOL(c) {
  return c === 9 || c === 32 || c === 10 || c === 13;
}
function is_FLOW_INDICATOR(c) {
  return c === 44 || c === 91 || c === 93 || c === 123 || c === 125;
}
function fromHexCode(c) {
  var lc;
  if (48 <= c && c <= 57) {
    return c - 48;
  }
  lc = c | 32;
  if (97 <= lc && lc <= 102) {
    return lc - 97 + 10;
  }
  return -1;
}
function escapedHexLen(c) {
  if (c === 120) {
    return 2;
  }
  if (c === 117) {
    return 4;
  }
  if (c === 85) {
    return 8;
  }
  return 0;
}
function fromDecimalCode(c) {
  if (48 <= c && c <= 57) {
    return c - 48;
  }
  return -1;
}
function simpleEscapeSequence(c) {
  return c === 48 ? "\0" : c === 97 ? "\x07" : c === 98 ? "\b" : c === 116 ? "	" : c === 9 ? "	" : c === 110 ? "\n" : c === 118 ? "\v" : c === 102 ? "\f" : c === 114 ? "\r" : c === 101 ? "\x1B" : c === 32 ? " " : c === 34 ? '"' : c === 47 ? "/" : c === 92 ? "\\" : c === 78 ? "\x85" : c === 95 ? "\xA0" : c === 76 ? "\u2028" : c === 80 ? "\u2029" : "";
}
function charFromCodepoint(c) {
  if (c <= 65535) {
    return String.fromCharCode(c);
  }
  return String.fromCharCode(
    (c - 65536 >> 10) + 55296,
    (c - 65536 & 1023) + 56320
  );
}
function setProperty(object2, key, value) {
  if (key === "__proto__") {
    Object.defineProperty(object2, key, {
      configurable: true,
      enumerable: true,
      writable: true,
      value
    });
  } else {
    object2[key] = value;
  }
}
var simpleEscapeCheck = new Array(256);
var simpleEscapeMap = new Array(256);
for (i = 0; i < 256; i++) {
  simpleEscapeCheck[i] = simpleEscapeSequence(i) ? 1 : 0;
  simpleEscapeMap[i] = simpleEscapeSequence(i);
}
var i;
function State$1(input, options) {
  this.input = input;
  this.filename = options["filename"] || null;
  this.schema = options["schema"] || _default3;
  this.onWarning = options["onWarning"] || null;
  this.legacy = options["legacy"] || false;
  this.json = options["json"] || false;
  this.listener = options["listener"] || null;
  this.implicitTypes = this.schema.compiledImplicit;
  this.typeMap = this.schema.compiledTypeMap;
  this.length = input.length;
  this.position = 0;
  this.line = 0;
  this.lineStart = 0;
  this.lineIndent = 0;
  this.firstTabInLine = -1;
  this.documents = [];
}
function generateError(state, message2) {
  var mark = {
    name: state.filename,
    buffer: state.input.slice(0, -1),
    // omit trailing \0
    position: state.position,
    line: state.line,
    column: state.position - state.lineStart
  };
  mark.snippet = snippet(mark);
  return new exception(message2, mark);
}
function throwError(state, message2) {
  throw generateError(state, message2);
}
function throwWarning(state, message2) {
  if (state.onWarning) {
    state.onWarning.call(null, generateError(state, message2));
  }
}
var directiveHandlers = {
  YAML: function handleYamlDirective(state, name, args) {
    var match, major, minor;
    if (state.version !== null) {
      throwError(state, "duplication of %YAML directive");
    }
    if (args.length !== 1) {
      throwError(state, "YAML directive accepts exactly one argument");
    }
    match = /^([0-9]+)\.([0-9]+)$/.exec(args[0]);
    if (match === null) {
      throwError(state, "ill-formed argument of the YAML directive");
    }
    major = parseInt(match[1], 10);
    minor = parseInt(match[2], 10);
    if (major !== 1) {
      throwError(state, "unacceptable YAML version of the document");
    }
    state.version = args[0];
    state.checkLineBreaks = minor < 2;
    if (minor !== 1 && minor !== 2) {
      throwWarning(state, "unsupported YAML version of the document");
    }
  },
  TAG: function handleTagDirective(state, name, args) {
    var handle, prefix;
    if (args.length !== 2) {
      throwError(state, "TAG directive accepts exactly two arguments");
    }
    handle = args[0];
    prefix = args[1];
    if (!PATTERN_TAG_HANDLE.test(handle)) {
      throwError(state, "ill-formed tag handle (first argument) of the TAG directive");
    }
    if (_hasOwnProperty$1.call(state.tagMap, handle)) {
      throwError(state, 'there is a previously declared suffix for "' + handle + '" tag handle');
    }
    if (!PATTERN_TAG_URI.test(prefix)) {
      throwError(state, "ill-formed tag prefix (second argument) of the TAG directive");
    }
    try {
      prefix = decodeURIComponent(prefix);
    } catch (err) {
      throwError(state, "tag prefix is malformed: " + prefix);
    }
    state.tagMap[handle] = prefix;
  }
};
function captureSegment(state, start, end, checkJson) {
  var _position, _length2, _character, _result;
  if (start < end) {
    _result = state.input.slice(start, end);
    if (checkJson) {
      for (_position = 0, _length2 = _result.length; _position < _length2; _position += 1) {
        _character = _result.charCodeAt(_position);
        if (!(_character === 9 || 32 <= _character && _character <= 1114111)) {
          throwError(state, "expected valid JSON character");
        }
      }
    } else if (PATTERN_NON_PRINTABLE.test(_result)) {
      throwError(state, "the stream contains non-printable characters");
    }
    state.result += _result;
  }
}
function mergeMappings(state, destination, source, overridableKeys) {
  var sourceKeys, key, index, quantity;
  if (!common.isObject(source)) {
    throwError(state, "cannot merge mappings; the provided source object is unacceptable");
  }
  sourceKeys = Object.keys(source);
  for (index = 0, quantity = sourceKeys.length; index < quantity; index += 1) {
    key = sourceKeys[index];
    if (!_hasOwnProperty$1.call(destination, key)) {
      setProperty(destination, key, source[key]);
      overridableKeys[key] = true;
    }
  }
}
function storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, startLine, startLineStart, startPos) {
  var index, quantity;
  if (Array.isArray(keyNode)) {
    keyNode = Array.prototype.slice.call(keyNode);
    for (index = 0, quantity = keyNode.length; index < quantity; index += 1) {
      if (Array.isArray(keyNode[index])) {
        throwError(state, "nested arrays are not supported inside keys");
      }
      if (typeof keyNode === "object" && _class(keyNode[index]) === "[object Object]") {
        keyNode[index] = "[object Object]";
      }
    }
  }
  if (typeof keyNode === "object" && _class(keyNode) === "[object Object]") {
    keyNode = "[object Object]";
  }
  keyNode = String(keyNode);
  if (_result === null) {
    _result = {};
  }
  if (keyTag === "tag:yaml.org,2002:merge") {
    if (Array.isArray(valueNode)) {
      for (index = 0, quantity = valueNode.length; index < quantity; index += 1) {
        mergeMappings(state, _result, valueNode[index], overridableKeys);
      }
    } else {
      mergeMappings(state, _result, valueNode, overridableKeys);
    }
  } else {
    if (!state.json && !_hasOwnProperty$1.call(overridableKeys, keyNode) && _hasOwnProperty$1.call(_result, keyNode)) {
      state.line = startLine || state.line;
      state.lineStart = startLineStart || state.lineStart;
      state.position = startPos || state.position;
      throwError(state, "duplicated mapping key");
    }
    setProperty(_result, keyNode, valueNode);
    delete overridableKeys[keyNode];
  }
  return _result;
}
function readLineBreak(state) {
  var ch;
  ch = state.input.charCodeAt(state.position);
  if (ch === 10) {
    state.position++;
  } else if (ch === 13) {
    state.position++;
    if (state.input.charCodeAt(state.position) === 10) {
      state.position++;
    }
  } else {
    throwError(state, "a line break is expected");
  }
  state.line += 1;
  state.lineStart = state.position;
  state.firstTabInLine = -1;
}
function skipSeparationSpace(state, allowComments, checkIndent) {
  var lineBreaks = 0, ch = state.input.charCodeAt(state.position);
  while (ch !== 0) {
    while (is_WHITE_SPACE(ch)) {
      if (ch === 9 && state.firstTabInLine === -1) {
        state.firstTabInLine = state.position;
      }
      ch = state.input.charCodeAt(++state.position);
    }
    if (allowComments && ch === 35) {
      do {
        ch = state.input.charCodeAt(++state.position);
      } while (ch !== 10 && ch !== 13 && ch !== 0);
    }
    if (is_EOL(ch)) {
      readLineBreak(state);
      ch = state.input.charCodeAt(state.position);
      lineBreaks++;
      state.lineIndent = 0;
      while (ch === 32) {
        state.lineIndent++;
        ch = state.input.charCodeAt(++state.position);
      }
    } else {
      break;
    }
  }
  if (checkIndent !== -1 && lineBreaks !== 0 && state.lineIndent < checkIndent) {
    throwWarning(state, "deficient indentation");
  }
  return lineBreaks;
}
function testDocumentSeparator(state) {
  var _position = state.position, ch;
  ch = state.input.charCodeAt(_position);
  if ((ch === 45 || ch === 46) && ch === state.input.charCodeAt(_position + 1) && ch === state.input.charCodeAt(_position + 2)) {
    _position += 3;
    ch = state.input.charCodeAt(_position);
    if (ch === 0 || is_WS_OR_EOL(ch)) {
      return true;
    }
  }
  return false;
}
function writeFoldedLines(state, count) {
  if (count === 1) {
    state.result += " ";
  } else if (count > 1) {
    state.result += common.repeat("\n", count - 1);
  }
}
function readPlainScalar(state, nodeIndent, withinFlowCollection) {
  var preceding, following, captureStart, captureEnd, hasPendingContent, _line, _lineStart, _lineIndent, _kind = state.kind, _result = state.result, ch;
  ch = state.input.charCodeAt(state.position);
  if (is_WS_OR_EOL(ch) || is_FLOW_INDICATOR(ch) || ch === 35 || ch === 38 || ch === 42 || ch === 33 || ch === 124 || ch === 62 || ch === 39 || ch === 34 || ch === 37 || ch === 64 || ch === 96) {
    return false;
  }
  if (ch === 63 || ch === 45) {
    following = state.input.charCodeAt(state.position + 1);
    if (is_WS_OR_EOL(following) || withinFlowCollection && is_FLOW_INDICATOR(following)) {
      return false;
    }
  }
  state.kind = "scalar";
  state.result = "";
  captureStart = captureEnd = state.position;
  hasPendingContent = false;
  while (ch !== 0) {
    if (ch === 58) {
      following = state.input.charCodeAt(state.position + 1);
      if (is_WS_OR_EOL(following) || withinFlowCollection && is_FLOW_INDICATOR(following)) {
        break;
      }
    } else if (ch === 35) {
      preceding = state.input.charCodeAt(state.position - 1);
      if (is_WS_OR_EOL(preceding)) {
        break;
      }
    } else if (state.position === state.lineStart && testDocumentSeparator(state) || withinFlowCollection && is_FLOW_INDICATOR(ch)) {
      break;
    } else if (is_EOL(ch)) {
      _line = state.line;
      _lineStart = state.lineStart;
      _lineIndent = state.lineIndent;
      skipSeparationSpace(state, false, -1);
      if (state.lineIndent >= nodeIndent) {
        hasPendingContent = true;
        ch = state.input.charCodeAt(state.position);
        continue;
      } else {
        state.position = captureEnd;
        state.line = _line;
        state.lineStart = _lineStart;
        state.lineIndent = _lineIndent;
        break;
      }
    }
    if (hasPendingContent) {
      captureSegment(state, captureStart, captureEnd, false);
      writeFoldedLines(state, state.line - _line);
      captureStart = captureEnd = state.position;
      hasPendingContent = false;
    }
    if (!is_WHITE_SPACE(ch)) {
      captureEnd = state.position + 1;
    }
    ch = state.input.charCodeAt(++state.position);
  }
  captureSegment(state, captureStart, captureEnd, false);
  if (state.result) {
    return true;
  }
  state.kind = _kind;
  state.result = _result;
  return false;
}
function readSingleQuotedScalar(state, nodeIndent) {
  var ch, captureStart, captureEnd;
  ch = state.input.charCodeAt(state.position);
  if (ch !== 39) {
    return false;
  }
  state.kind = "scalar";
  state.result = "";
  state.position++;
  captureStart = captureEnd = state.position;
  while ((ch = state.input.charCodeAt(state.position)) !== 0) {
    if (ch === 39) {
      captureSegment(state, captureStart, state.position, true);
      ch = state.input.charCodeAt(++state.position);
      if (ch === 39) {
        captureStart = state.position;
        state.position++;
        captureEnd = state.position;
      } else {
        return true;
      }
    } else if (is_EOL(ch)) {
      captureSegment(state, captureStart, captureEnd, true);
      writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));
      captureStart = captureEnd = state.position;
    } else if (state.position === state.lineStart && testDocumentSeparator(state)) {
      throwError(state, "unexpected end of the document within a single quoted scalar");
    } else {
      state.position++;
      captureEnd = state.position;
    }
  }
  throwError(state, "unexpected end of the stream within a single quoted scalar");
}
function readDoubleQuotedScalar(state, nodeIndent) {
  var captureStart, captureEnd, hexLength, hexResult, tmp, ch;
  ch = state.input.charCodeAt(state.position);
  if (ch !== 34) {
    return false;
  }
  state.kind = "scalar";
  state.result = "";
  state.position++;
  captureStart = captureEnd = state.position;
  while ((ch = state.input.charCodeAt(state.position)) !== 0) {
    if (ch === 34) {
      captureSegment(state, captureStart, state.position, true);
      state.position++;
      return true;
    } else if (ch === 92) {
      captureSegment(state, captureStart, state.position, true);
      ch = state.input.charCodeAt(++state.position);
      if (is_EOL(ch)) {
        skipSeparationSpace(state, false, nodeIndent);
      } else if (ch < 256 && simpleEscapeCheck[ch]) {
        state.result += simpleEscapeMap[ch];
        state.position++;
      } else if ((tmp = escapedHexLen(ch)) > 0) {
        hexLength = tmp;
        hexResult = 0;
        for (; hexLength > 0; hexLength--) {
          ch = state.input.charCodeAt(++state.position);
          if ((tmp = fromHexCode(ch)) >= 0) {
            hexResult = (hexResult << 4) + tmp;
          } else {
            throwError(state, "expected hexadecimal character");
          }
        }
        state.result += charFromCodepoint(hexResult);
        state.position++;
      } else {
        throwError(state, "unknown escape sequence");
      }
      captureStart = captureEnd = state.position;
    } else if (is_EOL(ch)) {
      captureSegment(state, captureStart, captureEnd, true);
      writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));
      captureStart = captureEnd = state.position;
    } else if (state.position === state.lineStart && testDocumentSeparator(state)) {
      throwError(state, "unexpected end of the document within a double quoted scalar");
    } else {
      state.position++;
      captureEnd = state.position;
    }
  }
  throwError(state, "unexpected end of the stream within a double quoted scalar");
}
function readFlowCollection(state, nodeIndent) {
  var readNext = true, _line, _lineStart, _pos, _tag = state.tag, _result, _anchor = state.anchor, following, terminator, isPair, isExplicitPair, isMapping, overridableKeys = /* @__PURE__ */ Object.create(null), keyNode, keyTag, valueNode, ch;
  ch = state.input.charCodeAt(state.position);
  if (ch === 91) {
    terminator = 93;
    isMapping = false;
    _result = [];
  } else if (ch === 123) {
    terminator = 125;
    isMapping = true;
    _result = {};
  } else {
    return false;
  }
  if (state.anchor !== null) {
    state.anchorMap[state.anchor] = _result;
  }
  ch = state.input.charCodeAt(++state.position);
  while (ch !== 0) {
    skipSeparationSpace(state, true, nodeIndent);
    ch = state.input.charCodeAt(state.position);
    if (ch === terminator) {
      state.position++;
      state.tag = _tag;
      state.anchor = _anchor;
      state.kind = isMapping ? "mapping" : "sequence";
      state.result = _result;
      return true;
    } else if (!readNext) {
      throwError(state, "missed comma between flow collection entries");
    } else if (ch === 44) {
      throwError(state, "expected the node content, but found ','");
    }
    keyTag = keyNode = valueNode = null;
    isPair = isExplicitPair = false;
    if (ch === 63) {
      following = state.input.charCodeAt(state.position + 1);
      if (is_WS_OR_EOL(following)) {
        isPair = isExplicitPair = true;
        state.position++;
        skipSeparationSpace(state, true, nodeIndent);
      }
    }
    _line = state.line;
    _lineStart = state.lineStart;
    _pos = state.position;
    composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
    keyTag = state.tag;
    keyNode = state.result;
    skipSeparationSpace(state, true, nodeIndent);
    ch = state.input.charCodeAt(state.position);
    if ((isExplicitPair || state.line === _line) && ch === 58) {
      isPair = true;
      ch = state.input.charCodeAt(++state.position);
      skipSeparationSpace(state, true, nodeIndent);
      composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
      valueNode = state.result;
    }
    if (isMapping) {
      storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, _line, _lineStart, _pos);
    } else if (isPair) {
      _result.push(storeMappingPair(state, null, overridableKeys, keyTag, keyNode, valueNode, _line, _lineStart, _pos));
    } else {
      _result.push(keyNode);
    }
    skipSeparationSpace(state, true, nodeIndent);
    ch = state.input.charCodeAt(state.position);
    if (ch === 44) {
      readNext = true;
      ch = state.input.charCodeAt(++state.position);
    } else {
      readNext = false;
    }
  }
  throwError(state, "unexpected end of the stream within a flow collection");
}
function readBlockScalar(state, nodeIndent) {
  var captureStart, folding, chomping = CHOMPING_CLIP, didReadContent = false, detectedIndent = false, textIndent = nodeIndent, emptyLines = 0, atMoreIndented = false, tmp, ch;
  ch = state.input.charCodeAt(state.position);
  if (ch === 124) {
    folding = false;
  } else if (ch === 62) {
    folding = true;
  } else {
    return false;
  }
  state.kind = "scalar";
  state.result = "";
  while (ch !== 0) {
    ch = state.input.charCodeAt(++state.position);
    if (ch === 43 || ch === 45) {
      if (CHOMPING_CLIP === chomping) {
        chomping = ch === 43 ? CHOMPING_KEEP : CHOMPING_STRIP;
      } else {
        throwError(state, "repeat of a chomping mode identifier");
      }
    } else if ((tmp = fromDecimalCode(ch)) >= 0) {
      if (tmp === 0) {
        throwError(state, "bad explicit indentation width of a block scalar; it cannot be less than one");
      } else if (!detectedIndent) {
        textIndent = nodeIndent + tmp - 1;
        detectedIndent = true;
      } else {
        throwError(state, "repeat of an indentation width identifier");
      }
    } else {
      break;
    }
  }
  if (is_WHITE_SPACE(ch)) {
    do {
      ch = state.input.charCodeAt(++state.position);
    } while (is_WHITE_SPACE(ch));
    if (ch === 35) {
      do {
        ch = state.input.charCodeAt(++state.position);
      } while (!is_EOL(ch) && ch !== 0);
    }
  }
  while (ch !== 0) {
    readLineBreak(state);
    state.lineIndent = 0;
    ch = state.input.charCodeAt(state.position);
    while ((!detectedIndent || state.lineIndent < textIndent) && ch === 32) {
      state.lineIndent++;
      ch = state.input.charCodeAt(++state.position);
    }
    if (!detectedIndent && state.lineIndent > textIndent) {
      textIndent = state.lineIndent;
    }
    if (is_EOL(ch)) {
      emptyLines++;
      continue;
    }
    if (state.lineIndent < textIndent) {
      if (chomping === CHOMPING_KEEP) {
        state.result += common.repeat("\n", didReadContent ? 1 + emptyLines : emptyLines);
      } else if (chomping === CHOMPING_CLIP) {
        if (didReadContent) {
          state.result += "\n";
        }
      }
      break;
    }
    if (folding) {
      if (is_WHITE_SPACE(ch)) {
        atMoreIndented = true;
        state.result += common.repeat("\n", didReadContent ? 1 + emptyLines : emptyLines);
      } else if (atMoreIndented) {
        atMoreIndented = false;
        state.result += common.repeat("\n", emptyLines + 1);
      } else if (emptyLines === 0) {
        if (didReadContent) {
          state.result += " ";
        }
      } else {
        state.result += common.repeat("\n", emptyLines);
      }
    } else {
      state.result += common.repeat("\n", didReadContent ? 1 + emptyLines : emptyLines);
    }
    didReadContent = true;
    detectedIndent = true;
    emptyLines = 0;
    captureStart = state.position;
    while (!is_EOL(ch) && ch !== 0) {
      ch = state.input.charCodeAt(++state.position);
    }
    captureSegment(state, captureStart, state.position, false);
  }
  return true;
}
function readBlockSequence(state, nodeIndent) {
  var _line, _tag = state.tag, _anchor = state.anchor, _result = [], following, detected = false, ch;
  if (state.firstTabInLine !== -1) return false;
  if (state.anchor !== null) {
    state.anchorMap[state.anchor] = _result;
  }
  ch = state.input.charCodeAt(state.position);
  while (ch !== 0) {
    if (state.firstTabInLine !== -1) {
      state.position = state.firstTabInLine;
      throwError(state, "tab characters must not be used in indentation");
    }
    if (ch !== 45) {
      break;
    }
    following = state.input.charCodeAt(state.position + 1);
    if (!is_WS_OR_EOL(following)) {
      break;
    }
    detected = true;
    state.position++;
    if (skipSeparationSpace(state, true, -1)) {
      if (state.lineIndent <= nodeIndent) {
        _result.push(null);
        ch = state.input.charCodeAt(state.position);
        continue;
      }
    }
    _line = state.line;
    composeNode(state, nodeIndent, CONTEXT_BLOCK_IN, false, true);
    _result.push(state.result);
    skipSeparationSpace(state, true, -1);
    ch = state.input.charCodeAt(state.position);
    if ((state.line === _line || state.lineIndent > nodeIndent) && ch !== 0) {
      throwError(state, "bad indentation of a sequence entry");
    } else if (state.lineIndent < nodeIndent) {
      break;
    }
  }
  if (detected) {
    state.tag = _tag;
    state.anchor = _anchor;
    state.kind = "sequence";
    state.result = _result;
    return true;
  }
  return false;
}
function readBlockMapping(state, nodeIndent, flowIndent) {
  var following, allowCompact, _line, _keyLine, _keyLineStart, _keyPos, _tag = state.tag, _anchor = state.anchor, _result = {}, overridableKeys = /* @__PURE__ */ Object.create(null), keyTag = null, keyNode = null, valueNode = null, atExplicitKey = false, detected = false, ch;
  if (state.firstTabInLine !== -1) return false;
  if (state.anchor !== null) {
    state.anchorMap[state.anchor] = _result;
  }
  ch = state.input.charCodeAt(state.position);
  while (ch !== 0) {
    if (!atExplicitKey && state.firstTabInLine !== -1) {
      state.position = state.firstTabInLine;
      throwError(state, "tab characters must not be used in indentation");
    }
    following = state.input.charCodeAt(state.position + 1);
    _line = state.line;
    if ((ch === 63 || ch === 58) && is_WS_OR_EOL(following)) {
      if (ch === 63) {
        if (atExplicitKey) {
          storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos);
          keyTag = keyNode = valueNode = null;
        }
        detected = true;
        atExplicitKey = true;
        allowCompact = true;
      } else if (atExplicitKey) {
        atExplicitKey = false;
        allowCompact = true;
      } else {
        throwError(state, "incomplete explicit mapping pair; a key node is missed; or followed by a non-tabulated empty line");
      }
      state.position += 1;
      ch = following;
    } else {
      _keyLine = state.line;
      _keyLineStart = state.lineStart;
      _keyPos = state.position;
      if (!composeNode(state, flowIndent, CONTEXT_FLOW_OUT, false, true)) {
        break;
      }
      if (state.line === _line) {
        ch = state.input.charCodeAt(state.position);
        while (is_WHITE_SPACE(ch)) {
          ch = state.input.charCodeAt(++state.position);
        }
        if (ch === 58) {
          ch = state.input.charCodeAt(++state.position);
          if (!is_WS_OR_EOL(ch)) {
            throwError(state, "a whitespace character is expected after the key-value separator within a block mapping");
          }
          if (atExplicitKey) {
            storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos);
            keyTag = keyNode = valueNode = null;
          }
          detected = true;
          atExplicitKey = false;
          allowCompact = false;
          keyTag = state.tag;
          keyNode = state.result;
        } else if (detected) {
          throwError(state, "can not read an implicit mapping pair; a colon is missed");
        } else {
          state.tag = _tag;
          state.anchor = _anchor;
          return true;
        }
      } else if (detected) {
        throwError(state, "can not read a block mapping entry; a multiline key may not be an implicit key");
      } else {
        state.tag = _tag;
        state.anchor = _anchor;
        return true;
      }
    }
    if (state.line === _line || state.lineIndent > nodeIndent) {
      if (atExplicitKey) {
        _keyLine = state.line;
        _keyLineStart = state.lineStart;
        _keyPos = state.position;
      }
      if (composeNode(state, nodeIndent, CONTEXT_BLOCK_OUT, true, allowCompact)) {
        if (atExplicitKey) {
          keyNode = state.result;
        } else {
          valueNode = state.result;
        }
      }
      if (!atExplicitKey) {
        storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, _keyLine, _keyLineStart, _keyPos);
        keyTag = keyNode = valueNode = null;
      }
      skipSeparationSpace(state, true, -1);
      ch = state.input.charCodeAt(state.position);
    }
    if ((state.line === _line || state.lineIndent > nodeIndent) && ch !== 0) {
      throwError(state, "bad indentation of a mapping entry");
    } else if (state.lineIndent < nodeIndent) {
      break;
    }
  }
  if (atExplicitKey) {
    storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos);
  }
  if (detected) {
    state.tag = _tag;
    state.anchor = _anchor;
    state.kind = "mapping";
    state.result = _result;
  }
  return detected;
}
function readTagProperty(state) {
  var _position, isVerbatim = false, isNamed = false, tagHandle, tagName, ch;
  ch = state.input.charCodeAt(state.position);
  if (ch !== 33) return false;
  if (state.tag !== null) {
    throwError(state, "duplication of a tag property");
  }
  ch = state.input.charCodeAt(++state.position);
  if (ch === 60) {
    isVerbatim = true;
    ch = state.input.charCodeAt(++state.position);
  } else if (ch === 33) {
    isNamed = true;
    tagHandle = "!!";
    ch = state.input.charCodeAt(++state.position);
  } else {
    tagHandle = "!";
  }
  _position = state.position;
  if (isVerbatim) {
    do {
      ch = state.input.charCodeAt(++state.position);
    } while (ch !== 0 && ch !== 62);
    if (state.position < state.length) {
      tagName = state.input.slice(_position, state.position);
      ch = state.input.charCodeAt(++state.position);
    } else {
      throwError(state, "unexpected end of the stream within a verbatim tag");
    }
  } else {
    while (ch !== 0 && !is_WS_OR_EOL(ch)) {
      if (ch === 33) {
        if (!isNamed) {
          tagHandle = state.input.slice(_position - 1, state.position + 1);
          if (!PATTERN_TAG_HANDLE.test(tagHandle)) {
            throwError(state, "named tag handle cannot contain such characters");
          }
          isNamed = true;
          _position = state.position + 1;
        } else {
          throwError(state, "tag suffix cannot contain exclamation marks");
        }
      }
      ch = state.input.charCodeAt(++state.position);
    }
    tagName = state.input.slice(_position, state.position);
    if (PATTERN_FLOW_INDICATORS.test(tagName)) {
      throwError(state, "tag suffix cannot contain flow indicator characters");
    }
  }
  if (tagName && !PATTERN_TAG_URI.test(tagName)) {
    throwError(state, "tag name cannot contain such characters: " + tagName);
  }
  try {
    tagName = decodeURIComponent(tagName);
  } catch (err) {
    throwError(state, "tag name is malformed: " + tagName);
  }
  if (isVerbatim) {
    state.tag = tagName;
  } else if (_hasOwnProperty$1.call(state.tagMap, tagHandle)) {
    state.tag = state.tagMap[tagHandle] + tagName;
  } else if (tagHandle === "!") {
    state.tag = "!" + tagName;
  } else if (tagHandle === "!!") {
    state.tag = "tag:yaml.org,2002:" + tagName;
  } else {
    throwError(state, 'undeclared tag handle "' + tagHandle + '"');
  }
  return true;
}
function readAnchorProperty(state) {
  var _position, ch;
  ch = state.input.charCodeAt(state.position);
  if (ch !== 38) return false;
  if (state.anchor !== null) {
    throwError(state, "duplication of an anchor property");
  }
  ch = state.input.charCodeAt(++state.position);
  _position = state.position;
  while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {
    ch = state.input.charCodeAt(++state.position);
  }
  if (state.position === _position) {
    throwError(state, "name of an anchor node must contain at least one character");
  }
  state.anchor = state.input.slice(_position, state.position);
  return true;
}
function readAlias(state) {
  var _position, alias, ch;
  ch = state.input.charCodeAt(state.position);
  if (ch !== 42) return false;
  ch = state.input.charCodeAt(++state.position);
  _position = state.position;
  while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {
    ch = state.input.charCodeAt(++state.position);
  }
  if (state.position === _position) {
    throwError(state, "name of an alias node must contain at least one character");
  }
  alias = state.input.slice(_position, state.position);
  if (!_hasOwnProperty$1.call(state.anchorMap, alias)) {
    throwError(state, 'unidentified alias "' + alias + '"');
  }
  state.result = state.anchorMap[alias];
  skipSeparationSpace(state, true, -1);
  return true;
}
function composeNode(state, parentIndent, nodeContext, allowToSeek, allowCompact) {
  var allowBlockStyles, allowBlockScalars, allowBlockCollections, indentStatus = 1, atNewLine = false, hasContent = false, typeIndex, typeQuantity, typeList, type2, flowIndent, blockIndent;
  if (state.listener !== null) {
    state.listener("open", state);
  }
  state.tag = null;
  state.anchor = null;
  state.kind = null;
  state.result = null;
  allowBlockStyles = allowBlockScalars = allowBlockCollections = CONTEXT_BLOCK_OUT === nodeContext || CONTEXT_BLOCK_IN === nodeContext;
  if (allowToSeek) {
    if (skipSeparationSpace(state, true, -1)) {
      atNewLine = true;
      if (state.lineIndent > parentIndent) {
        indentStatus = 1;
      } else if (state.lineIndent === parentIndent) {
        indentStatus = 0;
      } else if (state.lineIndent < parentIndent) {
        indentStatus = -1;
      }
    }
  }
  if (indentStatus === 1) {
    while (readTagProperty(state) || readAnchorProperty(state)) {
      if (skipSeparationSpace(state, true, -1)) {
        atNewLine = true;
        allowBlockCollections = allowBlockStyles;
        if (state.lineIndent > parentIndent) {
          indentStatus = 1;
        } else if (state.lineIndent === parentIndent) {
          indentStatus = 0;
        } else if (state.lineIndent < parentIndent) {
          indentStatus = -1;
        }
      } else {
        allowBlockCollections = false;
      }
    }
  }
  if (allowBlockCollections) {
    allowBlockCollections = atNewLine || allowCompact;
  }
  if (indentStatus === 1 || CONTEXT_BLOCK_OUT === nodeContext) {
    if (CONTEXT_FLOW_IN === nodeContext || CONTEXT_FLOW_OUT === nodeContext) {
      flowIndent = parentIndent;
    } else {
      flowIndent = parentIndent + 1;
    }
    blockIndent = state.position - state.lineStart;
    if (indentStatus === 1) {
      if (allowBlockCollections && (readBlockSequence(state, blockIndent) || readBlockMapping(state, blockIndent, flowIndent)) || readFlowCollection(state, flowIndent)) {
        hasContent = true;
      } else {
        if (allowBlockScalars && readBlockScalar(state, flowIndent) || readSingleQuotedScalar(state, flowIndent) || readDoubleQuotedScalar(state, flowIndent)) {
          hasContent = true;
        } else if (readAlias(state)) {
          hasContent = true;
          if (state.tag !== null || state.anchor !== null) {
            throwError(state, "alias node should not have any properties");
          }
        } else if (readPlainScalar(state, flowIndent, CONTEXT_FLOW_IN === nodeContext)) {
          hasContent = true;
          if (state.tag === null) {
            state.tag = "?";
          }
        }
        if (state.anchor !== null) {
          state.anchorMap[state.anchor] = state.result;
        }
      }
    } else if (indentStatus === 0) {
      hasContent = allowBlockCollections && readBlockSequence(state, blockIndent);
    }
  }
  if (state.tag === null) {
    if (state.anchor !== null) {
      state.anchorMap[state.anchor] = state.result;
    }
  } else if (state.tag === "?") {
    if (state.result !== null && state.kind !== "scalar") {
      throwError(state, 'unacceptable node kind for !<?> tag; it should be "scalar", not "' + state.kind + '"');
    }
    for (typeIndex = 0, typeQuantity = state.implicitTypes.length; typeIndex < typeQuantity; typeIndex += 1) {
      type2 = state.implicitTypes[typeIndex];
      if (type2.resolve(state.result)) {
        state.result = type2.construct(state.result);
        state.tag = type2.tag;
        if (state.anchor !== null) {
          state.anchorMap[state.anchor] = state.result;
        }
        break;
      }
    }
  } else if (state.tag !== "!") {
    if (_hasOwnProperty$1.call(state.typeMap[state.kind || "fallback"], state.tag)) {
      type2 = state.typeMap[state.kind || "fallback"][state.tag];
    } else {
      type2 = null;
      typeList = state.typeMap.multi[state.kind || "fallback"];
      for (typeIndex = 0, typeQuantity = typeList.length; typeIndex < typeQuantity; typeIndex += 1) {
        if (state.tag.slice(0, typeList[typeIndex].tag.length) === typeList[typeIndex].tag) {
          type2 = typeList[typeIndex];
          break;
        }
      }
    }
    if (!type2) {
      throwError(state, "unknown tag !<" + state.tag + ">");
    }
    if (state.result !== null && type2.kind !== state.kind) {
      throwError(state, "unacceptable node kind for !<" + state.tag + '> tag; it should be "' + type2.kind + '", not "' + state.kind + '"');
    }
    if (!type2.resolve(state.result, state.tag)) {
      throwError(state, "cannot resolve a node with !<" + state.tag + "> explicit tag");
    } else {
      state.result = type2.construct(state.result, state.tag);
      if (state.anchor !== null) {
        state.anchorMap[state.anchor] = state.result;
      }
    }
  }
  if (state.listener !== null) {
    state.listener("close", state);
  }
  return state.tag !== null || state.anchor !== null || hasContent;
}
function readDocument(state) {
  var documentStart = state.position, _position, directiveName, directiveArgs, hasDirectives = false, ch;
  state.version = null;
  state.checkLineBreaks = state.legacy;
  state.tagMap = /* @__PURE__ */ Object.create(null);
  state.anchorMap = /* @__PURE__ */ Object.create(null);
  while ((ch = state.input.charCodeAt(state.position)) !== 0) {
    skipSeparationSpace(state, true, -1);
    ch = state.input.charCodeAt(state.position);
    if (state.lineIndent > 0 || ch !== 37) {
      break;
    }
    hasDirectives = true;
    ch = state.input.charCodeAt(++state.position);
    _position = state.position;
    while (ch !== 0 && !is_WS_OR_EOL(ch)) {
      ch = state.input.charCodeAt(++state.position);
    }
    directiveName = state.input.slice(_position, state.position);
    directiveArgs = [];
    if (directiveName.length < 1) {
      throwError(state, "directive name must not be less than one character in length");
    }
    while (ch !== 0) {
      while (is_WHITE_SPACE(ch)) {
        ch = state.input.charCodeAt(++state.position);
      }
      if (ch === 35) {
        do {
          ch = state.input.charCodeAt(++state.position);
        } while (ch !== 0 && !is_EOL(ch));
        break;
      }
      if (is_EOL(ch)) break;
      _position = state.position;
      while (ch !== 0 && !is_WS_OR_EOL(ch)) {
        ch = state.input.charCodeAt(++state.position);
      }
      directiveArgs.push(state.input.slice(_position, state.position));
    }
    if (ch !== 0) readLineBreak(state);
    if (_hasOwnProperty$1.call(directiveHandlers, directiveName)) {
      directiveHandlers[directiveName](state, directiveName, directiveArgs);
    } else {
      throwWarning(state, 'unknown document directive "' + directiveName + '"');
    }
  }
  skipSeparationSpace(state, true, -1);
  if (state.lineIndent === 0 && state.input.charCodeAt(state.position) === 45 && state.input.charCodeAt(state.position + 1) === 45 && state.input.charCodeAt(state.position + 2) === 45) {
    state.position += 3;
    skipSeparationSpace(state, true, -1);
  } else if (hasDirectives) {
    throwError(state, "directives end mark is expected");
  }
  composeNode(state, state.lineIndent - 1, CONTEXT_BLOCK_OUT, false, true);
  skipSeparationSpace(state, true, -1);
  if (state.checkLineBreaks && PATTERN_NON_ASCII_LINE_BREAKS.test(state.input.slice(documentStart, state.position))) {
    throwWarning(state, "non-ASCII line breaks are interpreted as content");
  }
  state.documents.push(state.result);
  if (state.position === state.lineStart && testDocumentSeparator(state)) {
    if (state.input.charCodeAt(state.position) === 46) {
      state.position += 3;
      skipSeparationSpace(state, true, -1);
    }
    return;
  }
  if (state.position < state.length - 1) {
    throwError(state, "end of the stream or a document separator is expected");
  } else {
    return;
  }
}
function loadDocuments(input, options) {
  input = String(input);
  options = options || {};
  if (input.length !== 0) {
    if (input.charCodeAt(input.length - 1) !== 10 && input.charCodeAt(input.length - 1) !== 13) {
      input += "\n";
    }
    if (input.charCodeAt(0) === 65279) {
      input = input.slice(1);
    }
  }
  var state = new State$1(input, options);
  var nullpos = input.indexOf("\0");
  if (nullpos !== -1) {
    state.position = nullpos;
    throwError(state, "null byte is not allowed in input");
  }
  state.input += "\0";
  while (state.input.charCodeAt(state.position) === 32) {
    state.lineIndent += 1;
    state.position += 1;
  }
  while (state.position < state.length - 1) {
    readDocument(state);
  }
  return state.documents;
}
function loadAll$1(input, iterator, options) {
  if (iterator !== null && typeof iterator === "object" && typeof options === "undefined") {
    options = iterator;
    iterator = null;
  }
  var documents = loadDocuments(input, options);
  if (typeof iterator !== "function") {
    return documents;
  }
  for (var index = 0, length = documents.length; index < length; index += 1) {
    iterator(documents[index]);
  }
}
function load$1(input, options) {
  var documents = loadDocuments(input, options);
  if (documents.length === 0) {
    return void 0;
  } else if (documents.length === 1) {
    return documents[0];
  }
  throw new exception("expected a single document in the stream, but found more");
}
var loadAll_1 = loadAll$1;
var load_1 = load$1;
var loader = {
  loadAll: loadAll_1,
  load: load_1
};
var _toString = Object.prototype.toString;
var _hasOwnProperty = Object.prototype.hasOwnProperty;
var CHAR_BOM = 65279;
var CHAR_TAB = 9;
var CHAR_LINE_FEED = 10;
var CHAR_CARRIAGE_RETURN = 13;
var CHAR_SPACE = 32;
var CHAR_EXCLAMATION = 33;
var CHAR_DOUBLE_QUOTE = 34;
var CHAR_SHARP = 35;
var CHAR_PERCENT = 37;
var CHAR_AMPERSAND = 38;
var CHAR_SINGLE_QUOTE = 39;
var CHAR_ASTERISK = 42;
var CHAR_COMMA = 44;
var CHAR_MINUS = 45;
var CHAR_COLON = 58;
var CHAR_EQUALS = 61;
var CHAR_GREATER_THAN = 62;
var CHAR_QUESTION = 63;
var CHAR_COMMERCIAL_AT = 64;
var CHAR_LEFT_SQUARE_BRACKET = 91;
var CHAR_RIGHT_SQUARE_BRACKET = 93;
var CHAR_GRAVE_ACCENT = 96;
var CHAR_LEFT_CURLY_BRACKET = 123;
var CHAR_VERTICAL_LINE = 124;
var CHAR_RIGHT_CURLY_BRACKET = 125;
var ESCAPE_SEQUENCES = {};
ESCAPE_SEQUENCES[0] = "\\0";
ESCAPE_SEQUENCES[7] = "\\a";
ESCAPE_SEQUENCES[8] = "\\b";
ESCAPE_SEQUENCES[9] = "\\t";
ESCAPE_SEQUENCES[10] = "\\n";
ESCAPE_SEQUENCES[11] = "\\v";
ESCAPE_SEQUENCES[12] = "\\f";
ESCAPE_SEQUENCES[13] = "\\r";
ESCAPE_SEQUENCES[27] = "\\e";
ESCAPE_SEQUENCES[34] = '\\"';
ESCAPE_SEQUENCES[92] = "\\\\";
ESCAPE_SEQUENCES[133] = "\\N";
ESCAPE_SEQUENCES[160] = "\\_";
ESCAPE_SEQUENCES[8232] = "\\L";
ESCAPE_SEQUENCES[8233] = "\\P";
var DEPRECATED_BOOLEANS_SYNTAX = [
  "y",
  "Y",
  "yes",
  "Yes",
  "YES",
  "on",
  "On",
  "ON",
  "n",
  "N",
  "no",
  "No",
  "NO",
  "off",
  "Off",
  "OFF"
];
var DEPRECATED_BASE60_SYNTAX = /^[-+]?[0-9_]+(?::[0-9_]+)+(?:\.[0-9_]*)?$/;
function compileStyleMap(schema2, map3) {
  var result, keys, index, length, tag2, style, type2;
  if (map3 === null) return {};
  result = {};
  keys = Object.keys(map3);
  for (index = 0, length = keys.length; index < length; index += 1) {
    tag2 = keys[index];
    style = String(map3[tag2]);
    if (tag2.slice(0, 2) === "!!") {
      tag2 = "tag:yaml.org,2002:" + tag2.slice(2);
    }
    type2 = schema2.compiledTypeMap["fallback"][tag2];
    if (type2 && _hasOwnProperty.call(type2.styleAliases, style)) {
      style = type2.styleAliases[style];
    }
    result[tag2] = style;
  }
  return result;
}
function encodeHex(character) {
  var string4, handle, length;
  string4 = character.toString(16).toUpperCase();
  if (character <= 255) {
    handle = "x";
    length = 2;
  } else if (character <= 65535) {
    handle = "u";
    length = 4;
  } else if (character <= 4294967295) {
    handle = "U";
    length = 8;
  } else {
    throw new exception("code point within a string may not be greater than 0xFFFFFFFF");
  }
  return "\\" + handle + common.repeat("0", length - string4.length) + string4;
}
var QUOTING_TYPE_SINGLE = 1;
var QUOTING_TYPE_DOUBLE = 2;
function State(options) {
  this.schema = options["schema"] || _default3;
  this.indent = Math.max(1, options["indent"] || 2);
  this.noArrayIndent = options["noArrayIndent"] || false;
  this.skipInvalid = options["skipInvalid"] || false;
  this.flowLevel = common.isNothing(options["flowLevel"]) ? -1 : options["flowLevel"];
  this.styleMap = compileStyleMap(this.schema, options["styles"] || null);
  this.sortKeys = options["sortKeys"] || false;
  this.lineWidth = options["lineWidth"] || 80;
  this.noRefs = options["noRefs"] || false;
  this.noCompatMode = options["noCompatMode"] || false;
  this.condenseFlow = options["condenseFlow"] || false;
  this.quotingType = options["quotingType"] === '"' ? QUOTING_TYPE_DOUBLE : QUOTING_TYPE_SINGLE;
  this.forceQuotes = options["forceQuotes"] || false;
  this.replacer = typeof options["replacer"] === "function" ? options["replacer"] : null;
  this.implicitTypes = this.schema.compiledImplicit;
  this.explicitTypes = this.schema.compiledExplicit;
  this.tag = null;
  this.result = "";
  this.duplicates = [];
  this.usedDuplicates = null;
}
function indentString(string4, spaces) {
  var ind = common.repeat(" ", spaces), position = 0, next = -1, result = "", line, length = string4.length;
  while (position < length) {
    next = string4.indexOf("\n", position);
    if (next === -1) {
      line = string4.slice(position);
      position = length;
    } else {
      line = string4.slice(position, next + 1);
      position = next + 1;
    }
    if (line.length && line !== "\n") result += ind;
    result += line;
  }
  return result;
}
function generateNextLine(state, level) {
  return "\n" + common.repeat(" ", state.indent * level);
}
function testImplicitResolving(state, str2) {
  var index, length, type2;
  for (index = 0, length = state.implicitTypes.length; index < length; index += 1) {
    type2 = state.implicitTypes[index];
    if (type2.resolve(str2)) {
      return true;
    }
  }
  return false;
}
function isWhitespace(c) {
  return c === CHAR_SPACE || c === CHAR_TAB;
}
function isPrintable(c) {
  return 32 <= c && c <= 126 || 161 <= c && c <= 55295 && c !== 8232 && c !== 8233 || 57344 <= c && c <= 65533 && c !== CHAR_BOM || 65536 <= c && c <= 1114111;
}
function isNsCharOrWhitespace(c) {
  return isPrintable(c) && c !== CHAR_BOM && c !== CHAR_CARRIAGE_RETURN && c !== CHAR_LINE_FEED;
}
function isPlainSafe(c, prev, inblock) {
  var cIsNsCharOrWhitespace = isNsCharOrWhitespace(c);
  var cIsNsChar = cIsNsCharOrWhitespace && !isWhitespace(c);
  return (
    // ns-plain-safe
    (inblock ? (
      // c = flow-in
      cIsNsCharOrWhitespace
    ) : cIsNsCharOrWhitespace && c !== CHAR_COMMA && c !== CHAR_LEFT_SQUARE_BRACKET && c !== CHAR_RIGHT_SQUARE_BRACKET && c !== CHAR_LEFT_CURLY_BRACKET && c !== CHAR_RIGHT_CURLY_BRACKET) && c !== CHAR_SHARP && !(prev === CHAR_COLON && !cIsNsChar) || isNsCharOrWhitespace(prev) && !isWhitespace(prev) && c === CHAR_SHARP || prev === CHAR_COLON && cIsNsChar
  );
}
function isPlainSafeFirst(c) {
  return isPrintable(c) && c !== CHAR_BOM && !isWhitespace(c) && c !== CHAR_MINUS && c !== CHAR_QUESTION && c !== CHAR_COLON && c !== CHAR_COMMA && c !== CHAR_LEFT_SQUARE_BRACKET && c !== CHAR_RIGHT_SQUARE_BRACKET && c !== CHAR_LEFT_CURLY_BRACKET && c !== CHAR_RIGHT_CURLY_BRACKET && c !== CHAR_SHARP && c !== CHAR_AMPERSAND && c !== CHAR_ASTERISK && c !== CHAR_EXCLAMATION && c !== CHAR_VERTICAL_LINE && c !== CHAR_EQUALS && c !== CHAR_GREATER_THAN && c !== CHAR_SINGLE_QUOTE && c !== CHAR_DOUBLE_QUOTE && c !== CHAR_PERCENT && c !== CHAR_COMMERCIAL_AT && c !== CHAR_GRAVE_ACCENT;
}
function isPlainSafeLast(c) {
  return !isWhitespace(c) && c !== CHAR_COLON;
}
function codePointAt(string4, pos) {
  var first = string4.charCodeAt(pos), second;
  if (first >= 55296 && first <= 56319 && pos + 1 < string4.length) {
    second = string4.charCodeAt(pos + 1);
    if (second >= 56320 && second <= 57343) {
      return (first - 55296) * 1024 + second - 56320 + 65536;
    }
  }
  return first;
}
function needIndentIndicator(string4) {
  var leadingSpaceRe = /^\n* /;
  return leadingSpaceRe.test(string4);
}
var STYLE_PLAIN = 1;
var STYLE_SINGLE = 2;
var STYLE_LITERAL = 3;
var STYLE_FOLDED = 4;
var STYLE_DOUBLE = 5;
function chooseScalarStyle(string4, singleLineOnly, indentPerLevel, lineWidth, testAmbiguousType, quotingType, forceQuotes, inblock) {
  var i;
  var char = 0;
  var prevChar = null;
  var hasLineBreak = false;
  var hasFoldableLine = false;
  var shouldTrackWidth = lineWidth !== -1;
  var previousLineBreak = -1;
  var plain = isPlainSafeFirst(codePointAt(string4, 0)) && isPlainSafeLast(codePointAt(string4, string4.length - 1));
  if (singleLineOnly || forceQuotes) {
    for (i = 0; i < string4.length; char >= 65536 ? i += 2 : i++) {
      char = codePointAt(string4, i);
      if (!isPrintable(char)) {
        return STYLE_DOUBLE;
      }
      plain = plain && isPlainSafe(char, prevChar, inblock);
      prevChar = char;
    }
  } else {
    for (i = 0; i < string4.length; char >= 65536 ? i += 2 : i++) {
      char = codePointAt(string4, i);
      if (char === CHAR_LINE_FEED) {
        hasLineBreak = true;
        if (shouldTrackWidth) {
          hasFoldableLine = hasFoldableLine || // Foldable line = too long, and not more-indented.
          i - previousLineBreak - 1 > lineWidth && string4[previousLineBreak + 1] !== " ";
          previousLineBreak = i;
        }
      } else if (!isPrintable(char)) {
        return STYLE_DOUBLE;
      }
      plain = plain && isPlainSafe(char, prevChar, inblock);
      prevChar = char;
    }
    hasFoldableLine = hasFoldableLine || shouldTrackWidth && (i - previousLineBreak - 1 > lineWidth && string4[previousLineBreak + 1] !== " ");
  }
  if (!hasLineBreak && !hasFoldableLine) {
    if (plain && !forceQuotes && !testAmbiguousType(string4)) {
      return STYLE_PLAIN;
    }
    return quotingType === QUOTING_TYPE_DOUBLE ? STYLE_DOUBLE : STYLE_SINGLE;
  }
  if (indentPerLevel > 9 && needIndentIndicator(string4)) {
    return STYLE_DOUBLE;
  }
  if (!forceQuotes) {
    return hasFoldableLine ? STYLE_FOLDED : STYLE_LITERAL;
  }
  return quotingType === QUOTING_TYPE_DOUBLE ? STYLE_DOUBLE : STYLE_SINGLE;
}
function writeScalar(state, string4, level, iskey, inblock) {
  state.dump = (function() {
    if (string4.length === 0) {
      return state.quotingType === QUOTING_TYPE_DOUBLE ? '""' : "''";
    }
    if (!state.noCompatMode) {
      if (DEPRECATED_BOOLEANS_SYNTAX.indexOf(string4) !== -1 || DEPRECATED_BASE60_SYNTAX.test(string4)) {
        return state.quotingType === QUOTING_TYPE_DOUBLE ? '"' + string4 + '"' : "'" + string4 + "'";
      }
    }
    var indent = state.indent * Math.max(1, level);
    var lineWidth = state.lineWidth === -1 ? -1 : Math.max(Math.min(state.lineWidth, 40), state.lineWidth - indent);
    var singleLineOnly = iskey || state.flowLevel > -1 && level >= state.flowLevel;
    function testAmbiguity(string5) {
      return testImplicitResolving(state, string5);
    }
    switch (chooseScalarStyle(
      string4,
      singleLineOnly,
      state.indent,
      lineWidth,
      testAmbiguity,
      state.quotingType,
      state.forceQuotes && !iskey,
      inblock
    )) {
      case STYLE_PLAIN:
        return string4;
      case STYLE_SINGLE:
        return "'" + string4.replace(/'/g, "''") + "'";
      case STYLE_LITERAL:
        return "|" + blockHeader(string4, state.indent) + dropEndingNewline(indentString(string4, indent));
      case STYLE_FOLDED:
        return ">" + blockHeader(string4, state.indent) + dropEndingNewline(indentString(foldString(string4, lineWidth), indent));
      case STYLE_DOUBLE:
        return '"' + escapeString(string4) + '"';
      default:
        throw new exception("impossible error: invalid scalar style");
    }
  })();
}
function blockHeader(string4, indentPerLevel) {
  var indentIndicator = needIndentIndicator(string4) ? String(indentPerLevel) : "";
  var clip = string4[string4.length - 1] === "\n";
  var keep = clip && (string4[string4.length - 2] === "\n" || string4 === "\n");
  var chomp = keep ? "+" : clip ? "" : "-";
  return indentIndicator + chomp + "\n";
}
function dropEndingNewline(string4) {
  return string4[string4.length - 1] === "\n" ? string4.slice(0, -1) : string4;
}
function foldString(string4, width) {
  var lineRe = /(\n+)([^\n]*)/g;
  var result = (function() {
    var nextLF = string4.indexOf("\n");
    nextLF = nextLF !== -1 ? nextLF : string4.length;
    lineRe.lastIndex = nextLF;
    return foldLine(string4.slice(0, nextLF), width);
  })();
  var prevMoreIndented = string4[0] === "\n" || string4[0] === " ";
  var moreIndented;
  var match;
  while (match = lineRe.exec(string4)) {
    var prefix = match[1], line = match[2];
    moreIndented = line[0] === " ";
    result += prefix + (!prevMoreIndented && !moreIndented && line !== "" ? "\n" : "") + foldLine(line, width);
    prevMoreIndented = moreIndented;
  }
  return result;
}
function foldLine(line, width) {
  if (line === "" || line[0] === " ") return line;
  var breakRe = / [^ ]/g;
  var match;
  var start = 0, end, curr = 0, next = 0;
  var result = "";
  while (match = breakRe.exec(line)) {
    next = match.index;
    if (next - start > width) {
      end = curr > start ? curr : next;
      result += "\n" + line.slice(start, end);
      start = end + 1;
    }
    curr = next;
  }
  result += "\n";
  if (line.length - start > width && curr > start) {
    result += line.slice(start, curr) + "\n" + line.slice(curr + 1);
  } else {
    result += line.slice(start);
  }
  return result.slice(1);
}
function escapeString(string4) {
  var result = "";
  var char = 0;
  var escapeSeq;
  for (var i = 0; i < string4.length; char >= 65536 ? i += 2 : i++) {
    char = codePointAt(string4, i);
    escapeSeq = ESCAPE_SEQUENCES[char];
    if (!escapeSeq && isPrintable(char)) {
      result += string4[i];
      if (char >= 65536) result += string4[i + 1];
    } else {
      result += escapeSeq || encodeHex(char);
    }
  }
  return result;
}
function writeFlowSequence(state, level, object2) {
  var _result = "", _tag = state.tag, index, length, value;
  for (index = 0, length = object2.length; index < length; index += 1) {
    value = object2[index];
    if (state.replacer) {
      value = state.replacer.call(object2, String(index), value);
    }
    if (writeNode(state, level, value, false, false) || typeof value === "undefined" && writeNode(state, level, null, false, false)) {
      if (_result !== "") _result += "," + (!state.condenseFlow ? " " : "");
      _result += state.dump;
    }
  }
  state.tag = _tag;
  state.dump = "[" + _result + "]";
}
function writeBlockSequence(state, level, object2, compact) {
  var _result = "", _tag = state.tag, index, length, value;
  for (index = 0, length = object2.length; index < length; index += 1) {
    value = object2[index];
    if (state.replacer) {
      value = state.replacer.call(object2, String(index), value);
    }
    if (writeNode(state, level + 1, value, true, true, false, true) || typeof value === "undefined" && writeNode(state, level + 1, null, true, true, false, true)) {
      if (!compact || _result !== "") {
        _result += generateNextLine(state, level);
      }
      if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
        _result += "-";
      } else {
        _result += "- ";
      }
      _result += state.dump;
    }
  }
  state.tag = _tag;
  state.dump = _result || "[]";
}
function writeFlowMapping(state, level, object2) {
  var _result = "", _tag = state.tag, objectKeyList = Object.keys(object2), index, length, objectKey, objectValue, pairBuffer;
  for (index = 0, length = objectKeyList.length; index < length; index += 1) {
    pairBuffer = "";
    if (_result !== "") pairBuffer += ", ";
    if (state.condenseFlow) pairBuffer += '"';
    objectKey = objectKeyList[index];
    objectValue = object2[objectKey];
    if (state.replacer) {
      objectValue = state.replacer.call(object2, objectKey, objectValue);
    }
    if (!writeNode(state, level, objectKey, false, false)) {
      continue;
    }
    if (state.dump.length > 1024) pairBuffer += "? ";
    pairBuffer += state.dump + (state.condenseFlow ? '"' : "") + ":" + (state.condenseFlow ? "" : " ");
    if (!writeNode(state, level, objectValue, false, false)) {
      continue;
    }
    pairBuffer += state.dump;
    _result += pairBuffer;
  }
  state.tag = _tag;
  state.dump = "{" + _result + "}";
}
function writeBlockMapping(state, level, object2, compact) {
  var _result = "", _tag = state.tag, objectKeyList = Object.keys(object2), index, length, objectKey, objectValue, explicitPair, pairBuffer;
  if (state.sortKeys === true) {
    objectKeyList.sort();
  } else if (typeof state.sortKeys === "function") {
    objectKeyList.sort(state.sortKeys);
  } else if (state.sortKeys) {
    throw new exception("sortKeys must be a boolean or a function");
  }
  for (index = 0, length = objectKeyList.length; index < length; index += 1) {
    pairBuffer = "";
    if (!compact || _result !== "") {
      pairBuffer += generateNextLine(state, level);
    }
    objectKey = objectKeyList[index];
    objectValue = object2[objectKey];
    if (state.replacer) {
      objectValue = state.replacer.call(object2, objectKey, objectValue);
    }
    if (!writeNode(state, level + 1, objectKey, true, true, true)) {
      continue;
    }
    explicitPair = state.tag !== null && state.tag !== "?" || state.dump && state.dump.length > 1024;
    if (explicitPair) {
      if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
        pairBuffer += "?";
      } else {
        pairBuffer += "? ";
      }
    }
    pairBuffer += state.dump;
    if (explicitPair) {
      pairBuffer += generateNextLine(state, level);
    }
    if (!writeNode(state, level + 1, objectValue, true, explicitPair)) {
      continue;
    }
    if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
      pairBuffer += ":";
    } else {
      pairBuffer += ": ";
    }
    pairBuffer += state.dump;
    _result += pairBuffer;
  }
  state.tag = _tag;
  state.dump = _result || "{}";
}
function detectType(state, object2, explicit) {
  var _result, typeList, index, length, type2, style;
  typeList = explicit ? state.explicitTypes : state.implicitTypes;
  for (index = 0, length = typeList.length; index < length; index += 1) {
    type2 = typeList[index];
    if ((type2.instanceOf || type2.predicate) && (!type2.instanceOf || typeof object2 === "object" && object2 instanceof type2.instanceOf) && (!type2.predicate || type2.predicate(object2))) {
      if (explicit) {
        if (type2.multi && type2.representName) {
          state.tag = type2.representName(object2);
        } else {
          state.tag = type2.tag;
        }
      } else {
        state.tag = "?";
      }
      if (type2.represent) {
        style = state.styleMap[type2.tag] || type2.defaultStyle;
        if (_toString.call(type2.represent) === "[object Function]") {
          _result = type2.represent(object2, style);
        } else if (_hasOwnProperty.call(type2.represent, style)) {
          _result = type2.represent[style](object2, style);
        } else {
          throw new exception("!<" + type2.tag + '> tag resolver accepts not "' + style + '" style');
        }
        state.dump = _result;
      }
      return true;
    }
  }
  return false;
}
function writeNode(state, level, object2, block, compact, iskey, isblockseq) {
  state.tag = null;
  state.dump = object2;
  if (!detectType(state, object2, false)) {
    detectType(state, object2, true);
  }
  var type2 = _toString.call(state.dump);
  var inblock = block;
  var tagStr;
  if (block) {
    block = state.flowLevel < 0 || state.flowLevel > level;
  }
  var objectOrArray = type2 === "[object Object]" || type2 === "[object Array]", duplicateIndex, duplicate;
  if (objectOrArray) {
    duplicateIndex = state.duplicates.indexOf(object2);
    duplicate = duplicateIndex !== -1;
  }
  if (state.tag !== null && state.tag !== "?" || duplicate || state.indent !== 2 && level > 0) {
    compact = false;
  }
  if (duplicate && state.usedDuplicates[duplicateIndex]) {
    state.dump = "*ref_" + duplicateIndex;
  } else {
    if (objectOrArray && duplicate && !state.usedDuplicates[duplicateIndex]) {
      state.usedDuplicates[duplicateIndex] = true;
    }
    if (type2 === "[object Object]") {
      if (block && Object.keys(state.dump).length !== 0) {
        writeBlockMapping(state, level, state.dump, compact);
        if (duplicate) {
          state.dump = "&ref_" + duplicateIndex + state.dump;
        }
      } else {
        writeFlowMapping(state, level, state.dump);
        if (duplicate) {
          state.dump = "&ref_" + duplicateIndex + " " + state.dump;
        }
      }
    } else if (type2 === "[object Array]") {
      if (block && state.dump.length !== 0) {
        if (state.noArrayIndent && !isblockseq && level > 0) {
          writeBlockSequence(state, level - 1, state.dump, compact);
        } else {
          writeBlockSequence(state, level, state.dump, compact);
        }
        if (duplicate) {
          state.dump = "&ref_" + duplicateIndex + state.dump;
        }
      } else {
        writeFlowSequence(state, level, state.dump);
        if (duplicate) {
          state.dump = "&ref_" + duplicateIndex + " " + state.dump;
        }
      }
    } else if (type2 === "[object String]") {
      if (state.tag !== "?") {
        writeScalar(state, state.dump, level, iskey, inblock);
      }
    } else if (type2 === "[object Undefined]") {
      return false;
    } else {
      if (state.skipInvalid) return false;
      throw new exception("unacceptable kind of an object to dump " + type2);
    }
    if (state.tag !== null && state.tag !== "?") {
      tagStr = encodeURI(
        state.tag[0] === "!" ? state.tag.slice(1) : state.tag
      ).replace(/!/g, "%21");
      if (state.tag[0] === "!") {
        tagStr = "!" + tagStr;
      } else if (tagStr.slice(0, 18) === "tag:yaml.org,2002:") {
        tagStr = "!!" + tagStr.slice(18);
      } else {
        tagStr = "!<" + tagStr + ">";
      }
      state.dump = tagStr + " " + state.dump;
    }
  }
  return true;
}
function getDuplicateReferences(object2, state) {
  var objects = [], duplicatesIndexes = [], index, length;
  inspectNode(object2, objects, duplicatesIndexes);
  for (index = 0, length = duplicatesIndexes.length; index < length; index += 1) {
    state.duplicates.push(objects[duplicatesIndexes[index]]);
  }
  state.usedDuplicates = new Array(length);
}
function inspectNode(object2, objects, duplicatesIndexes) {
  var objectKeyList, index, length;
  if (object2 !== null && typeof object2 === "object") {
    index = objects.indexOf(object2);
    if (index !== -1) {
      if (duplicatesIndexes.indexOf(index) === -1) {
        duplicatesIndexes.push(index);
      }
    } else {
      objects.push(object2);
      if (Array.isArray(object2)) {
        for (index = 0, length = object2.length; index < length; index += 1) {
          inspectNode(object2[index], objects, duplicatesIndexes);
        }
      } else {
        objectKeyList = Object.keys(object2);
        for (index = 0, length = objectKeyList.length; index < length; index += 1) {
          inspectNode(object2[objectKeyList[index]], objects, duplicatesIndexes);
        }
      }
    }
  }
}
function dump$1(input, options) {
  options = options || {};
  var state = new State(options);
  if (!state.noRefs) getDuplicateReferences(input, state);
  var value = input;
  if (state.replacer) {
    value = state.replacer.call({ "": value }, "", value);
  }
  if (writeNode(state, 0, value, true, true)) return state.dump + "\n";
  return "";
}
var dump_1 = dump$1;
var dumper = {
  dump: dump_1
};
function renamed(from, to) {
  return function() {
    throw new Error("Function yaml." + from + " is removed in js-yaml 4. Use yaml." + to + " instead, which is now safe by default.");
  };
}
var Type = type;
var Schema = schema;
var FAILSAFE_SCHEMA = failsafe;
var JSON_SCHEMA = json2;
var CORE_SCHEMA = core;
var DEFAULT_SCHEMA = _default3;
var load = loader.load;
var loadAll = loader.loadAll;
var dump = dumper.dump;
var YAMLException = exception;
var types2 = {
  binary,
  float,
  map: map2,
  null: _null4,
  pairs,
  set: set2,
  timestamp,
  bool,
  int: int2,
  merge: merge3,
  omap,
  seq,
  str
};
var safeLoad = renamed("safeLoad", "load");
var safeLoadAll = renamed("safeLoadAll", "loadAll");
var safeDump = renamed("safeDump", "dump");
var jsYaml = {
  Type,
  Schema,
  FAILSAFE_SCHEMA,
  JSON_SCHEMA,
  CORE_SCHEMA,
  DEFAULT_SCHEMA,
  load,
  loadAll,
  dump,
  YAMLException,
  types: types2,
  safeLoad,
  safeLoadAll,
  safeDump
};

// src/ts/core/lessonSchemas.ts
init_zod();
init_coreTypes();
init_basicTaskCore();
init_newUserWelcomeCore();
init_mainMenuCore();
var LessonMetadataSchema = external_exports.object({
  id: ImmutableId,
  entityType: external_exports.enum(["lesson", "menu"]),
  // allows both types
  title: external_exports.string().min(1).max(200),
  description: external_exports.string().min(1).max(1e3),
  domainId: ImmutableId.optional(),
  // only required for learning lessons
  estimatedMinutes: external_exports.number().int().min(1).max(60),
  difficulty: external_exports.enum(["beginner", "intermediate", "advanced"]),
  version: external_exports.string().regex(/^\d+\.\d+\.\d+$/)
});
var ComponentConfigSchema = external_exports.discriminatedUnion("type", [
  BasicTaskComponentConfigSchema,
  NewUserWelcomeComponentConfigSchema,
  MainMenuComponentConfigSchema
  // Add new component schemas here as you create them
  // Example: QuizComponentConfigSchema,
  // Example: VideoComponentConfigSchema,
]);
var PageSchema = external_exports.object({
  id: ImmutableId,
  title: external_exports.string().min(1).max(200),
  description: external_exports.string().optional(),
  order: external_exports.number().int().min(0),
  components: external_exports.array(ComponentConfigSchema).min(1).max(10)
});
var LessonSchema = external_exports.object({
  metadata: LessonMetadataSchema,
  pages: external_exports.array(PageSchema).min(1).max(10)
});

// src/ts/initialization/yamlParser.ts
var MAX_WAIT_MS = 1e4;
var INITIAL_BACKOFF_MS = 50;
var MAX_BACKOFF_MS = 3200;
var MAX_FETCH_RETRIES = 3;
var RETRY_BACKOFF_MS = 1e3;
var MAX_RETRY_BACKOFF_MS = 5e3;
var YAMLLoadTimeoutError = class extends Error {
  constructor(message2) {
    super(message2);
    this.name = "YAMLLoadTimeoutError";
  }
};
var YAMLFetchError = class extends Error {
  constructor(filename, path, attempts, lastError) {
    super(
      `Failed to fetch YAML file after ${attempts} attempts: ${filename}
Path: ${path}
Last error: ${lastError}`
    );
    this.name = "YAMLFetchError";
    this.filename = filename;
    this.path = path;
    this.attempts = attempts;
  }
};
var YAMLParseError = class extends Error {
  constructor(filename, yamlError) {
    super(`Failed to parse YAML file: ${filename}`);
    this.name = "YAMLParseError";
    this.filename = filename;
    this.yamlError = yamlError;
  }
};
var YAMLValidationError = class extends Error {
  constructor(filename, lessonId, zodError) {
    super(`YAML validation failed for ${filename} (lesson ID: ${lessonId})`);
    this.name = "YAMLValidationError";
    this.filename = filename;
    this.lessonId = lessonId;
    this.zodError = zodError;
  }
};
async function loadAndParseAllLessons() {
  console.log("\u{1F680} Starting YAML parsing workflow...");
  await waitForYAMLLoad();
  await retryFailedFiles();
  const lessons = parseAllLessons();
  console.log("\u2705 YAML parsing workflow complete");
  return lessons;
}
async function waitForYAMLLoad() {
  console.log("\u23F3 Waiting for YAML loader to complete initial attempt...");
  const startTime = Date.now();
  let backoffMs = INITIAL_BACKOFF_MS;
  let attempt = 0;
  while (Date.now() - startTime < MAX_WAIT_MS) {
    attempt++;
    if (window.initializationStatus?.yamlsComplete === true) {
      const elapsed = Date.now() - startTime;
      const total = window.initializationStatus.yamlsTotal;
      const loaded = window.initializationStatus.yamlsLoaded;
      const failed = total - loaded;
      console.log(
        `\u2705 YAML loader complete in ${elapsed}ms (${loaded}/${total} succeeded, ${failed} failed)`
      );
      return;
    }
    await new Promise((resolve) => setTimeout(resolve, backoffMs));
    backoffMs = Math.min(backoffMs * 2, MAX_BACKOFF_MS);
  }
  const status = window.initializationStatus;
  throw new YAMLLoadTimeoutError(
    `YAML loader timed out after ${MAX_WAIT_MS}ms. Status: ${status?.yamlsLoaded || 0}/${status?.yamlsTotal || 0} files loaded. This indicates a critical failure in yaml-loader.js itself.`
  );
}
async function retryFetchYAML(filename, path) {
  console.log(`\u{1F504} Retrying failed file: ${filename}`);
  let lastError = "Unknown error";
  for (let attempt = 1; attempt <= MAX_FETCH_RETRIES; attempt++) {
    try {
      console.log(
        `  \u{1F4E1} Attempt ${attempt}/${MAX_FETCH_RETRIES} for ${filename}...`
      );
      const response = await fetch(path);
      if (!response.ok) {
        lastError = `HTTP ${response.status}: ${response.statusText}`;
        if (attempt < MAX_FETCH_RETRIES) {
          const delay = Math.min(
            RETRY_BACKOFF_MS * Math.pow(2, attempt - 1),
            MAX_RETRY_BACKOFF_MS
          );
          console.warn(
            `  \u26A0\uFE0F HTTP ${response.status} for ${filename}, retrying in ${delay}ms...`
          );
          await new Promise((resolve) => setTimeout(resolve, delay));
          continue;
        }
        throw new YAMLFetchError(filename, path, attempt, lastError);
      }
      const yamlText = await response.text();
      console.log(
        `  \u2705 Successfully fetched ${filename} on attempt ${attempt}`
      );
      return yamlText;
    } catch (error46) {
      if (error46 instanceof YAMLFetchError) {
        throw error46;
      }
      lastError = error46 instanceof Error ? error46.message : String(error46);
      if (attempt < MAX_FETCH_RETRIES) {
        const delay = Math.min(
          RETRY_BACKOFF_MS * Math.pow(2, attempt - 1),
          MAX_RETRY_BACKOFF_MS
        );
        console.warn(
          `  \u26A0\uFE0F Network error for ${filename}: ${lastError}, retrying in ${delay}ms...`
        );
        await new Promise((resolve) => setTimeout(resolve, delay));
        continue;
      }
      throw new YAMLFetchError(filename, path, attempt, lastError);
    }
  }
  throw new YAMLFetchError(filename, path, MAX_FETCH_RETRIES, lastError);
}
async function retryFailedFiles() {
  const errors = window.yamlLoadingErrors || [];
  if (errors.length === 0) {
    console.log("\u2705 No failed files to retry");
    return;
  }
  console.log(`\u{1F504} Retrying ${errors.length} failed file(s)...`);
  const retryResults = await Promise.allSettled(
    errors.map((error46) => retryFetchYAML(error46.filename, error46.path))
  );
  const stillFailed = [];
  let retrySucceeded = 0;
  for (let i = 0; i < retryResults.length; i++) {
    const result = retryResults[i];
    const error46 = errors[i];
    if (result.status === "fulfilled") {
      window.lessonRegistry[error46.filename] = result.value;
      retrySucceeded++;
    } else {
      stillFailed.push(error46);
    }
  }
  if (stillFailed.length > 0) {
    console.error(
      `\u274C ${stillFailed.length} file(s) failed after retries:`,
      stillFailed.map((e) => e.filename)
    );
    const first = stillFailed[0];
    throw new YAMLFetchError(
      first.filename,
      first.path,
      MAX_FETCH_RETRIES,
      first.error
    );
  }
  console.log(`\u2705 Successfully retried all ${retrySucceeded} failed file(s)`);
}
function parseAllLessons() {
  console.log("\u{1F4D6} Parsing and validating lesson YAML files...");
  if (!window.lessonRegistry) {
    throw new Error(
      "window.lessonRegistry is not defined. Critical initialization failure - yaml-loader.js did not execute."
    );
  }
  const lessons = /* @__PURE__ */ new Map();
  const entries = Object.entries(window.lessonRegistry);
  if (entries.length === 0) {
    throw new Error(
      "No lesson files found in window.lessonRegistry. This means all YAML files failed to load. Critical failure."
    );
  }
  console.log(`\u{1F4DA} Processing ${entries.length} lesson file(s)...`);
  for (const [filename, yamlText] of entries) {
    if (filename.startsWith("domain_") || filename.startsWith("curriculum_")) {
      console.log(`\u23ED\uFE0F  Skipping non-lesson file: ${filename}`);
      continue;
    }
    console.log(`\u{1F4C4} Parsing ${filename}...`);
    let parsed;
    try {
      parsed = jsYaml.load(yamlText);
    } catch (error46) {
      console.error(`\u274C YAML parse error in ${filename}:`, error46);
      throw new YAMLParseError(filename, error46);
    }
    const lessonId = parsed?.metadata?.id ?? "UNKNOWN";
    let lesson;
    try {
      lesson = LessonSchema.parse(parsed);
    } catch (error46) {
      console.error(
        `\u274C Validation error in ${filename} (lesson ${lessonId}):`,
        error46
      );
      throw new YAMLValidationError(filename, lessonId, error46);
    }
    if (lessons.has(lesson.metadata.id)) {
      throw new Error(
        `Duplicate lesson ID ${lesson.metadata.id} found in ${filename}. Each lesson must have a unique ID. Critical content error.`
      );
    }
    lessons.set(lesson.metadata.id, lesson);
    console.log(
      `\u2705 Validated ${filename} (lesson ${lesson.metadata.id}: "${lesson.metadata.title}")`
    );
  }
  console.log(`\u{1F389} Successfully parsed and validated ${lessons.size} lesson(s)`);
  return lessons;
}

// src/ts/ui/userMessage.ts
async function showUserMessage(title, message2, primaryLabel, secondaryLabel) {
  return new Promise((resolve) => {
    const overlay = document.createElement("div");
    overlay.className = "fixed inset-0 bg-black/60 flex items-center justify-center z-50";
    overlay.id = "user-message-overlay";
    const card = document.createElement("div");
    card.className = "bg-white rounded-lg shadow-2xl p-6 max-w-md mx-4 space-y-4";
    const titleEl = document.createElement("h2");
    titleEl.className = "text-xl font-semibold text-gray-900";
    titleEl.textContent = title;
    const messageEl = document.createElement("p");
    messageEl.className = "text-gray-700 whitespace-pre-line";
    messageEl.textContent = message2;
    const buttonContainer = document.createElement("div");
    buttonContainer.className = "flex gap-3 justify-end pt-2";
    const primaryBtn = document.createElement("button");
    primaryBtn.className = "px-4 py-2 bg-blue-600 hover:bg-blue-700 text-white font-medium rounded transition-colors";
    primaryBtn.textContent = primaryLabel;
    primaryBtn.onclick = () => {
      cleanup();
      resolve("primary");
    };
    if (secondaryLabel) {
      const secondaryBtn = document.createElement("button");
      secondaryBtn.className = "px-4 py-2 bg-gray-200 hover:bg-gray-300 text-gray-800 font-medium rounded transition-colors";
      secondaryBtn.textContent = secondaryLabel;
      secondaryBtn.onclick = () => {
        cleanup();
        resolve("secondary");
      };
      buttonContainer.appendChild(secondaryBtn);
    }
    buttonContainer.appendChild(primaryBtn);
    card.appendChild(titleEl);
    card.appendChild(messageEl);
    card.appendChild(buttonContainer);
    overlay.appendChild(card);
    document.body.appendChild(overlay);
    primaryBtn.focus();
    function cleanup() {
      overlay.remove();
    }
  });
}
async function flashSuccess(message2, durationMs = 2e3) {
  return new Promise((resolve) => {
    const overlay = document.createElement("div");
    overlay.className = "fixed inset-0 bg-black/40 flex items-center justify-center z-50";
    overlay.id = "success-flash-overlay";
    const card = document.createElement("div");
    card.className = "bg-white rounded-lg shadow-2xl p-6 max-w-sm mx-4";
    const messageEl = document.createElement("p");
    messageEl.className = "text-lg font-medium text-green-700 text-center";
    messageEl.textContent = message2;
    card.appendChild(messageEl);
    overlay.appendChild(card);
    document.body.appendChild(overlay);
    setTimeout(() => {
      overlay.remove();
      resolve();
    }, durationMs);
  });
}

// src/ts/initialization/initializationOrchestrator.ts
init_meraBridge();

// src/ts/persistence/saveOrchestrator.ts
init_meraBridge();
async function orchestrateSave(bundleJSON, timestamp2, allowSolidSaves) {
  const fileNames = generateFilenames(timestamp2);
  let localOfflineSucceeded = false;
  try {
    await Promise.all([
      saveLoadCheckCleanLocal(fileNames.localOfflinePrimary, bundleJSON),
      saveLoadCheckCleanLocal(fileNames.localOfflineDup, bundleJSON)
    ]);
    localOfflineSucceeded = true;
  } catch (localOfflineError) {
    console.error("Local offline save failed:", localOfflineError);
  }
  let podSucceeded = false;
  if (allowSolidSaves) {
    try {
      await Promise.all([
        saveLoadCheckCleanSolid(fileNames.solidPrimary, bundleJSON),
        saveLoadCheckCleanSolid(fileNames.solidDup, bundleJSON)
      ]);
      podSucceeded = true;
    } catch (podError) {
      console.error("Pod save failed:", podError);
    }
  } else {
    console.warn("Pod save blocked - concurrence check did not pass");
  }
  if (!podSucceeded) {
    return localOfflineSucceeded ? 2 /* OnlyLocalSucceeded */ : 1 /* BothFailed */;
  }
  try {
    await Promise.all([
      saveLoadCheckCleanLocal(fileNames.localOnlinePrimary, bundleJSON),
      saveLoadCheckCleanLocal(fileNames.localOnlineDup, bundleJSON)
    ]);
    const bridge = MeraBridge.getInstance();
    try {
      await Promise.all([
        bridge.localDelete(fileNames.localOfflinePrimary),
        bridge.localDelete(fileNames.localOfflineDup)
      ]);
    } catch (cleanupError) {
      console.warn("Cleanup failed:", cleanupError);
    }
    return 0 /* BothSucceeded */;
  } catch (localOnlineError) {
    console.error("Local online save failed:", localOnlineError);
    return 3 /* OnlySolidSucceeded */;
  }
}
async function saveLoadCheckCleanLocal(filename, bundleJSON) {
  const bridge = MeraBridge.getInstance();
  try {
    const saveResult = await bridge.localSave(filename, bundleJSON);
    if (!saveResult.success) {
      throw new Error(saveResult.error || "Local save failed");
    }
    const loadResult = await bridge.localLoad(filename);
    if (!loadResult.success || !loadResult.data) {
      throw new Error(loadResult.error || "Local load failed");
    }
    if (loadResult.data !== bundleJSON) {
      throw new Error(`Data mismatch in ${filename}`);
    }
  } catch (error46) {
    try {
      await bridge.localDelete(filename);
    } catch (cleanupError) {
      console.warn("Failed to cleanup after error:", cleanupError);
    }
    throw error46;
  }
}
async function saveLoadCheckCleanSolid(filename, bundleJSON) {
  const bridge = MeraBridge.getInstance();
  try {
    const saveResult = await bridge.solidSave(filename, bundleJSON);
    if (!saveResult.success) {
      throw new Error(saveResult.error || "Solid save failed");
    }
    const loadResult = await bridge.solidLoad(filename);
    if (!loadResult.success || !loadResult.data) {
      throw new Error(loadResult.error || "Solid load failed");
    }
    if (loadResult.data !== bundleJSON) {
      throw new Error(`Data mismatch in ${filename}`);
    }
  } catch (error46) {
    try {
      await bridge.solidDelete(filename);
    } catch (cleanupError) {
      console.warn("Failed to cleanup corrupted Pod file:", cleanupError);
    }
    throw error46;
  }
}
function generateFilenames(timestamp2) {
  const v = CURRENT_SCHEMA_VERSION;
  const prefix = `mera.${v.major}.${v.minor}.${v.patch}`;
  return {
    localOfflinePrimary: `${prefix}.lofp.${timestamp2}.json`,
    localOfflineDup: `${prefix}.lofd.${timestamp2}.json`,
    solidPrimary: `${prefix}.sp.${timestamp2}.json`,
    solidDup: `${prefix}.sd.${timestamp2}.json`,
    localOnlinePrimary: `${prefix}.lonp.${timestamp2}.json`,
    localOnlineDup: `${prefix}.lond.${timestamp2}.json`
  };
}

// src/ts/persistence/saveManager.ts
init_meraBridge();
var SaveManager = class _SaveManager {
  // ============================================================================
  // INITIALIZATION
  // ============================================================================
  constructor() {
    // ============================================================================
    // CORE STATE
    // ============================================================================
    /** Prevents concurrent save operations */
    this.saveInProgress = false;
    /** Last save outcome, used for retry logic and online status */
    this.lastSaveResult = 0 /* BothSucceeded */;
    /** Latest progress bundle JSON queued by Main Core */
    this.queuedSave = null;
    /** Flag indicating bundle has changed since last save */
    this.saveHasChanged = false;
    /** Flag indicating a critical save (e.g., lesson completion) is pending */
    this.criticalSavePending = false;
    // ============================================================================
    // CONCURRENT SESSION PROTECTION STATE
    // ============================================================================
    /** Session ID for concurrent session detection (null until first save) */
    this.sessionId = null;
    /** Path to session protection file in Pod */
    this.SESSION_FILE_PATH = "mera_concurrent_session_protection.json";
    this.startPolling();
  }
  /**
   * Gets singleton instance, creating and starting it if needed.
   *
   * @returns The global SaveManager instance
   */
  static getInstance() {
    if (!_SaveManager.instance) {
      _SaveManager.instance = new _SaveManager();
    }
    return _SaveManager.instance;
  }
  /**
   * Begins save polling cycle. Called automatically by constructor.
   *
   * Runs every 50ms to check for changed state and trigger saves.
   * Each poll cycle completes before scheduling the next one.
   */
  startPolling() {
    const poll = async () => {
      await this.checkAndSave();
      setTimeout(poll, 50);
    };
    poll();
  }
  // ============================================================================
  // CORE SAVE LOGIC
  // ============================================================================
  /**
   * Polling cycle that checks for changed state and triggers saves.
   *
   * Save triggers when:
   * - No save currently in progress, AND
   * - Either progress has changed, OR last Pod save failed (retry logic)
   *
   * However, core generally only calls queueSave() every 15 seconds except for with progress events
   *
   * Sequential execution: Each poll waits for save to complete before returning.
   */
  async checkAndSave() {
    if (this.queuedSave === null) {
      return;
    }
    if (!this.saveInProgress && (this.saveHasChanged || this.lastSaveResult === 1 /* BothFailed */ || this.lastSaveResult === 2 /* OnlyLocalSucceeded */)) {
      this.saveInProgress = true;
      this.saveHasChanged = false;
      const wasCriticalPending = this.criticalSavePending;
      const bundleSnapshot = this.queuedSave;
      const timestamp2 = Date.now();
      const concurrenceCheck = await this.checkConcurrentSessions();
      if (concurrenceCheck === 1 /* ConcurrentSessionDetected */) {
        showCriticalError({
          title: "Concurrent Session Detected",
          message: "Another device or tab is using this account. Please refresh to continue.",
          technicalDetails: "Session ID mismatch detected in Pod",
          errorCode: "concurrent-session"
        });
        this.lastSaveResult = 1 /* BothFailed */;
        return;
      }
      if (concurrenceCheck === 2 /* InitializationFailed */) {
        showCriticalError({
          title: "Save System Failure",
          message: "Failed to initialize session protection. Progress is not being saved.",
          technicalDetails: "Could not write or verify session file after retries",
          errorCode: "session-init-failure"
        });
        this.lastSaveResult = 1 /* BothFailed */;
        return;
      }
      try {
        const allowSolidSaves = concurrenceCheck === 0 /* Passed */;
        const result = await orchestrateSave(
          bundleSnapshot,
          timestamp2,
          allowSolidSaves
        );
        this.lastSaveResult = result;
        if (result === 0 /* BothSucceeded */) {
          console.log(`\u2705 Save completed: Pod + localStorage`);
        } else if (result === 2 /* OnlyLocalSucceeded */) {
          console.log(`\u26A0\uFE0F Save completed: localStorage only (Pod failed)`);
        } else if (result === 3 /* OnlySolidSucceeded */) {
          console.error(
            "\u26A0\uFE0F localStorage save failed - offline mode unavailable"
          );
        } else {
          console.log(`\u274C Save failed: both Pod and localStorage`);
        }
        if (wasCriticalPending && result !== 1 /* BothFailed */) {
          this.criticalSavePending = false;
        }
        if (result === 3 /* OnlySolidSucceeded */) {
          console.error(
            "\u26A0\uFE0F localStorage save failed - offline mode unavailable"
          );
        }
      } catch (error46) {
        showCriticalError({
          title: "Save System Failure",
          message: "Progress is not being saved.",
          technicalDetails: error46.stack,
          errorCode: "save-orchestration-failure"
        });
        this.lastSaveResult = 1 /* BothFailed */;
      } finally {
        this.saveInProgress = false;
      }
    }
  }
  /**
   * Queues progress bundle JSON for next save cycle.
   *
   * Called by Main Core after processing progress updates. Does not
   * block - save happens asynchronously during next polling cycle.
   *
   * Typically happens once every 15 seconds if there had been a change
   * or happens with major progress event.
   *
   * @param bundleJSON - Pre-stringified JSON representation of complete progress bundle
   * @param hasChanged - True if bundle differs from last save
   * @param criticalSave - Optional: True if this save represents critical progress (e.g., lesson completion)
   */
  queueSave(bundleJSON, hasChanged, criticalSave) {
    this.queuedSave = bundleJSON;
    this.saveHasChanged = hasChanged;
    if (criticalSave) {
      this.criticalSavePending = true;
    }
  }
  /**
   * Returns whether Solid Pod sync is currently working.
   *
   * Used by UI to display online/offline status. True if last save
   * succeeded in reaching the Pod, false if offline or Pod unreachable.
   *
   * @returns True if Pod sync operational, false otherwise
   */
  getOnlineStatus() {
    if (this.lastSaveResult === 0 /* BothSucceeded */ || this.lastSaveResult === 3 /* OnlySolidSucceeded */) {
      return true;
    } else {
      return false;
    }
  }
  /**
   * Returns whether it's safe to close the window.
   *
   * Used by UI to warn user before closing if critical progress hasn't been saved yet.
   * Returns false if a critical save is pending (queued or in progress but not completed).
   *
   * @returns True if safe to close (no critical saves pending), false otherwise
   */
  safeToClose() {
    return !this.criticalSavePending;
  }
  // ============================================================================
  // CONCURRENT SESSION PROTECTION (Edge Case Prevention)
  // ============================================================================
  //
  // This section implements tamper-detection tripwire logic to prevent data
  // corruption when the same Pod is accessed from multiple devices/tabs.
  //
  // Strategy: Write a random session ID to the Pod, then verify it hasn't
  // changed before each save. If it changes, another session is active.
  //
  // This is NOT a lock - it's detection after the fact. The 50ms pause after
  // writing creates a window to catch near-simultaneous session starts.
  // ============================================================================
  /**
   * Generates a cryptographically random 128-bit session ID.
   *
   * @returns Hex-encoded 128-bit random ID
   */
  generateSessionId() {
    const array2 = new Uint8Array(16);
    crypto.getRandomValues(array2);
    return Array.from(array2, (byte) => byte.toString(16).padStart(2, "0")).join(
      ""
    );
  }
  /**
   * Checks for concurrent sessions by verifying session ID in Pod.
   *
   * First call: Writes random session ID, waits, verifies write succeeded
   * Subsequent calls: Reads session ID, verifies it matches local copy
   *
   * This is a tamper-detection tripwire, not a lock. If another device/tab
   * starts a session, we detect the ID change and halt to prevent corruption.
   *
   * @returns ConcurrenceCheckResult indicating what happened
   */
  async checkConcurrentSessions() {
    const bridge = MeraBridge.getInstance();
    if (this.sessionId === null) {
      const newSessionId = this.generateSessionId();
      const sessionFile = { sessionId: newSessionId };
      const maxRetries = 5;
      let retryCount = 0;
      let writeSucceeded = false;
      while (retryCount < maxRetries && !writeSucceeded) {
        try {
          await bridge.solidSave(
            this.SESSION_FILE_PATH,
            JSON.stringify(sessionFile)
          );
          writeSucceeded = true;
        } catch (error46) {
          retryCount++;
          if (retryCount >= maxRetries) {
            console.error(
              `Failed to write session protection file after ${maxRetries} attempts:`,
              error46
            );
            return 2 /* InitializationFailed */;
          }
          await new Promise(
            (resolve) => setTimeout(resolve, 50 * Math.pow(2, retryCount - 1))
          );
        }
      }
      await new Promise((resolve) => setTimeout(resolve, 50));
      try {
        const readBackResult = await bridge.solidLoad(this.SESSION_FILE_PATH);
        if (!readBackResult.success || !readBackResult.data) {
          console.error("Session file read failed:", readBackResult.error);
          return 2 /* InitializationFailed */;
        }
        const verified = JSON.parse(readBackResult.data);
        if (verified.sessionId !== newSessionId) {
          console.error(
            "Concurrent session detected during initialization - another device/tab overwrote session ID"
          );
          return 1 /* ConcurrentSessionDetected */;
        }
        this.sessionId = newSessionId;
        return 0 /* Passed */;
      } catch (error46) {
        console.error("Session verification failed:", error46);
        return 2 /* InitializationFailed */;
      }
    } else {
      try {
        const currentResult = await bridge.solidLoad(this.SESSION_FILE_PATH);
        if (!currentResult.success || !currentResult.data) {
          console.warn(
            "Session check network error, blocking solid saves:",
            currentResult.error
          );
          return 3 /* NetworkError */;
        }
        const currentFile = JSON.parse(
          currentResult.data
        );
        if (currentFile.sessionId !== this.sessionId) {
          console.error(
            "Concurrent session detected - session ID changed. Another device/tab is active."
          );
          return 1 /* ConcurrentSessionDetected */;
        }
        return 0 /* Passed */;
      } catch (error46) {
        console.warn("Session check failed, blocking solid saves:", error46);
        return 3 /* NetworkError */;
      }
    }
  }
};

// src/ts/persistence/saveCleaner.ts
init_meraBridge();
var SaveCleaner = class _SaveCleaner {
  constructor() {
    this.startCleaning();
  }
  /**
   * Begins cleanup interval. Called automatically by constructor.
   * 
   * Runs cleanup every 60 seconds as fire-and-forget operations.
   * Errors are logged but do not stop the interval.
   */
  startCleaning() {
    setInterval(() => this.clean(), 60 * 1e3);
  }
  /**
   * Gets singleton instance, creating and starting it if needed.
   * 
   * @returns The global SaveCleaner instance
   */
  static getInstance() {
    if (!_SaveCleaner.instance) {
      _SaveCleaner.instance = new _SaveCleaner();
    }
    return _SaveCleaner.instance;
  }
  /**
   * Triggers cleanup for both storage locations in parallel.
   * 
   * Fire-and-forget pattern with error handling. Cleanup failures
   * are logged but don't block the interval or crash the app.
   */
  clean() {
    const timestamp2 = Date.now();
    this.cleanSolid(timestamp2).catch(
      (err) => console.error("Solid cleanup failed:", err)
    );
    this.cleanLocal(timestamp2).catch(
      (err) => console.error("Local cleanup failed:", err)
    );
  }
  /**
   * Cleans Solid Pod backups using time-bracket retention strategy.
   * 
   * Treats primary/duplicate pairs as single units. Lists only primaries (.sp.)
   * for bracket logic, but deletes both primary and duplicate together.
   * 
   * Enforces minimum 4 backup pairs. Applies conditional deletion to preserve
   * temporal diversity during transition periods.
   * 
   * After bracket-based cleanup, removes orphaned duplicates older than 24 hours.
   * 
   * @param timestamp - Current time in milliseconds for age calculation
   */
  async cleanSolid(timestamp2) {
    const bridge = MeraBridge.getInstance();
    const result = await bridge.solidList("mera.*.*.*.sp.*.json");
    if (!result.success || !result.data) {
      console.error("Failed to list Solid backups:", result.error);
      return;
    }
    const primaryFiles = result.data;
    if (primaryFiles.length <= 4) {
      console.log("Skipping Solid cleanup: minimum 4 backups maintained");
      return;
    }
    const backups = this.parseBackupFiles(primaryFiles, timestamp2);
    const toDelete = this.selectFilesForDeletion(backups);
    for (const primaryFilename of toDelete) {
      if (await this.canDeleteSolid()) {
        const dupFilename = primaryFilename.replace(".sp.", ".sd.");
        const primaryResult = await bridge.solidDelete(primaryFilename);
        if (!primaryResult.success) {
          console.error(`Failed to delete ${primaryFilename}:`, primaryResult.error);
        }
        const dupResult = await bridge.solidDelete(dupFilename);
        if (!dupResult.success) {
          console.error(`Failed to delete ${dupFilename}:`, dupResult.error);
        }
      } else {
        break;
      }
    }
    await this.cleanOrphanedDuplicates("solid", timestamp2);
  }
  /**
   * Cleans localStorage backups using time-bracket retention strategy.
   * 
   * Treats primary/duplicate pairs as single units. Lists both offline (.lofp.)
   * and online (.lonp.) primaries together, as both represent local backup history.
   * 
   * Why treat them together: Offline files persist if device stays offline,
   * online files replace them after Pod sync. Both contribute to the same
   * local recovery point timeline.
   * 
   * Enforces minimum 4 backup pairs. Applies conditional deletion strategy.
   * 
   * After bracket-based cleanup, removes orphaned duplicates older than 24 hours.
   * 
   * @param timestamp - Current time in milliseconds for age calculation
   */
  async cleanLocal(timestamp2) {
    const bridge = MeraBridge.getInstance();
    const offlineResult = await bridge.localList("mera.*.*.*.lofp.*.json");
    const onlineResult = await bridge.localList("mera.*.*.*.lonp.*.json");
    if (!offlineResult.success || !offlineResult.data) {
      console.error("Failed to list local offline backups:", offlineResult.error);
      return;
    }
    if (!onlineResult.success || !onlineResult.data) {
      console.error("Failed to list local online backups:", onlineResult.error);
      return;
    }
    const primaryFiles = [...offlineResult.data, ...onlineResult.data];
    if (primaryFiles.length <= 4) {
      console.log("Skipping local cleanup: minimum 4 backups maintained");
      return;
    }
    const backups = this.parseBackupFiles(primaryFiles, timestamp2);
    const toDelete = this.selectFilesForDeletion(backups);
    for (const primaryFilename of toDelete) {
      if (await this.canDeleteLocal()) {
        const dupFilename = primaryFilename.replace(".lofp.", ".lofd.").replace(".lonp.", ".lond.");
        const primaryResult = await bridge.localDelete(primaryFilename);
        if (!primaryResult.success) {
          console.error(`Failed to delete ${primaryFilename}:`, primaryResult.error);
        }
        const dupResult = await bridge.localDelete(dupFilename);
        if (!dupResult.success) {
          console.error(`Failed to delete ${dupFilename}:`, dupResult.error);
        }
      } else {
        break;
      }
    }
    await this.cleanOrphanedDuplicates("local", timestamp2);
  }
  /**
   * Parses backup filenames into structured objects with age calculation.
   * 
   * Extracts Unix timestamp from filename pattern:
   * "mera.{major}.{minor}.{patch}.{type}.{timestamp}.json"
   * 
   * Examples:
   * - mera.0.1.0.sp.1234567890.json (Solid primary)
   * - mera.0.1.0.lofp.1234567890.json (Local offline primary)
   * - mera.0.1.0.lonp.1234567890.json (Local online primary)
   * 
   * Calculates age relative to current time. Invalid filenames are filtered out.
   * 
   * @param filenames - Array of backup filenames to parse
   * @param currentTime - Current timestamp for age calculation
   * @returns Sorted array of backup objects, oldest first
   */
  parseBackupFiles(filenames, currentTime) {
    return filenames.map((filename) => {
      const match = filename.match(/mera\.\d+\.\d+\.\d+\.[a-z]+\.(\d+)\.json/);
      if (!match) return null;
      const timestamp2 = parseInt(match[1]);
      const ageMs = currentTime - timestamp2;
      return { filename, timestamp: timestamp2, ageMs };
    }).filter((backup) => backup !== null).sort((a, b) => a.timestamp - b.timestamp);
  }
  /**
   * Selects files for deletion using conditional time-bracket strategy.
   * 
   * Time brackets (newest to oldest):
   * - <1 minute: Keep ALL (active saves, never delete)
   * - 1-10 minutes: Keep newest only (consolidate when recent bracket populated)
   * - 10 minutes-1 hour: Keep newest only (consolidate when 1-10min bracket populated)
   * - 1-24 hours: Keep newest only (consolidate when 10min-1hr bracket populated)
   * - >24 hours: Delete all (consolidate when 1-24hr bracket populated)
   * 
   * This conditional deletion preserves temporal diversity during idle-to-active
   * transitions. Old stratified backups remain until new recovery points establish.
   * 
   * @param backups - Sorted array of backup files with age data
   * @returns Array of filenames selected for deletion
   */
  selectFilesForDeletion(backups) {
    const oneMin = 60 * 1e3;
    const tenMin = 10 * oneMin;
    const oneHour = 60 * oneMin;
    const twentyFourHours = 24 * oneHour;
    const brackets = {
      ancient: backups.filter((b) => b.ageMs > twentyFourHours),
      day: backups.filter((b) => b.ageMs > oneHour && b.ageMs <= twentyFourHours),
      hour: backups.filter((b) => b.ageMs > tenMin && b.ageMs <= oneHour),
      tenMin: backups.filter((b) => b.ageMs > oneMin && b.ageMs <= tenMin),
      recent: backups.filter((b) => b.ageMs <= oneMin)
    };
    const toDelete = [];
    if (brackets.day.length > 0) {
      toDelete.push(...brackets.ancient);
    }
    if (brackets.hour.length > 0) {
      toDelete.push(...brackets.day.slice(0, -1));
    }
    if (brackets.tenMin.length > 0) {
      toDelete.push(...brackets.hour.slice(0, -1));
    }
    if (brackets.recent.length > 0) {
      toDelete.push(...brackets.tenMin.slice(0, -1));
    }
    return toDelete.map((b) => b.filename);
  }
  /**
   * Removes orphaned duplicate files older than 24 hours.
   * 
   * Duplicates are orphaned when their primary doesn't exist (failed delete,
   * corruption, etc). Wait 24 hours before deleting in case they're the only
   * surviving copy.
   * 
   * @param storageType - 'solid' or 'local'
   * @param currentTime - Current timestamp for age calculation
   */
  async cleanOrphanedDuplicates(storageType, currentTime) {
    const bridge = MeraBridge.getInstance();
    const twentyFourHours = 24 * 60 * 60 * 1e3;
    const patterns = storageType === "solid" ? ["mera.*.*.*.sd.*.json"] : ["mera.*.*.*.lofd.*.json", "mera.*.*.*.lond.*.json"];
    const listFn = storageType === "solid" ? bridge.solidList : bridge.localList;
    const loadFn = storageType === "solid" ? bridge.solidLoad : bridge.localLoad;
    const deleteFn = storageType === "solid" ? bridge.solidDelete : bridge.localDelete;
    const toPrimary = (dup) => dup.replace(".sd.", ".sp.").replace(".lofd.", ".lofp.").replace(".lond.", ".lonp.");
    const allDups = [];
    for (const pattern of patterns) {
      const result = await listFn.call(bridge, pattern);
      if (result.success && result.data) {
        allDups.push(...result.data);
      }
    }
    for (const dup of allDups) {
      const match = dup.match(/\.(\d+)\.json$/);
      if (!match) continue;
      const age = currentTime - parseInt(match[1]);
      if (age <= twentyFourHours) continue;
      const primary = toPrimary(dup);
      const primaryExists = await loadFn.call(bridge, primary);
      if (!primaryExists.success) {
        await deleteFn.call(bridge, dup);
      }
    }
  }
  /**
   * Checks if Solid Pod backup deletion is safe.
   * 
   * Re-lists primary files to verify count hasn't dropped below minimum.
   * This check happens before each deletion to handle concurrent
   * operations or failed deletes.
   * 
   * @returns True if more than 4 backup pairs exist, false otherwise
   */
  async canDeleteSolid() {
    const bridge = MeraBridge.getInstance();
    const result = await bridge.solidList("mera.*.*.*.sp.*.json");
    if (!result.success || !result.data) {
      return false;
    }
    return result.data.length > 4;
  }
  /**
   * Checks if localStorage backup deletion is safe.
   * 
   * Re-lists both offline and online primary files to verify count hasn't
   * dropped below minimum. This check happens before each deletion to handle
   * concurrent operations or failed deletes.
   * 
   * @returns True if more than 4 backup pairs exist, false otherwise
   */
  async canDeleteLocal() {
    const bridge = MeraBridge.getInstance();
    const offlineResult = await bridge.localList("mera.*.*.*.lofp.*.json");
    const onlineResult = await bridge.localList("mera.*.*.*.lonp.*.json");
    if (!offlineResult.success || !offlineResult.data || !onlineResult.success || !onlineResult.data) {
      return false;
    }
    const totalPrimaries = offlineResult.data.length + onlineResult.data.length;
    return totalPrimaries > 4;
  }
};

// src/ts/core/startCore.ts
init_navigationSchema();
init_overallProgressSchema();
init_settingsSchema();
init_mera_registry();

// src/ts/components/componentManagerFactory.ts
init_basicTaskCore();
init_newUserWelcomeCore();
init_mainMenuCore();
function createComponentProgressManager(componentType, config2, progressData) {
  switch (componentType) {
    case "basic_task": {
      const validated = BasicTaskComponentProgressSchema.parse(progressData);
      return new BasicTaskProgressManager(
        config2,
        // Pass config first
        validated
      );
    }
    case "new_user_welcome": {
      const validated = NewUserWelcomeComponentProgressSchema.parse(progressData);
      return new NewUserWelcomeProgressManager(
        config2,
        // Pass config first
        validated
      );
    }
    case "main_menu": {
      const validated = MainMenuComponentProgressSchema.parse(progressData);
      return new MainMenuProgressManager(
        config2,
        validated
      );
    }
    // Future component types go here
    default:
      throw new Error(`Unknown component type: ${componentType}`);
  }
}

// src/ts/components/componentProgressHandlerFactory.ts
init_basicTaskCore();
function createComponentProgressHandlers(componentManagers) {
  const handlers = /* @__PURE__ */ new Map();
  const basicTaskHandler = new BasicTaskProgressMessageHandler(componentManagers);
  handlers.set("basic_task", basicTaskHandler);
  return handlers;
}

// src/ts/core/startCore.ts
init_mera_registry();
init_mera_registry();

// src/ts/components/componentPermissions.ts
var MESSAGE_TYPE_PERMISSIONS = {
  "basic_task": {
    componentProgress: true,
    // Can update its own state
    overallProgress: false,
    // Cannot mark lessons complete
    navigation: false,
    // Cannot navigate
    settings: false
    // Cannot change settings
  },
  "new_user_welcome": {
    componentProgress: false,
    // Doesn't have persistent state
    overallProgress: false,
    // Cannot mark lessons complete
    navigation: true,
    // Can navigate
    settings: true
    // Can change settings
  },
  "main_menu": {
    componentProgress: true,
    // Special: can modify OTHER components' progress
    overallProgress: true,
    // Can mark lessons incomplete or complete
    navigation: true,
    // Can navigate to lessons
    settings: false
    // Cannot change settings
  }
  // Add additional components here
};
function hasPermissions(componentType) {
  return componentType in MESSAGE_TYPE_PERMISSIONS;
}
function getPermissions(componentType) {
  return MESSAGE_TYPE_PERMISSIONS[componentType];
}

// src/ts/core/componentInstantiator.ts
init_mera_registry();

// src/ts/components/componentCoreFactory.ts
init_basicTaskCore();

// src/ts/ui/timelineContainer.ts
var TimelineContainer = class {
  constructor(containerId = "lesson-container") {
    this.containerId = containerId;
    this.timelineId = `${containerId}-timeline`;
    this.setupTimelineStructure();
  }
  /**
   * Create the basic timeline DOM structure - just a centered container
   */
  setupTimelineStructure() {
    const container = document.getElementById(this.containerId);
    if (!container) {
      throw new Error(`Container ${this.containerId} not found`);
    }
    container.innerHTML = `
        <div class="max-w-4xl lg:max-w-6xl mx-auto py-8 px-4">
            <div id="${this.timelineId}" class="space-y-8">
              <!-- Component slots will be added here -->
             </div>
        </div>
    `;
    console.log("\u2705 Timeline container initialized");
  }
  /**
   * Add a slot for a component to render into.
   * Creates a simple wrapper div with consistent spacing.
   *
   * @param componentId - Unique identifier for the component
   */
  addComponentSlot(componentId) {
    const timeline2 = document.getElementById(this.timelineId);
    if (!timeline2) {
      console.error("\u274C Timeline not found, cannot add slot");
      return;
    }
    const slotHtml = `
            <div id="slot-${componentId}" class="component-slot">
                <div id="component-area-${componentId}" class="component-content">
                    <!-- Component interface renders here -->
                </div>
            </div>
        `;
    timeline2.insertAdjacentHTML("beforeend", slotHtml);
    console.log(`\u{1F4CD} Added slot for component ${componentId}`);
  }
  /**
   * Get the DOM element where a component should render its content.
   * Component interfaces use this to know where to attach their UI.
   *
   * @param componentId - Component identifier
   * @returns The render area element, or null if not found
   */
  getComponentArea(componentId) {
    const area = document.getElementById(`component-area-${componentId}`);
    if (!area) {
      console.warn(`\u26A0\uFE0F Component area ${componentId} not found`);
    }
    return area;
  }
  /**
   * Remove all component slots from the timeline.
   * Called when navigating to a new page - clears everything for fresh start.
   */
  clearTimeline() {
    const timeline2 = document.getElementById(this.timelineId);
    if (timeline2) {
      timeline2.innerHTML = "";
      console.log("\u{1F9F9} Timeline cleared of all component slots");
    }
  }
  /**
   * Get basic timeline statistics for debugging.
   *
   * @returns Object with timeline metrics
   */
  getTimelineStats() {
    const timeline2 = document.getElementById(this.timelineId);
    const totalSlots = timeline2 ? timeline2.querySelectorAll(".component-slot").length : 0;
    return {
      totalSlots,
      containerId: this.containerId,
      timelineId: this.timelineId
    };
  }
};
var timelineInstance = null;
function initializeTimeline(containerId = "lesson-container") {
  if (timelineInstance) {
    console.warn(
      "\u26A0\uFE0F Timeline already initialized, returning existing instance"
    );
    return timelineInstance;
  }
  timelineInstance = new TimelineContainer(containerId);
  console.log("\u2705 Timeline singleton initialized");
  return timelineInstance;
}
function getTimelineInstance() {
  if (!timelineInstance) {
    throw new Error(
      "Timeline not initialized. Call initializeTimeline() in bootstrap first."
    );
  }
  return timelineInstance;
}

// src/ts/components/componentCoreFactory.ts
init_newUserWelcomeCore();
init_mainMenuCore();
function createComponentCore(componentType, config2, progressManager, curriculumData2, overallProgressManager, navigationManager, settingsManager) {
  const timeline2 = getTimelineInstance();
  switch (componentType) {
    case "basic_task":
      return new BasicTaskCore(
        config2,
        progressManager,
        timeline2,
        overallProgressManager,
        navigationManager,
        settingsManager,
        curriculumData2
      );
    case "new_user_welcome":
      return new NewUserWelcomeCore(
        config2,
        progressManager,
        timeline2,
        overallProgressManager,
        navigationManager,
        settingsManager,
        curriculumData2
      );
    case "main_menu":
      return new MainMenuCore(
        config2,
        progressManager,
        timeline2,
        overallProgressManager,
        navigationManager,
        settingsManager,
        curriculumData2
      );
    // TODO: Add other component types as they're implemented
    // case 'quiz':
    //   return new QuizCore(
    //     config as QuizComponentConfig,
    //     progressManager as QuizProgressManager,
    //     curriculumData
    //   );
    default:
      throw new Error(
        `Unknown component type: '${componentType}'. Add to componentCoreFactory.ts when implementing new component types.`
      );
  }
}

// src/ts/components/componentCoordinator.ts
var ComponentCoordinator = class {
  constructor() {
    // Current page's components being coordinated (cloned map for safety)
    this.currentPageCores = null;
    // Whether a page load is currently in progress
    this.loadingInProgress = false;
  }
  /**
   * Clear current page state in preparation for new page.
   * 
   * Called by runCore before destroying old components.
   * Resets coordinator state for the next page load.
   */
  clearPage() {
    console.log("\u{1F4C4} ComponentCoordinator: Clearing page state");
    this.currentPageCores = null;
    this.loadingInProgress = false;
  }
  /**
   * Begin coordinating a new page load.
   * 
   * Orchestrates the async loading and activation of all components:
   * 1. Store cloned map of cores (defensive against external changes)
   * 2. Poll components for readiness (assets loaded)
   * 3. Activate all components when ready (or on timeout)
   * 
   * This method is async but called fire-and-forget. Main Core continues
   * polling normally while this runs in parallel. Components return empty
   * message arrays until activated.
   * 
   * @param cores - Map of component cores to coordinate (componentId -> core)
   * @returns Promise that resolves when page load complete (or times out)
   */
  async beginPageLoad(cores) {
    console.log(
      `\u{1F3AC} ComponentCoordinator: Beginning page load with ${cores.size} components`
    );
    this.currentPageCores = new Map(cores);
    this.loadingInProgress = true;
    try {
      await this.waitForAllReady();
      this.activateAllComponents();
      console.log("\u2705 ComponentCoordinator: Page load complete");
    } catch (error46) {
      console.error("\u274C ComponentCoordinator: Page load failed:", error46);
      this.activateAllComponents();
    } finally {
      this.loadingInProgress = false;
    }
  }
  /**
   * Wait for all components to report ready.
   * 
   * Polls every 50ms, checking if all components have finished loading assets.
   * 
   * Uses progress-based timeout: Times out only if NO progress detected for
   * 30 seconds. This allows slow connections to take as long as needed, while 
   * still timing out on truly stalled connections.
   * 
   * Progress is tracked via component.interface.getLoadingProgress() which
   * returns {loaded, total} for components that support it. If any component
   * shows increasing 'loaded' bytes, the timeout clock resets.
   * 
   * Each component check is wrapped in try-catch to handle destroyed/broken
   * components gracefully. A broken component doesn't block page load.
   * 
   * @returns Promise that resolves when all ready or stall timeout reached
   */
  async waitForAllReady() {
    const POLL_INTERVAL_MS2 = 50;
    const STALL_TIMEOUT_MS = 3e4;
    let lastProgressTime = Date.now();
    let lastProgressSnapshot = this.captureProgressSnapshot();
    let iterationCount = 0;
    while (true) {
      if (this.allComponentsReady()) {
        console.log(
          `\u2705 All components ready after ${iterationCount * POLL_INTERVAL_MS2}ms`
        );
        return;
      }
      const currentSnapshot = this.captureProgressSnapshot();
      if (this.hasProgressChanged(lastProgressSnapshot, currentSnapshot)) {
        lastProgressTime = Date.now();
        lastProgressSnapshot = currentSnapshot;
      }
      const timeSinceProgress = Date.now() - lastProgressTime;
      if (timeSinceProgress > STALL_TIMEOUT_MS) {
        console.warn(
          `\u26A0\uFE0F ComponentCoordinator: No progress for ${STALL_TIMEOUT_MS}ms - connection stalled, proceeding anyway`
        );
        return;
      }
      await new Promise((resolve) => setTimeout(resolve, POLL_INTERVAL_MS2));
      iterationCount++;
    }
  }
  /**
   * Capture current loading progress for all components.
   * 
   * Returns a snapshot of how many bytes each component has loaded.
   * Used to detect whether progress is being made on slow connections.
   * 
   * Components that don't support progress tracking (like BasicTask with
   * no assets) won't appear in the snapshot - that's fine, we just track
   * the ones that do report progress.
   * 
   * @returns Map of componentId  bytes loaded
   */
  captureProgressSnapshot() {
    const snapshot = /* @__PURE__ */ new Map();
    if (!this.currentPageCores) return snapshot;
    for (const [componentId, core2] of this.currentPageCores) {
      try {
        const progress = core2.interface.getLoadingProgress();
        if (progress) {
          snapshot.set(componentId, progress.loaded);
        }
      } catch (error46) {
      }
    }
    return snapshot;
  }
  /**
   * Check if any component has loaded more bytes.
   * 
   * Compares two progress snapshots to detect forward progress.
   * Even 1 byte of progress resets the stall timeout.
   * 
   * @param oldSnapshot - Previous progress snapshot
   * @param newSnapshot - Current progress snapshot
   * @returns true if any component loaded more data
   */
  hasProgressChanged(oldSnapshot, newSnapshot) {
    for (const [componentId, newBytes] of newSnapshot) {
      const oldBytes = oldSnapshot.get(componentId) || 0;
      if (newBytes > oldBytes) {
        return true;
      }
    }
    return false;
  }
  /**
   * Check if all components report ready.
   * 
   * Defensive implementation - each component check wrapped in try-catch.
   * Broken/destroyed components are treated as "ready" (don't block page).
   * 
   * @returns true if all components ready (or no components exist)
   */
  allComponentsReady() {
    if (!this.currentPageCores || this.currentPageCores.size === 0) {
      return true;
    }
    for (const [componentId, core2] of this.currentPageCores) {
      try {
        if (!core2.isInterfaceReady()) {
          return false;
        }
      } catch (error46) {
        console.warn(
          `\u26A0\uFE0F Component ${componentId} readiness check failed, treating as ready:`,
          error46
        );
      }
    }
    return true;
  }
  /**
   * Activate all components.
   * 
   * Calls displayInterface() on each component, which:
   * 1. Renders component to DOM (creates timeline slot, displays content)
   * 2. Enables operations (_operationsEnabled = true)
   * 
   * After this, components can produce messages and interact with users.
   * 
   * Each activation is wrapped in try-catch. One broken component doesn't
   * prevent others from activating.
   */
  activateAllComponents() {
    if (!this.currentPageCores) {
      return;
    }
    console.log(
      `\u{1F680} ComponentCoordinator: Activating ${this.currentPageCores.size} components`
    );
    for (const [componentId, core2] of this.currentPageCores) {
      try {
        core2.displayInterface();
      } catch (error46) {
        console.error(
          `\u274C Component ${componentId} activation failed:`,
          error46
        );
      }
    }
  }
  /**
   * Check if all components on current page are complete.
   * 
   * Called synchronously by navigation components to determine if user
   * can proceed to next page (e.g., "Next" button should be enabled).
   * 
   * Defensive implementation - broken components treated as complete
   * (don't block navigation due to component bugs).
   * 
   * Race condition acceptable: If user clicks during the 50ms window
   * where a component becomes incomplete, navigation may still succeed.
   * This is an acceptable UX trade-off vs. complex locking.
   * 
   * @returns true if all components complete (or no components exist)
   */
  areAllComplete() {
    if (!this.currentPageCores || this.currentPageCores.size === 0) {
      return true;
    }
    for (const [componentId, core2] of this.currentPageCores) {
      try {
        if (!core2.isComplete()) {
          return false;
        }
      } catch (error46) {
        console.warn(
          `\u26A0\uFE0F Component ${componentId} completion check failed, treating as complete:`,
          error46
        );
      }
    }
    return true;
  }
  /**
   * Check if page load is currently in progress.
   * 
   * Can be used by UI to show loading indicators, though not currently
   * required by the architecture.
   * 
   * @returns true if beginPageLoad() is running
   */
  isLoadingInProgress() {
    return this.loadingInProgress;
  }
};
var componentCoordinator = new ComponentCoordinator();

// src/ts/core/componentInstantiator.ts
function instantiateComponents(navigationState, lessonConfigs, componentManagers, curriculumData2, settingsManager, overallProgressManager, navigationManager) {
  const currentEntityId = navigationState.currentEntityId;
  const currentPage = navigationState.currentPage;
  const lessonConfig = lessonConfigs.get(currentEntityId);
  if (!lessonConfig) {
    throw new Error(
      `Lesson config not found for entity ${currentEntityId}. This indicates curriculum/YAML mismatch.`
    );
  }
  const componentsOnPage = lessonConfig.components.filter(
    (component) => component.page === currentPage
  );
  componentsOnPage.sort((a, b) => a.order - b.order);
  console.log(
    `\u{1F4C4} Page ${currentPage} of entity ${currentEntityId}: ${componentsOnPage.length} components to instantiate`
  );
  const componentCores = /* @__PURE__ */ new Map();
  const componentProgressPolling = /* @__PURE__ */ new Map();
  const overallProgressPolling = /* @__PURE__ */ new Map();
  const navigationPolling = /* @__PURE__ */ new Map();
  const settingsPolling = /* @__PURE__ */ new Map();
  for (const componentConfig of componentsOnPage) {
    const componentId = componentConfig.id;
    const componentType = componentIdToTypeMap.get(componentId);
    if (!componentType) {
      throw new Error(
        `Component ${componentId} not found in componentIdToTypeMap. This indicates registry generation bug.`
      );
    }
    if (!hasPermissions(componentType)) {
      throw new Error(
        `Component type '${componentType}' has no defined permissions. Add to MESSAGE_TYPE_PERMISSIONS in componentPermissions.ts`
      );
    }
    const primaryManager = componentManagers.get(componentId);
    if (!primaryManager) {
      throw new Error(
        `Progress manager not found for component ${componentId}. This indicates startCore instantiation bug.`
      );
    }
    const secondaryManager = createComponentProgressManager(
      componentType,
      componentConfig,
      // Type assertion: YAML parser guarantees BaseComponentConfig structure
      primaryManager.getProgress()
      //  Already cloned by getProgress()!
    );
    try {
      const core2 = createComponentCore(
        componentType,
        componentConfig,
        secondaryManager,
        //  Component gets CLONED secondary manager
        curriculumData2,
        overallProgressManager,
        navigationManager,
        settingsManager
      );
      componentCores.set(componentId, core2);
      const permissions = getPermissions(componentType);
      if (!permissions) {
        throw new Error(
          `Permissions unexpectedly undefined for ${componentType}`
        );
      }
      if (permissions.componentProgress) {
        componentProgressPolling.set(componentId, componentType);
      }
      if (permissions.overallProgress) {
        overallProgressPolling.set(componentId, componentType);
      }
      if (permissions.navigation) {
        navigationPolling.set(componentId, componentType);
      }
      if (permissions.settings) {
        settingsPolling.set(componentId, componentType);
      }
    } catch (err) {
      console.error(
        `\u26A0\uFE0F Component ${componentId} (${componentType}) failed to instantiate - skipping:`,
        err
      );
      continue;
    }
  }
  console.log(`\u2705 Created ${componentCores.size} component cores`);
  console.log(
    `   - componentProgress: ${componentProgressPolling.size} allowed`
  );
  console.log(`   - overallProgress: ${overallProgressPolling.size} allowed`);
  console.log(`   - navigation: ${navigationPolling.size} allowed`);
  console.log(`   - settings: ${settingsPolling.size} allowed`);
  componentCoordinator.beginPageLoad(componentCores).catch((err) => {
    console.error("Component coordinator failed:", err);
  });
  return {
    componentCores,
    componentProgressPolling,
    overallProgressPolling,
    navigationPolling,
    settingsPolling
  };
}

// src/ts/core/runCore.ts
init_mera_registry();
init_progressIntegrity();
async function runCore(params) {
  console.log("\u{1F504} Starting main polling loop (50ms)...");
  let pageChanged = true;
  let currentComponents = null;
  let hasChanged = false;
  let overallProgressChanged = false;
  const saveManager = SaveManager.getInstance();
  let lastSaveQueueTime = Date.now();
  const SAVE_QUEUE_INTERVAL_MS = 15e3;
  while (true) {
    const navStateAtStart = params.navigationManager.getState();
    if (pageChanged) {
      const navigationState = params.navigationManager.getState();
      currentComponents = instantiateComponents(
        navigationState,
        params.lessonConfigs,
        params.componentManagers,
        params.curriculumData,
        params.settingsManager,
        params.overallProgressManager,
        params.navigationManager
      );
      pageChanged = false;
      console.log(
        `\u{1F4E6} Instantiated ${currentComponents.componentCores.size} components`
      );
    }
    if (!currentComponents) {
      throw new Error("No components instantiated - this should never happen");
    }
    for (const [componentId, core2] of currentComponents.componentCores) {
      const componentType = componentIdToTypeMap.get(componentId);
      if (!componentType) {
        throw new Error(
          `CRITICAL: Component ${componentId} exists in componentCores but has no type in registry. This indicates registry generation bug or deployment error. Registry must be regenerated with current curriculum.`
        );
      }
      if (currentComponents.componentProgressPolling.has(componentId)) {
        const messages = core2.getComponentProgressMessages();
        if (messages.length > 0) {
          hasChanged = true;
          const MAIN_MENU_COMPONENT_ID = 1e6;
          if (componentId !== MAIN_MENU_COMPONENT_ID) {
            for (const msg of messages) {
              try {
                if (msg.componentId !== componentId) {
                  throw new Error(
                    `Component ${componentId} attempted to modify component ${msg.componentId} (unauthorized)`
                  );
                }
                const handler = params.componentProgressHandlers.get(componentType);
                if (!handler) {
                  console.error(
                    `No handler for component type ${componentType}`
                  );
                  continue;
                }
                handler.handleMessage(msg);
              } catch (error46) {
                console.error(
                  `Component ${componentId} message failed:`,
                  error46
                );
              }
            }
          } else {
            for (const msg of messages) {
              try {
                const targetComponentType = componentIdToTypeMap.get(
                  msg.componentId
                );
                if (!targetComponentType) {
                  console.error(
                    `Main menu targeted unknown component ${msg.componentId}`
                  );
                  continue;
                }
                const handler = params.componentProgressHandlers.get(targetComponentType);
                if (!handler) {
                  console.error(
                    `No handler for component type ${targetComponentType}`
                  );
                  continue;
                }
                handler.handleMessage(msg);
              } catch (error46) {
                console.error(
                  `Main menu message failed for component ${msg.componentId}:`,
                  error46
                );
              }
            }
          }
        }
      }
      if (currentComponents.settingsPolling.has(componentId)) {
        const messages = core2.getSettingsMessages();
        if (messages.length > 0) {
          hasChanged = true;
          for (const msg of messages) {
            params.settingsHandler.handleMessage(msg);
          }
        }
      }
      if (currentComponents.overallProgressPolling.has(componentId)) {
        const messages = core2.getOverallProgressMessages();
        if (messages.length > 0) {
          hasChanged = true;
          overallProgressChanged = true;
          for (const msg of messages) {
            params.overallProgressHandler.handleMessage(msg);
          }
        }
      }
      if (currentComponents.navigationPolling.has(componentId)) {
        const messages = core2.getNavigationMessages();
        if (messages.length > 0) {
          hasChanged = true;
          for (const msg of messages) {
            params.navigationHandler.handleMessage(msg);
          }
        }
      }
    }
    const navStateAtEnd = params.navigationManager.getState();
    if (navStateAtEnd.currentEntityId !== navStateAtStart.currentEntityId || navStateAtEnd.currentPage !== navStateAtStart.currentPage) {
      pageChanged = true;
    }
    const componentProgressObj = {};
    for (const [componentId, manager] of params.componentManagers) {
      componentProgressObj[componentId.toString()] = manager.getProgress();
    }
    const bundle = {
      metadata: { webId: params.webId },
      overallProgress: params.overallProgressManager.getProgress(),
      settings: params.settingsManager.getSettings(),
      navigationState: params.navigationManager.getState(),
      combinedComponentProgress: {
        components: componentProgressObj
      }
    };
    const bundleJSON = JSON.stringify(bundle);
    try {
      const integrityCheck = enforceDataIntegrity(
        bundleJSON,
        params.webId,
        params.lessonConfigs
      );
      if (!integrityCheck.perfectlyValidInput) {
        console.error("\u{1F4A5} CRITICAL: Generated corrupt bundle:", integrityCheck);
        throw new Error(
          "Bundle failed integrity check - this is a bug in state managers"
        );
      }
    } catch (error46) {
      console.error("\u{1F4A5} CRITICAL: Bundle integrity validation failed:", error46);
      throw error46;
    }
    const now = Date.now();
    const timeSinceLastSave = now - lastSaveQueueTime;
    const shouldQueueSave = hasChanged && timeSinceLastSave >= SAVE_QUEUE_INTERVAL_MS || overallProgressChanged;
    if (shouldQueueSave) {
      saveManager.queueSave(bundleJSON, hasChanged, overallProgressChanged);
      lastSaveQueueTime = now;
      console.log(
        `\u{1F4BE} Save queued (hasChanged=${hasChanged}, critical=${overallProgressChanged})`
      );
      hasChanged = false;
      overallProgressChanged = false;
    } else {
      if (timeSinceLastSave % 3e4 < 100) {
        console.log(
          `\u23ED\uFE0F Core running, no save needed (no changes, last save ${Math.floor(timeSinceLastSave / 1e3)}s ago)`
        );
      }
    }
    await new Promise((resolve) => setTimeout(resolve, 50));
    if (pageChanged && currentComponents !== null) {
      componentCoordinator.clearPage();
      currentComponents.componentCores.forEach((core2) => {
        try {
          core2.interface.destroy();
        } catch (error46) {
          console.error(`Error destroying component ${core2.config.id}:`, error46);
        }
      });
      currentComponents = null;
    }
  }
}

// src/ts/core/startCore.ts
async function startCore(bundle, lessonConfigs) {
  console.log("\u{1F680} Starting Main Application Core initialization...");
  console.log("  Progress bundle:", {
    webId: bundle.metadata.webId,
    lessonsCompleted: Object.keys(bundle.overallProgress.lessonCompletions).length,
    settings: Object.keys(bundle.settings).length,
    components: Object.keys(bundle.combinedComponentProgress.components).length
  });
  console.log("  Lesson configs:", lessonConfigs.size, "lessons");
  const settingsManager = new SettingsDataManager(bundle.settings);
  const navigationManager = new NavigationStateManager(
    bundle.navigationState,
    curriculumData
  );
  const overallProgressManager = new OverallProgressManager(
    bundle.overallProgress,
    curriculumData
  );
  const componentManagers = /* @__PURE__ */ new Map();
  for (const [componentIdStr, progressData] of Object.entries(
    bundle.combinedComponentProgress.components
  )) {
    const componentId = Number(componentIdStr);
    if (!Number.isInteger(componentId)) {
      throw new Error(
        `Invalid component ID format in bundle: "${componentIdStr}" (expected integer)`
      );
    }
    const componentType = componentIdToTypeMap.get(componentId);
    if (!componentType) {
      throw new Error(
        `No component type mapping found for component ID ${componentId}. This indicates registry generation bug or deployment error. Registry must be regenerated with current curriculum.`
      );
    }
    const lessonId = componentToLessonMap.get(componentId);
    if (lessonId === void 0) {
      throw new Error(
        `No lesson mapping found for component ID ${componentId}. This indicates registry generation bug or corrupted mappings.`
      );
    }
    const lessonConfig = lessonConfigs.get(lessonId);
    if (!lessonConfig) {
      throw new Error(
        `No lesson config found for lesson ID ${lessonId}. This indicates YAML parser failure or orchestration bug. Expected ${lessonConfigs.size} lessons, missing lesson ${lessonId}.`
      );
    }
    const componentConfig = lessonConfig.components.find(
      (c) => c.id === componentId
    );
    if (!componentConfig) {
      throw new Error(
        `Component ${componentId} not found in lesson ${lessonId} config. This indicates structure mismatch between registry and YAML. Lesson has ${lessonConfig.components.length} components.`
      );
    }
    const typedConfig = componentConfig;
    const manager = createComponentProgressManager(
      componentType,
      typedConfig,
      progressData
    );
    componentManagers.set(componentId, manager);
  }
  const navigationHandler = new NavigationMessageHandler(
    navigationManager,
    curriculumData
  );
  const settingsHandler = new SettingsMessageHandler(settingsManager);
  const overallProgressHandler = new OverallProgressMessageHandler(
    overallProgressManager,
    curriculumData
  );
  const componentProgressHandlers = createComponentProgressHandlers(componentManagers);
  console.log("\u2705 All managers and handlers instantiated successfully");
  const webId = bundle.metadata.webId;
  try {
    await runCore({
      settingsManager,
      navigationManager,
      overallProgressManager,
      componentManagers,
      navigationHandler,
      settingsHandler,
      overallProgressHandler,
      componentProgressHandlers,
      curriculumData,
      lessonConfigs,
      webId
    });
  } catch (err) {
    console.error("\u{1F4A5} FATAL ERROR in runCore() polling loop:");
    throw err;
  }
}

// src/ts/initialization/initializationOrchestrator.ts
async function initializationOrchestrator() {
  console.log("\u{1F3AF} Starting initialization orchestration...");
  console.log("\u{1F4DA} Phase 0: Loading lesson configurations...");
  const rawLessons = await loadAndParseAllLessons();
  const lessonConfigs = new Map(
    Array.from(rawLessons.entries()).map(([id, lesson]) => {
      const components = lesson.pages.flatMap(
        (page, pageIndex) => page.components.map((component) => ({
          ...component,
          page: pageIndex
        }))
      );
      return [
        id,
        {
          metadata: lesson.metadata,
          pages: lesson.pages,
          components
        }
      ];
    })
  );
  console.log(`\u2705 Loaded ${lessonConfigs.size} lesson configurations`);
  console.log("\u{1F50D} Phase 1: Checking session protection file...");
  const sessionFileExists = await checkSessionFileExists();
  console.log(`Session file exists: ${sessionFileExists}`);
  console.log("\u{1F4E6} Phase 2: Loading progress...");
  const loadResult = await orchestrateProgressLoading(lessonConfigs);
  if (loadResult === null) {
    showCriticalError({
      title: "Authentication Failure",
      message: "Cannot proceed - user authentication state is invalid. This indicates a critical bootstrap failure.",
      technicalDetails: "progressLoader returned null despite bootstrap authentication check"
    });
    throw new Error("Authentication failure after bootstrap - critical error");
  }
  if (!loadResult.bundle) {
    console.log("\u{1F4DD} New user detected - creating default bundle");
    const { MeraBridge: MeraBridge2 } = await Promise.resolve().then(() => (init_meraBridge(), meraBridge_exports));
    const webId = MeraBridge2.getInstance().getWebId();
    const { enforceDataIntegrity: enforceDataIntegrity2 } = await Promise.resolve().then(() => (init_progressIntegrity(), progressIntegrity_exports));
    const defaultResult = enforceDataIntegrity2("", webId, lessonConfigs);
    defaultResult.bundle.metadata.webId = webId;
    loadResult.bundle = defaultResult.bundle;
    loadResult.recoveryMetrics = defaultResult.recoveryMetrics;
  }
  console.log("\u{1F914} Phase 3: Evaluating recovery scenario...");
  const shouldProceed = await handleRecoveryScenario(
    loadResult,
    sessionFileExists
  );
  if (!shouldProceed) {
    await showStopDialog();
    return;
  }
  console.log("\u2699\uFE0F Phase 4: Starting background services...");
  SaveManager.getInstance();
  SaveCleaner.getInstance();
  console.log("\u2705 Background services started");
  console.log("\u{1F680} Phase 5: Launching core...");
  startCore(loadResult.bundle, lessonConfigs).then(
    () => {
      console.log("\u2705 Core started successfully");
    },
    (error46) => {
      console.error("\u274C Core initialization failed:", error46);
      showCriticalError({
        title: "Core Initialization Failed",
        message: "The application failed to start.",
        technicalDetails: error46 instanceof Error ? error46.message : String(error46)
      });
    }
  );
  console.log("\u2705 Initialization complete - core launching independently");
}
async function checkSessionFileExists() {
  const bridge = MeraBridge.getInstance();
  const SESSION_FILE_PATH = "mera_concurrent_session_protection.json";
  try {
    const result = await bridge.solidLoad(SESSION_FILE_PATH);
    return result.success;
  } catch (error46) {
    return false;
  }
}
async function handleRecoveryScenario(loadResult, sessionFileExists) {
  const { scenario, recoveryMetrics } = loadResult;
  if (scenario === "DEFAULT_NO_SAVES" /* DEFAULT_NO_SAVES */ && sessionFileExists) {
    return await handleCatastrophicLoss();
  }
  if (scenario === "DEFAULT_FAILED_RECOVERY" /* DEFAULT_FAILED_RECOVERY */ && sessionFileExists) {
    return await handleCatastrophicLoss();
  }
  if (scenario === "DEFAULT_WEBID_MISMATCH" /* DEFAULT_WEBID_MISMATCH */ && sessionFileExists) {
    return await handleCatastrophicLoss();
  }
  if (scenario === "IMPERFECT_RECOVERY_CORRUPTION" /* IMPERFECT_RECOVERY_CORRUPTION */) {
    return await handleDegradedRecovery(recoveryMetrics);
  }
  if (scenario === "PERFECT_RECOVERY" /* PERFECT_RECOVERY */) {
    await flashSuccess("Progress loaded \u2713", 1500);
    return true;
  }
  if (scenario === "IMPERFECT_RECOVERY_MIGRATION" /* IMPERFECT_RECOVERY_MIGRATION */) {
    await flashSuccess("Progress loaded \u2713", 1500);
    return true;
  }
  if (scenario === "DEFAULT_NO_SAVES" /* DEFAULT_NO_SAVES */ && !sessionFileExists) {
    console.log("New user - proceeding with default progress");
    return true;
  }
  console.warn(`Unhandled recovery scenario: ${scenario}`);
  return true;
}
async function handleCatastrophicLoss() {
  const choice = await showUserMessage(
    "Data Recovery Failed",
    "We found evidence you've used Mera before, but couldn't recover any of your progress. This is unusual and may indicate a serious issue.\n\nYou can start fresh with empty progress, or stop Mera to prevent further changes and contact support for manual recovery assistance.",
    "Start Fresh",
    "Stop Mera"
  );
  return choice === "primary";
}
async function handleDegradedRecovery(metrics) {
  const issues = [];
  if (metrics.overallProgress.lessonsLostToCorruption > 0) {
    issues.push(
      `${metrics.overallProgress.lessonsLostToCorruption} lessons lost to corruption`
    );
  }
  if (metrics.combinedComponentProgress.componentsDefaulted > 0) {
    issues.push(
      `${metrics.combinedComponentProgress.componentsDefaulted} components reset to defaults`
    );
  }
  if (metrics.settings.defaultedRatio > 0) {
    issues.push("Some settings were reset");
  }
  const issuesSummary = issues.length > 0 ? issues.join(", ") : "Some data required recovery";
  const choice = await showUserMessage(
    "Progress Recovered with Issues",
    `We recovered your progress but encountered some problems:

${issuesSummary}

You can proceed with this recovered data, or stop Mera to contact support for manual recovery assistance. If you proceed, we'll save your current state as a backup, so manual recovery will still be possible later if needed.`,
    "Proceed",
    "Stop Mera"
  );
  return choice === "primary";
}
async function showStopDialog() {
  await showUserMessage(
    "Mera Stopped",
    "Stopping Mera prevents further changes to your data.\n\nFor manual recovery help, email support@meralearn.org.\n\nNote: If you choose to try recovery later, we'll save your current state as a backup before proceeding, so manual recovery will still be possible.",
    "Refresh to Restart"
  );
  window.location.reload();
}

// src/ts/initialization/bootstrap.ts
var CLOCK_SKEW_THRESHOLD_MS = 6e4;
var MAX_ATTEMPTS = 50;
var POLL_INTERVAL_MS = 100;
var timeline = null;
var errorDisplay = null;
function setupUI() {
  try {
    console.log("\u{1F3A8} Setting up UI components...");
    const authStatus = document.getElementById("auth-status");
    if (authStatus) {
      authStatus.classList.add("hidden");
    }
    const lessonContainer = document.getElementById("lesson-container");
    if (lessonContainer) {
      lessonContainer.classList.remove("hidden");
    }
    timeline = initializeTimeline("lesson-container");
    errorDisplay = new SolidConnectionErrorDisplay(timeline);
    console.log("\u2705 UI components initialized");
    return true;
  } catch (error46) {
    console.error("\u{1F4A5} UI setup failed:", error46);
    return false;
  }
}
function showBootstrapError(error46) {
  const errorMessage = error46 instanceof Error ? error46.message : "Unknown error occurred";
  if (errorDisplay) {
    errorDisplay.showSystemError(
      "bootstrap-init",
      "Bootstrap initialization failed",
      errorMessage
    );
    return;
  }
  const authStatus = document.getElementById("auth-status");
  if (authStatus) {
    authStatus.innerHTML = `
      <div class="text-center py-12">
        <div class="text-red-600 mb-4">
          <span class="font-semibold">Bootstrap Failed</span>
        </div>
        <p class="text-sm text-red-500 mb-4">${errorMessage}</p>
        <button onclick="location.reload()" 
                class="bg-red-600 hover:bg-red-700 text-white px-4 py-2 rounded-lg">
          Reload
        </button>
      </div>
    `;
  }
}
async function checkClockSkew() {
  try {
    const clientTime = Date.now();
    const response = await fetch("/", { method: "HEAD" });
    if (!response.ok) {
      throw new Error(
        `Server returned ${response.status} - cannot verify clock`
      );
    }
    const serverDateHeader = response.headers.get("Date");
    if (!serverDateHeader) {
      throw new Error("No Date header in server response - cannot verify clock");
    }
    const serverTime = new Date(serverDateHeader).getTime();
    const skewMs = Math.abs(clientTime - serverTime);
    if (skewMs > CLOCK_SKEW_THRESHOLD_MS) {
      const skewSeconds = Math.floor(skewMs / 1e3);
      throw new Error(
        `Clock skew detected: ${skewSeconds} seconds. Please check your device time settings.`
      );
    }
    console.log(`\u2705 Clock check passed (skew: ${skewMs}ms)`);
  } catch (error46) {
    const message2 = error46 instanceof Error ? error46.message : "Unknown error during clock check";
    throw new Error(`Clock verification failed: ${message2}`);
  }
}
function continueToNextModule() {
  console.log("\u{1F517} Solid Pod connected - starting initialization");
  initializationOrchestrator().then(
    () => {
      console.log("\u2705 Initialization completed successfully");
    },
    (error46) => {
      console.error("\u274C Initialization failed:", error46);
      if (errorDisplay) {
        errorDisplay.showSystemError(
          "initialization-failed",
          "Failed to load user progress",
          error46 instanceof Error ? error46.message : "Unknown error"
        );
      }
    }
  );
  console.log("\u2705 Bootstrap complete - initialization running independently");
}
function noSolidConnection() {
  console.log("\u{1F510} No Solid connection - authentication required");
  if (errorDisplay) {
    errorDisplay.showConnectionError("solid");
  }
}
async function startBootstrap() {
  try {
    if (!setupUI()) {
      console.error("Cannot continue - UI setup failed");
      return;
    }
    console.log("\u{1F50D} Checking for Solid Pod authentication...");
    const bridge = MeraBridge.getInstance();
    for (let attempt = 1; attempt <= MAX_ATTEMPTS; attempt++) {
      if (bridge.check()) {
        console.log(`\u2705 Solid Pod connected (attempt ${attempt})`);
        await checkClockSkew();
        continueToNextModule();
        return;
      }
      await new Promise((resolve) => setTimeout(resolve, POLL_INTERVAL_MS));
    }
    console.log(
      `\u274C No Solid Pod connection after ${MAX_ATTEMPTS} attempts. Authentication required.`
    );
    noSolidConnection();
  } catch (error46) {
    console.error("\u{1F4A5} Bootstrap error:", error46);
    showBootstrapError(error46);
  }
}
if (document.readyState === "loading") {
  document.addEventListener("DOMContentLoaded", () => {
    console.log("\u{1F680} Starting initialization...");
    startBootstrap();
  });
} else {
  console.log("\u{1F680} Starting initialization...");
  startBootstrap();
}
export {
  startBootstrap
};
/*! Bundled license information:

ieee754/index.js:
  (*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> *)

buffer/index.js:
  (*!
   * The buffer module from node.js, for the browser.
   *
   * @author   Feross Aboukhadijeh <https://feross.org>
   * @license  MIT
   *)

safe-buffer/index.js:
  (*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> *)

@inrupt/oidc-client/lib/oidc-client.min.js:
  (*! (c) Tom Wu | http://www-cs-students.stanford.edu/~tjw/jsbn/
   *)
  (*! Mike Samuel (c) 2009 | code.google.com/p/json-sans-eval
   *)
  (*!
   * The buffer module from node.js, for the browser.
   *
   * @author   Feross Aboukhadijeh <http://feross.org>
   * @license  MIT
   *)
  (*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> *)

js-yaml/dist/js-yaml.mjs:
  (*! js-yaml 4.1.1 https://github.com/nodeca/js-yaml @license MIT *)
*/
